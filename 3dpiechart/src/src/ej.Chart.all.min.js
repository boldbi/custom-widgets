/*!
*  filename: sf.chart.js
*  version : 19.2.0.55
*  Copyright Sfusion Inc. 2001 - 2021. All rights reserved.
*  Use of this code is subject to the terms of our license.
*  A copy of the current license can be obtained at any time by e-mailing
*  licensing@Sfusion.com. Any infringement will be prosecuted under
*  applicable laws. 
*/


window.sf = window.Sfusion = window.Sfusion || {};


(function ($, sf, undefined) {
    'use strict';

    sf.version = "19.2.0.55";

    sf.consts = {
        NamespaceJoin: '-'
    };
    sf.TextAlign = {
        Center: 'center',
        Justify: 'justify',
        Left: 'left',
        Right: 'right'
    };
    sf.Orientation = { Horizontal: "horizontal", Vertical: "vertical" };

    sf.serverTimezoneOffset = 0;

    sf.parseDateInUTC = false;

    sf.persistStateVersion = null;

    sf.locales = sf.locales || [];

    if (!Object.prototype.hasOwnProperty) {
        Object.prototype.hasOwnProperty = function (obj, prop) {
            return obj[prop] !== undefined;
        };
    }

    //to support toISOString() in IE8
    if (!Date.prototype.toISOString) {
        (function () {
            function pad(number) {
                var r = String(number);
                if (r.length === 1) {
                    r = '0' + r;
                }
                return r;
            }
            Date.prototype.toISOString = function () {
                return this.getUTCFullYear()
                    + '-' + pad(this.getUTCMonth() + 1)
                    + '-' + pad(this.getUTCDate())
                    + 'T' + pad(this.getUTCHours())
                    + ':' + pad(this.getUTCMinutes())
                    + ':' + pad(this.getUTCSeconds())
                    + '.' + String((this.getUTCMilliseconds() / 1000).toFixed(3)).slice(2, 5)
                    + 'Z';
            };
        }());
    }

    String.format = function () {
        var source = arguments[0];
        for (var i = 0; i < arguments.length - 1; i++)
            source = source.replace(new RegExp("\\{" + i + "\\}", "gm"), arguments[i + 1]);

        source = source.replace(/\{[0-9]\}/g, "");
        return source;
    };

    jQuery.uaMatch = function (ua) {
        ua = ua.toLowerCase();

        var match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
            /(webkit)[ \/]([\w.]+)/.exec(ua) ||
            /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
            /(msie) ([\w.]+)/.exec(ua) ||
            ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
            [];

        return {
            browser: match[1] || "",
            version: match[2] || "0"
        };
    };
    // Function to create new class
    sf.defineClass = function (className, constructor, proto, replace) {
        /// <summary>Creates the javascript class with given namespace & class name & constructor etc</summary>
        /// <param name="className" type="String">class name prefixed with namespace</param>
        /// <param name="constructor" type="Function">constructor function</param>
        /// <param name="proto" type="Object">prototype for the class</param>
        /// <param name="replace" type="Boolean">[Optional]Replace existing class if exists</param>
        /// <returns type="Function">returns the class function</returns>
        if (!className || !proto) return undefined;

        var parts = className.split(".");

        // Object creation
        var obj = window, i = 0;
        for (; i < parts.length - 1; i++) {

            if (sf.isNullOrUndefined(obj[parts[i]]))
                obj[parts[i]] = {};

            obj = obj[parts[i]];
        }

        if (replace || sf.isNullOrUndefined(obj[parts[i]])) {

            //constructor
            constructor = typeof constructor === "function" ? constructor : function () {
            };

            obj[parts[i]] = constructor;

            // prototype
            obj[parts[i]].prototype = proto;
        }

        return obj[parts[i]];
    };

    sf.util = {
        getNameSpace: function (className) {
            /// <summary>Internal function, this will create namespace for plugins using class name</summary>
            /// <param name="className" type="String"></param>
            /// <returns type="String"></returns>
            var splits = className.toLowerCase().split(".");
            splits[0] === "sf" && (splits[0] = "e");

            return splits.join(sf.consts.NamespaceJoin);
        },

        getObject: function (nameSpace, from) {
            if (!from || !nameSpace) return undefined;
			(typeof(nameSpace) != "string") && (nameSpace = JSON.stringify(nameSpace));
            var value = from, splits = nameSpace.split('.');

            for (var i = 0; i < splits.length; i++) {

                if (sf.util.isNullOrUndefined(value)) break;

                value = value[splits[i]];
            }

            return value;
        },

        createObject: function (nameSpace, value, initIn) {
            var splits = nameSpace.split('.'), start = initIn || window, from = start, i, t, length = splits.length;

            for (i = 0; i < length; i++) {
                t = splits[i];
                if (i + 1 == length)
                    from[t] = value;
                else if (sf.isNullOrUndefined(from[t]))
                    from[t] = {};

                from = from[t];
            }

            return start;
        },

        isNullOrUndefined: function (value) {
            /// <summary>Util to check null or undefined</summary>
            /// <param name="value" type="Object"></param>
            /// <returns type="Boolean"></returns>
            return value === undefined || value === null;
        },
        exportAll: function (action, controlIds) {
            var inputAttr = [], widget, locale = [], index, controlEle, controlInstance, controlObject, modelClone;
            var attr = { action: action, method: 'post', "data-ajax": "false" };
            var form = sf.buildTag('form', "", null, attr);
            if (controlIds.length != 0) {
                for (var i = 0; i < controlIds.length; i++) {
                    index = i;
                    controlEle = $("#" + controlIds[i]);
                    controlInstance = $("#" + controlIds[i]).data();
                    widget = controlInstance["ejWidgets"];
                    controlObject = $(controlEle).data(widget[0]);
                    locale.push({ id: controlObject._id, locale: controlObject.model.locale });
                    if (!sf.isNullOrUndefined(controlObject)) {
                        modelClone = controlObject._getExportModel(controlObject.model);
                        inputAttr.push({ name: widget[0], type: 'hidden', value: controlObject.stringify(modelClone) });
                        var input = sf.buildTag('input', "", null, inputAttr[index]);
                        form.append(input);
                    }
                }
                $('body').append(form);
                form.submit();
                setTimeout(function () {
                    var ctrlInstance, ctrlObject;
                    if (locale.length) {
                        for (var j = 0; j < locale.length; j++) {
                            if (!sf.isNullOrUndefined(locale[j].locale)) {
                                ctrlInstance = $("#" + locale[j].id).data();
                                widget = ctrlInstance["ejWidgets"];
                                ctrlObject = $("#" + locale[j].id).data(widget[0]);
                                ctrlObject.model.locale = locale[j].locale;
                            }
                        }
                    }
                }, 0);
                form.remove();
            }
            return true;
        },
        print: function (element, printWin) {
            var $div = sf.buildTag('div')
            var elementClone = element.clone();
            $div.append(elementClone);
            if (!printWin)
                var printWin = window.open('', 'print', "height=452,width=1024,tabbar=no");
            printWin.document.write('<!DOCTYPE html>');
            var links = $('head').find('link').add("style");
            if (sf.browserInfo().name === "msie") {
                var a = ""
                links.each(function (index, obj) {
                    if (obj.tagName == "LINK")
                        $(obj).attr('href', obj.href);
                    a += obj.outerHTML;
                });
                printWin.document.write('<html><head></head><body>' + a + $div[0].innerHTML + '</body></html>');
            }
            else {
                var a = ""
                printWin.document.write('<html><head>')
                links.each(function (index, obj) {
                    if (obj.tagName == "LINK")
                        $(obj).attr('href', obj.href);
                    a += obj.outerHTML;
                });
                printWin.document.writeln(a + '</head><body>')
                printWin.document.writeln($div[0].innerHTML + '</body></html>')
            }
            printWin.document.close();
            printWin.focus();
            setTimeout(function () {
                if (!sf.isNullOrUndefined(printWin.window)) {
                    printWin.print();
                    setTimeout(function () { printWin.close() }, 1000);
                }
            }, 1000);
        },
        ieClearRemover: function (element) {
            var searchBoxHeight = $(element).height();
            element.style.paddingTop = parseFloat(searchBoxHeight / 2) + "px";
            element.style.paddingBottom = parseFloat(searchBoxHeight / 2) + "px";
            element.style.height = "1px";
            element.style.lineHeight = "1px";
        },
        //To send ajax request
        sendAjaxRequest: function (ajaxOptions) {
            $.ajax({
                type: ajaxOptions.type,
                cache: ajaxOptions.cache,
                url: ajaxOptions.url,
                dataType: ajaxOptions.dataType,
                data: ajaxOptions.data,
                contentType: ajaxOptions.contentType,
                async: ajaxOptions.async,
                success: ajaxOptions.successHandler,
                error: ajaxOptions.errorHandler,
                beforeSend: ajaxOptions.beforeSendHandler,
                complete: ajaxOptions.completeHandler
            });
        },

        buildTag: function (tag, innerHtml, styles, attrs) {
            /// <summary>Helper to build jQuery element</summary>
            /// <param name="tag" type="String">tagName#id.cssClass</param>
            /// <param name="innerHtml" type="String"></param>
            /// <param name="styles" type="Object">A set of key/value pairs that configure styles</param>
            /// <param name="attrs" type="Object">A set of key/value pairs that configure attributes</param>
            /// <returns type="jQuery"></returns>
            var tagName = /^[a-z]*[0-9a-z]+/ig.exec(tag)[0];

           var id = /#([_a-z0-9-&@\/\\,+()$~%:*?<>{}\[\]]+\S)/ig.exec(tag);
            id = id ? id[id.length - 1].replace(/[&@\/\\,+()$~%.:*?<>{}\[\]]/g, ''): undefined;

            var className = /\.([a-z]+[-_0-9a-z ]+)/ig.exec(tag);
            className = className ? className[className.length - 1] : undefined;

            return $(document.createElement(tagName))
                .attr(id ? { "id": id } : {})
                .addClass(className || "")
                .css(styles || {})
                .attr(attrs || {})
                .html(innerHtml || "");
        },
        _preventDefaultException: function (el, exceptions) {
            if (el) {
                for (var i in exceptions) {
                    if (exceptions[i].test(el[i])) {
                        return true;
                    }
                }
            }

            return false;
        },

        //Gets the maximum z-index in the document
        getMaxZindex: function () {
            var maxZ = 1;
            maxZ = Math.max.apply(null, $.map($('body *'), function (e, n) {
                if ($(e).css('position') == 'absolute' || $(e).css('position') == 'fixed')
                    return parseInt($(e).css('z-index')) || 1;
            })
            );
            if (maxZ == undefined || maxZ == null)
                maxZ = 1;
            return maxZ;
        },

        //To prevent default actions for the element
        blockDefaultActions: function (e) {
            e.cancelBubble = true;
            e.returnValue = false;
            if (e.preventDefault) e.preventDefault();
            if (e.stopPropagation) e.stopPropagation();
        },

        //To get dimensions of the element when its hidden
        getDimension: function (element, method) {
            var value;
            var $hidden = $(element).parents().andSelf().filter(':hidden');
            if ($hidden) {
                var prop = { visibility: 'hidden', display: 'block' };
                var tmp = [];
                $hidden.each(function () {
                    var temp = {}, name;
                    for (name in prop) {
                        temp[name] = this.style[name];
                        this.style[name] = prop[name];
                    }
                    tmp.push(temp);
                });
                value = /(outer)/g.test(method) ?
                $(element)[method](true) :
               $(element)[method]();

                $hidden.each(function (i) {
                    var temp = tmp[i], name;
                    for (name in prop) {
                        this.style[name] = temp[name];
                    }
                });
            }
            return value;
        },
        //Get triggers when transition End
        transitionEndEvent: function () {
            var transitionEnd = {
                '': 'transitionend',
                'webkit': 'webkitTransitionEnd',
                'Moz': 'transitionend',
                'O': 'otransitionend',
                'ms': 'MSTransitionEnd'
            };

            return transitionEnd[sf.userAgent()];
        },
        //Get triggers when transition End
        animationEndEvent: function () {
            var animationEnd = {
                '': 'animationend',
                'webkit': 'webkitAnimationEnd',
                'Moz': 'animationend',
                'O': 'webkitAnimationEnd',
                'ms': 'animationend'
            };

            return animationEnd[sf.userAgent()];
        },
        //To return the start event to bind for element
        startEvent: function () {
            return (sf.isTouchDevice() || $.support.hasPointer) ? "touchstart" : "mousedown";
        },
        //To return end event to bind for element
        endEvent: function () {
            return (sf.isTouchDevice() || $.support.hasPointer) ? "touchend" : "mouseup"
        },
        //To return move event to bind for element
        moveEvent: function () {
            return (sf.isTouchDevice() || $.support.hasPointer) ? ($.support.hasPointer && !sf.isMobile()) ? "ejtouchmove" : "touchmove" : "mousemove";
        },
        //To return cancel event to bind for element
        cancelEvent: function () {
            return (sf.isTouchDevice() || $.support.hasPointer) ? "touchcancel" : "mousecancel";
        },
        //To return tap event to bind for element
        tapEvent: function () {
            return (sf.isTouchDevice() || $.support.hasPointer) ? "tap" : "click";
        },
        //To return tap hold event to bind for element
        tapHoldEvent: function () {
            return (sf.isTouchDevice() || $.support.hasPointer) ? "taphold" : "click";
        },
        //To check whether its Device
        isDevice: function () {
            if (sf.getBooleanVal($('head'), 'data-sf-forceset', false))
                return sf.getBooleanVal($('head'), 'data-sf-device', this._device());
            else
                return this._device();
        },
        //To check whether its portrait or landscape mode
        isPortrait: function () {
            var elem = document.documentElement;
            return (elem) && ((elem.clientWidth / elem.clientHeight) < 1.1);
        },
        //To check whether its in lower resolution
        isLowerResolution: function () {
            return ((window.innerWidth <= 640 && sf.isPortrait() && sf.isDevice()) || (window.innerWidth <= 800 && !sf.isDevice()) || (window.innerWidth <= 800 && !sf.isPortrait() && sf.isWindows() && sf.isDevice()) || sf.isMobile());
        },
        //To check whether its iOS web view
        isIOSWebView: function () {
            return (/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent));
        },
        //To check whether its Android web view
        isAndroidWebView: function () {
            return (!(typeof (Android) === "undefined"));
        },
        //To check whether its windows web view
        isWindowsWebView: function () {
            return location.href.indexOf("x-wmapp") != -1;
        },
        _device: function () {
            return (/Android|BlackBerry|iPhone|iPad|iPod|IEMobile|kindle|windows\sce|palm|smartphone|iemobile|mobile|pad|xoom|sch-i800|playbook/i.test(navigator.userAgent.toLowerCase()));
        },
        //To check whether its Mobile
        isMobile: function () {
            return ((/iphone|ipod|android|blackberry|opera|mini|windows\sce|palm|smartphone|iemobile/i.test(navigator.userAgent.toLowerCase()) && /mobile/i.test(navigator.userAgent.toLowerCase()))) || (sf.getBooleanVal($('head'), 'data-sf-mobile', false) === true);
        },
        //To check whether its Tablet
        isTablet: function () {
            return (/ipad|xoom|sch-i800|playbook|tablet|kindle/i.test(navigator.userAgent.toLowerCase())) || (sf.getBooleanVal($('head'), 'data-sf-tablet', false) === true) || (!sf.isMobile() && sf.isDevice());
        },
        //To check whether its Touch Device
        isTouchDevice: function () {
            return (('ontouchstart' in window || (window.navigator.msPointerEnabled && sf.isMobile())) && this.isDevice());
        },
        //To get the outerHTML string for object
        getClearString: function (string) {
            return $.trim(string.replace(/\s+/g, " ").replace(/(\r\n|\n|\r)/gm, "").replace(new RegExp("\>[\n\t ]+\<", "g"), "><"));
        },
        //Get the attribute value with boolean type of element
        getBooleanVal: function (ele, val, option) {
            /// <summary>Util to get the property from data attributes</summary>
            /// <param name="ele" type="Object"></param>
            /// <param name="val" type="String"></param>
            /// <param name="option" type="GenericType"></param>
            /// <returns type="GenericType"></returns>
            var value = $(ele).attr(val);
            if (value != null)
                return value.toLowerCase() == "true";
            else
                return option;
        },
        //Gets the Skew class based on the element current position
        _getSkewClass: function (item, pageX, pageY) {
            var itemwidth = item.width();
            var itemheight = item.height();
            var leftOffset = item.offset().left;
            var rightOffset = item.offset().left + itemwidth;
            var topOffset = item.offset().top;
            var bottomOffset = item.offset().top + itemheight;
            var widthoffset = itemwidth * 0.3;
            var heightoffset = itemheight * 0.3;
            if (pageX < leftOffset + widthoffset && pageY < topOffset + heightoffset)
                return "e-m-skew-topleft";
            if (pageX > rightOffset - widthoffset && pageY < topOffset + heightoffset)
                return "e-m-skew-topright";
            if (pageX > rightOffset - widthoffset && pageY > bottomOffset - heightoffset)
                return "e-m-skew-bottomright";
            if (pageX < leftOffset + widthoffset && pageY > bottomOffset - heightoffset)
                return "e-m-skew-bottomleft";
            if (pageX > leftOffset + widthoffset && pageY < topOffset + heightoffset && pageX < rightOffset - widthoffset)
                return "e-m-skew-top";
            if (pageX < leftOffset + widthoffset)
                return "e-m-skew-left";
            if (pageX > rightOffset - widthoffset)
                return "e-m-skew-right";
            if (pageY > bottomOffset - heightoffset)
                return "e-m-skew-bottom";
            return "e-m-skew-center";
        },
        //Removes the added Skew class on the element
        _removeSkewClass: function (element) {
            $(element).removeClass("e-m-skew-top e-m-skew-bottom e-m-skew-left e-m-skew-right e-m-skew-topleft e-m-skew-topright e-m-skew-bottomleft e-m-skew-bottomright e-m-skew-center e-skew-top e-skew-bottom e-skew-left e-skew-right e-skew-topleft e-skew-topright e-skew-bottomleft e-skew-bottomright e-skew-center");
        },
        //Object.keys  method to support all the browser including IE8.
        _getObjectKeys: function (obj) {
            var i, keys = [];
            obj = Object.prototype.toString.call(obj) === Object.prototype.toString() ? obj : {};
            if (!Object.keys) {
                for (i in obj) {
                    if (obj.hasOwnProperty(i))
                        keys.push(i);
                }
                return keys;
            }
            if (Object.keys)
                return Object.keys(obj);
        },
        _touchStartPoints: function (evt, object) {
            if (evt) {
                var point = evt.touches ? evt.touches[0] : evt;
                object._distX = 0;
                object._distY = 0;
                object._moved = false;
                object._pointX = point.pageX;
                object._pointY = point.pageY;
            }
        },
        _isTouchMoved: function (evt, object) {
            if (evt) {
                var point = evt.touches ? evt.touches[0] : evt,
                deltaX = point.pageX - object._pointX,
                deltaY = point.pageY - object._pointY,
                timestamp = Date.now(),
                newX, newY,
                absDistX, absDistY;
                object._pointX = point.pageX;
                object._pointY = point.pageY;
                object._distX += deltaX;
                object._distY += deltaY;
                absDistX = Math.abs(object._distX);
                absDistY = Math.abs(object._distY);
                return !(absDistX < 5 && absDistY < 5);
            }
        },
        //To bind events for element
        listenEvents: function (selectors, eventTypes, handlers, remove, pluginObj, disableMouse) {
            for (var i = 0; i < selectors.length; i++) {
                sf.listenTouchEvent(selectors[i], eventTypes[i], handlers[i], remove, pluginObj, disableMouse);
            }
        },
        //To bind touch events for element
        listenTouchEvent: function (selector, eventType, handler, remove, pluginObj, disableMouse) {
            var event = remove ? "removeEventListener" : "addEventListener";
            var jqueryEvent = remove ? "off" : "on";
            var elements = $(selector);
            for (var i = 0; i < elements.length; i++) {
                var element = elements[i];
                switch (eventType) {
                    case "touchstart":
                        sf._bindEvent(element, event, eventType, handler, "mousedown", "MSPointerDown", "pointerdown", disableMouse);
                        break;
                    case "touchmove":
                        sf._bindEvent(element, event, eventType, handler, "mousemove", "MSPointerMove", "pointermove", disableMouse);
                        break;
                    case "touchend":
                        sf._bindEvent(element, event, eventType, handler, "mouseup", "MSPointerUp", "pointerup", disableMouse);
                        break;
                    case "touchcancel":
                        sf._bindEvent(element, event, eventType, handler, "mousecancel", "MSPointerCancel", "pointercancel", disableMouse);
                        break;
                    case "tap": case "taphold": case "ejtouchmove": case "click":
                        $(element)[jqueryEvent](eventType, handler);
                        break;
                    default:
                        if (sf.browserInfo().name == "msie" && sf.browserInfo().version < 9)
                            pluginObj["_on"]($(element), eventType, handler);
                        else
                            element[event](eventType, handler, true);
                        break;
                }
            }
        },
        //To bind events for element
        _bindEvent: function (element, event, eventType, handler, mouseEvent, pointerEvent, ie11pointerEvent, disableMouse) {
            if ($.support.hasPointer)
                element[event](window.navigator.pointerEnabled ? ie11pointerEvent : pointerEvent, handler, true);
            else
                element[event](eventType, handler, true);
        },
        _browser: function () {
            return (/webkit/i).test(navigator.appVersion) ? 'webkit' : (/firefox/i).test(navigator.userAgent) ? 'Moz' : (/trident/i).test(navigator.userAgent) ? 'ms' : 'opera' in window ? 'O' : '';
        },
        styles: document.createElement('div').style,
        /**
       * To get the userAgent Name     
       * @example             
       * &lt;script&gt;
       *       sf.userAgent();//return user agent name
       * &lt;/script&gt         
       * @memberof AppView
       * @instance
       */
        userAgent: function () {
            var agents = 'webkitT,t,MozT,msT,OT'.split(','),
            t,
            i = 0,
            l = agents.length;

            for (; i < l; i++) {
                t = agents[i] + 'ransform';
                if (t in sf.styles) {
                    return agents[i].substr(0, agents[i].length - 1);
                }
            }

            return false;
        },
        addPrefix: function (style) {
            if (sf.userAgent() === '') return style;

            style = style.charAt(0).toUpperCase() + style.substr(1);
            return sf.userAgent() + style;
        },
        //To Prevent Default Exception

        //To destroy the mobile widgets
        destroyWidgets: function (element) {
            var dataEl = $(element).find("[data-role *= ejm]");
            dataEl.each(function (index, element) {
                var $element = $(element);
                var plugin = $element.data("ejWidgets");
                if (plugin)
                    $element[plugin]("destroy");
            });
        },
        //Get the attribute value of element
        getAttrVal: function (ele, val, option) {
            /// <summary>Util to get the property from data attributes</summary>
            /// <param name="ele" type="Object"></param>
            /// <param name="val" type="String"></param>
            /// <param name="option" type="GenericType"></param>
            /// <returns type="GenericType"></returns>
            var value = $(ele).attr(val);
            if (value != null)
                return value;
            else
                return option;
        },

        // Get the offset value of element
        getOffset: function (ele) {
            var pos = {};
            var offsetObj = ele.offset() || { left: 0, top: 0 };
            $.extend(true, pos, offsetObj);
            if ($("body").css("position") != "static") {
                var bodyPos = $("body").offset();
                pos.left -= bodyPos.left;
                pos.top -= bodyPos.top;
            }
            return pos;
        },

        // Z-index calculation for the element
        getZindexPartial: function (element, popupEle) {
            if (!sf.isNullOrUndefined(element) && element.length > 0) {
                var parents = element.parents(), bodyEle;
                bodyEle = $('body').children();
                if (!sf.isNullOrUndefined(element) && element.length > 0)
                    bodyEle.splice(bodyEle.index(popupEle), 1);
                $(bodyEle).each(function (i, ele) { parents.push(ele); });

                var maxZ = Math.max.apply(maxZ, $.map(parents, function (e, n) {
                    if ($(e).css('position') != 'static') return parseInt($(e).css('z-index')) || 1;
                }));
                if (!maxZ || maxZ < 10000) maxZ = 10000;
                else maxZ += 1;
                return maxZ;
            }
        },

        isValidAttr: function (element, attribute) {
            var element = $(element)[0];
            if (typeof element[attribute] != "undefined")
                return true;
            else {
                var _isValid = false;
                $.each(element, function (key) {
                    if (key.toLowerCase() == attribute.toLowerCase()) {
                        _isValid = true;
                        return false;
                    }
                });
            }
            return _isValid;
        }

    };

    $.extend(sf, sf.util);

    // base class for all sf widgets. It will automatically inhertied
    sf.widgetBase = {
        droppables: { 'default': [] },
        resizables: { 'default': [] },

        _renderEjTemplate: function (selector, data, index, prop, ngTemplateType) {
            var type = null;
            if (typeof selector === "object" || selector.startsWith("#") || selector.startsWith("."))
                type = $(selector).attr("type");
            if (type) {
                type = type.toLowerCase();
                if (sf.template[type])
                    return sf.template[type](this, selector, data, index, prop);
            }
            // For ejGrid Angular2 Template Support
            else if (!sf.isNullOrUndefined(ngTemplateType))
                 return sf.template['text/x-'+ ngTemplateType](this, selector, data, index, prop);
            return sf.template.render(this, selector, data, index, prop);
        },

        destroy: function () {

            if (this._trigger("destroy"))
                return;

            if (this.model.enablePersistence) {
                this.persistState();
                $(window).off("unload", this._persistHandler);
            }

            try {
                this._destroy();
            } catch (e) { }

            var arr = this.element.data("ejWidgets") || [];
            for (var i = 0; i < arr.length; i++) {
                if (arr[i] == this.pluginName) {
                    arr.splice(i, 1);
                }
            }
            if (!arr.length)
                this.element.removeData("ejWidgets");

            while (this._events) {
                var item = this._events.pop(), args = [];

                if (!item)
                    break;

                for (var i = 0; i < item[1].length; i++)
                    if (!$.isPlainObject(item[1][i]))
                        args.push(item[1][i]);

                $.fn.off.apply(item[0], args);
            }

            this._events = null;

            this.element
                .removeClass(sf.util.getNameSpace(this.sfType))
                .removeClass("e-js")
                .removeData(this.pluginName);

            this.element = null;
            this.model = null;
        },

        _on: function (element) {
            if (!this._events)
                this._events = [];
            var args = [].splice.call(arguments, 1, arguments.length - 1);

            var handler = {}, i = args.length;
            while (handler && typeof handler !== "function") {
                handler = args[--i];
            }

            args[i] = sf.proxy(args[i], this);

            this._events.push([element, args, handler, args[i]]);

            $.fn.on.apply(element, args);

            return this;
        },

        _off: function (element, eventName, selector, handlerObject) {
            var e = this._events, temp;
            if (!e || !e.length)
                return this;
            if (typeof selector == "function") {
                temp = handlerObject;
                handlerObject = selector;
                selector = temp;
            }
            var t = (eventName.match(/\S+/g) || [""]);
            for (var i = 0; i < e.length; i++) {
                var arg = e[i],
                r = arg[0].length && (!handlerObject || arg[2] === handlerObject) && (arg[1][0] === eventName || t[0]) && (!selector || arg[1][1] === selector) && $.inArray(element[0], arg[0]) > -1;
                if (r) {
                    $.fn.off.apply(element, handlerObject ? [eventName, selector, arg[3]] : [eventName, selector]);
                    e.splice(i, 1);
                    break;
                }
            }

            return this;
        },

        // Client side events wire-up / trigger helper.
        _trigger: function (eventName, eventProp) {
            var fn = null, returnValue, args, clientProp = {};
            $.extend(clientProp, eventProp)

            if (eventName in this.model)
                fn = this.model[eventName];

            if (fn) {
                if (typeof fn === "string") {
                    fn = sf.util.getObject(fn, window);
                }

                if ($.isFunction(fn)) {

                    args = sf.event(eventName, this.model, eventProp);

                    
                    returnValue = fn.call(this, args);

                    // sending changes back - deep copy option should not be enabled for this $.extend 
                    if (eventProp) $.extend(eventProp, args);

                    if (args.cancel || !sf.isNullOrUndefined(returnValue))
                        return returnValue === false || args.cancel;
                }
            }

            var isPropDefined = Boolean(eventProp);
            eventProp = eventProp || {};
            eventProp.originalEventType = eventName;
            eventProp.type = this.pluginName + eventName;

            args = $.Event(eventProp.type, sf.event(eventProp.type, this.model, eventProp));

            this.element && this.element.trigger(args);

            // sending changes back - deep copy option should not be enabled for this $.extend 
            if (isPropDefined) $.extend(eventProp, args);

            if (sf.isOnWebForms && args.cancel == false && this.model.serverEvents && this.model.serverEvents.length)
                sf.raiseWebFormsServerEvents(eventName, eventProp, clientProp);

            return args.cancel;
        },

        setModel: function (options, forceSet) {
            // check for whether to apply values are not. if _setModel function is defined in child,
            //  this will call that function and validate it using return value

            if (this._trigger("modelChange", { "changes": options }))
                return;

            for (var prop in options) {
                if (!forceSet) {
                    if (this.model[prop] === options[prop]) {
                        delete options[prop];
                        continue;
                    }
                    if ($.isPlainObject(options[prop])) {
                        iterateAndRemoveProps(this.model[prop], options[prop]);
                        if ($.isEmptyObject(options[prop])) {
                            delete options[prop];
                            continue;
                        }
                    }
                }

                if (this.dataTypes) {
                    var returnValue = this._isValidModelValue(prop, this.dataTypes, options);
                    if (returnValue !== true)
                        throw "setModel - Invalid input for property :" + prop + " - " + returnValue;
                }
                if (this.model.notifyOnEachPropertyChanges && this.model[prop] !== options[prop]) {
                    var arg = {
                        oldValue: this.model[prop],
                        newValue: options[prop]
                    };

                    options[prop] = this._trigger(prop + "Change", arg) ? this.model[prop] : arg.newValue;
                }
            }
            if ($.isEmptyObject(options))
                return;

            if (this._setFirst) {
                var ds = options.dataSource;
                if (ds) delete options.dataSource;

                $.extend(true, this.model, options);
                if (ds) {
                    this.model.dataSource = (ds instanceof Array) ? ds.slice() : ds;
                    options["dataSource"] = this.model.dataSource;
                }
                !this._setModel || this._setModel(options);

            } else if (!this._setModel || this._setModel(options) !== false) {
                $.extend(true, this.model, options);
            }
            if ("enablePersistence" in options) {
                this._setState(options.enablePersistence);
            }
        },
        option: function (prop, value, forceSet) {
            if (!prop)
                return this.model;

            if ($.isPlainObject(prop))
                return this.setModel(prop, forceSet);

            if (typeof prop === "string") {
                prop = prop.replace(/^model\./, "");
                var oldValue = sf.getObject(prop, this.model);

                if (value === undefined && !forceSet)
                    return oldValue;

                if (prop === "enablePersistence")
                    return this._setState(value);

                if (forceSet && value === sf.extensions.modelGUID) {
                    return this._setModel(sf.createObject(prop, sf.getObject(prop, this.model), {}));
                }

                if (forceSet || sf.getObject(prop, this.model) !== value)
                    return this.setModel(sf.createObject(prop, value, {}), forceSet);
            }
            return undefined;
        },

        _isValidModelValue: function (prop, types, options) {
            var value = types[prop], option = options[prop], returnValue;

            if (!value)
                return true;

            if (typeof value === "string") {
                if (value == "enum") {
                    options[prop] = option ? option.toString().toLowerCase() : option;
                    value = "string";
                }

                if (value === "array") {
                    if (Object.prototype.toString.call(option) === '[object Array]')
                        return true;
                }
                else if (value === "data") {
                    return true;
                }
                else if (value === "parent") {
                    return true;
                }
                else if (typeof option === value)
                    return true;

                return "Expected type - " + value;
            }

            if (option instanceof Array) {
                for (var i = 0; i < option.length; i++) {
                    returnValue = this._isValidModelValue(prop, types, option[i]);
                    if (returnValue !== true) {
                        return " [" + i + "] - " + returnValue;
                    }
                }
                return true;
            }

            for (var innerProp in option) {
                returnValue = this._isValidModelValue(innerProp, value, option);
                if (returnValue !== true)
                    return innerProp + " : " + returnValue;
            }

            return true;
        },

        _returnFn: function (obj, propName) {
            if (propName.indexOf('.') != -1) {
                this._returnFn(obj[propName.split('.')[0]], propName.split('.').slice(1).join('.'));
            }
            else
                obj[propName] = obj[propName].call(obj.propName);
        },

        _removeCircularRef: function (obj) {
            var seen = [];
            function detect(obj, key, parent) {
                if (typeof obj != 'object') { return; }
                if (!Array.prototype.indexOf) {
                    Array.prototype.indexOf = function (val) {
                        return jQuery.inArray(val, this);
                    };
                }
                if (seen.indexOf(obj) >= 0) {
                    delete parent[key];
                    return;
                }
                seen.push(obj);
                for (var k in obj) { //dive on the object's children
                    if (obj.hasOwnProperty(k)) { detect(obj[k], k, obj); }
                }
                seen.pop();
                return;
            }
            detect(obj, 'obj', null);
            return obj;
        },

        stringify: function (model, removeCircular) {
            var observables = this.observables;
            for (var k = 0; k < observables.length; k++) {
                var val = sf.getObject(observables[k], model);
                if (!sf.isNullOrUndefined(val) && typeof (val) === "function")
                    this._returnFn(model, observables[k]);
            }
            if (removeCircular) model = this._removeCircularRef(model);
            return JSON.stringify(model);
        },

        _setState: function (val) {
            if (val === true) {
                this._persistHandler = sf.proxy(this.persistState, this);
                $(window).on("unload", this._persistHandler);
            } else {
                this.deleteState();
                $(window).off("unload", this._persistHandler);
            }
        },

        _removeProp: function (obj, propName) {
            if (!sf.isNullOrUndefined(obj)) {
                if (propName.indexOf('.') != -1) {
                    this._removeProp(obj[propName.split('.')[0]], propName.split('.').slice(1).join('.'));
                }
                else
                    delete obj[propName];
            }
        },

        persistState: function () {
            var model;

            if (this._ignoreOnPersist) {
                model = copyObject({}, this.model);
                for (var i = 0; i < this._ignoreOnPersist.length; i++) {
                    this._removeProp(model, this._ignoreOnPersist[i]);
                }
                model.ignoreOnPersist = this._ignoreOnPersist;
            } else if (this._addToPersist) {
                model = {};
                for (var i = 0; i < this._addToPersist.length; i++) {
                    sf.createObject(this._addToPersist[i], sf.getObject(this._addToPersist[i], this.model), model);
                }
                model.addToPersist = this._addToPersist;
            } else {
                model = copyObject({}, this.model);
            }

            if (this._persistState) {
                model.customPersists = {};
                this._persistState(model.customPersists);
            }

            if (window.localStorage) {
                if (!sf.isNullOrUndefined(sf.persistStateVersion) && window.localStorage.getItem("persistKey") == null)
                    window.localStorage.setItem("persistKey", sf.persistStateVersion);
                window.localStorage.setItem("$sf$" + this.pluginName + this._id, JSON.stringify(model));
            }
            else if (document.cookie) {
                if (!sf.isNullOrUndefined(sf.persistStateVersion) && sf.cookie.get("persistKey") == null)
                    sf.cookie.set("persistKey", sf.persistStateVersion);
                sf.cookie.set("$sf$" + this.pluginName + this._id, model);
            }
        },

        deleteState: function () {
            var model;
            if (window.localStorage)
                window.localStorage.removeItem("$sf$" + this.pluginName + this._id);
            else if (document.cookie)
                sf.cookie.set("$sf$" + this.pluginName + this._id, model, new Date());
        },

        restoreState: function (silent) {
            var value = null;
            if (window.localStorage)
                value = window.localStorage.getItem("$sf$" + this.pluginName + this._id);
            else if (document.cookie)
                value = sf.cookie.get("$sf$" + this.pluginName + this._id);

            if (value) {
                var model = JSON.parse(value);

                if (this._restoreState) {
                    this._restoreState(model.customPersists);
                    delete model.customPersists;
                }

                if (sf.isNullOrUndefined(model) === false)
                    if (!sf.isNullOrUndefined(model.ignoreOnPersist)) {
                        this._ignoreOnPersist = model.ignoreOnPersist;
                        delete model.ignoreOnPersist;
                    } else if (!sf.isNullOrUndefined(model.addToPersist)) {
                        this._addToPersist = model.addToPersist;
                        delete model.addToPersist;
                    }
            }
            if (!sf.isNullOrUndefined(model) && !sf.isNullOrUndefined(this._ignoreOnPersist)) {
                for(var i = 0, len =  this._ignoreOnPersist.length; i < len; i++) {
					if (this._ignoreOnPersist[i].indexOf('.') !== -1)
                        sf.createObject(this._ignoreOnPersist[i], sf.getObject(this._ignoreOnPersist[i], this.model), model);
                    else
                        model[this._ignoreOnPersist[i]] = this.model[this._ignoreOnPersist[i]];
				}
				if(this.model.ngTemplateId && this.model.ngTemplateId != model.ngTemplateId)
				   model.ngTemplateId = this.model.ngTemplateId;			   
                this.model = model;
            }
            else
                this.model = $.extend(true, this.model, model);

            if (!silent && value && this._setModel)
                this._setModel(this.model);
        },

        //to prevent persistence
        ignoreOnPersist: function (properties) {
            var collection = [];
            if (typeof (properties) == "object")
                collection = properties;
            else if (typeof (properties) == 'string')
                collection.push(properties);
            if (this._addToPersist === undefined) {
                this._ignoreOnPersist = this._ignoreOnPersist || [];
                for (var i = 0; i < collection.length; i++) {
                    this._ignoreOnPersist.push(collection[i]);
                }
            } else {
                for (var i = 0; i < collection.length; i++) {
                    var index = this._addToPersist.indexOf(collection[i]);
                    this._addToPersist.splice(index, 1);
                }
            }
        },

        //to maintain persistence
        addToPersist: function (properties) {
            var collection = [];
            if (typeof (properties) == "object")
                collection = properties;
            else if (typeof (properties) == 'string')
                collection.push(properties);
            if (this._addToPersist === undefined) {
                this._ignoreOnPersist = this._ignoreOnPersist || [];
                for (var i = 0; i < collection.length; i++) {
                    var index = this._ignoreOnPersist.indexOf(collection[i]);
                    this._ignoreOnPersist.splice(index, 1);
                }
            } else {
                for (var i = 0; i < collection.length; i++) {
                    if ($.inArray(collection[i], this._addToPersist) === -1)
                        this._addToPersist.push(collection[i]);
                }
            }
        },

        // Get formatted text 
        formatting: function (formatstring, str, locale) {
            formatstring = formatstring.replace(/%280/g, "\"").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            locale = sf.preferredCulture(locale) ? locale : "en-US";
            var s = formatstring;
            var frontHtmlidx, FrontHtml, RearHtml, lastidxval;
            frontHtmlidx = formatstring.split("{0:");
            lastidxval = formatstring.split("}");
            FrontHtml = frontHtmlidx[0];
            RearHtml = lastidxval[1];
            if (typeof (str) == "string" && $.isNumeric(str))
                str = Number(str);
            if (formatstring.indexOf("{0:") != -1) {
                var toformat = new RegExp("\\{0(:([^\\}]+))?\\}", "gm");
                var formatVal = toformat.exec(formatstring);
                if (formatVal != null && str != null) {
                    if (FrontHtml != null && RearHtml != null)
                        str = FrontHtml + sf.format(str, formatVal[2], locale) + RearHtml;
                    else
                        str = sf.format(str, formatVal[2], locale);
                } else if (str != null)
                    str = str;
                else
                    str = "";
                return str;
            } else if (s.startsWith("{") && !s.startsWith("{0:")) {
                var fVal = s.split(""), str = (str || "") + "", strSplt = str.split(""), formats = /[0aA\*CN<>\?]/gm;
                for (var f = 0, f, val = 0; f < fVal.length; f++)
                    fVal[f] = formats.test(fVal[f]) ? "{" + val++ + "}" : fVal[f];
                return String.format.apply(String, [fVal.join("")].concat(strSplt)).replace('{', '').replace('}', '');
            } else if (this.data != null && this.data.Value == null) {
                $.each(this.data, function (dataIndex, dataValue) {
                    s = s.replace(new RegExp('\\{' + dataIndex + '\\}', 'gm'), dataValue);
                });
                return s;
            } else {
                return this.data.Value;
            }
        },
    };

    sf.WidgetBase = function () {
    }

    var iterateAndRemoveProps = function (source, target) {
		if(source instanceof Array) {
			for (var i = 0, len = source.length; i < len; i++) {
				prop = source[i];
				if(prop === target[prop])
					delete target[prop];
				if ($.isPlainObject(target[prop]) && $.isPlainObject(prop))
					iterateAndRemoveProps(prop, target[prop]);
			}
		}
		else {
			for (var prop in source) {
				if (source[prop] === target[prop])
					delete target[prop];
				if ($.isPlainObject(target[prop]) && $.isPlainObject(source[prop]))
					iterateAndRemoveProps(source[prop], target[prop]);
			}
		}
    }

    sf.widget = function (pluginName, className, proto) {
        /// <summary>Widget helper for developers, this set have predefined function to jQuery plug-ins</summary>
        /// <param name="pluginName" type="String">the plugin name that will be added in jquery.fn</param>
        /// <param name="className" type="String">the class name for your plugin, this will help create default cssClas</param>
        /// <param name="proto" type="Object">prototype for of the plug-in</param>

        if (typeof pluginName === "object") {
            proto = className;
            for (var prop in pluginName) {
                var name = pluginName[prop];

                if (name instanceof Array) {
                    proto._rootCSS = name[1];
                    name = name[0];
                }

                sf.widget(prop, name, proto);

                if (pluginName[prop] instanceof Array)
                    proto._rootCSS = "";
            }

            return;
        }

        var nameSpace = proto._rootCSS || sf.getNameSpace(className);

        proto = sf.defineClass(className, function (element, options) {

            this.sfType = className;
            this.pluginName = pluginName;
            this.instance = pInstance;

            if (sf.isNullOrUndefined(this._setFirst))
                this._setFirst = true;

            this["ob.values"] = {};

            $.extend(this, sf.widgetBase);

            if (this.dataTypes) {
                for (var property in options) {
                    var returnValue = this._isValidModelValue(property, this.dataTypes, options);
                    if (returnValue !== true)
                        throw "setModel - Invalid input for property :" + property + " - " + returnValue;
                }
            }

            var arr = (element.data("ejWidgets") || []);
            arr.push(pluginName);
            element.data("ejWidgets", arr);

            for (var i = 0; sf.widget.observables && this.observables && i < this.observables.length; i++) {
                var t = sf.getObject(this.observables[i], options);
                if (t) sf.createObject(this.observables[i], sf.widget.observables.register(t, this.observables[i], this, element), options);
            }

            this.element = element.jquery ? element : $(element);
            this.model = copyObject(true, {}, proto.prototype.defaults, options);
            this.model.keyConfigs = copyObject(this.keyConfigs);

            this.element.addClass(nameSpace + " e-js").data(pluginName, this);

            this._id = element[0].id;

            if (this.model.enablePersistence) {
                if (window.localStorage && !sf.isNullOrUndefined(sf.persistStateVersion) && window.localStorage.getItem("persistKey") != sf.persistStateVersion) {
                    for (var i in window.localStorage) {
                        if (i.indexOf("$sf$") != -1) {
                            window.localStorage.removeItem(i); //removing the previously stored plugin item from local storage
							window.localStorage.setItem("persistKey", sf.persistStateVersion);
						}				
                    }
                }
                else if (document.cookie && !sf.isNullOrUndefined(sf.persistStateVersion) && sf.cookie.get("persistKey") != sf.persistStateVersion) {
                    var model;
                    var splits = document.cookie.split(/; */);
                    for (var k in splits) {
                        if (k.indexOf("$sf$") != -1) {
                            sf.cookie.set(k.split("=")[0], model, new Date()); //removing the previously stored plugin item from local storage
							sf.cookie.set("persistKey", sf.persistStateVersion);
						}		
                    }
                }
                this._persistHandler = sf.proxy(this.persistState, this);
                $(window).on("unload", this._persistHandler);
                this.restoreState(true);
            }

            this._init(options);

            if (typeof this.model.keyConfigs === "object" && !(this.model.keyConfigs instanceof Array)) {
                var requiresEvt = false;
                if (this.model.keyConfigs.focus)
                    this.element.attr("accesskey", this.model.keyConfigs.focus);

                for (var keyProps in this.model.keyConfigs) {
                    if (keyProps !== "focus") {
                        requiresEvt = true;
                        break;
                    }
                }

                if (requiresEvt && this._keyPressed) {
                    var el = element, evt = "keydown";

                    if (this.keySettings) {
                        el = this.keySettings.getElement ? this.keySettings.getElement() || el : el;
                        evt = this.keySettings.event || evt;
                    }

                    this._on(el, evt, function (e) {
                        if (!this.model.keyConfigs) return;

                        var action = keyFn.getActionFromCode(this.model.keyConfigs, e.which, e.ctrlKey, e.shiftKey, e.altKey);
                        var arg = {
                            code: e.which,
                            ctrl: e.ctrlKey,
                            alt: e.altKey,
                            shift: e.shiftKey
                        };
                        if (!action) return;

                        if (this._keyPressed(action, e.target, arg, e) === false)
                            e.preventDefault();
                    });
                }
            }
            this._trigger("create");
        }, proto);

        $.fn[pluginName] = function (options) {
            var opt = options, args;
            for (var i = 0; i < this.length; i++) {

                var $this = $(this[i]),
                    pluginObj = $this.data(pluginName),
                    isAlreadyExists = pluginObj && $this.hasClass(nameSpace),
                    obj = null;

                if (this.length > 0 && $.isPlainObject(opt))
                    options = sf.copyObject({}, opt);

                // ----- plug-in creation/init
                if (!isAlreadyExists) {
                    if (proto.prototype._requiresID === true && !$(this[i]).attr("id")) {
                        $this.attr("id", getUid("ejControl_"));
                    }
                    if (!options || typeof options === "object") {
                        if (proto.prototype.defaults && !sf.isNullOrUndefined(sf.setCulture) && "locale" in proto.prototype.defaults && pluginName != "ejChart") {
                            if (options && !("locale" in options)) options.locale = sf.setCulture().name;
                            else if (sf.isNullOrUndefined(options)) {
                                options = {}; options.locale = sf.setCulture().name;
                            }
                        }
                        new proto($this, options);
                    }
                    else {
                        throwError(pluginName + ": methods/properties can be accessed only after plugin creation");
                    }
                    continue;
                }

                if (!options) continue;

                args = [].slice.call(arguments, 1);

                if (this.length > 0 && args[0] && opt === "option" && $.isPlainObject(args[0])) {
                    args[0] = sf.copyObject({}, args[0]);
                }

                // --- Function/property set/access
                if ($.isPlainObject(options)) {
                    // setModel using JSON object
                    pluginObj.setModel(options);
                }

                    // function/property name starts with "_" is private so ignore it.
                else if (options.indexOf('_') !== 0
                    && !sf.isNullOrUndefined(obj = sf.getObject(options, pluginObj))
                    || options.indexOf("model.") === 0) {

                    if (!obj || !$.isFunction(obj)) {

                        // if property is accessed, then break the jquery chain
                        if (arguments.length == 1)
                            return obj;

                        //setModel using string input
                        pluginObj.option(options, arguments[1]);

                        continue;
                    }

                    var value = obj.apply(pluginObj, args);

                    // If function call returns any value, then break the jquery chain
                    if (value !== undefined)
                        return value;

                } else {
                    throwError(className + ": function/property - " + options + " does not exist");
                }
            }
            if (pluginName.indexOf("ejm") != -1)
                sf.widget.registerInstance($this, pluginName, className, proto.prototype);
            // maintaining jquery chain
            return this;
        };

        sf.widget.register(pluginName, className, proto.prototype);
        sf.loadLocale(pluginName);
    };

    sf.loadLocale = function (pluginName) {
        var i, len, locales = sf.locales;
        for (i = 0, len = locales.length; i < len; i++)
            $.fn["Locale_" + locales[i]](pluginName);
    };


    $.extend(sf.widget, (function () {
        var _widgets = {}, _registeredInstances = [],

        register = function (pluginName, className, prototype) {
            if (!sf.isNullOrUndefined(_widgets[pluginName]))
                throwError("sf.widget : The widget named " + pluginName + " is trying to register twice.");

            _widgets[pluginName] = { name: pluginName, className: className, proto: prototype };

            sf.widget.extensions && sf.widget.extensions.registerWidget(pluginName);
        },
        registerInstance = function (element, pluginName, className, prototype) {
            _registeredInstances.push({ element: element, pluginName: pluginName, className: className, proto: prototype });
        }

        return {
            register: register,
            registerInstance: registerInstance,
            registeredWidgets: _widgets,
            registeredInstances: _registeredInstances
        };

    })());

    sf.widget.destroyAll = function (elements) {
        if (!elements || !elements.length) return;

        for (var i = 0; i < elements.length; i++) {
            var data = elements.eq(i).data(), wds = data["ejWidgets"];
            if (wds && wds.length) {
                for (var j = 0; j < wds.length; j++) {
                    if (data[wds[j]] && data[wds[j]].destroy)
                        data[wds[j]].destroy();
                }
            }
        }
    };

    sf.cookie = {
        get: function (name) {
            var value = RegExp(name + "=([^;]+)").exec(document.cookie);

            if (value && value.length > 1)
                return value[1];

            return undefined;
        },
        set: function (name, value, expiryDate) {
            if (typeof value === "object")
                value = JSON.stringify(value);

            value = escape(value) + ((expiryDate == null) ? "" : "; expires=" + expiryDate.toUTCString());
            document.cookie = name + "=" + value;
        }
    };

    var keyFn = {
        getActionFromCode: function (keyConfigs, keyCode, isCtrl, isShift, isAlt) {
            isCtrl = isCtrl || false;
            isShift = isShift || false;
            isAlt = isAlt || false;

            for (var keys in keyConfigs) {
                if (keys === "focus") continue;

                var key = keyFn.getKeyObject(keyConfigs[keys]);
                for (var i = 0; i < key.length; i++) {
                    if (keyCode === key[i].code && isCtrl == key[i].isCtrl && isShift == key[i].isShift && isAlt == key[i].isAlt)
                        return keys;
                }
            }
            return null;
        },
        getKeyObject: function (key) {
            var res = {
                isCtrl: false,
                isShift: false,
                isAlt: false
            };
            var tempRes = $.extend(true, {}, res);
            var $key = key.split(","), $res = [];
            for (var i = 0; i < $key.length; i++) {
                var rslt = null;
                if ($key[i].indexOf("+") != -1) {
                    var k = $key[i].split("+");
                    for (var j = 0; j < k.length; j++) {
                        rslt = keyFn.getResult($.trim(k[j]), res);
                    }
                }
                else {
                    rslt = keyFn.getResult($.trim($key[i]), $.extend(true, {}, tempRes));
                }
                $res.push(rslt);
            }
            return $res;
        },
        getResult: function (key, res) {
            if (key === "ctrl")
                res.isCtrl = true;
            else if (key === "shift")
                res.isShift = true;
            else if (key === "alt")
                res.isAlt = true;
            else res.code = parseInt(key, 10);
            return res;
        }
    };

    sf.getScrollableParents = function (element) {
        return $(element).parentsUntil("html").filter(function () {
            return $(this).css("overflow") != "visible";
        }).add($(window));
    }
    sf.browserInfo = function () {
        var browser = {}, clientInfo = [],
        browserClients = {
            opera: /(opera|opr)(?:.*version|)[ \/]([\w.]+)/i, edge: /(edge)(?:.*version|)[ \/]([\w.]+)/i, webkit: /(chrome)[ \/]([\w.]+)/i, safari: /(webkit)[ \/]([\w.]+)/i, msie: /(msie|trident) ([\w.]+)/i, mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
        };
        for (var client in browserClients) {
            if (browserClients.hasOwnProperty(client)) {
                clientInfo = navigator.userAgent.match(browserClients[client]);
                if (clientInfo) {
                    browser.name = clientInfo[1].toLowerCase() == "opr" ? "opera" : clientInfo[1].toLowerCase();
                    browser.version = clientInfo[2];
                    browser.culture = {};
                    browser.culture.name = browser.culture.language = navigator.language || navigator.userLanguage;
                    if (typeof (sf.globalize) != 'undefined') {
                        var oldCulture = sf.preferredCulture().name;
                        var culture = (navigator.language || navigator.userLanguage) ? sf.preferredCulture(navigator.language || navigator.userLanguage) : sf.preferredCulture("en-US");
                        for (var i = 0; (navigator.languages) && i < navigator.languages.length; i++) {
                            culture = sf.preferredCulture(navigator.languages[i]);
                            if (culture.language == navigator.languages[i])
                                break;
                        }
                        sf.preferredCulture(oldCulture);
                        $.extend(true, browser.culture, culture);
                    }
                    if (!!navigator.userAgent.match(/Trident\/7\./)) {
                        browser.name = "msie";
                    }
                    break;
                }
            }
        }
        browser.isMSPointerEnabled = (browser.name == 'msie') && browser.version > 9 && window.navigator.msPointerEnabled;
        browser.pointerEnabled = window.navigator.pointerEnabled;
        return browser;
    };
    sf.eventType = {
        mouseDown: "mousedown touchstart",
        mouseMove: "mousemove touchmove",
        mouseUp: "mouseup touchend",
        mouseLeave: "mouseleave touchcancel",
        click: "click touchend"
    };

    sf.event = function (type, data, eventProp) {

        var e = $.extend(eventProp || {},
            {
                "type": type,
                "model": data,
                "cancel": false
            });

        return e;
    };

    sf.proxy = function (fn, context, arg) {
        if (!fn || typeof fn !== "function")
            return null;

        if ('on' in fn && context)
            return arg ? fn.on(context, arg) : fn.on(context);

        return function () {
            var args = arg ? [arg] : []; args.push.apply(args, arguments);
            return fn.apply(context || this, args);
        };
    };

    sf.hasStyle = function (prop) {
        var style = document.documentElement.style;

        if (prop in style) return true;

        var prefixs = ['ms', 'Moz', 'Webkit', 'O', 'Khtml'];

        prop = prop[0].toUpperCase() + prop.slice(1);

        for (var i = 0; i < prefixs.length; i++) {
            if (prefixs[i] + prop in style)
                return true;
        }

        return false;
    };

    Array.prototype.indexOf = Array.prototype.indexOf || function (searchElement) {
        var len = this.length;

        if (len === 0) return -1;

        for (var i = 0; i < len; i++) {
            if (i in this && this[i] === searchElement)
                return i;
        }
        return -1;
    };

    String.prototype.startsWith = String.prototype.startsWith || function (key) {
        return this.slice(0, key.length) === key;
    };
    var copyObject = sf.copyObject = function (isDeepCopy, target) {
        var start = 2, current, source;
        if (typeof isDeepCopy !== "boolean") {
            start = 1;
        }
        var objects = [].slice.call(arguments, start);
        if (start === 1) {
            target = isDeepCopy;
            isDeepCopy = undefined;
        }

        for (var i = 0; i < objects.length; i++) {
            for (var prop in objects[i]) {
                current = target[prop], source = objects[i][prop];

                if (source === undefined || current === source || objects[i] === source || target === source)
                    continue;
                if (source instanceof Array) {
                    if (i === 0 && isDeepCopy) {
                        if (prop === "dataSource" || prop === "data" || prop === "predicates")
                            target[prop] = source.slice();
					  else  {
                        target[prop] = new Array();
                        for (var j = 0; j < source.length; j++) {
                            copyObject(true, target[prop], source);
                        }
					  }
                    }
                    else
                        target[prop] = source.slice();
                }
                else if (sf.isPlainObject(source)) {
                    target[prop] = current || {};
                    if (isDeepCopy)
                        copyObject(isDeepCopy, target[prop], source);
                    else
                        copyObject(target[prop], source);
                } else
                    target[prop] = source;
            }
        }
        return target;
    };
    var pInstance = function () {
        return this;
    }

    var _uid = 0;
    var getUid = function (prefix) {
        return prefix + _uid++;
    }

    sf.template = {};

    sf.template.render = sf.template["text/x-jsrender"] = function (self, selector, data, index, prop) {
        if (selector.slice(0, 1) !== "#")
            selector = ["<div>", selector, "</div>"].join("");
        var property = { prop: prop, index: index };
        return $(selector).render(data, property);
    }

    sf.isPlainObject = function (obj) {
        if (!obj) return false;
        if (sf.DataManager !== undefined && obj instanceof sf.DataManager) return false;
        if (typeof obj !== "object" || obj.nodeType || jQuery.isWindow(obj)) return false;
        try {
            if (obj.constructor &&
                !obj.constructor.prototype.hasOwnProperty("isPrototypeOf")) {
                return false;
            }
        } catch (e) {
            return false;
        }

        var key, ownLast = sf.support.isOwnLast;
        for (key in obj) {
            if (ownLast) break;
        }

        return key === undefined || obj.hasOwnProperty(key);
    };
    var getValueFn = false;
    sf.util.valueFunction = function (prop) {
        return function (value, getObservable) {
            var val = sf.getObject(prop, this.model);

            if (getValueFn === false)
                getValueFn = sf.getObject("observables.getValue", sf.widget);

            if (value === undefined) {
                if (!sf.isNullOrUndefined(getValueFn)) {
                    return getValueFn(val, getObservable);
                }
                return typeof val === "function" ? val.call(this) : val;
            }

            if (typeof val === "function") {
                this["ob.values"][prop] = value;
                val.call(this, value);
            }
            else
                sf.createObject(prop, value, this.model);
        }
    };
    sf.util.getVal = function (val) {
        if (typeof val === "function")
            return val();
        return val;
    };
    sf.support = {
        isOwnLast: function () {
            var fn = function () { this.a = 1; };
            fn.prototype.b = 1;

            for (var p in new fn()) {
                return p === "b";
            }
        }(),
        outerHTML: function () {
            return document.createElement("div").outerHTML !== undefined;
        }()
    };

    var throwError = sf.throwError = function (er) {
        try {
            throw new Error(er);
        } catch (e) {
            throw e.message + "\n" + e.stack;
        }
    };

    sf.getRandomValue = function (min, max) {
        if (min === undefined || max === undefined)
            return sf.throwError("Min and Max values are required for generating a random number");

        var rand;
        if ("crypto" in window && "getRandomValues" in crypto) {
            var arr = new Uint16Array(1);
            window.crypto.getRandomValues(arr);
            rand = arr[0] % (max - min) + min;
        }
        else rand = Math.random() * (max - min) + min;
        return rand | 0;
    }

    sf.extensions = {};
    sf.extensions.modelGUID = "{0B1051BA-1CCB-42C2-A3B5-635389B92A50}";
})(window.jQuery, window.Sfusion);
(function () {
    $.fn.addEleAttrs = function (json) {
        var $this = $(this);
        $.each(json, function (i, attr) {
            if (attr && attr.specified) {
                $this.attr(attr.name, attr.value);
            }
        });

    };
    $.fn.removeEleAttrs = function (regex) {
        return this.each(function () {
            var $this = $(this),
                names = [],
                attrs = $(this.attributes).clone();
            $.each(attrs, function (i, attr) {
                if (attr && attr.specified && regex.test(attr.name)) {
                    $this.removeAttr(attr.name);
                }
            });
        });
    };
    $.fn.attrNotStartsWith = function (regex) {
        var proxy = this;
        var attributes = [], attrs;
        this.each(function () {
            attrs = $(this.attributes).clone();
        });
        for ( var i = 0; i < attrs.length; i++) {
            if (attrs[i] && attrs[i].specified && regex.test(attrs[i].name)) {
                continue
            }
            else
                attributes.push(attrs[i])
        }
        return attributes;

    }
    $.fn.removeEleEmptyAttrs = function () {
        return this.each(function () {
            var $this = $(this),
                names = [],
                attrs = $(this.attributes).clone();
            $.each(attrs, function (i, attr) {
                if (attr && attr.specified && attr.value === "") {
                    $this.removeAttr(attr.name);
                }
            });
        });
    };
    $.extend($.support, {
        has3d: sf.addPrefix('perspective') in sf.styles,
        hasTouch: 'ontouchstart' in window,
        hasPointer: navigator.msPointerEnabled,
        hasTransform: sf.userAgent() !== false,
        pushstate: "pushState" in history &&
        "replaceState" in history,
        hasTransition: sf.addPrefix('transition') in sf.styles
    });
    //Ensuring elements having attribute starts with 'ejm-' 
    $.extend($.expr[':'], {
        attrNotStartsWith: function (element, index, match) {
            var i, attrs = element.attributes;
            for (i = 0; i < attrs.length; i++) {
                if (attrs[i].nodeName.indexOf(match[3]) === 0) {
                    return false;
                }
            }
            return true;
        }
    });
    //addBack() is supported from Jquery >1.8 and andSelf() supports later version< 1.8. support for both the method is provided by extending the JQuery function.
    var oldSelf = $.fn.andSelf || $.fn.addBack;
    $.fn.andSelf = $.fn.addBack = function () {
        return oldSelf.apply(this, arguments);
    };
})();;
;
window.sf = window.Sfusion = window.Sfusion || {};

(function ($, sf, doc, undefined) {
    'use strict';

  
    sf.DataManager = function (dataSource, query, adaptor) {
          if (!(this instanceof sf.DataManager))
            return new sf.DataManager(dataSource, query, adaptor);

        if (!dataSource)
            dataSource = [];
        adaptor = adaptor || dataSource.adaptor;

        if (typeof (adaptor) === "string") 
            adaptor = new sf[adaptor]();
        var data = [], self = this;

        if (dataSource instanceof Array) {
            // JSON array
            data = {
                json: dataSource,
                offline: true
            };

        } else if (typeof dataSource === "object") {
            if ($.isPlainObject(dataSource)) {
                if (!dataSource.json)
                    dataSource.json = [];
                if (dataSource.table)
                    dataSource.json = this._getJsonFromElement(dataSource.table, dataSource.headerOption);
                data = {
                    url: dataSource.url,
                    insertUrl: dataSource.insertUrl,
                    removeUrl: dataSource.removeUrl,
                    updateUrl: dataSource.updateUrl,
                    crudUrl: dataSource.crudUrl,
                    batchUrl: dataSource.batchUrl,
                    json: dataSource.json,
                    headers: dataSource.headers,
                    accept: dataSource.accept,
                    data: dataSource.data,
					async : dataSource.async,
                    timeTillExpiration: dataSource.timeTillExpiration,
                    cachingPageSize: dataSource.cachingPageSize,
                    enableCaching: dataSource.enableCaching,
                    requestType: dataSource.requestType,
                    key: dataSource.key,
                    crossDomain: dataSource.crossDomain,
                    antiForgery: dataSource.antiForgery,
                    jsonp: dataSource.jsonp,
                    dataType: dataSource.dataType,
                    enableAjaxCache: dataSource.enableAjaxCache,
                    offline: dataSource.offline !== undefined ? dataSource.offline : dataSource.adaptor == "remoteSaveAdaptor" || dataSource.adaptor instanceof sf.remoteSaveAdaptor ? false : dataSource.url ? false : true,
                    requiresFormat: dataSource.requiresFormat
                };
            } else if (dataSource.jquery || isHtmlElement(dataSource)) {
                data = {
                    json: this._getJsonFromElement(dataSource),
                    offline: true,
                    table: dataSource
                };
            }
        } else if (typeof dataSource === "string") {
            data = {
                url: dataSource,
                offline: false,
                dataType: "json",
                json: []
            };
        }

        if (data.requiresFormat === undefined && !sf.support.cors)
            data.requiresFormat = isNull(data.crossDomain) ? true : data.crossDomain;
         if(data.antiForgery){
        this.antiForgeryToken();
        }
        if (data.dataType === undefined)
            data.dataType = "json";
        this.dataSource = data;
        this.defaultQuery = query;

        if (data.url && data.offline && !data.json.length) {
            this.isDataAvailable = false;
            this.adaptor = adaptor || new sf.ODataAdaptor();
            this.dataSource.offline = false;
            this.ready = this.executeQuery(query || sf.Query()).done(function (e) {
                self.dataSource.offline = true;
                self.isDataAvailable = true;
                data.json = e.result;
                self.adaptor = new sf.JsonAdaptor();
            });
        }
        else
            this.adaptor = data.offline ? new sf.JsonAdaptor() : new sf.ODataAdaptor();
        if (!data.jsonp && this.adaptor instanceof sf.ODataAdaptor)
            data.jsonp = "callback";
        this.adaptor = adaptor || this.adaptor;
        if (data.enableCaching)
            this.adaptor = new sf.CacheAdaptor(this.adaptor, data.timeTillExpiration, data.cachingPageSize);
        return this;
    };

    sf.DataManager.prototype = {
        setDefaultQuery: function (query) {
            this.defaultQuery = query;
        },
	
        executeQuery: function (query, done, fail, always) {
            if (typeof query === "function") {
                always = fail;
                fail = done;
                done = query;
                query = null;
            }

            if (!query)
                query = this.defaultQuery;

            if (!(query instanceof sf.Query))
                throwError("DataManager - executeQuery() : A query is required to execute");

            var deffered = $.Deferred();

            deffered.then(done, fail, always);
            var args = { query: query };

            if (!this.dataSource.offline && this.dataSource.url != undefined) {
				 var result = this.adaptor.processQuery(this, query);
                if (!sf.isNullOrUndefined(result.url))
                    this._makeRequest(result, deffered, args, query);
                else {
                    nextTick(function () {
                        args = this._getDeferedArgs(query, result, args);
                        deffered.resolveWith(this, [args]);;
                    }, this);
                }
            } else {
				if(!sf.isNullOrUndefined(this.dataSource.async) && this.dataSource.async == false)
					this._localQueryProcess(query, args, deffered);
				else{
					nextTick(function () {
						this._localQueryProcess(query, args, deffered);
					}, this);
				}
            }
            return deffered.promise();
        },
		_localQueryProcess: function(query, args, deffered){
			var res = this.executeLocal(query);
			args = this._getDeferedArgs(query, res, args);
			deffered.resolveWith(this, [args]);
		},
        _getDeferedArgs: function (query, result, args) {
            if (query._requiresCount) {
                args.result = result.result;
                args.count = result.count;
            } else
                args.result = result;
            args.getTableModel = getTableModel(query._fromTable, args.result, this);
            args.getKnockoutModel = getKnockoutModel(args.result);
            return args;
        },
	
        executeLocal: function (query) {
            if (!this.defaultQuery && !(query instanceof sf.Query))
                throwError("DataManager - executeLocal() : A query is required to execute");

            if (!this.dataSource.json)
                throwError("DataManager - executeLocal() : Json data is required to execute");

            query = query || this.defaultQuery;

            var result = this.adaptor.processQuery(this, query);

            if (query._subQuery) {
                var from = query._subQuery._fromTable, lookup = query._subQuery._lookup,
                    res = query._requiresCount ? result.result : result;

                if (lookup && lookup instanceof Array) {
                    buildHierarchy(query._subQuery._fKey, from, res, lookup, query._subQuery._key);
                }

                for (var j = 0; j < res.length; j++) {
                    if (res[j][from] instanceof Array) {
                        res[j] = $.extend({}, res[j]);
                        res[j][from] = this.adaptor.processResponse(query._subQuery.using(sf.DataManager(res[j][from].slice(0))).executeLocal(), this, query);
                    }
                }
            }

            return this.adaptor.processResponse(result, this, query);
        },

        _makeRequest: function (url, deffered, args, query) {
            var isSelector = !!query._subQuerySelector;

            var fnFail = $proxy(function (e) {
                args.error = e;
                deffered.rejectWith(this, [args]);
            }, this);

            var process = $proxy(function (data, count, xhr, request, actual, aggregates, virtualSelectRecords) {
                if (isSelector) return;

                args.xhr = xhr;
                args.count = parseInt(count, 10);
                args.result = data;
                args.request = request;
                args.aggregates = aggregates;
                args.getTableModel = getTableModel(query._fromTable, data, this);
                args.getKnockoutModel = getKnockoutModel(data);
                args.actual = actual;
                args.virtualSelectRecords = virtualSelectRecords;
                deffered.resolveWith(this, [args]);

            }, this);

            var fnQueryChild = $proxy(function (data, selector) {
                var subDeffer = $.Deferred(),
                    childArgs = { parent: args };

                query._subQuery._isChild = true;

                var subUrl = this.adaptor.processQuery(this, query._subQuery, data ? this.adaptor.processResponse(data) : selector);

                var childReq = this._makeRequest(subUrl, subDeffer, childArgs, query._subQuery);

                if(!isSelector)
                    subDeffer.then(function (subData) {
                        if (data) {
                            buildHierarchy(query._subQuery._fKey, query._subQuery._fromTable, data, subData, query._subQuery._key);
                            process(data);
                        }
                    }, fnFail);

                return childReq;
            }, this);

            var fnSuccess = proxy(function (data, status, xhr, request) {
                if (xhr.getResponseHeader("Content-Type").indexOf("xml") == -1 && sf.dateParse)
                    data = sf.parseJSON(data);
                var result = this.adaptor.processResponse(data, this, query, xhr, request), count = 0, aggregates = null;
                var virtualSelectRecords = data.virtualSelectRecords;
                if (query._requiresCount) {
                    count = result.count;
                    aggregates = result.aggregates;
                    result = result.result;
                }

                if (!query._subQuery) {
                    process(result, count, xhr, request, data, aggregates, virtualSelectRecords);
                    return;
                }

                if (!isSelector)
                    fnQueryChild(result);

            }, this);

            var req = $.extend({
                type: "GET",
                dataType: this.dataSource.dataType,
                crossDomain: this.dataSource.crossDomain,
                jsonp: this.dataSource.jsonp,
                cache: sf.isNullOrUndefined(this.dataSource.enableAjaxCache) ? true: this.dataSource.enableAjaxCache,
                beforeSend: $proxy(this._beforeSend, this),
                processData: false,
                success: fnSuccess,
                error: fnFail
            }, url);

            if ("async" in this.dataSource)
                req.async = this.dataSource.async;

            req = $.ajax(req);

            if (isSelector) {
                var res = query._subQuerySelector.call(this, { query: query._subQuery, parent: query });

                if (res && res.length) {
                    req = $.when(req, fnQueryChild(null, res));

                    req.then(proxy(function (pData, cData, requests) {
                        var pResult = this.adaptor.processResponse(pData[0], this, query, pData[2], requests[0]), count = 0;
                        if (query._requiresCount) {
                            count = pResult.count;
                            pResult = pResult.result;
                        }
                        var cResult = this.adaptor.processResponse(cData[0], this, query._subQuery, cData[2], requests[1]), count = 0;
                        if (query._subQuery._requiresCount) {
                            count = cResult.count;
                            cResult = cResult.result;
                        }

                        buildHierarchy(query._subQuery._fKey, query._subQuery._fromTable, pResult, cResult, query._subQuery._key);
                        isSelector = false;
                        process(pResult, count, pData[2]);

                    }, this), fnFail);
                } else {
                    isSelector = false;
                }
            }

            return req;
        },

        _beforeSend: function (request, settings) {
            this.adaptor.beforeSend(this, request, settings);

            var headers = this.dataSource.headers, props;
            for (var i = 0; headers && i < headers.length; i++) {
                props = [];
                for (var prop in headers[i]) {
                    props.push(prop);
                    request.setRequestHeader(prop, headers[i][prop]);
                }
            }
        },
	
        saveChanges: function (changes, key, tableName, query) {

            if (tableName instanceof sf.Query) {
                query = tableName;
                tableName = null;
            }

            var args = {
                url: tableName,
                key: key || this.dataSource.key
            };

            var req = this.adaptor.batchRequest(this, changes, args, query);

            if (this.dataSource.offline) {
                return req;
            }

            var deff = $.Deferred();
            $.ajax($.extend({
                beforeSend: $proxy(this._beforeSend, this),
                success: proxy(function (data, status, xhr, request) {
                    deff.resolveWith(this, [this.adaptor.processResponse(data, this, null, xhr, request, changes, key)]);
                }, this),
                error: function (e) {
                    deff.rejectWith(this, [{ error: e }]);
                }
            }, req));

            return deff.promise();
        },
	
        insert: function (data, tableName, query) {       
            // Additional paramater is included based on the task (JS-56499) to prevent addition of serverOffset multiple times
            data = p.replacer(data, true);

            if (tableName instanceof sf.Query) {
                query = tableName;
                tableName = null;
            }

            var res = this.adaptor.insert(this, data, tableName, query);

            if (this.dataSource.offline) {
                return res;
            }            

            var deffer = $.Deferred();

            $.ajax($.extend({
                type: "POST",
                contentType: "application/json; charset=utf-8",
                processData: false,
                beforeSend: $proxy(this._beforeSend, this),
                success: proxy(function (record, status, xhr, request) {
                    try {
                        if (sf.isNullOrUndefined(record))
                            record = [];
                        else
                            p.parseJson(record);
                    }
                    catch (e) {
                        record = [];
                    }
                    record = this.adaptor.processResponse(p.parseJson(record), this, null, xhr, request);
                    deffer.resolveWith(this, [{ record: record, dataManager: this }]);
                }, this),
                error: function (e) {
                    deffer.rejectWith(this, [{ error: e, dataManager: this }]);
                }
            }, res));

            return deffer.promise();
        },
        antiForgeryToken: function () {
           var tokens = {};
           if(sf.isNullOrUndefined($("input[name='_ejRequestVerifyToken']").val()))
                var input = sf.buildTag("input", "", "", { type: "hidden", name: "_ejRequestVerifyToken" , value: sf.getGuid()}).appendTo("body"); 
           else
               $("input[name='_ejRequestVerifyToken']").val(sf.getGuid());
            sf.cookie.set("_ejRequestVerifyToken", $("input[name='_ejRequestVerifyToken']").val());
            tokens ={name: "_ejRequestVerifyToken", value: $("input[name='_ejRequestVerifyToken']").val()}
            return tokens;
        },
        remove: function (keyField, value, tableName, query) {
            if (typeof value === "object")
                value = value[keyField];

            if (tableName instanceof sf.Query) {
                query = tableName;
                tableName = null;
            }

            var res = this.adaptor.remove(this, keyField, value, tableName, query);

            if (this.dataSource.offline)
                return res;          

            var deffer = $.Deferred();
            $.ajax($.extend({
                type: "POST",
                contentType: "application/json; charset=utf-8",
                beforeSend: $proxy(this._beforeSend, this),
                success: proxy(function (record, status, xhr, request) {
                    try {
                        if (sf.isNullOrUndefined(record))
                            record = [];
                        else
                            p.parseJson(record);
                    }
                    catch (e) {
                        record = [];
                    }
                    record = this.adaptor.processResponse(p.parseJson(record), this, null, xhr, request);
                    deffer.resolveWith(this, [{ record: record, dataManager: this }]);
                }, this),
                error: function (e) {
                    deffer.rejectWith(this, [{ error: e, dataManager: this }]);
                }
            }, res));
            return deffer.promise();
        },
	
        update: function (keyField, value, tableName, query) {
            // Additional paramater is included based on this task (JS-56499) to prevent addition of serverOffset multiple times
            value = p.replacer(value, true);

            if (tableName instanceof sf.Query) {
                query = tableName;
                tableName = null;
            }

            var res = this.adaptor.update(this, keyField, value, tableName, query);

            if (this.dataSource.offline) {
                return res;
            }           

            var deffer = $.Deferred();

           $.ajax($.extend({
                contentType: "application/json; charset=utf-8",
                beforeSend: $proxy(this._beforeSend, this),
                success: proxy(function (record, status, xhr, request) {
                    try {
                        if (sf.isNullOrUndefined(record))
                            record = [];
                        else
                            p.parseJson(record);
                    }
                    catch (e) {
                        record = [];
                    }
                    record = this.adaptor.processResponse(p.parseJson(record), this, null, xhr, request);
                    deffer.resolveWith(this, [{ record: record, dataManager: this }]);
                }, this),
                error: function (e) {
                    deffer.rejectWith(this, [{ error: e, dataManager: this }]);
                }
           }, res));

           return deffer.promise();
        },

        _getJsonFromElement: function (ds) {
            if (typeof (ds) == "string")
                ds = $($(ds).html());

            ds = ds.jquery ? ds[0] : ds;

            var tagName = ds.tagName.toLowerCase();

            if (tagName !== "table")
                throwError("sf.DataManager : Unsupported htmlElement : " + tagName);

            return sf.parseTable(ds);
        }
    };

    var buildHierarchy = function (fKey, from, source, lookup, pKey) {
        var i, grp = {}, t;
        if (lookup.result) lookup = lookup.result;

        if (lookup.GROUPGUID)
            throwError("sf.DataManager: Do not have support Grouping in hierarchy");

        for (i = 0; i < lookup.length; i++) {
            var fKeyData = sf.getObject(fKey, lookup[i]);
            t = grp[fKeyData] || (grp[fKeyData] = []);

            t.push(lookup[i]);
        }

        for (i = 0; i < source.length; i++) {
            source[i][from] = grp[sf.getObject(pKey || fKey, source[i])];
        }
    };

    var oData = {
        accept: "application/json;odata=light;q=1,application/json;odata=verbose;q=0.5",
        multipartAccept: "multipart/mixed",
        batch: "$batch",
        changeSet: "--changeset_",
        batchPre: "batch_",
        contentId: "Content-Id: ",
        batchContent: "Content-Type: multipart/mixed; boundary=",
        changeSetContent: "Content-Type: application/http\nContent-Transfer-Encoding: binary ",
        batchChangeSetContentType: "Content-Type: application/json; charset=utf-8 "
    };
    var p = {
        parseJson: function (jsonText) {
            var type = typeof jsonText;
            if (type === "string") {
                jsonText = JSON.parse(jsonText, p.jsonReviver);
            } else if (jsonText instanceof Array) {
                p.iterateAndReviveArray(jsonText);
            } else if (type === "object")
                p.iterateAndReviveJson(jsonText);
            return jsonText;
        },
        iterateAndReviveArray: function (array) {
            for (var i = 0; i < array.length; i++) {
                if (typeof array[i] === "object")
                    p.iterateAndReviveJson(array[i]);
                else if (typeof array[i] === "string" && !/^[\s]*\[|^[\s]*\{|\"/g.test(array[i]))
                    array[i] = p.jsonReviver("",array[i]);
                else
                    array[i] = p.parseJson(array[i]);
            }
        },
        iterateAndReviveJson: function (json) {
            var value;
            for (var prop in json) {
                if (prop.startsWith("__"))
                    continue;

                value = json[prop];
                if (typeof value === "object") {
                    if (value instanceof Array)
                        p.iterateAndReviveArray(value);
                    else
                        p.iterateAndReviveJson(value);
                } else
                    json[prop] = p.jsonReviver(prop, value);
            }
        },
        jsonReviver: function (field, value) {
            var s = value, regex = /[\-,/,\,.,:,]+/;
            if (typeof value === "string") {
                var ms = /^\/Date\(([+-]?[0-9]+)([+-][0-9]{4})?\)\/$/.exec(value);
                if (ms)
                    return sf.parseDateInUTC ? p.isValidDate(ms[0]) : p.replacer(new Date(parseInt(ms[1])));
                else if (sf.dateParse ? (/^(?:(\d{4}\-\d\d\-\d\d)|(\d{4}\-\d\d\-\d\d([tT][\d:\.]*){1})([zZ]|([+\-])(\d\d):?(\d\d))?)$/.test(value)) : (/^(\d{4}\-\d\d\-\d\d([tT][\d:\.]*){1})([zZ]|([+\-])(\d\d):?(\d\d))?$/.test(value))) {
					var a = s.split(/[^0-9]/);
					if(/^(\d{4}\-\d\d\-\d\d)$/.test(value))
					  value = new Date(a[sf.dateFormat.split(regex).indexOf("yyyy")], a[sf.dateFormat.split(regex).indexOf("MM")]-1, a[sf.dateFormat.split(regex).indexOf("dd")]);					 
					else{
			          value = sf.parseDateInUTC ? p.isValidDate(value) : p.replacer(new Date(value));
                      if (isNaN(value)) 
                        value = p.replacer(new Date(a[0], a[1] - 1, a[2], a[3], a[4], a[5]));						
					}
                }
            }
            return value;
        },
        isValidDate: function (value) {
            var prop = value;
            if (typeof (prop) === "string" && prop.indexOf("/Date(") == 0) {
                value = prop.replace(/\d+/, function (n) {
                    var offsetMiliseconds = new Date(parseInt(n)).getTimezoneOffset() * 60000;
                    var ticks = parseInt(n) + offsetMiliseconds;
                    return p.replacer(new Date(parseInt(ticks)));
                });
            }
            if (typeof value === "string") {
                value = value.replace("/Date(", function () { return ""; });
                value = value.replace(")/", function () { return ""; })
                var ms = new Date(value) instanceof Date;
                if (ms)
                    return new Date(value);
                else return value;
            }
            return value;
        },
        isJson: function (jsonData) {
            if(typeof jsonData[0]== "string")
                return jsonData;
            return sf.parseJSON(jsonData);
        },
        isGuid: function (value) {
            var regex = /[A-Fa-f0-9]{8}(?:-[A-Fa-f0-9]{4}){3}-[A-Fa-f0-9]{12}/i;
            var match = regex.exec(value);
            return match != null;
        },
        // Additional paramater is included based on this task (JS-56499) to prevent addition of serverOffset multiple times
        replacer: function (value, serverOffset) {

            if (sf.isPlainObject(value))
                return p.jsonReplacer(value, serverOffset);

            if (value instanceof Array)
                return p.arrayReplacer(value);

            if (value instanceof Date)
                return p.jsonReplacer({ val: value }, serverOffset).val;

            return value;
        },
        jsonReplacer: function (val, serverOffset) {
            var value;
            for (var prop in val) {
                value = val[prop];

                if (!(value instanceof Date))
                    continue;
                // checking for update and insert operation and then including the proper offset, based on this task (JS-56499) 
                var offset = sf.serverTimezoneOffset * 60 * 60 * 1000 * (sf.isNullOrUndefined(serverOffset) || (serverOffset === false) ? (1) : -(1));
                val[prop] = new Date(+value + offset);
            }

            return val;
        },
        arrayReplacer: function (val) {

            for (var i = 0; i < val.length; i++) {            
                if (sf.isPlainObject(val[i]))
                    val[i] = p.jsonReplacer(val[i]);
                else if (val[i] instanceof Date)
                    val[i] = p.jsonReplacer({ date: val[i] }).date;
            }

            return val;
        }
    };

    sf.isJSON = p.isJson;
    sf.parseJSON = p.parseJson;
    sf.dateParse = true;
	 sf.dateFormat = "yyyy-MM-dd";
    sf.isGUID = p.isGuid;
    sf.Query = function (from) {
        if (!(this instanceof sf.Query))
            return new sf.Query(from);

        this.queries = [];
        this._key = "";
        this._fKey = "";

        if (typeof from === "string")
            this._fromTable = from || "";
        else if (from && from instanceof Array)
            this._lookup = from;

        this._expands = [];
        this._sortedColumns = [];
        this._groupedColumns = [];
        this._subQuery = null;
        this._isChild = false;
        this._params = [];
        return this;
    };

    sf.Query.prototype = {
        key: function (field) {
            if (typeof field === "string")
                this._key = field;

            return this;
        },
	
        using: function (dataManager) {
            if (dataManager instanceof sf.DataManager) {
                this.dataManagar = dataManager;
                return this;
            }

            return throwError("Query - using() : 'using' function should be called with parameter of instance sf.DataManager");
        },
	
        execute: function (dataManager, done, fail, always) {
            dataManager = dataManager || this.dataManagar;

            if (dataManager && dataManager instanceof sf.DataManager)
                return dataManager.executeQuery(this, done, fail, always);

            return throwError("Query - execute() : dataManager needs to be is set using 'using' function or should be passed as argument");
        },
	
        executeLocal: function (dataManager) {
            // this does not support for URL binding
            

            dataManager = dataManager || this.dataManagar;

            if (dataManager && dataManager instanceof sf.DataManager)
                return dataManager.executeLocal(this);

            return throwError("Query - executeLocal() : dataManager needs to be is set using 'using' function or should be passed as argument");
        },
	
        clone: function () {
            var cl = new sf.Query();
            cl.queries = this.queries.slice(0);
            cl._key = this._key;
            cl._isChild = this._isChild;
            cl.dataManagar = this.dataManager;
            cl._fromTable = this._fromTable;
            cl._params = this._params.slice(0);
            cl._expands = this._expands.slice(0);
            cl._sortedColumns = this._sortedColumns.slice(0);
            cl._groupedColumns = this._groupedColumns.slice(0);
            cl._subQuerySelector = this._subQuerySelector;
            cl._subQuery = this._subQuery;
            cl._fKey = this._fKey;
            cl._requiresCount = this._requiresCount;
            return cl;
        },
	
        from: function (tableName) {
            if (typeof tableName === "string")
                this._fromTable = tableName;

            return this;
        },
	
        addParams: function (key, value) {
            if (typeof value !== "function" && !sf.isPlainObject(value))
                this._params.push({ key: key, value: value });
            else if (typeof value === "function")
                this._params.push({ key: key, fn: value });

            return this;
        },
	
        expand: function (tables) {
            if (typeof tables === "string")
                this._expands = [].slice.call(arguments, 0);
            else
                this._expands = tables.slice(0);

            return this;
        },
	
        where: function (fieldName, operator, value, ignoreCase,ignoreAccent) {
            operator = (operator || sf.FilterOperators.equal).toLowerCase();
            var predicate = null;

            if (typeof fieldName === "string")
                predicate = new sf.Predicate(fieldName, operator, value, ignoreCase,ignoreAccent);
            else if (fieldName instanceof sf.Predicate)
                predicate = fieldName;
            else
                throwError("Query - where : Invalid arguments");

            this.queries.push({
                fn: "onWhere", 
                e: predicate
            });
            return this;
        },
	
        search: function (searchKey, fieldNames, operator, ignoreCase, ignoreAccent) {
            if (!fieldNames || typeof fieldNames === "boolean") {
                fieldNames = [];
                ignoreCase = fieldNames;
            } else if (typeof fieldNames === "string")
                fieldNames = [fieldNames];

            if (typeof operator === "boolean") {
                ignoreCase = operator;
                operator = null;
            }
            operator = operator || sf.FilterOperators.contains;
            if (operator.length < 3)
                operator = sf.data.operatorSymbols[operator];

            var comparer = sf.data.fnOperators[operator] || sf.data.fnOperators.processSymbols(operator);

            this.queries.push({
                fn: "onSearch",
                e: {
                    fieldNames: fieldNames,
                    operator: operator,
                    searchKey: searchKey,
                    ignoreCase: ignoreCase,
                    ignoreAccent: ignoreAccent,
                    comparer: comparer
                }
            });
            return this;
        },
		
        sortBy: function (fieldName, comparer, isFromGroup) {
            var order = sf.sortOrder.Ascending, sorts, t;

            if (typeof fieldName === "string" && fieldName.toLowerCase().endsWith(" desc")) {
                fieldName = fieldName.replace(/ desc$/i, '');
                comparer = sf.sortOrder.Descending;
            }
            if (fieldName instanceof Array) {
                for(var i=0;i<fieldName.length;i++)
                   this.sortBy(fieldName[i],comparer,isFromGroup);
                return this;
            }
            if (typeof comparer === "boolean")
                comparer = !comparer ? sf.sortOrder.Ascending : sf.sortOrder.Descending;
            else if (typeof comparer === "function")
                order = "custom";

            if (!comparer || typeof comparer === "string") {
                order = comparer ? comparer.toLowerCase() : sf.sortOrder.Ascending;
                comparer = sf.pvt.fnSort(comparer);
            }
            if (isFromGroup) {
                sorts = filterQueries(this.queries, "onSortBy");

                for (var i = 0; i < sorts.length; i++) {
                    t = sorts[i].e.fieldName;
                    if (typeof t === "string") {
                        if (t === fieldName) return this;
                    } else if (t instanceof Array) {
                        for (var j = 0; j < t.length; j++)
                            if (t[j] === fieldName || fieldName.toLowerCase() === t[j] + " desc")
                                return this;
                    }
                }
            }

            this.queries.push({
                fn: "onSortBy",
                e: {
                    fieldName: fieldName,
                    comparer: comparer,
                    direction: order
                }
            });

            return this;
        },
		
        sortByDesc: function (fieldName) {
            return this.sortBy(fieldName, sf.sortOrder.Descending);
        },
		
        group: function (fieldName,fn) {
            this.sortBy(fieldName, null, true);

            this.queries.push({
                fn: "onGroup",
                e: {
                    fieldName: fieldName,
                    fn: fn
                }
            });
            return this;
        },
	
        page: function (pageIndex, pageSize) {
            this.queries.push({
                fn: "onPage",
                e: {
                    pageIndex: pageIndex,
                    pageSize: pageSize
                }
            });
            return this;
        },
	
        range: function (start, end) {
            if (typeof start !== "number" || typeof end !== "number")
                throwError("Query() - range : Arguments type should be a number");

            this.queries.push({
                fn: "onRange",
                e: {
                    start: start,
                    end: end
                }
            });
            return this;
        },
	

        take: function (nos) {
            if (typeof nos !== "number")
                throwError("Query() - Take : Argument type should be a number");

            this.queries.push({
                fn: "onTake",
                e: {
                    nos: nos
                }
            });
            return this;
        },
	
        skip: function (nos) {
            if (typeof nos !== "number")
                throwError("Query() - Skip : Argument type should be a number");

            this.queries.push({
                fn: "onSkip",
                e: { nos: nos }
            });
            return this;
        },
	
        select: function (fieldNames) {
            if (typeof fieldNames === "string")
                fieldNames = [].slice.call(arguments, 0);

            if (!(fieldNames instanceof Array)) {
                throwError("Query() - Select : Argument type should be String or Array");
            }

            this.queries.push({
                fn: "onSelect",
                e: { fieldNames: fieldNames }
            });
            return this;
        },
	
        hierarchy: function (query, selectorFn) {
            if (!query || !(query instanceof sf.Query))
                throwError("Query() - hierarchy : query must be instance of sf.Query");

            if (typeof selectorFn === "function")
                this._subQuerySelector = selectorFn;

            this._subQuery = query;
            return this;
        },
	
        foreignKey: function (key) {
            if (typeof key === "string")
                this._fKey = key;

            return this;
        },
	
        requiresCount: function () {
            this._requiresCount = true;

            return this;
        },
        //type - sum, avg, min, max
        aggregate: function (type, field) {
            this.queries.push({
                fn: "onAggregates",
                e: { field: field, type: type }
            });
        }
    };

    sf.Adaptor = function (ds) {
        this.dataSource = ds;
        this.pvt = {};
		this.init.apply(this, [].slice.call(arguments, 1));
    };

    sf.Adaptor.prototype = {
        options: {
            from: "table",
            requestType: "json",
            sortBy: "sorted",
            select: "select",
            skip: "skip",
            group: "group",
            take: "take",
            search: "search",
            count: "requiresCounts",
            where: "where",
            aggregates: "aggregates",
            antiForgery: "antiForgery"
        },
        init: function () {
        },
        extend: function (overrides) {
            var fn = function (ds) {
                this.dataSource = ds;

                if (this.options)
                    this.options = $.extend({}, this.options);
				this.init.apply(this, [].slice.call(arguments, 0));

                this.pvt = {};
            };
            fn.prototype = new this.type();
            fn.prototype.type = fn;

            var base = fn.prototype.base = {};
            for (var p in overrides) {
                if (fn.prototype[p])
                    base[p] = fn.prototype[p];
            }
            $.extend(true, fn.prototype, overrides);
            return fn;
        },
        processQuery: function (dm, query) {
            // this needs to be overridden
        },
        processResponse: function (data, ds, query, xhr) {
            if (data.d)
               return data.d;
            return data;
        },
        convertToQueryString: function (req, query, dm) {
            return $.param(req);
        },
        type: sf.Adaptor
    };

    sf.UrlAdaptor = new sf.Adaptor().extend({
        processQuery: function (dm, query, hierarchyFilters) {
            var sorted = filterQueries(query.queries, "onSortBy"),
                grouped = filterQueries(query.queries, "onGroup"),
                filters = filterQueries(query.queries, "onWhere"),
                searchs = filterQueries(query.queries, "onSearch"),
                aggregates = filterQueries(query.queries, "onAggregates"),
                singles = filterQueryLists(query.queries, ["onSelect", "onPage", "onSkip", "onTake", "onRange"]),
                params = query._params,
                url = dm.dataSource.url, tmp, skip, take = null,
                op = this.options;

            var r = {
                sorted: [],
                grouped: [],
                filters: [],
                searches: [],
                aggregates: []
            };

            // calc Paging & Range
            if (singles["onPage"]) {
                tmp = singles["onPage"];
                skip = getValue(tmp.pageIndex, query);
                take = getValue(tmp.pageSize, query);
				skip = (skip - 1) * take;
            } else if (singles["onRange"]) {
                tmp = singles["onRange"];
                skip = tmp.start;
                take = tmp.end - tmp.start;
            }

            // Sorting
            for (var i = 0; i < sorted.length; i++) {
                tmp = getValue(sorted[i].e.fieldName, query);

                r.sorted.push(callAdaptorFunc(this, "onEachSort", { name: tmp, direction: sorted[i].e.direction }, query));
            }

            // hierarchy
            if (hierarchyFilters) {
                tmp = this.getFiltersFrom(hierarchyFilters, query);
                if (tmp)
                    r.filters.push(callAdaptorFunc(this, "onEachWhere", tmp.toJSON(), query));
            }

            // Filters
            for (var i = 0; i < filters.length; i++) {
                r.filters.push(callAdaptorFunc(this, "onEachWhere", filters[i].e.toJSON(), query));

                for (var prop in r.filters[i]) {
                    if (isNull(r[prop]))
                        delete r[prop];
                }
            }

            // Searches
            for (var i = 0; i < searchs.length; i++) {
                tmp = searchs[i].e;
                r.searches.push(callAdaptorFunc(this, "onEachSearch", {
                    fields: tmp.fieldNames,
                    operator: tmp.operator,
                    key: tmp.searchKey,
                    ignoreCase: tmp.ignoreCase
                }, query));
            }

            // Grouping
            for (var i = 0; i < grouped.length; i++) {
                r.grouped.push(getValue(grouped[i].e.fieldName, query));
            }

            // aggregates
            for (var i = 0; i < aggregates.length; i++) {
                tmp = aggregates[i].e; 
                r.aggregates.push({ type: tmp.type, field: getValue(tmp.field, query) });
            }

            var req = {};
            req[op.from] = query._fromTable;
            if (op.expand) req[op.expand] = query._expands;
            req[op.select] = singles["onSelect"] ? callAdaptorFunc(this, "onSelect", getValue(singles["onSelect"].fieldNames, query), query) : "";
            req[op.count] = query._requiresCount ? callAdaptorFunc(this, "onCount", query._requiresCount, query) : "";
            req[op.search] = r.searches.length ? callAdaptorFunc(this, "onSearch", r.searches, query) : "";
            req[op.skip] = singles["onSkip"] ? callAdaptorFunc(this, "onSkip", getValue(singles["onSkip"].nos, query), query) : "";
            req[op.take] = singles["onTake"] ? callAdaptorFunc(this, "onTake", getValue(singles["onTake"].nos, query), query) : "";
            req[op.antiForgery] = (dm.dataSource.antiForgery) ? dm.antiForgeryToken().value : "";
            req[op.where] = r.filters.length || r.searches.length ? callAdaptorFunc(this, "onWhere", r.filters, query) : "";
            req[op.sortBy] = r.sorted.length ? callAdaptorFunc(this, "onSortBy", r.sorted, query) : "";
            req[op.group] = r.grouped.length ? callAdaptorFunc(this, "onGroup", r.grouped, query) : "";
            req[op.aggregates] = r.aggregates.length ? callAdaptorFunc(this, "onAggregates", r.aggregates, query) : "";
			req["param"] = [];
			
            // Params
			callAdaptorFunc(this, "addParams", { dm: dm, query: query, params: params, reqParams: req });

            // cleanup
            for (var prop in req) {
                if (isNull(req[prop]) || req[prop] === "" || req[prop].length === 0 || prop === "params")
                    delete req[prop];
            }

            if (!(op.skip in req && op.take in req) && take !== null) {
                req[op.skip] = callAdaptorFunc(this, "onSkip", skip, query);
                req[op.take] = callAdaptorFunc(this, "onTake", take, query);
            }
            var p = this.pvt;
            this.pvt = {};

            if (this.options.requestType === "json") {
                return {
                    data: JSON.stringify(req),
                    url: url,
                    ejPvtData: p,
                    type: "POST",
                    contentType: "application/json; charset=utf-8"
                }
            }
            tmp = this.convertToQueryString(req, query, dm);
            tmp =  (dm.dataSource.url.indexOf("?")!== -1 ? "&" : "/") + tmp;
            return {
                type: "GET",
                url: tmp.length ? url.replace(/\/*$/, tmp) : url,
                ejPvtData: p
            };
        },
        convertToQueryString: function (req, query, dm) {
            if (dm.dataSource.url && dm.dataSource.url.indexOf("?") !== -1)
                return $.param(req);
            return "?" + $.param(req);
        },
        processResponse: function (data, ds, query, xhr, request, changes) {
            var pvt = request.ejPvtData || {};
			var groupDs= data.groupDs;
			if (xhr && xhr.getResponseHeader("Content-Type") && xhr.getResponseHeader("Content-Type").indexOf("xml") != -1 && data.nodeType == 9)
                return query._requiresCount ? { result: [], count: 0 } : [];
            var d = JSON.parse(request.data);
            if (d && d.action === "batch" && data.added) {
                changes.added = data.added;
                return changes;
            }
            if (data.d)
                data = data.d;

            if (pvt && pvt.aggregates && pvt.aggregates.length) {
                var agg = pvt.aggregates, args = {}, fn, res = {};
                if ('count' in data) args.count = data.count;
                if (data["result"]) args.result = data.result;
                if (data["aggregate"]) data = data.aggregate;
                for (var i = 0; i < agg.length; i++) {
                    fn = sf.aggregates[agg[i].type];
                    if (fn)
                        res[agg[i].field + " - " + agg[i].type] = fn(data, agg[i].field);
                }
                args["aggregates"] = res;
                data = args;
            }

            if (pvt && pvt.groups && pvt.groups.length) {
                var groups = pvt.groups, args = {};
                if ('count' in data) args.count = data.count;
                if (data["aggregates"]) args.aggregates = data.aggregates;
                if (data["result"]) data = data.result;
                for (var i = 0; i < groups.length; i++){
                    var level = null;
                    var format = getColFormat(groups[i], query.queries);
                    if (!sf.isNullOrUndefined(groupDs))
                        groupDs = sf.group(groupDs, groups[i], null, format);
                    data = sf.group(data, groups[i], pvt.aggregates, format, level, groupDs);
                }
                if (args.count != undefined)
                    args.result = data;
                else
                    args = data;
                return args;
            }
            return data;
        },
        onGroup: function (e) {
            this.pvt.groups = e;
        },
        onAggregates: function (e) {
            this.pvt.aggregates = e;
        },
        batchRequest: function (dm, changes, e, query) {
            var res = {
                changed: changes.changed,
                added: changes.added,
                deleted: changes.deleted,
                action: "batch",
                table: e.url,
                key: e.key,
				antiForgery: (dm.dataSource.antiForgery) ? dm.antiForgeryToken().value : ""
            };
            if (query)
                this.addParams({ dm: dm, query: query, params: query._params, reqParams: res });

            return {
                type: "POST",
                url: dm.dataSource.batchUrl || dm.dataSource.crudUrl || dm.dataSource.removeUrl || dm.dataSource.url,
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify(res)
            };
        },
        beforeSend: function (dm, request) {
        },
        insert: function (dm, data, tableName, query) {
            var res = {
                value: data,
                table: tableName,
                action: "insert",
                antiForgery: (dm.dataSource.antiForgery) ? dm.antiForgeryToken().value : ""
            };
            if (query)
                this.addParams({ dm: dm, query: query, params: query._params, reqParams: res });

            return {
                url: dm.dataSource.insertUrl || dm.dataSource.crudUrl || dm.dataSource.url,
                data: JSON.stringify(res)
            };
        },
        remove: function (dm, keyField, value, tableName, query) {
            var res = {
                key: value,
                keyColumn: keyField,
                table: tableName,
                action: "remove",
                antiForgery: (dm.dataSource.antiForgery) ? dm.antiForgeryToken().value : ""
            };
            if (query)
                this.addParams({ dm: dm, query: query, params: query._params, reqParams: res });

            return {
                type: "POST",
                url: dm.dataSource.removeUrl || dm.dataSource.crudUrl || dm.dataSource.url,
                data: JSON.stringify(res)
            };
        },
        update: function (dm, keyField, value, tableName, query) {
            var res = {
                value: value,
                action: "update",
                keyColumn: keyField,
                key: value[keyField],
                table: tableName,
                antiForgery: (dm.dataSource.antiForgery) ? dm.antiForgeryToken().value : ""
            };
            if (query)
                this.addParams({ dm: dm, query: query, params: query._params, reqParams: res });

            return {
                type: "POST",
                url: dm.dataSource.updateUrl || dm.dataSource.crudUrl || dm.dataSource.url,
                data: JSON.stringify(res)
            };
        },
        getFiltersFrom: function (data, query) {
            if (!(data instanceof Array) || !data.length)
                throwError("sf.SubQuery: Array of key values required");
            var key = query._fKey, value, prop = key, pKey = query._key, predicats = [],
                isValues = typeof data[0] !== "object";

            if (typeof data[0] !== "object") prop = null;

            for (var i = 0; i < data.length; i++) {
                value = !isValues ? sf.pvt.getObject(pKey || prop, data[i]) : data[i];
                predicats.push(new sf.Predicate(key, "equal", value));
            }

            return sf.Predicate.or(predicats);
        },
        addParams: function (options) {
            var dm = options.dm, query = options.query, params = options.params, req = options.reqParams; req["params"] = {};
            for (var i = 0, tmp; tmp = params[i]; i++) {
                if (req[tmp.key]) throwError("sf.Query: Custom Param is conflicting other request arguments");
                req[tmp.key] = tmp.value;
                if (tmp.fn)
                    req[tmp.key] = tmp.fn.call(query, tmp.key, query, dm);                
                req["params"][tmp.key] = req[tmp.key];
            }
        }
    });
    sf.WebMethodAdaptor = new sf.UrlAdaptor().extend({
        processQuery: function (dm, query, hierarchyFilters) {
            var obj = sf.UrlAdaptor.prototype.processQuery(dm, query, hierarchyFilters);
            var data = sf.parseJSON(obj.data), result = {};

            result["value"] = data;

            //Params             
            callAdaptorFunc(this, "addParams", { dm: dm, query: query, params: query._params, reqParams: result });

            return {
                data: JSON.stringify(result),
                url: obj.url,
                ejPvtData: obj.ejPvtData,
                type: "POST",
                contentType: "application/json; charset=utf-8"
            }
        },
        addParams: function (options) {
            var dm = options.dm, query = options.query, params = options.params, req = options.reqParams; req["params"] = {};
            for (var i = 0, tmp; tmp = params[i]; i++) {
                if (req[tmp.key]) throwError("sf.Query: Custom Param is conflicting other request arguments");
                var webkey = tmp.key, webvalue = tmp.value;
                if (tmp.fn)
                    webvalue = tmp.fn.call(query, tmp.key, query, dm);
                req[webkey] = webvalue;
                req["params"][webkey] = req[webkey];
            }
        }
    });
    sf.CacheAdaptor = new sf.UrlAdaptor().extend({
        init: function (adaptor, timeStamp, pageSize) {
            if (!sf.isNullOrUndefined(adaptor)) {
                this.cacheAdaptor = adaptor;
            }
            this.pageSize = pageSize;
            this.guidId = sf.getGuid("cacheAdaptor");
            var obj = { keys: [], results: [] };
            if (window.localStorage)
                window.localStorage.setItem(this.guidId, JSON.stringify(obj));
            var guid = this.guidId;
            if (!sf.isNullOrUndefined(timeStamp)) {
                setInterval(function () {
                    var data = sf.parseJSON(window.localStorage.getItem(guid));
                    var forDel = [];
                    for (var i = 0; i < data.results.length; i++) {
                        data.results[i].timeStamp = new Date() - new Date(data.results[i].timeStamp)
                        if (new Date() - new Date(data.results[i].timeStamp) > timeStamp)
                            forDel.push(i);
                    }
                    var d = forDel;
                    for (var i = 0; i < forDel.length; i++) {
                        data.results.splice(forDel[i], 1);
                        data.keys.splice(forDel[i], 1);
                    }
                    window.localStorage.removeItem(guid);
                    window.localStorage.setItem(guid, JSON.stringify(data));
                }, timeStamp);
            }
        },
        generateKey: function (url, query) {
            var sorted = filterQueries(query.queries, "onSortBy"),
                grouped = filterQueries(query.queries, "onGroup"),
                filters = filterQueries(query.queries, "onWhere"),
                searchs = filterQueries(query.queries, "onSearch"),
				pageQuery = filterQueries(query.queries, "onPage"),
                singles = filterQueryLists(query.queries, ["onSelect", "onPage", "onSkip", "onTake", "onRange"]),
                params = query._params;
            var key = url;
            if (singles["onPage"])
              key += singles["onPage"].pageIndex;
              sorted.forEach(function (obj) {
                   key += obj.e.direction + obj.e.fieldName;
              });
                grouped.forEach(function (obj) {
                    key += obj.e.fieldName;
                });
                searchs.forEach(function (obj) {
                    key += obj.e.searchKey;
                });
            
            for (var filter = 0; filter < filters.length; filter++) {
                var currentFilter = filters[filter];
                if (currentFilter.e.isComplex) {
                    var newQuery = query.clone();
                    newQuery.queries = [];
                    for (var i = 0; i < currentFilter.e.predicates.length; i++) {
                        newQuery.queries.push({ fn: "onWhere", e: currentFilter.e.predicates[i], filter: query.queries.filter });
                    }
                    key += currentFilter.e.condition + this.generateKey(url, newQuery);
                }
                else
                    key += currentFilter.e.field + currentFilter.e.operator + currentFilter.e.value
            }
            return key;
        },
        processQuery: function (dm, query, hierarchyFilters) {
            var key = this.generateKey(dm.dataSource.url, query);
            var cachedItems;
            if (window.localStorage)
                cachedItems = sf.parseJSON(window.localStorage.getItem(this.guidId));
            var data = cachedItems ? cachedItems.results[cachedItems.keys.indexOf(key)] : null;
            if (data != null && !this._crudAction && !this._insertAction) {
                return data;
            }
            this._crudAction = null; this._insertAction = null;
            return this.cacheAdaptor.processQuery.apply(this.cacheAdaptor, [].slice.call(arguments, 0))
        },
        processResponse: function (data, ds, query, xhr, request, changes) {
            if (this._insertAction || (request && this.cacheAdaptor.options.batch && request.url.endsWith(this.cacheAdaptor.options.batch) && request.type.toLowerCase() === "post")) {
                return this.cacheAdaptor.processResponse(data, ds, query, xhr, request, changes);
            }
            var data = this.cacheAdaptor.processResponse.apply(this, [].slice.call(arguments, 0));
            var key = this.generateKey(ds.dataSource.url, query)
            var obj = {};
            if (window.localStorage)
                obj = sf.parseJSON(window.localStorage.getItem(this.guidId));
            var index = $.inArray(key, obj.keys);
            if (index != -1) {
                obj.results.splice(index, 1);
                obj.keys.splice(index, 1);
            }
            obj.results[obj.keys.push(key) - 1] = { keys: key, result: data.result, timeStamp: new Date(), count: data.count }
            while (obj.results.length > this.pageSize) {
                obj.results.splice(0, 1);
                obj.keys.splice(0, 1);
            }
            window.localStorage.setItem(this.guidId, JSON.stringify(obj));
            return data;
        },
        update: function (dm, keyField, value, tableName) {
            this._crudAction = true;
            return this.cacheAdaptor.update(dm, keyField, value, tableName);
        },
        insert: function (dm, data, tableName) {
            this._insertAction = true;
            return this.cacheAdaptor.insert(dm, data, tableName);
        },
        remove: function (dm, keyField, value, tableName) {
            this._crudAction = true;
            return this.cacheAdaptor.remove(dm, keyField, value, tableName);
        },
        batchRequest: function (dm, changes, e) {
            return this.cacheAdaptor.batchRequest(dm, changes, e);
        }
    });
    var filterQueries = function (queries, name) {
        return queries.filter(function (q) {
            return q.fn === name;
        }) || [];
    };
    var filterQueryLists = function (queries, singles) {
        var filtered = queries.filter(function (q) {
            return singles.indexOf(q.fn) !== -1;
        }), res = {};
        for (var i = 0; i < filtered.length; i++) {
            if (!res[filtered[i].fn])
                res[filtered[i].fn] = filtered[i].e;
        }
        return res;
    };
    var callAdaptorFunc = function (obj, fnName, param, param1) {
        if (obj[fnName]) {
            var res = obj[fnName](param, param1);
            if (!isNull(res)) param = res;
        }
        return param;
    };

    sf.ODataAdaptor = new sf.UrlAdaptor().extend({
        options: {
            requestType: "get",
            accept: "application/json;odata=light;q=1,application/json;odata=verbose;q=0.5",
            multipartAccept: "multipart/mixed",
            sortBy: "$orderby",
            select: "$select",
            skip: "$skip",
            take: "$top",
            count: "$inlinecount",
            where: "$filter",
            expand: "$expand",
            batch: "$batch",
            changeSet: "--changeset_",
            batchPre: "batch_",
            contentId: "Content-Id: ",
            batchContent: "Content-Type: multipart/mixed; boundary=",
            changeSetContent: "Content-Type: application/http\nContent-Transfer-Encoding: binary ",
            batchChangeSetContentType: "Content-Type: application/json; charset=utf-8 "
        },
        onEachWhere: function (filter, requiresCast) {
            return filter.isComplex ? this.onComplexPredicate(filter, requiresCast) : this.onPredicate(filter, requiresCast);
        },
		_typeStringQuery: function (pred, requiresCast,val,field,guid) {
			if(val.indexOf("'") != -1)
			    val = val.replace(new RegExp(/'/g), "''");
			var specialCharFormat = /[ !@@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/; 
			if (specialCharFormat.test(val)) { 
			    val = encodeURIComponent(val)
			}
            val = "'" + val + "'";
            if (requiresCast) {
                field = "cast(" + field + ", 'Edm.String')";
            }
            if (sf.isGUID(val))
                guid = 'guid';
            if (pred.ignoreCase) {
                !guid ? field = "tolower(" + field + ")" : field;
                val = val.toLowerCase();
            }
			return {"val":val,"guid":guid ,"field":field};
		},
        onPredicate: function (pred, query, requiresCast) {
            var returnValue = "",
                operator,guid,
                val = pred.value,
                type = typeof val,
                field = this._p(pred.field);

            if (val instanceof Date)
                val = "datetime'" + p.replacer(val).toJSON() + "'";

            if (type === "string") {
				var args = this._typeStringQuery(pred,requiresCast,val,field , guid);
				val = args["val"]; field = args["field"]; guid = args["guid"];
            }

            operator = sf.data.odBiOperator[pred.operator];
			if(pred.anyCondition != "" && operator) {
				returnValue += val["table"];
				returnValue += ("/"+pred.anyCondition);
				returnValue += "(d:d/";
				returnValue += field;
				returnValue += operator;
				returnValue += val["value"];
				returnValue += ")";
				return returnValue;
			}
			if( pred.operator == "in" || pred.operator == "notin" ) {
				returnValue += "(";
				for(var index = 0; index < val.length; index++ ) {
					if (val[index] instanceof Date)
						val[index] = "datetime'" + p.replacer(val[index]).toJSON() + "'";
					if (typeof val[index] === "string") {
						var args = this._typeStringQuery(pred,requiresCast,val[index],field , guid);
						val[index] = args["val"]; field = args["field"]; guid = args["guid"];
					}
					returnValue += field;
					returnValue += operator;
					returnValue += val[index];
					if( index != val.length -1 ) returnValue += ( pred.operator == "in") ? " or " : " and ";
				}
				returnValue += ")";
				return returnValue;
			}
		    if (operator) {
		        return this.onOperation(returnValue, operator, field, val, guid);
		    }

            operator = sf.data.odUniOperator[pred.operator];
            if (!operator || type !== "string") return "";

            if (operator === "substringof") {
                var t = val;
                val = field;
                field = t;
            }

            returnValue += operator + "(";
            returnValue += field + ",";
            if (guid) returnValue += guid;
            returnValue += val + ")";
			
			if( pred.operator == "notcontains" ) {
				returnValue += " eq false"
			}
			if(pred.anyCondition != "" && operator) {
				var returnValue1;
				returnValue1 += val["table"];
				returnValue1 += ("/"+pred.anyCondition);
				returnValue1 += "(d:d/";
				returnValue += returnValue;
				returnValue1 += ")";
				return returnValue1;
			}
            return returnValue;
		},
		onOperation: function (returnValue, operator, field, val, guid) {
		        returnValue += field;
		        returnValue += operator;
		        if (guid)
		            returnValue += guid;
		        return returnValue + val;
        },
        onComplexPredicate: function (pred, requiresCast) {
            var res = [];
            for (var i = 0; i < pred.predicates.length; i++) {
                res.push("(" + this.onEachWhere(pred.predicates[i], requiresCast) + ")");
            }
            return res.join(" " + pred.condition + " ");
        },
        onWhere: function (filters) {
            if (this.pvt.searches)
                filters.push(this.onEachWhere(this.pvt.searches, null, true));

            return filters.join(" and ");
        },
        onEachSearch: function (e) {
            if (e.fields.length === 0)
                throwError("Query() - Search : oData search requires list of field names to search");

            var filter = this.pvt.searches || [];
            for (var i = 0; i < e.fields.length; i++) {
                filter.push(new sf.Predicate(e.fields[i], e.operator, e.key, e.ignoreCase));
            }
            this.pvt.searches = filter;
        },
        onSearch: function (e) {
            this.pvt.searches = sf.Predicate.or(this.pvt.searches);
            return "";
        },
        onEachSort: function (e) {
            var res = [];
            if (e.name instanceof Array) {
                for (var i = 0; i < e.name.length; i++)
                    res.push(this._p(e.name[i]));
            } else {
                res.push(this._p(e.name) + (e.direction === "descending" ? " desc" : ""));
            }
            return res.join(",");
        },
        onSortBy: function (e) {
            return e.reverse().join(",");
        },
        onGroup: function (e) {
            this.pvt.groups = e;
            return "";
        },
        onSelect: function (e) {
            for (var i = 0; i < e.length; i++)
                e[i] = this._p(e[i]);

            return e.join(',');
        },
        onAggregates: function(e){
            this.pvt.aggregates = e;
            return "";
        },
        onCount: function (e) {
            return e === true ? "allpages" : "";
        },
        beforeSend: function (dm, request, settings) {
            if (settings.url.endsWith(this.options.batch) && settings.type.toLowerCase() === "post") {
                request.setRequestHeader("Accept", oData.multipartAccept);
                request.setRequestHeader("DataServiceVersion", "2.0");
                request.overrideMimeType("text/plain; charset=x-user-defined");
            }

            if (!dm.dataSource.crossDomain) {
                request.setRequestHeader("DataServiceVersion", "2.0");
                request.setRequestHeader("MaxDataServiceVersion", "2.0");
            }
        },
        processResponse: function (data, ds, query, xhr, request, changes) {
            if (!sf.isNullOrUndefined(data.d)) {
                var dataCopy = (query && query._requiresCount) ? data.d.results : data.d;
                if (!sf.isNullOrUndefined(dataCopy))
                    for (var i = 0; i < dataCopy.length; i++) {
                        !sf.isNullOrUndefined(dataCopy[i].__metadata) && delete dataCopy[i].__metadata;
                    }
            }
            var pvt = request && request.ejPvtData;
            if (xhr && xhr.getResponseHeader("Content-Type") && xhr.getResponseHeader("Content-Type").indexOf("xml") != -1 && data.nodeType == 9)
                return query._requiresCount ? { result: [], count: 0 } : [];
            if (request && this.options.batch && request.url.endsWith(this.options.batch) && request.type.toLowerCase() === "post") {
                var guid = xhr.getResponseHeader("Content-Type"), cIdx, jsonObj;
                guid = guid.substring(guid.indexOf("=batchresponse") + 1);
                data = data.split(guid);
                if (data.length < 2) return;

                data = data[1];
                var exVal = /(?:\bContent-Type.+boundary=)(changesetresponse.+)/i.exec(data);
                data.replace(exVal[0], "");

                var changeGuid = exVal[1];
                data = data.split(changeGuid);

                for (var i = data.length; i > -1; i--) {
                    if (!/\bContent-ID:/i.test(data[i]) || !/\bHTTP.+201/.test(data[i]))
                        continue;

                    cIdx = parseInt(/\bContent-ID: (\d+)/i.exec(data[i])[1]);

                    if (changes.added[cIdx]) {
                        jsonObj = p.parseJson(/^\{.+\}/m.exec(data[i])[0]);
                        $.extend(changes.added[cIdx], this.processResponse(jsonObj));
                    }
                }
                return changes;
            }
            var version = xhr && xhr.getResponseHeader("DataServiceVersion"), count = null, aggregateResult = {};
            version = (version && parseInt(version, 10)) || 2;

            if (query && query._requiresCount) {
                if (data.__count || data['odata.count']) count = data.__count || data['odata.count'];
                if (data.d) data = data.d;
                if (data.__count || data['odata.count']) count = data.__count || data['odata.count'];
            }

            if (version === 3 && data.value) data = data.value;
            if (data.d) data = data.d;
            if (version < 3 && data.results) data = data.results;

            if (pvt && pvt.aggregates && pvt.aggregates.length) {
                var agg = pvt.aggregates, args = {}, fn, res = {};
                for (var i = 0; i < agg.length; i++) {
                    fn = sf.aggregates[agg[i].type];
                    if (fn)
                        res[agg[i].field + " - " + agg[i].type] = fn(data, agg[i].field);
                }
                aggregateResult = res;
            }
            if (pvt && pvt.groups && pvt.groups.length) {
                var groups = pvt.groups;
                for (var i = 0; i < groups.length; i++) {
                    var format = getColFormat(groups[i], query.queries)
                    data = sf.group(data, groups[i], pvt.aggregates, format);
                }
            }
            return isNull(count) ? data : { result: data, count: count, aggregates: aggregateResult };
        },
        convertToQueryString: function (req, query, dm) {
            var res = [], tableName = req.table || "";
            delete req.table;

            if (dm.dataSource.requiresFormat)
                req["$format"] = "json";

            for (var prop in req)
                res.push(prop + "=" + req[prop]);

            res = res.join("&");

            if (dm.dataSource.url && dm.dataSource.url.indexOf("?") !== -1 && !tableName)
                return res;

            return res.length ? tableName + "?" + res : tableName || "";
        },
        insert: function (dm, data, tableName) {
            return {
                url: dm.dataSource.url.replace(/\/*$/, tableName ? '/' + tableName : ''),
                data: JSON.stringify(data)
            }
        },
        remove: function (dm, keyField, value, tableName) {
            if(typeof(value) == "string"){
                return {
                    type: "DELETE",
                    url: sf.isGUID(value) ? dm.dataSource.url.replace(/\/*$/, tableName ? '/' + tableName : '') + "(" + value + ")" : dm.dataSource.url.replace(/\/*$/, tableName ? '/' + tableName : '') + "('" + value + "')"
                };
            }
            return {
                type: "DELETE",
                url: dm.dataSource.url.replace(/\/*$/, tableName ? '/' + tableName : '') + '(' + value + ')'
            };
        },
        update: function (dm, keyField, value, tableName) {
			var url;
			if(typeof value[keyField] === "string")
			    url = sf.isGUID(value[keyField]) ? dm.dataSource.url.replace(/\/*$/, tableName ? '/' + tableName : '') + "(" + value[keyField] + ")" : dm.dataSource.url.replace(/\/*$/, tableName ? '/' + tableName : '') + "('" + value[keyField] + "')";
			else 
				url = dm.dataSource.url.replace(/\/*$/, tableName ? '/' + tableName : '') + '(' + value[keyField] + ')';
            return {
                type: "PUT",
                url: url,
                data: JSON.stringify(value),
                accept: this.options.accept
            };
        },
        batchRequest: function (dm, changes, e) {
            var initialGuid = e.guid = sf.getGuid(oData.batchPre);
            var url = dm.dataSource.url.replace(/\/*$/, '/' + this.options.batch);
            var args = {
                url: e.url,
                key: e.key,
                cid: 1,
                cSet: sf.getGuid(oData.changeSet)
            };
            var req = "--" + initialGuid + "\n";

            req += "Content-Type: multipart/mixed; boundary=" + args.cSet.replace("--", "") + "\n";

            this.pvt.changeSet = 0;

            req += this.generateInsertRequest(changes.added, args);
            req += this.generateUpdateRequest(changes.changed, args);
            req += this.generateDeleteRequest(changes.deleted, args);

            req += args.cSet + "--\n";
            req += "--" + initialGuid + "--";

            return {
                type: "POST",
                url: url,
                contentType: "multipart/mixed; charset=UTF-8;boundary=" + initialGuid,
                data: req
            };
        },
        generateDeleteRequest: function (arr, e) {
            if (!arr) return "";
            var req = "", val;

            for (var i = 0; i < arr.length; i++) {
                req += "\n" + e.cSet + "\n";
                req += oData.changeSetContent + "\n\n";
                req += "DELETE ";
                val = typeof arr[i][e.key] == "string" ? "'" + arr[i][e.key] + "'" : arr[i][e.key];
                req += e.url + "(" + val + ") HTTP/1.1\n";
                req += "If-Match : * \n"
                req += "Accept: " + oData.accept + "\n";
                req += "Content-Id: " + this.pvt.changeSet++ + "\n";
                req += oData.batchChangeSetContentType + "\n";
            }

            return req + "\n";
        },
        generateInsertRequest: function (arr, e) {
            if (!arr) return "";
            var req = "";

            for (var i = 0; i < arr.length; i++) {
                req += "\n" + e.cSet + "\n";
                req += oData.changeSetContent + "\n\n";
                req += "POST ";
                req += e.url + " HTTP/1.1\n";
                req += "Accept: " + oData.accept + "\n";
                req += "Content-Id: " + this.pvt.changeSet++ + "\n";
                req += oData.batchChangeSetContentType + "\n\n";

                req += JSON.stringify(arr[i]) + "\n";
            }

            return req;
        },
        generateUpdateRequest: function (arr, e) {
            if (!arr) return "";
            var req = "", val;

            for (var i = 0; i < arr.length; i++) {
                req += "\n" + e.cSet + "\n";
                req += oData.changeSetContent + "\n\n";
                req += "PUT ";
                val = typeof arr[i][e.key] == "string" ? "'" + arr[i][e.key] + "'" : arr[i][e.key];
                req += e.url + "(" + val + ")" + " HTTP/1.1\n";
                req += "If-Match : * \n"
                req += "Accept: " + oData.accept + "\n";
                req += "Content-Id: " + this.pvt.changeSet++ + "\n";
                req += oData.batchChangeSetContentType + "\n\n";

                req += JSON.stringify(arr[i]) + "\n\n";
            }

            return req;
        },
        _p: function (prop) {
            return prop.replace(/\./g, "/");
        }
    });
    sf.ODataV4Adaptor = new sf.ODataAdaptor().extend({
        options: {
            requestType: "get",
            accept: "application/json;odata=light;q=1,application/json;odata=verbose;q=0.5",
            multipartAccept: "multipart/mixed",
            sortBy: "$orderby",
            select: "$select",
            skip: "$skip",
            take: "$top",
            count: "$count",
            search: "$search",
            where: "$filter",
            expand: "$expand",
            batch: "$batch",
            changeSet: "--changeset_",
            batchPre: "batch_",
            contentId: "Content-Id: ",
            batchContent: "Content-Type: multipart/mixed; boundary=",
            changeSetContent: "Content-Type: application/http\nContent-Transfer-Encoding: binary ",
            batchChangeSetContentType: "Content-Type: application/json; charset=utf-8 "
        },
        onCount: function (e) {
            return e === true ? "true" : "";
        },
        onPredicate: function (pred, query, requiresCast) {
            var returnValue = "",
                val = pred.value,
                isDate = val instanceof Date;               
            sf.data.odUniOperator["contains"] = "contains";
            returnValue = sf.ODataAdaptor.prototype.onPredicate.call(this, pred, query, requiresCast);
            sf.data.odUniOperator["contains"] = "substringof";
                if (isDate)
                    returnValue = returnValue.replace(/datetime'(.*)'$/, "$1");

            return returnValue;
        },
        onOperation: function (returnValue, operator, field, val, guid) {
            if (guid) {
                returnValue += "(" + field;
                returnValue += operator;
                returnValue += val.replace(/["']/g, "") + ")";
            } else {
                returnValue += field;
                returnValue += operator;
                returnValue += val;
            }
            return returnValue;
        },
        onEachSearch: function (e) {
			 var search = this.pvt.search || [];
			 search.push(e.key);
			 this.pvt.search = search;
		},
		onSearch: function (e) {
			 return this.pvt.search.join(" OR ");
		},
        beforeSend: function (dm, request, settings) {
 
        },
        processQuery: function (ds, query) {
            var digitsWithSlashesExp = /\/[\d*\/]*/g;
            var poppedExpand = "";
            for (var i = query._expands.length - 1; i > 0; i--) {
                if (poppedExpand.indexOf(query._expands[i]) >= 0) { // If current expand is child of previous
                    query._expands.pop(); // Just remove it because its in the expand already
                }
                else {
                    if (digitsWithSlashesExp.test(query._expands[i])) { //If expanded to subentities
                        poppedExpand = query._expands.pop();
                        var r = poppedExpand.replace(digitsWithSlashesExp, "($expand="); //Rewrite into odata v4 expand
                        for (var j = 0; j < poppedExpand.split(digitsWithSlashesExp).length - 1; j++) {
                            r = r + ")"; // Add closing brackets
                        }
                        query._expands.unshift(r); // Add to the front of the array
                        i++;
                    }
                }
            }
            return sf.ODataAdaptor.prototype.processQuery.apply(this, [ds, query]);
        },
        processResponse: function (data, ds, query, xhr, request, changes) {
            var pvt = request && request.ejPvtData;
            if (xhr && xhr.getResponseHeader("Content-Type") && xhr.getResponseHeader("Content-Type").indexOf("xml") != -1 && data.nodeType == 9)
                return query._requiresCount ? { result: [], count: 0 } : [];
            if (request && this.options.batch && request.url.endsWith(this.options.batch) && request.type.toLowerCase() === "post") {
                var guid = xhr.getResponseHeader("Content-Type"), cIdx, jsonObj;
                guid = guid.substring(guid.indexOf("=batchresponse") + 1);
                data = data.split(guid);
                if (data.length < 2) return;

                data = data[1];
                var exVal = /(?:\bContent-Type.+boundary=)(changesetresponse.+)/i.exec(data);
                data.replace(exVal[0], "");

                var changeGuid = exVal[1];
                data = data.split(changeGuid);

                for (var i = data.length; i > -1; i--) {
                   if (!/\bContent-ID:/i.test(data[i]) || !/\bHTTP.+201/.test(data[i]))
                        continue;

                    cIdx = parseInt(/\bContent-ID: (\d+)/i.exec(data[i])[1]);

                    if (changes.added[cIdx]) {
                        jsonObj = p.parseJson(/^\{.+\}/m.exec(data[i])[0]);
                        $.extend(changes.added[cIdx], this.processResponse(jsonObj));
                    }
                }
                return changes;
           }
            var count = null, aggregateResult = {};
            if (query && query._requiresCount)
                if ('@odata.count' in data) count = data['@odata.count'];

            data = sf.isNullOrUndefined(data.value) ? data : data.value;
           if (pvt && pvt.aggregates && pvt.aggregates.length) {
               var agg = pvt.aggregates, args = {}, fn, res = {};
               for (var i = 0; i < agg.length; i++) {
                   fn = sf.aggregates[agg[i].type];
                   if (fn)
                       res[agg[i].field + " - " + agg[i].type] = fn(data, agg[i].field);
               }
               aggregateResult = res;
           }
            if (pvt && pvt.groups && pvt.groups.length) {
                var groups = pvt.groups;
                for (var i = 0; i < groups.length; i++) {
                    var format = getColFormat(groups[i], query.queries);
                    data = sf.group(data, groups[i], pvt.aggregates, format);
                }
            }
            return isNull(count) ? data : { result: data, count: count, aggregates: aggregateResult };
        },
    });
    sf.JsonAdaptor = new sf.Adaptor().extend({
        processQuery: function (ds, query) {
            var result = ds.dataSource.json.slice(0), count = result.length, cntFlg = true, ret, key, agg = {};

            for (var i = 0; i < query.queries.length; i++) {
                key = query.queries[i];
                ret = this[key.fn].call(this, result, key.e, query);
                if (key.fn == "onAggregates")
                    agg[key.e.field + " - " + key.e.type] = ret;
                else
                result = ret !== undefined ? ret : result;

                if (key.fn === "onPage" || key.fn === "onSkip" || key.fn === "onTake" || key.fn === "onRange") cntFlg = false;

                if (cntFlg) count = result.length;
            }

            if (query._requiresCount) {
                result = {
                    result: result,
                    count: count,
                    aggregates: agg
                };
            }

            return result;
        },
        batchRequest: function (dm, changes, e) {
            var i;
            for (i = 0; i < changes.added.length; i++)
                this.insert(dm, changes.added[i]);
            for (i = 0; i < changes.changed.length; i++)
                this.update(dm, e.key, changes.changed[i]);
            for (i = 0; i < changes.deleted.length; i++)
                this.remove(dm, e.key, changes.deleted[i]);
            return changes;
        },
        onWhere: function (ds, e) {
            if (!ds) return ds;

            return ds.filter(function (obj) {
                return e.validate(obj);
            });
        },
        onAggregates: function(ds, e){
            var fn = sf.aggregates[e.type];
            if (!ds || !fn || ds.length == 0) return null;
            return fn(ds, e.field);
        },
        onSearch: function (ds, e) {
            if (!ds || !ds.length) return ds;

            if (e.fieldNames.length === 0) {
                sf.pvt.getFieldList(ds[0], e.fieldNames);
            }

            return ds.filter(function (obj) {
                for (var j = 0; j < e.fieldNames.length; j++) {
                    if (e.comparer.call(obj, sf.pvt.getObject(e.fieldNames[j], obj), e.searchKey, e.ignoreCase,e.ignoreAccent))
                        return true;
                }
                return false;
            });
        },
        onSortBy: function (ds, e, query) {
            if (!ds) return ds;
            var fnCompare, field = getValue(e.fieldName, query);
            if (!field)
                return ds.sort(e.comparer);

            if (field instanceof Array) {
                field = field.slice(0);

                for (var i = field.length - 1; i >= 0; i--) {
                    if (!field[i]) continue;

                    fnCompare = e.comparer;

                    if (field[i].endsWith(" desc")) {
                        fnCompare = sf.pvt.fnSort(sf.sortOrder.Descending);
                        field[i] = field[i].replace(" desc", "");
                    }

                    ds = stableSort(ds, field[i], fnCompare, []);
                }
                return ds;
            }
            return stableSort(ds, field, e.comparer, query ? query.queries : []);
        },
        onGroup: function (ds, e, query) {
            if (!ds) return ds;
            var aggQuery = filterQueries(query.queries, "onAggregates"), agg = [];
            if (aggQuery.length) {
                var tmp;
                for (var i = 0; i < aggQuery.length; i++) {
                    tmp = aggQuery[i].e;
                    agg.push({ type: tmp.type, field: getValue(tmp.field, query) });
                }
            }
            var format = getColFormat(e.fieldName, query.queries);
            return sf.group(ds, getValue(e.fieldName, query), agg, format);
        },
        onPage: function (ds, e, query) {
            var size = getValue(e.pageSize, query),
                start = (getValue(e.pageIndex, query) - 1) * size, end = start + size;

            if (!ds) return ds;

            return ds.slice(start, end);
        },
        onRange: function (ds, e) {
            if (!ds) return ds;
            return ds.slice(getValue(e.start), getValue(e.end));
        },
        onTake: function (ds, e) {
            if (!ds) return ds;

            return ds.slice(0, getValue(e.nos));
        },
        onSkip: function (ds, e) {
            if (!ds) return ds;
            return ds.slice(getValue(e.nos));
        },
        onSelect: function (ds, e) {
            if (!ds) return ds;
            return sf.select(ds, getValue(e.fieldNames));
        },
        insert: function (dm, data) {
            return dm.dataSource.json.push(data);
        },
        remove: function (dm, keyField, value, tableName) {
            var ds = dm.dataSource.json, i;
            if (typeof value === "object")
                value = sf.getObject(keyField, value);
            for (i = 0; i < ds.length; i++) {
                if (sf.getObject(keyField, ds[i]) === value) break;
            }

            return i !== ds.length ? ds.splice(i, 1) : null;
        },
        update: function (dm, keyField, value, tableName) {
            var ds = dm.dataSource.json, i, key = sf.getObject(keyField, value);

            for (i = 0; i < ds.length; i++) {
                if (sf.getObject(keyField, ds[i]) === key) break;
            }

            return i < ds.length ? $.extend(ds[i], value) : null;
        }
    });
    sf.ForeignKeyAdaptor = function (data, type) {
        var foreignObj = new sf[type || "JsonAdaptor"]().extend({
            init: function () {
                this.foreignData = [];
                this.key = [];
                this.adaptorType = type;
                this.value = [];
                this.fValue = [];
                this.keyField = [];
                var dataObj = data;
                for (var i = 0; i < dataObj.length; i++) {
                    this.foreignData[i] = dataObj[i].dataSource;
                    this.key[i] = dataObj[i].foreignKeyField;
                    this.fValue[i] = sf.isNullOrUndefined(dataObj[i].field)? dataObj[i].foreignKeyValue : dataObj[i].field + "_" + dataObj[i].foreignKeyValue;
                    this.value[i] = dataObj[i].foreignKeyValue;
                    this.keyField[i] = dataObj[i].field || dataObj[i].foreignKeyField;
                    this.initial = true;
                }
            },
            processQuery: function (ds, query) {
                var data = ds.dataSource.json;
                if (this.initial) {
                    for (var i = 0; i < data.length; i++) {
                        var proxy = this;
                        for (var j = 0; j < this.foreignData.length; j++) {
                            this.foreignData[j].filter(function (col) { //filtering the foreignKey dataSource
                                if (sf.getObject(proxy.key[j], col) == sf.getObject(proxy.keyField[j], data[i]))
                                    data[i][proxy.fValue[j]] = sf.getObject(proxy.value[j], col);
                            });
                        }
                    }
                    this.initial = false;
                }
                return this.base.processQuery.apply(this, [ds, query]);
            },
            setValue: function (value) {
                for (var i = 0; i < this.foreignData.length; i++) {
                    var proxy = this;
                    var keyValue = value[this.fValue[i]];
                    if (typeof keyValue == "string" && !isNaN(keyValue))
                        keyValue = sf.parseFloat(keyValue);
                    var data = $.grep(proxy.foreignData[i], function (e) {
                        return e[proxy.value[i]] == keyValue;
                    })[0];
                    if (sf.isNullOrUndefined(data)) {
                        data = $.grep(proxy.foreignData[i], function (e) {
                            return e[proxy.key[i]] == keyValue;
                        })[0];
                        if (sf.getObject(this.value[i], data) != undefined)
                            sf.createObject(proxy.value[i], sf.getObject(this.value[i], data), value);
                    }
                    if (sf.getObject(this.value[i], data) != undefined)
                        sf.createObject(this.keyField[i], sf.getObject(this.key[i], data), value);
                }
            },
            insert: function (dm, data, tableName) {
                this.setValue(data);
                return {
                    url: dm.dataSource.insertUrl || dm.dataSource.crudUrl || dm.dataSource.url,
                    data: JSON.stringify({
                        value: data,
                        table: tableName,
                        action: "insert",
                        antiForgery: (dm.dataSource.antiForgery) ? dm.antiForgeryToken().value : ""
                    })
                };
            },
            update: function (dm, keyField, value, tableName) {
                this.setValue(value);
                sf.JsonAdaptor.prototype.update(dm, keyField, value, tableName);
                return {
                    type: "POST",
                    url: dm.dataSource.updateUrl || dm.dataSource.crudUrl || dm.dataSource.url,
                    data: JSON.stringify({
                        value: value,
                        action: "update",
                        keyColumn: keyField,
                        key: value[keyField],
                        table: tableName,
                        antiForgery: (dm.dataSource.antiForgery) ? dm.antiForgeryToken().value : ""
                    })
                };
            }
        });
        $.extend(this, new foreignObj());
        return this;
    }
    sf.remoteSaveAdaptor = new sf.JsonAdaptor().extend({
        beforeSend: sf.UrlAdaptor.prototype.beforeSend,
        insert: sf.UrlAdaptor.prototype.insert,
        update: sf.UrlAdaptor.prototype.update,
        remove: sf.UrlAdaptor.prototype.remove,
        addParams: sf.UrlAdaptor.prototype.addParams,
        batchRequest: function (dm, changes, e, query) { 
			var res = {
                changed: changes.changed,
                added: changes.added,
                deleted: changes.deleted,
                action: "batch",
                table: e.url,
                key: e.key,
                antiForgery: (dm.dataSource.antiForgery) ? dm.antiForgeryToken().value : ""
            };
            if (query)
                this.addParams({ dm: dm, query: query, params: query._params, reqParams: res });
            return {
                type: "POST",
                url: dm.dataSource.batchUrl || dm.dataSource.crudUrl || dm.dataSource.url,
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify(res)
            };
        },
        processResponse: function (data, ds, query, xhr, request, changes, key) {
            if(!sf.isNullOrUndefined(changes)){
            if (data.d)
                data = data.d;
            if(data.added)changes.added = sf.parseJSON(data.added);
            if(data.changed)changes.changed = sf.parseJSON(data.changed);
            if(data.deleted)changes.deleted = sf.parseJSON(data.deleted);
            var i;
            for (i = 0; i < changes.added.length; i++)
                sf.JsonAdaptor.prototype.insert(ds, changes.added[i]);
            for (i = 0; i < changes.changed.length; i++)
                sf.JsonAdaptor.prototype.update(ds, key, changes.changed[i]);
            for (i = 0; i < changes.deleted.length; i++)
                sf.JsonAdaptor.prototype.remove(ds, key, changes.deleted[i]);
            return data;
             }
            else{
                if (data.d)
               return data.d;
            return data;
            }
        }
    });
    sf.WebApiAdaptor = new sf.ODataAdaptor().extend({
        insert: function (dm, data, tableName) {
            return {
                type: "POST",
                url: dm.dataSource.url,
                data: JSON.stringify(data)
            };
        },
        remove: function (dm, keyField, value, tableName) {
            return {
                type: "DELETE",
                url: dm.dataSource.url + "/" + value,
                data: JSON.stringify(value)
            };
        },
        update: function (dm, keyField, value, tableName) {
            return {
                type: "PUT",
                url: dm.dataSource.url,
                data: JSON.stringify(value)
            };
        },
		batchRequest: function (dm, changes, e) {
            var initialGuid = e.guid = sf.getGuid(oData.batchPre);
            var req = [];

		    //insertion 
		
			$.each(changes.added, function (i, d) {
			    req.push('--' + initialGuid);
			    req.push('Content-Type: application/http; msgtype=request', '');
			    req.push('POST' + ' ' + dm.dataSource.insertUrl + ' HTTP/1.1');
			    req.push('Content-Type: ' + 'application/json; charset=utf-8');
			    req.push('Host: ' + location.host);
			    req.push('', d ? JSON.stringify(d) : '');
			});
			
			//updation
			$.each(changes.changed, function (i, d) {
			    req.push('--' + initialGuid);
			    req.push('Content-Type: application/http; msgtype=request', '');
			    req.push('PUT' + ' ' + dm.dataSource.updateUrl + ' HTTP/1.1');
			    req.push('Content-Type: ' + 'application/json; charset=utf-8');
			    req.push('Host: ' + location.host);
			    req.push('', d ? JSON.stringify(d) : '');
			});
			
			//deletion
			$.each(changes.deleted, function (i, d) {
			    req.push('--' + initialGuid);
                req.push('Content-Type: application/http; msgtype=request', '');
                req.push('DELETE' + ' ' + dm.dataSource.removeUrl +"/"+ d[e.key] + ' HTTP/1.1');
                req.push('Content-Type: ' + 'application/json; charset=utf-8');
                req.push('Host: ' + location.host);
                req.push('', d ? JSON.stringify(d) : '');		
			});
			req.push('--' + initialGuid + '--', '');
            return {
				type: 'POST',
				url: dm.dataSource.batchUrl || dm.dataSource.crudUrl || dm.dataSource.url,
                data: req.join('\r\n'),
                contentType: 'multipart/mixed; boundary="' + initialGuid + '"',
            };
        },
        processResponse: function (data, ds, query, xhr, request, changes) {

            var pvt = request && request.ejPvtData;
            if (request && request.type.toLowerCase() != "post") {
                var version = xhr && xhr.getResponseHeader("DataServiceVersion"), count = null, aggregateResult = {};
                version = (version && parseInt(version, 10)) || 2;

                if (query && query._requiresCount) {
                     if (!isNull(data.Count)) count = data.Count;
                }

                if (version < 3 && data.Items) data = data.Items;

                if (pvt && pvt.aggregates && pvt.aggregates.length) {
                    var agg = pvt.aggregates, args = {}, fn, res = {};
                    for (var i = 0; i < agg.length; i++) {
                        fn = sf.aggregates[agg[i].type];
                        if (fn)
                            res[agg[i].field + " - " + agg[i].type] = fn(data, agg[i].field);
                    }
                    aggregateResult = res;
                }
                if (pvt && pvt.groups && pvt.groups.length) {
                    var groups = pvt.groups;
                    for (var i = 0; i < groups.length; i++) {
                        var format = getColFormat(groups[i], query.queries);
                        data = sf.group(data, groups[i], pvt.aggregates, format);
                    }
                }
                return isNull(count) ? data : { result: data, count: count, aggregates: aggregateResult };
            }
        }
    });
    var getValue = function (value, inst) {
        if (typeof value === "function")
            return value.call(inst || {});
        return value;
    }

    sf.TableModel = function (name, jsonArray, dataManager, modelComputed) {
        if (!instance(this, sf.TableModel))
            return new sf.TableModel(jsonArray);

        if (!instance(jsonArray, Array))
            throwError("sf.TableModel - Json Array is required");

        var rows = [], model, dirtyFn = $proxy(setDirty, this);

        for (var i = 0; i < jsonArray.length; i++) {
            model = new sf.Model(jsonArray[i], this);
            model.state = "unchanged";
            model.on("stateChange", dirtyFn);
            if (modelComputed)
                model.computes(modelComputed);
            rows.push(model);
        }

        this.name = name || "table1";

        this.rows = sf.NotifierArray(rows);
        this._deleted = [];

        this._events = $({});

        this.dataManager = dataManager;

        this._isDirty = false;

        return this;
    };

    sf.TableModel.prototype = {
        on: function (eventName, handler) {
            this._events.on(eventName, handler);
        },

        off: function (eventName, handler) {
            this._events.off(eventName, handler);
        },

        setDataManager: function (dataManager) {
            this.dataManagar = dataManager;
        },

        saveChanges: function () {
            if (!this.dataManager || !instance(this.dataManager, sf.DataManager))
                throwError("sf.TableModel - saveChanges : Set the dataManager using setDataManager function");

            if (!this.isDirty())
                return;

            var promise = this.dataManager.saveChanges(this.getChanges(), this.key, this.name);

            promise.done($proxy(function (changes) {
                var rows = this.toArray();
                for (var i = 0; i < rows.length; i++) {
                    if (rows.state === "added") {
                        rows.set(this.key, changes.added.filter(function (e) {
                            return e[this.key] === rows.get(this.key);
                        })[0][this.key]);
                    }
                    rows[i].markCommit();
                }

                this._events.triggerHandler({ type: "save", table: this });

            }, this));

            promise.fail($proxy(function (e) {
                this.rejectChanges();
                this._events.triggerHandler({ type: "reject", table: this, error: e });
            }, this));

            this._isDirty = false;
        },

        rejectChanges: function () {
            var rows = this.toArray();
            for (var i = 0; i < rows.length; i++)
                rows[i].revert(true);

            this._isDirty = false;
            this._events.triggerHandler({ type: "reject", table: this });
        },

        insert: function (json) {
            var model = new sf.Model(json);
            model._isDirty = this._isDirty = true;

            this.rows.push(model);

            this._events.triggerHandler({ type: "insert", model: model, table: this });
        },

        update: function (value) {
            if (!this.key)
                throwError("TableModel - update : Primary key should be assigned to TableModel.key");

            var row = value, model, key = this.key, keyValue = row[key];

            model = this.rows.array.filter(function (obj) {
                return obj.get(key) === keyValue;
            });

            model = model[0];

            for (var col in row) {
                model.set(col, row[col]);
            }

            this._isDirty = true;

            this._events.triggerHandler({ type: "update", model: model, table: this });
        },

        remove: function (key) {
            if (!this.key)
                throwError("TableModel - update : Primary key should be assigned to TableModel.key");

            var field = this.key;

            var index = -1, model;

            if (key && typeof key === "object") {
                key = key[field] !== undefined ? key[field] : key.get(field);
            }

            for (var i = 0; i < this.rows.length() ; i++) {
                if (this.rows.array[i].get(field) === key) {
                    index = i;
                    break;
                }
            }

            if (index > -1) {
                model = this.rows.removeAt(index);
                model.markDelete();

                this._deleted.push({ model: model, position: index });

                this._isDirty = true;
                this._events.triggerHandler({ type: "remove", model: model, table: this });
            }
        },

        isDirty: function () {
            return this._isDirty;
        },

        getChanges: function () {

            var changes = {
                added: [],
                changed: []
            };
            var rows = this.toArray();
            for (var i = 0; i < rows.length; i++) {
                if (changes[rows[i].state])
                    changes[rows[i].state].push(rows[i].json);
            }

            changes.deleted = sf.select(this._deleted, ["model"]);

            return changes;
        },

        toArray: function () {
            return this.rows.toArray();
        },

        setDirty: function (dirty, model) {
            if (this._isDirty === !!dirty) return;

            this._isDirty = !!dirty;

            this._events.triggerHandler({ type: "dirty", table: this, model: model });
        },
        get: function (index) {
            return this.rows.array[index];
        },
        length: function () {
            return this.rows.array.length;
        },

        bindTo: function (element) {
            var marker = tDiv, template = $(element.html()), rows = this.toArray(), cur;
            if ($.inArray(element.prop("tagName").toLowerCase(), ["table", "tbody"]))
                marker = tTR;

            marker.insertBefore(element);
            element.detach().empty();

            for (var i = 0; i < rows.length; i++) {
                cur = template.clone();
                rows[i].bindTo(cur);
                element.append(cur);
            }

            element.insertAfter(marker);
            marker.remove();
        }
    };

    var tDiv = doc ? $(document.createElement("div")) : {},
        tTR = doc ? $(document.createElement("tr")) : {};

    sf.Model = function (json, table, name) {
        if (typeof table === "string") {
            name = table;
            table = null;
        }
        this.$id = getUid("m");

        this.json = json;
        this.table = table instanceof sf.TableModel ? table : null;
        this.name = name || (this.table && this.table.name);
        this.dataManager = (table instanceof sf.DataManager) ? table : table.dataManagar;
        this.actual = {};
        this._events = $({});
        this.isDirty = false;
        this.state = "added";
        this._props = [];
        this._computeEls = {};
        this._fields = {};
        this._attrEls = {};
        this._updates = {};
        this.computed = {};
    };

    sf.Model.prototype = {
        computes: function (value) {
            $.extend(this.computed, value);
        },
        on: function (eventName, handler) {
            this._events.on(eventName, handler);
        },
        off: function (eventName, handler) {
            this._events.off(eventName, handler);
        },
        set: function (field, value) {
            var obj = this.json, actual = field, prev;
            field = field.split('.');

            for (var i = 0; i < field.length - 1; i++) {
                field = field[0];
                obj = obj[field[0]];
            }

            this.isDirty = true;
            this.changeState("changed", { from: "set" });

            prev = obj[field];

            if (this.actual[field] === undefined && !(field in this.actual))
                this.actual[field] = value; // Complex property ?

            obj[field] = value;

            this._updateValues(field, value);
            this._events.triggerHandler({ type: actual, current: value, previous: prev, model: this });
        },
        get: function (field) {
            return sf.pvt.getObject(field, this.json);
        },
        revert: function (suspendEvent) {
            for (var prop in this.actual) {
                this.json[prop] = this.actual[prop];
            }

            this.isDirty = false;

            if (suspendEvent)
                this.state = "unchanged";
            else
                this.changeState("unchanged", { from: "revert" });
        },
        save: function (dm, key) {
            dm = dm || this.dataManagar;
            key = key || dm.dataSource.key;
            if (!dm) throwError("sf.Model - DataManager is required to commit the changes");
            if (this.state === "added") {
                return dm.insert(this.json, this.name).done(sf.proxy(function (e) {
                    $.extend(this.json, e.record);
                }, this));
            }
            else if (this.state === "changed") {
                return dm.update(key, this.json, this.name);
            }
            else if (this.state === "deleted") {
                return dm.remove(key, this.json, this.name);
            }
        },
        markCommit: function () {
            this.isDirty = false;
            this.changeState("unchanged", { from: "commit" });
        },
        markDelete: function () {
            this.changeState("deleted", { from: "delete" });
        },
        changeState: function (state, args) {
            if (this.state === state) return;

            if (this.state === "added") {
                if (state === "deleted")
                    state = "unchanged";
                else return;
            }

            var prev = state;
            args = args || {};

            this.state = state;
            this._events.triggerHandler($.extend({ type: "stateChange", current: state, previous: prev, model: this }, args));
        },
        properties: function () {
            if (this._props.length)
                return this._props;

            for (var pr in this.json) {
                this._props.push(pr);
                this._updates[pr] = { read: [], input: [] };
            }

            return this._props;
        },
        bindTo: function (element) {
            var el = $(element), ctl, field,
                elements = el.find("[sf-observe], [sf-computed], [sf-prop]"), len = elements.length;

            el.data("ejModel", this);
            var unbindData = { fields: [], props: [], computes: [] };
            for (var i = 0; i < len; i++) {
                ctl = elements.eq(i);

                field = ctl.attr("sf-prop");
                if (field) {
                    this._processAttrib(field, ctl, unbindData);
                }
                field = ctl.attr("sf-observe");
                if (field && this._props.indexOf(field) !== -1) {
                    this._processField(ctl, field, unbindData);
                    continue;
                }

                field = ctl.attr("sf-computed");
                if (field) {
                    this._processComputed(field, ctl, unbindData);
                    continue;
                }
            }
            el.data("ejModelBinding" + this.$id, unbindData);
        },
        unbind: function (element) {
            var tmp, data = {
                props: this._attrEls,
                computes: this._computeEls
            }, isCustom = false;

            if (element) {
                data = $(element).removeData("ejModel").data("ejModelBinding" + this.$id) || data;
                isCustom = true;
            }

            for (var p in this.computed) {
                tmp = data.computes[p], p = this.computed[p];
                if (tmp && p.deps) {
                    this.off(p.deps.join(' '), tmp.handle);
                    if (isCustom)
                        delete this._computeEls[p];
                }
            }
            if (!isCustom)
                this._computeEls = {};

            for (var p in data.props) {
                tmp = data.props[p];
                if (tmp) {
                    this.off(tmp.deps.join(' '), tmp.handle);
                    delete data.props[p];
                    if (isCustom)
                        delete this._attrEls[p];
                }
            }
            if (!isCustom)
                this._attrEls = {};

            if (data.fields && data.fields.length) {
                var len = data.fields.length, ctl, idx, ty;
                for (var i = 0; i < len; i++) {
                    ctl = data.fields[i];
                    $(ctl).off("change", null, this._changeHandler);

                    ty = this.formElements.indexOf(ctl.tagName.toLowerCase()) !== -1 ? "input" : "read";
                    idx = this._updates[ty].indexOf(ctl);
                    if (idx !== -1)
                        this._updates[ty].splice(idx, 1);
                }
            }
        },
        _processComputed: function (value, element, data) {
            if (!value) return;

            var val, deps, safeVal = safeStr(value),
            type = this.formElements.indexOf(element[0].tagName.toLowerCase()) !== -1 ? "val" : "html";

            if (!this.computed[value] || !this.computed[safeVal]) {
                this.computed[safeVal] = {
                    value: new Function("var e = this; return " + value),
                    deps: this._generateDeps(value)
                }
                value = safeVal;
            }

            val = this.computed[value];
            if (!val.get) {
                val.get = function () {
                    val.value.call(this.json);
                }
            }

            deps = val.deps;
            val = val.value;

            this._updateDeps(deps);
            this._updateElement(element, type, val);

            val = { el: element, handle: $proxy(this._computeHandle, this, { value: value, type: type }) };
            this._computeEls[value] = val;
            data.computes[value] = val;

            this.on(deps.join(' '), val.handle);
        },
        _computeHandle: function (e) {
            var el = this._computeEls[e.value];
            if (el && this.computed[e.value])
                this._updateElement(el.el, e.type, this.computed[e.value].value);
        },
        _updateElement: function (el, type, val) {
            el[type](val.call($.extend({}, this.json, this.computed)));
        },
        _updateDeps: function (deps) {
            for (var i = 0; i < deps.length; i++) {
                if (!(deps[i] in this.json) && deps[i] in this.computed)
                    sf.merge(deps, this.computed[deps[i]].deps);
            }
        },
        _generateDeps: function (value) {
            var splits = value.replace(/(^e\.)|( e\.)/g, '#%^*##sf.#').split("#%^*#"),
                field, deps = [];

            for (var i = 0; i < splits.length; i++) {
                if (splits[i].startsWith("#sf.#")) {
                    field = splits[i].replace("#sf.#", "").split(' ')[0];
                    if (field && this._props.indexOf(field) !== -1)
                        deps.push(field);
                }
            }

            return deps;
        },
        _processAttrib: function (value, el, data) {
            var prop, val, res = {};
            value = value.replace(/^ +| +$/g, "").split(";");
            for (var i = 0; i < value.length; i++) {
                value[i] = value[i].split(":");
                if (value[i].length < 2) continue;

                prop = value[i][0].replace(/^ +| +$/g, "").replace(/^'|^"|'$|"$/g, "");
                res[prop] = value[i][1].replace(/^ +| +$/g, "").replace(/^'|^"|'$|"$/g, "");
            }
            value = res;
            var deps = [];
            for (prop in value)
                deps.push(value[prop]);

            this._updateDeps(deps);
            this._updateProps(el, value);

            res = getUid("emak");
            val = { el: el, handle: $proxy(this._attrHandle, this, res), value: value, deps: deps };
            el.prop("ejmodelattrkey", res);

            data.props[res] = val;
            this._attrEls[res] = val;

            this.on(deps.join(' '), val.handle);
        },
        _attrHandle: function (res) {
            var el = this._attrEls[res];
            if (el)
                this._updateProps(el.el, el.value);
        },
        _updateProps: function (element, value) {
            var json = this.json, t, c = this.computed;
            for (var prop in value) {
                t = value[prop];
                if (t in json)
                    t = json[t];
                else if (t in c) {
                    t = c[t];
                    if (t) {
                        t = t.value.call($.extend({}, this.json, c));
                    }
                }

                if (!isNull(t)) {
                    element.prop(prop, t);
                }
            }
        },
        _updateValues: function (prop, value) {
            var arr = this._updates[prop];

            if (!arr || (!arr.read && !arr.input)) return;

            this._ensureItems(arr.read, "html", value);
            this._ensureItems(arr.input, "val", value);
        },
        _ensureItems: function (a, type, value) {
            if (!a) return;

            for (var i = a.length - 1; i > -1; i--) {
                if (!a[i].offsetParent) {
                    a.splice(i, 1);
                    continue;
                }
                $(a[i])[type](value);
            }
        },
        _changeHandler: function (e) {
            e.data.self.set(e.data.prop, $(this).val());
        },
        _processField: function (ctl, field, data) {
            var e = { self: this, prop: field }, val = this.get(field);

            data.fields.push(ctl[0]);

            if (this.formElements.indexOf(ctl[0].tagName.toLowerCase()) === -1) {
                ctl.html(val);
                return this._updates[field].read.push(ctl[0]);
            }

            ctl.val(val)
                    .off("change", null, this._changeHandler)
                    .on("change", null, e, this._changeHandler);

            return this._updates[field].input.push(ctl[0]);
        },
        formElements: ["input", "select", "textarea"]
    };

    var safeReg = /[^\w]+/g;
    var safeStr = function (value) {
        return value.replace(safeReg, "_");
    };
    var setDirty = function (e) {
        this.setDirty(true, e.model);
    };

    sf.Predicate = function (field, operator, value, ignoreCase, ignoreAccent) {
        if (!(this instanceof sf.Predicate))
            return new sf.Predicate(field, operator, value, ignoreCase,ignoreAccent);

        this.ignoreAccent = false;

        if (typeof field === "string") {
			var checkAny = "";
			if(operator.toLowerCase().indexOf(" any") != -1) {
				operator = operator.replace(" any","");
				checkAny = "any";
			} 
			else if(operator.toLowerCase().indexOf(" all") != -1) {
				operator = operator.replace(" all","");
				checkAny = "all";
			} 
            this.field = field;
            this.operator = operator;
            this.value = value;
            this.ignoreCase = ignoreCase;
            this.ignoreAccent = ignoreAccent;
            this.isComplex = false;
			this.anyCondition = checkAny;

            this._comparer = sf.data.fnOperators.processOperator(checkAny != "" ? checkAny:this.operator);

        } else if (field instanceof sf.Predicate && value instanceof sf.Predicate || value instanceof Array) {
            this.isComplex = true;
            this.condition = operator.toLowerCase();
            this.predicates = [field];
            if (value instanceof Array)
                [].push.apply(this.predicates, value);
            else
                this.predicates.push(value);
        }
        return this;
    };

    sf.Predicate.and = function () {
        return pvtPredicate._combinePredicates([].slice.call(arguments, 0), "and");
    };

    sf.Predicate.or = function () {
        return pvtPredicate._combinePredicates([].slice.call(arguments, 0), "or");
    };

    sf.Predicate.fromJSON = function (json) {
        if (instance(json, Array)) {
            var res = [];
            for (var i = 0, len = json.length; i < len; i++)
                res.push(pvtPredicate._fromJSON(json[i]));
            return res;
        }

        return pvtPredicate._fromJSON(json);
    };

    // Private fn
    var pvtPredicate = {
        _combinePredicates: function (predicates, operator) {
            if (!predicates.length) return undefined;
            if (predicates.length === 1) {
                if (!instance(predicates[0], Array))
                    return predicates[0];
                predicates = predicates[0];
            }
            return new sf.Predicate(predicates[0], operator, predicates.slice(1));
        },

        _combine: function (pred, field, operator, value, condition, ignoreCase, ignoreAccent) {
            if (field instanceof sf.Predicate)
                return sf.Predicate[condition](pred, field);

            if (typeof field === "string")
                return sf.Predicate[condition](pred, new sf.Predicate(field, operator, value, ignoreCase,ignoreAccent));

            return throwError("Predicate - " + condition + " : invalid arguments");
        },

        _fromJSON: function (json) {

            if (!json || instance(json, sf.Predicate))
                return json;

            var preds = json.predicates || [], len = preds.length, predicates = [], result;

            for (var i = 0; i < len; i++)
                predicates.push(pvtPredicate._fromJSON(preds[i]));                     

            if(!json.isComplex)
                result = new sf.Predicate(json.field, json.operator, sf.parseJSON({ val: json.value }).val, json.ignoreCase,json.ignoreAccent);
            else
                result = new sf.Predicate(predicates[0], json.condition, predicates.slice(1));

            return result;
        }
    };

    sf.Predicate.prototype = {
        and: function (field, operator, value, ignoreCase,ignoreAccent) {
            return pvtPredicate._combine(this, field, operator, value, "and", ignoreCase,ignoreAccent);
        },
        or: function (field, operator, value, ignoreCase,ignoreAccent) {
            return pvtPredicate._combine(this, field, operator, value, "or", ignoreCase,ignoreAccent);
        },
        validate: function (record) {
            var p = this.predicates, isAnd, ret;

            if (!this.isComplex) {
                return this._comparer.call(this, sf.pvt.getObject(this.field, record), this.value, this.ignoreCase,this.ignoreAccent);
            }

            isAnd = this.condition === "and";

            for (var i = 0; i < p.length; i++) {
                ret = p[i].validate(record);
                if (isAnd) {
                    if (!ret) return false;
                } else {
                    if (ret) return true;
                }
            }

            return isAnd;
        },
        toJSON: function () {
            var predicates, p;
            if (this.isComplex) {
                predicates = [], p = this.predicates;
                for (var i = 0; i < p.length; i++)
                    predicates.push(p[i].toJSON());
            }
            return {
                isComplex: this.isComplex,
                field: this.field,
                operator: this.operator,
                value: this.value,
                ignoreCase: this.ignoreCase,
                ignoreAccent: this.ignoreAccent,
                condition: this.condition,
                predicates: predicates,
				anyCondition: this.anyCondition
            }
        }
    };

    sf.dataUtil = {
        swap: function (array, x, y) {
            if (x == y) return;

            var tmp = array[x];
            array[x] = array[y];
            array[y] = tmp;
        },

        mergeSort: function (jsonArray, fieldName, comparer) {
            if (!comparer || typeof comparer === "string")
                comparer = sf.pvt.fnSort(comparer, true);

            if (typeof fieldName === "function") {
                comparer = fieldName;
                fieldName = null;
            }

            return sf.pvt.mergeSort(jsonArray, fieldName, comparer);
        },

        max: function (jsonArray, fieldName, comparer) {
            if (typeof fieldName === "function") {
                comparer = fieldName;
                fieldName = null;
            }

            return sf.pvt.getItemFromComparer(jsonArray, fieldName, comparer || sf.pvt.fnDescending);
        },

        min: function (jsonArray, fieldName, comparer) {
            if (typeof fieldName === "function") {
                comparer = fieldName;
                fieldName = null;
            }

            return sf.pvt.getItemFromComparer(jsonArray, fieldName, comparer || sf.pvt.fnAscending);
        },

        distinct: function (json, fieldName, requiresCompleteRecord) {
            var result = [], val, tmp = {};
            for (var i = 0; i < json.length; i++) {
                val = getVal(json, fieldName, i);
                if (!(val in tmp)) {
                    result.push(!requiresCompleteRecord ? val : json[i]);
                    tmp[val] = 1;
                }
            }
            return result;
        },

        sum: function (json, fieldName) {
            var result = 0, val, castRequired = typeof getVal(json, fieldName, 0) !== "number";

            for (var i = 0; i < json.length; i++) {
                val = getVal(json, fieldName, i);
                if (!isNaN(val) && val !== null) {
                    if (castRequired)
                       val = +val;
                   result += val;
                }
            }
            return result;
        },

        avg: function (json, fieldName) {
            return sf.sum(json, fieldName) / json.length;
        },

        select: function (jsonArray, fields) {
            var newData = [];

            for (var i = 0; i < jsonArray.length; i++) {
                newData.push(sf.pvt.extractFields(jsonArray[i], fields));
            }

            return newData;
        },

        group: function (jsonArray, field, agg, format,/* internal */ level,groupDs) {
            level = level || 1;

            if (jsonArray.GROUPGUID == sf.pvt.consts.GROUPGUID) {
                for (var j = 0; j < jsonArray.length; j++) {
                    if(!sf.isNullOrUndefined(groupDs)){
                        var indx = -1;
                        var temp = $.grep(groupDs,function(e){return e.key==jsonArray[j].key});
                        indx = groupDs.indexOf(temp[0]);
                        jsonArray[j].items = sf.group(jsonArray[j].items, field, agg, format, jsonArray.level + 1, groupDs[indx].items);
                        jsonArray[j].count = groupDs[indx].count;
                    }
                    else{
                        jsonArray[j].items = sf.group(jsonArray[j].items, field, agg, format, jsonArray.level + 1);
                        jsonArray[j].count = jsonArray[j].items.length;
                    }  
                }

                jsonArray.childLevels += 1;
                return jsonArray;
            }

            var grouped = {}, groupedArray = [];

            groupedArray.GROUPGUID = sf.pvt.consts.GROUPGUID;
            groupedArray.level = level;
            groupedArray.childLevels = 0;
            groupedArray.records = jsonArray;

            for (var i = 0; i < jsonArray.length; i++) {
                var val = getVal(jsonArray, field, i);
                if (!sf.isNullOrUndefined(format)) val = format(val, field);

                if (!grouped[val]) {
                    grouped[val] = {
                        key: val,
                        count: 0,
                        items: [],
                        aggregates: {},
                        field: field
                    };
                    groupedArray.push(grouped[val]);
					if(!sf.isNullOrUndefined(groupDs)) {
                        var tempObj = $.grep(groupDs,function(e){return e.key==grouped[val].key});
                       grouped[val].count = tempObj[0].count
                    }
                }

                grouped[val].count = !sf.isNullOrUndefined(groupDs) ? grouped[val].count :  grouped[val].count += 1;
                grouped[val].items.push(jsonArray[i]);
            }
            if (agg && agg.length) {

                for (var i = 0; i < groupedArray.length; i++) {
                    var res = {}, fn;
                    for (var j = 0; j < agg.length; j++) {

                        fn = sf.aggregates[agg[j].type];
                        if(!sf.isNullOrUndefined(groupDs)) {
                            var temp = $.grep(groupDs,function(e){return e.key==groupedArray[i].key});
                            if(fn)
                                res[agg[j].field + " - " + agg[j].type] = fn(temp[0].items, agg[j].field);
                        }
                        else{
                            if (fn)
                                res[agg[j].field + " - " + agg[j].type] = fn(groupedArray[i].items, agg[j].field);
                        }

                    }
                    groupedArray[i]["aggregates"] = res;
                }
            }
            return groupedArray;
        },

        parseTable: function (table, headerOption, headerRowIndex) {
            var tr = table.rows, headerRow, headerTds = [], data = [], i;

            if (!tr.length) return [];

            headerRowIndex = headerRowIndex || 0;

            switch ((headerOption || "").toLowerCase()) {
                case sf.headerOption.tHead:
                    headerRow = table.tHead.rows[headerRowIndex];
                    break;
                case sf.headerOption.row:
                default:
                    headerRow = table.rows[headerRowIndex];
                    break;
            }

            var hTd = headerRow.cells;

            for (i = 0; i < hTd.length; i++)
                headerTds.push($.trim(hTd[i].innerHTML));

            for (i = headerRowIndex + 1; i < tr.length; i++) {
                var json = {}, td = tr[i].cells;
                for (var j = 0; j < td.length; j++) {
                    var temp = td[j].innerHTML;
                    if (typeof temp == "string" && $.isNumeric(temp))
                       json[headerTds[j]] = Number(temp);
				    else
                       json[headerTds[j]] = temp;
                }
                data.push(json);
            }
            return data;
        }
    };

    sf.headerOption = {
        tHead: "thead",
        row: "row"
    };

    sf.aggregates = {
        sum: function (ds, field) {
            return sf.sum(ds, field);
        },
        average: function (ds, field) {
            return sf.avg(ds, field);
        },
        minimum: function (ds, field) {
            return sf.getObject(field, sf.min(ds, field));
        },
        maximum: function (ds, field) {
            return  sf.getObject(field, sf.max(ds, field));
        },
        truecount: function (ds, field){
            var predicate = sf.Predicate(field, "equal", true);
            return sf.DataManager(ds).executeLocal(sf.Query().where(predicate)).length;
        },
        falsecount: function (ds, field) {
            var predicate = sf.Predicate(field, "equal", false);
            return sf.DataManager(ds).executeLocal(sf.Query().where(predicate)).length;
        },
        count: function (ds, field) {
            return ds.length;
        }

    };
    sf.pvt = {
        filterQueries: filterQueries,
        mergeSort: function (jsonArray, fieldName, comparer) {
            if (jsonArray.length <= 1)
                return jsonArray;

            // else list size is > 1, so split the list into two sublists
            var middle = parseInt(jsonArray.length / 2, 10);

            var left = jsonArray.slice(0, middle),
                right = jsonArray.slice(middle);

            left = sf.pvt.mergeSort(left, fieldName, comparer);
            right = sf.pvt.mergeSort(right, fieldName, comparer);

            return sf.pvt.merge(left, right, fieldName, comparer);
        },

        getItemFromComparer: function (array, field, comparer) {
            var keyVal, current, key, i = 0,castRequired = typeof getVal(array, field, 0) == "string";
            if (array.length)
            while (sf.isNullOrUndefined(keyVal) && i < array.length) {
                keyVal = getVal(array, field, i);
                key = array[i++];
            }
            for (; i < array.length; i++) {
                current = getVal(array, field, i);
                if (sf.isNullOrUndefined(current))
                    continue;
                if (castRequired) {
                    keyVal = +keyVal;
                    current = +current;
                }
                if (comparer(keyVal, current) > 0) {
                    keyVal = current;
                    key = array[i];
                }
            }
            return key;
        },

        quickSelect: function (array, fieldName, left, right, k, comparer) {
            if (left == right)
                return array[left];

            var pivotNewIndex = sf.pvt.partition(array, fieldName, left, right, comparer);

            var pivotDist = pivotNewIndex - left + 1;

            if (pivotDist == k)
                return array[pivotNewIndex];

            else if (k < pivotDist)
                return sf.pvt.quickSelect(array, fieldName, left, pivotNewIndex - 1, k, comparer);
            else
                return sf.pvt.quickSelect(array, fieldName, pivotNewIndex + 1, right, k - pivotDist, comparer);
        },

        extractFields: function (obj, fields) {
            var newObj = {};

            if (fields.length == 1)
                return sf.pvt.getObject(fields[0], obj);

            for (var i = 0; i < fields.length; i++) {
                newObj[fields[i].replace('.', sf.pvt.consts.complexPropertyMerge)] = sf.pvt.getObject(fields[i], obj);
            }

            return newObj;
        },

        partition: function (array, field, left, right, comparer) {

            var pivotIndex = parseInt((left + right) / 2, 10),
                pivot = getVal(array, field, pivotIndex);

            sf.swap(array, pivotIndex, right);

            pivotIndex = left;

            for (var i = left; i < right; i++) {
                if (comparer(getVal(array, field, i), pivot)) {
                    sf.swap(array, i, pivotIndex);
                    pivotIndex++;
                }
            }

            sf.swap(array, pivotIndex, right);

            return pivotIndex;
        },

        fnSort: function (order) {
            order = order ? order.toLowerCase() : sf.sortOrder.Ascending;

            if (order == sf.sortOrder.Ascending)
                return sf.pvt.fnAscending;

            return sf.pvt.fnDescending;
        },

        fnGetComparer: function (field, fn) {
            return function (x, y) {
                return fn(sf.pvt.getObject(field, x), sf.pvt.getObject(field, y));
            }
        },

        fnAscending: function (x, y) {
            if(sf.isNullOrUndefined(y) && sf.isNullOrUndefined(x))
                return -1;
                        
            if (y === null || y === undefined)
                return -1;

            if (typeof x === "string")
                return x.localeCompare(y);

            if (x === null || x === undefined)
                return 1;

            return x - y;
        },

        fnDescending: function (x, y) {
            if(sf.isNullOrUndefined(y) && sf.isNullOrUndefined(x))
                return -1;            

            if (y === null || y === undefined)
                return 1;

            if (typeof x === "string")
                return x.localeCompare(y) * -1;

            if (x === null || x === undefined)
                return -1;

            return y - x;
        },

        merge: function (left, right, fieldName, comparer) {
            var result = [], current;

            while (left.length > 0 || right.length > 0) {
                if (left.length > 0 && right.length > 0) {
                    if (comparer)
                        current = comparer(getVal(left, fieldName, 0), getVal(right, fieldName, 0)) <= 0 ? left : right;
                    else
                        current = left[0][fieldName] < left[0][fieldName] ? left : right;
                } else {
                    current = left.length > 0 ? left : right;
                }

                result.push(current.shift());
            }

            return result;
        },

        getObject: function (nameSpace, from) {
            if (!from) return undefined;
            if (!nameSpace) return from;

            if (nameSpace.indexOf('.') === -1) return from[nameSpace];

            var value = from, splits = nameSpace.split('.');

            for (var i = 0; i < splits.length; i++) {

                if (value == null) break;

                value = value[splits[i]];
            }

            return value;
        },

        createObject: function (nameSpace, value, initIn) {
            var splits = nameSpace.split('.'), start = initIn || window, from = start, i;

            for (i = 0; i < splits.length; i++) {

                if (i + 1 == splits.length)
                    from[splits[i]] = value === undefined ? {} : value;
                else if (from[splits[i]] == null)
                    from[splits[i]] = {};

                from = from[splits[i]];
            }

            return start;
        },

        ignoreDiacritics :function (value) {
            if (typeof value !== 'string') {
                return value;
            }
            var result = value.split('');
            var newValue = result.map(function (temp) { return temp in sf.data.diacritics ? sf.data.diacritics[temp] : temp; });
            return newValue.join('');
        },


        getFieldList: function (obj, fields, prefix) {
            if (prefix === undefined)
                prefix = "";

            if (fields === undefined || fields === null)
                return sf.pvt.getFieldList(obj, [], prefix);

            for (var prop in obj) {
                if (typeof obj[prop] === "object" && !(obj[prop] instanceof Array))
                    sf.pvt.getFieldList(obj[prop], fields, prefix + prop + ".");
                else
                    fields.push(prefix + prop);
            }

            return fields;
        }
    };

    sf.FilterOperators = {
        lessThan: "lessthan",
        greaterThan: "greaterthan",
        lessThanOrEqual: "lessthanorequal",
        greaterThanOrEqual: "greaterthanorequal",
        equal: "equal",
        contains: "contains",
        startsWith: "startswith",
        endsWith: "endswith",
        notEqual: "notequal"
    };

    sf.data = {};

    sf.data.operatorSymbols = {
        "<": "lessthan",
        ">": "greaterthan",
        "<=": "lessthanorequal",
        ">=": "greaterthanorequal",
        "==": "equal",
        "!=": "notequal",
        "*=": "contains",
        "$=": "endswith",
        "^=": "startswith"
    };

    sf.data.odBiOperator = {
        "<": " lt ",
        ">": " gt ",
        "<=": " le ",
        ">=": " ge ",
        "==": " eq ",
        "!=": " ne ",
        "lessthan": " lt ",
        "lessthanorequal": " le ",
        "greaterthan": " gt ",
        "greaterthanorequal": " ge ",
        "equal": " eq ",
        "notequal": " ne ",
		"in":" eq ",
		"notin": " ne "
    };

    sf.data.odUniOperator = {
        "$=": "endswith",
        "^=": "startswith",
        "*=": "substringof",
        "endswith": "endswith",
        "startswith": "startswith",
        "contains": "substringof",
		"notcontains":"substringof"
    };
    sf.data.diacritics = {
        '\u24B6': 'A',
        '\uFF21': 'A',
        '\u00C0': 'A',
        '\u00C1': 'A',
        '\u00C2': 'A',
        '\u1EA6': 'A',
        '\u1EA4': 'A',
        '\u1EAA': 'A',
        '\u1EA8': 'A',
        '\u00C3': 'A',
        '\u0100': 'A',
        '\u0102': 'A',
        '\u1EB0': 'A',
        '\u1EAE': 'A',
        '\u1EB4': 'A',
        '\u1EB2': 'A',
        '\u0226': 'A',
        '\u01E0': 'A',
        '\u00C4': 'A',
        '\u01DE': 'A',
        '\u1EA2': 'A',
        '\u00C5': 'A',
        '\u01FA': 'A',
        '\u01CD': 'A',
        '\u0200': 'A',
        '\u0202': 'A',
        '\u1EA0': 'A',
        '\u1EAC': 'A',
        '\u1EB6': 'A',
        '\u1E00': 'A',
        '\u0104': 'A',
        '\u023A': 'A',
        '\u2C6F': 'A',
        '\uA732': 'AA',
        '\u00C6': 'AE',
        '\u01FC': 'AE',
        '\u01E2': 'AE',
        '\uA734': 'AO',
        '\uA736': 'AU',
        '\uA738': 'AV',
        '\uA73A': 'AV',
        '\uA73C': 'AY',
        '\u24B7': 'B',
        '\uFF22': 'B',
        '\u1E02': 'B',
        '\u1E04': 'B',
        '\u1E06': 'B',
        '\u0243': 'B',
        '\u0182': 'B',
        '\u0181': 'B',
        '\u24B8': 'C',
        '\uFF23': 'C',
        '\u0106': 'C',
        '\u0108': 'C',
        '\u010A': 'C',
        '\u010C': 'C',
        '\u00C7': 'C',
        '\u1E08': 'C',
        '\u0187': 'C',
        '\u023B': 'C',
        '\uA73E': 'C',
        '\u24B9': 'D',
        '\uFF24': 'D',
        '\u1E0A': 'D',
        '\u010E': 'D',
        '\u1E0C': 'D',
        '\u1E10': 'D',
        '\u1E12': 'D',
        '\u1E0E': 'D',
        '\u0110': 'D',
        '\u018B': 'D',
        '\u018A': 'D',
        '\u0189': 'D',
        '\uA779': 'D',
        '\u01F1': 'DZ',
        '\u01C4': 'DZ',
        '\u01F2': 'Dz',
        '\u01C5': 'Dz',
        '\u24BA': 'E',
        '\uFF25': 'E',
        '\u00C8': 'E',
        '\u00C9': 'E',
        '\u00CA': 'E',
        '\u1EC0': 'E',
        '\u1EBE': 'E',
        '\u1EC4': 'E',
        '\u1EC2': 'E',
        '\u1EBC': 'E',
        '\u0112': 'E',
        '\u1E14': 'E',
        '\u1E16': 'E',
        '\u0114': 'E',
        '\u0116': 'E',
        '\u00CB': 'E',
        '\u1EBA': 'E',
        '\u011A': 'E',
        '\u0204': 'E',
        '\u0206': 'E',
        '\u1EB8': 'E',
        '\u1EC6': 'E',
        '\u0228': 'E',
        '\u1E1C': 'E',
        '\u0118': 'E',
        '\u1E18': 'E',
        '\u1E1A': 'E',
        '\u0190': 'E',
        '\u018E': 'E',
        '\u24BB': 'F',
        '\uFF26': 'F',
        '\u1E1E': 'F',
        '\u0191': 'F',
        '\uA77B': 'F',
        '\u24BC': 'G',
        '\uFF27': 'G',
        '\u01F4': 'G',
        '\u011C': 'G',
        '\u1E20': 'G',
        '\u011E': 'G',
        '\u0120': 'G',
        '\u01E6': 'G',
        '\u0122': 'G',
        '\u01E4': 'G',
        '\u0193': 'G',
        '\uA7A0': 'G',
        '\uA77D': 'G',
        '\uA77E': 'G',
        '\u24BD': 'H',
        '\uFF28': 'H',
        '\u0124': 'H',
        '\u1E22': 'H',
        '\u1E26': 'H',
        '\u021E': 'H',
        '\u1E24': 'H',
        '\u1E28': 'H',
        '\u1E2A': 'H',
        '\u0126': 'H',
        '\u2C67': 'H',
        '\u2C75': 'H',
        '\uA78D': 'H',
        '\u24BE': 'I',
        '\uFF29': 'I',
        '\u00CC': 'I',
        '\u00CD': 'I',
        '\u00CE': 'I',
        '\u0128': 'I',
        '\u012A': 'I',
        '\u012C': 'I',
        '\u0130': 'I',
        '\u00CF': 'I',
        '\u1E2E': 'I',
        '\u1EC8': 'I',
        '\u01CF': 'I',
        '\u0208': 'I',
        '\u020A': 'I',
        '\u1ECA': 'I',
        '\u012E': 'I',
        '\u1E2C': 'I',
        '\u0197': 'I',
        '\u24BF': 'J',
        '\uFF2A': 'J',
        '\u0134': 'J',
        '\u0248': 'J',
        '\u24C0': 'K',
        '\uFF2B': 'K',
        '\u1E30': 'K',
        '\u01E8': 'K',
        '\u1E32': 'K',
        '\u0136': 'K',
        '\u1E34': 'K',
        '\u0198': 'K',
        '\u2C69': 'K',
        '\uA740': 'K',
        '\uA742': 'K',
        '\uA744': 'K',
        '\uA7A2': 'K',
        '\u24C1': 'L',
        '\uFF2C': 'L',
        '\u013F': 'L',
        '\u0139': 'L',
        '\u013D': 'L',
        '\u1E36': 'L',
        '\u1E38': 'L',
        '\u013B': 'L',
        '\u1E3C': 'L',
        '\u1E3A': 'L',
        '\u0141': 'L',
        '\u023D': 'L',
        '\u2C62': 'L',
        '\u2C60': 'L',
        '\uA748': 'L',
        '\uA746': 'L',
        '\uA780': 'L',
        '\u01C7': 'LJ',
        '\u01C8': 'Lj',
        '\u24C2': 'M',
        '\uFF2D': 'M',
        '\u1E3E': 'M',
        '\u1E40': 'M',
        '\u1E42': 'M',
        '\u2C6E': 'M',
        '\u019C': 'M',
        '\u24C3': 'N',
        '\uFF2E': 'N',
        '\u01F8': 'N',
        '\u0143': 'N',
        '\u00D1': 'N',
        '\u1E44': 'N',
        '\u0147': 'N',
        '\u1E46': 'N',
        '\u0145': 'N',
        '\u1E4A': 'N',
        '\u1E48': 'N',
        '\u0220': 'N',
        '\u019D': 'N',
        '\uA790': 'N',
        '\uA7A4': 'N',
        '\u01CA': 'NJ',
        '\u01CB': 'Nj',
        '\u24C4': 'O',
        '\uFF2F': 'O',
        '\u00D2': 'O',
        '\u00D3': 'O',
        '\u00D4': 'O',
        '\u1ED2': 'O',
        '\u1ED0': 'O',
        '\u1ED6': 'O',
        '\u1ED4': 'O',
        '\u00D5': 'O',
        '\u1E4C': 'O',
        '\u022C': 'O',
        '\u1E4E': 'O',
        '\u014C': 'O',
        '\u1E50': 'O',
        '\u1E52': 'O',
        '\u014E': 'O',
        '\u022E': 'O',
        '\u0230': 'O',
        '\u00D6': 'O',
        '\u022A': 'O',
        '\u1ECE': 'O',
        '\u0150': 'O',
        '\u01D1': 'O',
        '\u020C': 'O',
        '\u020E': 'O',
        '\u01A0': 'O',
        '\u1EDC': 'O',
        '\u1EDA': 'O',
        '\u1EE0': 'O',
        '\u1EDE': 'O',
        '\u1EE2': 'O',
        '\u1ECC': 'O',
        '\u1ED8': 'O',
        '\u01EA': 'O',
        '\u01EC': 'O',
        '\u00D8': 'O',
        '\u01FE': 'O',
        '\u0186': 'O',
        '\u019F': 'O',
        '\uA74A': 'O',
        '\uA74C': 'O',
        '\u01A2': 'OI',
        '\uA74E': 'OO',
        '\u0222': 'OU',
        '\u24C5': 'P',
        '\uFF30': 'P',
        '\u1E54': 'P',
        '\u1E56': 'P',
        '\u01A4': 'P',
        '\u2C63': 'P',
        '\uA750': 'P',
        '\uA752': 'P',
        '\uA754': 'P',
        '\u24C6': 'Q',
        '\uFF31': 'Q',
        '\uA756': 'Q',
        '\uA758': 'Q',
        '\u024A': 'Q',
        '\u24C7': 'R',
        '\uFF32': 'R',
        '\u0154': 'R',
        '\u1E58': 'R',
        '\u0158': 'R',
        '\u0210': 'R',
        '\u0212': 'R',
        '\u1E5A': 'R',
        '\u1E5C': 'R',
        '\u0156': 'R',
        '\u1E5E': 'R',
        '\u024C': 'R',
        '\u2C64': 'R',
        '\uA75A': 'R',
        '\uA7A6': 'R',
        '\uA782': 'R',
        '\u24C8': 'S',
        '\uFF33': 'S',
        '\u1E9E': 'S',
        '\u015A': 'S',
        '\u1E64': 'S',
        '\u015C': 'S',
        '\u1E60': 'S',
        '\u0160': 'S',
        '\u1E66': 'S',
        '\u1E62': 'S',
        '\u1E68': 'S',
        '\u0218': 'S',
        '\u015E': 'S',
        '\u2C7E': 'S',
        '\uA7A8': 'S',
        '\uA784': 'S',
        '\u24C9': 'T',
        '\uFF34': 'T',
        '\u1E6A': 'T',
        '\u0164': 'T',
        '\u1E6C': 'T',
        '\u021A': 'T',
        '\u0162': 'T',
        '\u1E70': 'T',
        '\u1E6E': 'T',
        '\u0166': 'T',
        '\u01AC': 'T',
        '\u01AE': 'T',
        '\u023E': 'T',
        '\uA786': 'T',
        '\uA728': 'TZ',
        '\u24CA': 'U',
        '\uFF35': 'U',
        '\u00D9': 'U',
        '\u00DA': 'U',
        '\u00DB': 'U',
        '\u0168': 'U',
        '\u1E78': 'U',
        '\u016A': 'U',
        '\u1E7A': 'U',
        '\u016C': 'U',
        '\u00DC': 'U',
        '\u01DB': 'U',
        '\u01D7': 'U',
        '\u01D5': 'U',
        '\u01D9': 'U',
        '\u1EE6': 'U',
        '\u016E': 'U',
        '\u0170': 'U',
        '\u01D3': 'U',
        '\u0214': 'U',
        '\u0216': 'U',
        '\u01AF': 'U',
        '\u1EEA': 'U',
        '\u1EE8': 'U',
        '\u1EEE': 'U',
        '\u1EEC': 'U',
        '\u1EF0': 'U',
        '\u1EE4': 'U',
        '\u1E72': 'U',
        '\u0172': 'U',
        '\u1E76': 'U',
        '\u1E74': 'U',
        '\u0244': 'U',
        '\u24CB': 'V',
        '\uFF36': 'V',
        '\u1E7C': 'V',
        '\u1E7E': 'V',
        '\u01B2': 'V',
        '\uA75E': 'V',
        '\u0245': 'V',
        '\uA760': 'VY',
        '\u24CC': 'W',
        '\uFF37': 'W',
        '\u1E80': 'W',
        '\u1E82': 'W',
        '\u0174': 'W',
        '\u1E86': 'W',
        '\u1E84': 'W',
        '\u1E88': 'W',
        '\u2C72': 'W',
        '\u24CD': 'X',
        '\uFF38': 'X',
        '\u1E8A': 'X',
        '\u1E8C': 'X',
        '\u24CE': 'Y',
        '\uFF39': 'Y',
        '\u1EF2': 'Y',
        '\u00DD': 'Y',
        '\u0176': 'Y',
        '\u1EF8': 'Y',
        '\u0232': 'Y',
        '\u1E8E': 'Y',
        '\u0178': 'Y',
        '\u1EF6': 'Y',
        '\u1EF4': 'Y',
        '\u01B3': 'Y',
        '\u024E': 'Y',
        '\u1EFE': 'Y',
        '\u24CF': 'Z',
        '\uFF3A': 'Z',
        '\u0179': 'Z',
        '\u1E90': 'Z',
        '\u017B': 'Z',
        '\u017D': 'Z',
        '\u1E92': 'Z',
        '\u1E94': 'Z',
        '\u01B5': 'Z',
        '\u0224': 'Z',
        '\u2C7F': 'Z',
        '\u2C6B': 'Z',
        '\uA762': 'Z',
        '\u24D0': 'a',
        '\uFF41': 'a',
        '\u1E9A': 'a',
        '\u00E0': 'a',
        '\u00E1': 'a',
        '\u00E2': 'a',
        '\u1EA7': 'a',
        '\u1EA5': 'a',
        '\u1EAB': 'a',
        '\u1EA9': 'a',
        '\u00E3': 'a',
        '\u0101': 'a',
        '\u0103': 'a',
        '\u1EB1': 'a',
        '\u1EAF': 'a',
        '\u1EB5': 'a',
        '\u1EB3': 'a',
        '\u0227': 'a',
        '\u01E1': 'a',
        '\u00E4': 'a',
        '\u01DF': 'a',
        '\u1EA3': 'a',
        '\u00E5': 'a',
        '\u01FB': 'a',
        '\u01CE': 'a',
        '\u0201': 'a',
        '\u0203': 'a',
        '\u1EA1': 'a',
        '\u1EAD': 'a',
        '\u1EB7': 'a',
        '\u1E01': 'a',
        '\u0105': 'a',
        '\u2C65': 'a',
        '\u0250': 'a',
        '\uA733': 'aa',
        '\u00E6': 'ae',
        '\u01FD': 'ae',
        '\u01E3': 'ae',
        '\uA735': 'ao',
        '\uA737': 'au',
        '\uA739': 'av',
        '\uA73B': 'av',
        '\uA73D': 'ay',
        '\u24D1': 'b',
        '\uFF42': 'b',
        '\u1E03': 'b',
        '\u1E05': 'b',
        '\u1E07': 'b',
        '\u0180': 'b',
        '\u0183': 'b',
        '\u0253': 'b',
        '\u24D2': 'c',
        '\uFF43': 'c',
        '\u0107': 'c',
        '\u0109': 'c',
        '\u010B': 'c',
        '\u010D': 'c',
        '\u00E7': 'c',
        '\u1E09': 'c',
        '\u0188': 'c',
        '\u023C': 'c',
        '\uA73F': 'c',
        '\u2184': 'c',
        '\u24D3': 'd',
        '\uFF44': 'd',
        '\u1E0B': 'd',
        '\u010F': 'd',
        '\u1E0D': 'd',
        '\u1E11': 'd',
        '\u1E13': 'd',
        '\u1E0F': 'd',
        '\u0111': 'd',
        '\u018C': 'd',
        '\u0256': 'd',
        '\u0257': 'd',
        '\uA77A': 'd',
        '\u01F3': 'dz',
        '\u01C6': 'dz',
        '\u24D4': 'e',
        '\uFF45': 'e',
        '\u00E8': 'e',
        '\u00E9': 'e',
        '\u00EA': 'e',
        '\u1EC1': 'e',
        '\u1EBF': 'e',
        '\u1EC5': 'e',
        '\u1EC3': 'e',
        '\u1EBD': 'e',
        '\u0113': 'e',
        '\u1E15': 'e',
        '\u1E17': 'e',
        '\u0115': 'e',
        '\u0117': 'e',
        '\u00EB': 'e',
        '\u1EBB': 'e',
        '\u011B': 'e',
        '\u0205': 'e',
        '\u0207': 'e',
        '\u1EB9': 'e',
        '\u1EC7': 'e',
        '\u0229': 'e',
        '\u1E1D': 'e',
        '\u0119': 'e',
        '\u1E19': 'e',
        '\u1E1B': 'e',
        '\u0247': 'e',
        '\u025B': 'e',
        '\u01DD': 'e',
        '\u24D5': 'f',
        '\uFF46': 'f',
        '\u1E1F': 'f',
        '\u0192': 'f',
        '\uA77C': 'f',
        '\u24D6': 'g',
        '\uFF47': 'g',
        '\u01F5': 'g',
        '\u011D': 'g',
        '\u1E21': 'g',
        '\u011F': 'g',
        '\u0121': 'g',
        '\u01E7': 'g',
        '\u0123': 'g',
        '\u01E5': 'g',
        '\u0260': 'g',
        '\uA7A1': 'g',
        '\u1D79': 'g',
        '\uA77F': 'g',
        '\u24D7': 'h',
        '\uFF48': 'h',
        '\u0125': 'h',
        '\u1E23': 'h',
        '\u1E27': 'h',
        '\u021F': 'h',
        '\u1E25': 'h',
        '\u1E29': 'h',
        '\u1E2B': 'h',
        '\u1E96': 'h',
        '\u0127': 'h',
        '\u2C68': 'h',
        '\u2C76': 'h',
        '\u0265': 'h',
        '\u0195': 'hv',
        '\u24D8': 'i',
        '\uFF49': 'i',
        '\u00EC': 'i',
        '\u00ED': 'i',
        '\u00EE': 'i',
        '\u0129': 'i',
        '\u012B': 'i',
        '\u012D': 'i',
        '\u00EF': 'i',
        '\u1E2F': 'i',
        '\u1EC9': 'i',
        '\u01D0': 'i',
        '\u0209': 'i',
        '\u020B': 'i',
        '\u1ECB': 'i',
        '\u012F': 'i',
        '\u1E2D': 'i',
        '\u0268': 'i',
        '\u0131': 'i',
        '\u24D9': 'j',
        '\uFF4A': 'j',
        '\u0135': 'j',
        '\u01F0': 'j',
        '\u0249': 'j',
        '\u24DA': 'k',
        '\uFF4B': 'k',
        '\u1E31': 'k',
        '\u01E9': 'k',
        '\u1E33': 'k',
        '\u0137': 'k',
        '\u1E35': 'k',
        '\u0199': 'k',
        '\u2C6A': 'k',
        '\uA741': 'k',
        '\uA743': 'k',
        '\uA745': 'k',
        '\uA7A3': 'k',
        '\u24DB': 'l',
        '\uFF4C': 'l',
        '\u0140': 'l',
        '\u013A': 'l',
        '\u013E': 'l',
        '\u1E37': 'l',
        '\u1E39': 'l',
        '\u013C': 'l',
        '\u1E3D': 'l',
        '\u1E3B': 'l',
        '\u017F': 'l',
        '\u0142': 'l',
        '\u019A': 'l',
        '\u026B': 'l',
        '\u2C61': 'l',
        '\uA749': 'l',
        '\uA781': 'l',
        '\uA747': 'l',
        '\u01C9': 'lj',
        '\u24DC': 'm',
        '\uFF4D': 'm',
        '\u1E3F': 'm',
        '\u1E41': 'm',
        '\u1E43': 'm',
        '\u0271': 'm',
        '\u026F': 'm',
        '\u24DD': 'n',
        '\uFF4E': 'n',
        '\u01F9': 'n',
        '\u0144': 'n',
        '\u00F1': 'n',
        '\u1E45': 'n',
        '\u0148': 'n',
        '\u1E47': 'n',
        '\u0146': 'n',
        '\u1E4B': 'n',
        '\u1E49': 'n',
        '\u019E': 'n',
        '\u0272': 'n',
        '\u0149': 'n',
        '\uA791': 'n',
        '\uA7A5': 'n',
        '\u01CC': 'nj',
        '\u24DE': 'o',
        '\uFF4F': 'o',
        '\u00F2': 'o',
        '\u00F3': 'o',
        '\u00F4': 'o',
        '\u1ED3': 'o',
        '\u1ED1': 'o',
        '\u1ED7': 'o',
        '\u1ED5': 'o',
        '\u00F5': 'o',
        '\u1E4D': 'o',
        '\u022D': 'o',
        '\u1E4F': 'o',
        '\u014D': 'o',
        '\u1E51': 'o',
        '\u1E53': 'o',
        '\u014F': 'o',
        '\u022F': 'o',
        '\u0231': 'o',
        '\u00F6': 'o',
        '\u022B': 'o',
        '\u1ECF': 'o',
        '\u0151': 'o',
        '\u01D2': 'o',
        '\u020D': 'o',
        '\u020F': 'o',
        '\u01A1': 'o',
        '\u1EDD': 'o',
        '\u1EDB': 'o',
        '\u1EE1': 'o',
        '\u1EDF': 'o',
        '\u1EE3': 'o',
        '\u1ECD': 'o',
        '\u1ED9': 'o',
        '\u01EB': 'o',
        '\u01ED': 'o',
        '\u00F8': 'o',
        '\u01FF': 'o',
        '\u0254': 'o',
        '\uA74B': 'o',
        '\uA74D': 'o',
        '\u0275': 'o',
        '\u01A3': 'oi',
        '\u0223': 'ou',
        '\uA74F': 'oo',
        '\u24DF': 'p',
        '\uFF50': 'p',
        '\u1E55': 'p',
        '\u1E57': 'p',
        '\u01A5': 'p',
        '\u1D7D': 'p',
        '\uA751': 'p',
        '\uA753': 'p',
        '\uA755': 'p',
        '\u24E0': 'q',
        '\uFF51': 'q',
        '\u024B': 'q',
        '\uA757': 'q',
        '\uA759': 'q',
        '\u24E1': 'r',
        '\uFF52': 'r',
        '\u0155': 'r',
        '\u1E59': 'r',
        '\u0159': 'r',
        '\u0211': 'r',
        '\u0213': 'r',
        '\u1E5B': 'r',
        '\u1E5D': 'r',
        '\u0157': 'r',
        '\u1E5F': 'r',
        '\u024D': 'r',
        '\u027D': 'r',
        '\uA75B': 'r',
        '\uA7A7': 'r',
        '\uA783': 'r',
        '\u24E2': 's',
        '\uFF53': 's',
        '\u00DF': 's',
        '\u015B': 's',
        '\u1E65': 's',
        '\u015D': 's',
        '\u1E61': 's',
        '\u0161': 's',
        '\u1E67': 's',
        '\u1E63': 's',
        '\u1E69': 's',
        '\u0219': 's',
        '\u015F': 's',
        '\u023F': 's',
        '\uA7A9': 's',
        '\uA785': 's',
        '\u1E9B': 's',
        '\u24E3': 't',
        '\uFF54': 't',
        '\u1E6B': 't',
        '\u1E97': 't',
        '\u0165': 't',
        '\u1E6D': 't',
        '\u021B': 't',
        '\u0163': 't',
        '\u1E71': 't',
        '\u1E6F': 't',
        '\u0167': 't',
        '\u01AD': 't',
        '\u0288': 't',
        '\u2C66': 't',
        '\uA787': 't',
        '\uA729': 'tz',
        '\u24E4': 'u',
        '\uFF55': 'u',
        '\u00F9': 'u',
        '\u00FA': 'u',
        '\u00FB': 'u',
        '\u0169': 'u',
        '\u1E79': 'u',
        '\u016B': 'u',
        '\u1E7B': 'u',
        '\u016D': 'u',
        '\u00FC': 'u',
        '\u01DC': 'u',
        '\u01D8': 'u',
        '\u01D6': 'u',
        '\u01DA': 'u',
        '\u1EE7': 'u',
        '\u016F': 'u',
        '\u0171': 'u',
        '\u01D4': 'u',
        '\u0215': 'u',
        '\u0217': 'u',
        '\u01B0': 'u',
        '\u1EEB': 'u',
        '\u1EE9': 'u',
        '\u1EEF': 'u',
        '\u1EED': 'u',
        '\u1EF1': 'u',
        '\u1EE5': 'u',
        '\u1E73': 'u',
        '\u0173': 'u',
        '\u1E77': 'u',
        '\u1E75': 'u',
        '\u0289': 'u',
        '\u24E5': 'v',
        '\uFF56': 'v',
        '\u1E7D': 'v',
        '\u1E7F': 'v',
        '\u028B': 'v',
        '\uA75F': 'v',
        '\u028C': 'v',
        '\uA761': 'vy',
        '\u24E6': 'w',
        '\uFF57': 'w',
        '\u1E81': 'w',
        '\u1E83': 'w',
        '\u0175': 'w',
        '\u1E87': 'w',
        '\u1E85': 'w',
        '\u1E98': 'w',
        '\u1E89': 'w',
        '\u2C73': 'w',
        '\u24E7': 'x',
        '\uFF58': 'x',
        '\u1E8B': 'x',
        '\u1E8D': 'x',
        '\u24E8': 'y',
        '\uFF59': 'y',
        '\u1EF3': 'y',
        '\u00FD': 'y',
        '\u0177': 'y',
        '\u1EF9': 'y',
        '\u0233': 'y',
        '\u1E8F': 'y',
        '\u00FF': 'y',
        '\u1EF7': 'y',
        '\u1E99': 'y',
        '\u1EF5': 'y',
        '\u01B4': 'y',
        '\u024F': 'y',
        '\u1EFF': 'y',
        '\u24E9': 'z',
        '\uFF5A': 'z',
        '\u017A': 'z',
        '\u1E91': 'z',
        '\u017C': 'z',
        '\u017E': 'z',
        '\u1E93': 'z',
        '\u1E95': 'z',
        '\u01B6': 'z',
        '\u0225': 'z',
        '\u0240': 'z',
        '\u2C6C': 'z',
        '\uA763': 'z',
        '\u0386': '\u0391',
        '\u0388': '\u0395',
        '\u0389': '\u0397',
        '\u038A': '\u0399',
        '\u03AA': '\u0399',
        '\u038C': '\u039F',
        '\u038E': '\u03A5',
        '\u03AB': '\u03A5',
        '\u038F': '\u03A9',
        '\u03AC': '\u03B1',
        '\u03AD': '\u03B5',
        '\u03AE': '\u03B7',
        '\u03AF': '\u03B9',
        '\u03CA': '\u03B9',
        '\u0390': '\u03B9',
        '\u03CC': '\u03BF',
        '\u03CD': '\u03C5',
        '\u03CB': '\u03C5',
        '\u03B0': '\u03C5',
        '\u03C9': '\u03C9',
        '\u03C2': '\u03C3'
    };


    sf.data.fnOperators = {
        equal: function (actual, expected, ignoreCase,ignoreAccent) {
            if (ignoreAccent) {
                actual = sf.pvt.ignoreDiacritics(actual);
                expected = sf.pvt.ignoreDiacritics(expected);
            }
            if (ignoreCase)
                return toLowerCase(actual) == toLowerCase(expected);

            return actual == expected;
        },
        notequal: function (actual, expected, ignoreCase,ignoreAccent) {
            if (ignoreAccent) {
                actual = sf.pvt.ignoreDiacritics(actual);
                expected = sf.pvt.ignoreDiacritics(expected);
            }
            return !sf.data.fnOperators.equal(actual, expected, ignoreCase);
        },
		notin: function (actual, expected, ignoreCase) {
			for(var i = 0; i < expected.length; i++) 
				if(sf.data.fnOperators.notequal(actual, expected[i], ignoreCase) == false) return false;
            return true;
        },
        lessthan: function (actual, expected, ignoreCase) {
            if (ignoreCase)
                return toLowerCase(actual) < toLowerCase(expected);

            return actual < expected;
        },
        greaterthan: function (actual, expected, ignoreCase) {
            if (ignoreCase)
                return toLowerCase(actual) > toLowerCase(expected);

            return actual > expected;
        },
        lessthanorequal: function (actual, expected, ignoreCase) {
            if (ignoreCase)
                return toLowerCase(actual) <= toLowerCase(expected);

            return actual <= expected;
        },
        greaterthanorequal: function (actual, expected, ignoreCase) {
            if (ignoreCase)
                return toLowerCase(actual) >= toLowerCase(expected);

            return actual >= expected;
        },
        contains: function (actual, expected, ignoreCase,ignoreAccent) {
            if (ignoreAccent) {
                actual = sf.pvt.ignoreDiacritics(actual);
                expected = sf.pvt.ignoreDiacritics(expected);
            }
            if (ignoreCase)
                return !isNull(actual) && !isNull(expected) && toLowerCase(actual).indexOf(toLowerCase(expected)) != -1;

            return !isNull(actual) && !isNull(expected) && actual.toString().indexOf(expected) != -1;
        },
		notcontains: function (actual, expected, ignoreCase,ignoreAccent) {
            if (ignoreAccent) {
                actual = sf.pvt.ignoreDiacritics(actual);
                expected = sf.pvt.ignoreDiacritics(expected);
            }
			 return !sf.data.fnOperators.contains(actual, expected, ignoreCase);
		},
        notnull: function (actual) {
            return actual !== null;
        },
        isnull: function (actual) {
            return actual === null;
        },
        startswith: function (actual, expected, ignoreCase,ignoreAccent) {
            if (ignoreAccent) {
                actual = sf.pvt.ignoreDiacritics(actual);
                expected = sf.pvt.ignoreDiacritics(expected);
            }
            if (ignoreCase)
                return actual && expected && toLowerCase(actual).startsWith(toLowerCase(expected));

            return actual && expected && actual.startsWith(expected);
        },
        endswith: function (actual, expected, ignoreCase,ignoreAccent) {
            if (ignoreAccent) {
                actual = sf.pvt.ignoreDiacritics(actual);
                expected = sf.pvt.ignoreDiacritics(expected);
            }
            if (ignoreCase)
                return actual && expected && toLowerCase(actual).endsWith(toLowerCase(expected));

            return actual && expected && actual.endsWith(expected);
        },
		all: function (actual, expected, ignoreCase ) {
			for(var i = 0; i < expected.length; i++)
				if (sf.data.fnOperators[this.operator](actual, expected[i], ignoreCase) == false) return false;
            return true;
		},
		any: function (actual, expected, ignoreCase ) {
			for(var i = 0; i < expected.length; i++)
				if (sf.data.fnOperators[this.operator](actual, expected[i], ignoreCase) == true) return true;
            return false;
		},
        processSymbols: function (operator) {
            var fnName = sf.data.operatorSymbols[operator];
            if (fnName) {
                var fn = sf.data.fnOperators[fnName];
                if (fn) return fn;
            }

            return throwError("Query - Process Operator : Invalid operator");
        },

        processOperator: function (operator) {
            var fn = sf.data.fnOperators[operator];
            if (fn) return fn;
            return sf.data.fnOperators.processSymbols(operator);
        }
    };

    sf.data.fnOperators["in"] = function (actual, expected, ignoreCase) {
        for(var i = 0; i < expected.length; i++)
            if (sf.data.fnOperators.equal(actual, expected[i], ignoreCase) == true) return true;
        return false;
    };

    sf.NotifierArray = function (array) {
        if (!instance(this, sf.NotifierArray))
            return new sf.NotifierArray(array);

        this.array = array;

        this._events = $({});
        this._isDirty = false;

        return this;
    };

    sf.NotifierArray.prototype = {
        on: function (eventName, handler) {
            this._events.on(eventName, handler);
        },
        off: function (eventName, handler) {
            this._events.off(eventName, handler);
        },
        push: function (item) {
            var ret;

            if (instance(item, Array))
                ret = [].push.apply(this.array, item);
            else
                ret = this.array.push(item);

            this._raise("add", { item: item, index: this.length() - 1 });

            return ret;
        },
        pop: function () {
            var ret = this.array.pop();

            this._raise("remove", { item: ret, index: this.length() - 1 });

            return ret;
        },
        addAt: function (index, item) {
            this.array.splice(index, 0, item);

            this._raise("add", { item: item, index: index });

            return item;
        },
        removeAt: function (index) {
            var ret = this.array.splice(index, 1)[0];

            this._raise("remove", { item: ret, index: index });

            return ret;
        },
        remove: function (item) {
            var index = this.array.indexOf(item);

            if (index > -1) {
                this.array.splice(index, 1);
                this._raise("remove", { item: item, index: index });
            }

            return index;
        },
        length: function () {
            return this.array.length;
        },
        _raise: function (e, args) {
            this._events.triggerHandler($.extend({ type: e }, args));
            this._events.triggerHandler({ type: "all", name: e, args: args });
        },
        toArray: function () {
            return this.array;
        }
    };

    $.extend(sf, sf.dataUtil);

    // For IE8
    Array.prototype.forEach = Array.prototype.forEach || function (fn, scope) {
        for (var i = 0, len = this.length; i < len; ++i) {
            fn.call(scope, this[i], i, this);
        }
    };

    Array.prototype.indexOf = Array.prototype.indexOf || function (searchElement) {
        var len = this.length;

        if (len === 0) return -1;

        for (var i = 0; i < len; i++) {
            if (i in this && this[i] === searchElement)
                return i;
        }
        return -1;
    };

    Array.prototype.filter = Array.prototype.filter || function (fn) {
        if (typeof fn != "function")
            throw new TypeError();

        var res = [];
        var thisp = arguments[1] || this;
        for (var i = 0; i < this.length; i++) {
            var val = this[i]; // in case fun mutates this
            if (fn.call(thisp, val, i, this))
                res.push(val);
        }

        return res;
    };

    String.prototype.endsWith = String.prototype.endsWith || function (key) {
        return this.slice(-key.length) === key;
    };

    String.prototype.startsWith = String.prototype.startsWith || function (key) {
        return this.slice(0, key.length) === key;
    };

    if (!sf.support) sf.support = {};
    sf.support.stableSort = function () {
        var res = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16].sort(function () { return 0; });
		for(var i = 0; i < 17; i++){
		    if(i !== res[i]) return false;
		}
        return true;
    }();
    sf.support.cors = $.support.cors;

    if (!$.support.cors && window.XDomainRequest) {
        var httpRegEx = /^https?:\/\//i;
        var getOrPostRegEx = /^get|post$/i;
        var sameSchemeRegEx = new RegExp('^' + location.protocol, 'i');
        var xmlRegEx = /\/xml/i;

        // ajaxTransport exists in jQuery 1.5+
        $.ajaxTransport('text html xml json', function (options, userOptions, jqXHR) {
            // XDomainRequests must be: asynchronous, GET or POST methods, HTTP or HTTPS protocol, and same scheme as calling page
            if (options.crossDomain && options.async && getOrPostRegEx.test(options.type) && httpRegEx.test(userOptions.url) && sameSchemeRegEx.test(userOptions.url)) {
                var xdr = null;
                var userType = (userOptions.dataType || '').toLowerCase();
                return {
                    send: function (headers, complete) {
                        xdr = new XDomainRequest();
                        if (/^\d+$/.test(userOptions.timeout)) {
                            xdr.timeout = userOptions.timeout;
                        }
                        xdr.ontimeout = function () {
                            complete(500, 'timeout');
                        };
                        xdr.onload = function () {
                            var allResponseHeaders = 'Content-Length: ' + xdr.responseText.length + '\r\nContent-Type: ' + xdr.contentType;
                            var status = {
                                code: 200,
                                message: 'success'
                            };
                            var responses = {
                                text: xdr.responseText
                            };

                            try {
                                if (userType === 'json') {
                                    try {
                                        responses.json = JSON.parse(xdr.responseText);
                                    } catch (e) {
                                        status.code = 500;
                                        status.message = 'parseerror';
                                        //throw 'Invalid JSON: ' + xdr.responseText;
                                    }
                                } else if ((userType === 'xml') || ((userType !== 'text') && xmlRegEx.test(xdr.contentType))) {
                                    var doc = new ActiveXObject('Microsoft.XMLDOM');
                                    doc.async = false;
                                    try {
                                        doc.loadXML(xdr.responseText);
                                    } catch (e) {
                                        doc = undefined;
                                    }
                                    if (!doc || !doc.documentElement || doc.getElementsByTagName('parsererror').length) {
                                        status.code = 500;
                                        status.message = 'parseerror';
                                        throw 'Invalid XML: ' + xdr.responseText;
                                    }
                                    responses.xml = doc;
                                }
                            } catch (parseMessage) {
                                throw parseMessage;
                            } finally {
                                complete(status.code, status.message, responses, allResponseHeaders);
                            }
                        };
                        xdr.onerror = function () {
                            complete(500, 'error', {
                                text: xdr.responseText
                            });
                        };
						if(navigator.userAgent.indexOf("MSIE 9.0") != -1)
							xdr.onprogress = function() {};
                        xdr.open(options.type, options.url);
                        xdr.send(userOptions.data);
                        //xdr.send();
                    },
                    abort: function () {
                        if (xdr) {
                            xdr.abort();
                        }
                    }
                };
            }
        });
    }

    $.support.cors = true;

    sf.sortOrder = {
        Ascending: "ascending",
        Descending: "descending"
    };

    // privates
    sf.pvt.consts = {
        GROUPGUID: "{271bbba0-1ee7}",
        complexPropertyMerge: "_"
    };

    // private utils
    var nextTick = function (fn, context) {
        if (context) fn = $proxy(fn, context);
        (window.setImmediate || window.setTimeout)(fn, 0);
    };

    sf.support.enableLocalizedSort = false;

    var stableSort = function (ds, field, comparer, queries) {
        if (sf.support.stableSort) {
            if(!sf.support.enableLocalizedSort && typeof sf.pvt.getObject(field, ds[0] || {}) == "string" 
                && (comparer === sf.pvt.fnAscending || comparer === sf.pvt.fnDescending)
                && queries.filter(function(e){return e.fn === "onSortBy";}).length === 1)
                return fastSort(ds, field, comparer === sf.pvt.fnDescending);
            return ds.sort(sf.pvt.fnGetComparer(field, comparer));
        }
        return sf.mergeSort(ds, field, comparer);
    };
    var getColFormat = function (field, query) {
        var grpQuery = $.grep(query, function (args) { return args.fn == "onGroup" });
        for (var grp = 0; grp < grpQuery.length; grp++) {
            if (sf.getObject("fieldName", grpQuery[grp].e) == field) {
                return sf.getObject("fn", grpQuery[grp].e);
            }
        }
    };
    var fastSort = function(ds, field, isDesc){
        var old = Object.prototype.toString;
        Object.prototype.toString = (field.indexOf('.') === -1) ? function(){
            return this[field];
        }:function(){
            return sf.pvt.getObject(field, this);
        };
        ds = ds.sort();
        Object.prototype.toString = old;
        if(isDesc)
            ds.reverse();
    }

    var toLowerCase = function (val) {
        return val ? val.toLowerCase ? val.toLowerCase() : val.toString().toLowerCase() : (val === 0 || val === false) ? val.toString() : "";
    };

    var getVal = function (array, field, index) {
        return field ? sf.pvt.getObject(field, array[index]) : array[index];
    };

    var isHtmlElement = function (e) {
        return typeof HTMLElement === "object" ? e instanceof HTMLElement :
            e && e.nodeType === 1 && typeof e === "object" && typeof e.nodeName === "string";
    };

    var instance = function (obj, element) {
        return obj instanceof element;
    };

    var getTableModel = function (name, result, dm, computed) {
        return function (tName) {
            if (typeof tName === "object") {
                computed = tName;
                tName = null;
            }
            return new sf.TableModel(tName || name, result, dm, computed);
        };
    };

    var getKnockoutModel = function (result) {
        return function (computedObservables, ko) {
            ko = ko || window.ko;

            if (!ko) throwError("Knockout is undefined");

            var model, koModels = [], prop, ob;
            for (var i = 0; i < result.length; i++) {
                model = {};
                for (prop in result[i]) {
                    if (!prop.startsWith("_"))
                        model[prop] = ko.observable(result[i][prop]);
                }
                for (prop in computedObservables) {
                    ob = computedObservables[prop];

                    if ($.isPlainObject(ob)) {
                        if (!ob.owner) ob.owner = model;
                        ob = ko.computed(ob);
                    } else
                        ob = ko.computed(ob, model);

                    model[prop] = ob;
                }
                koModels.push(model);
            }

            return ko.observableArray(koModels);
        };
    };

    var uidIndex = 0;
    var getUid = function (prefix) {
        uidIndex += 1;
        return prefix + uidIndex;
    };

    sf.getGuid = function (prefix) {
        var hexs = '0123456789abcdef', rand;
        return (prefix || "") + '00000000-0000-4000-0000-000000000000'.replace(/0/g, function (val, i) {
            if ("crypto" in window && "getRandomValues" in crypto) {
                var arr = new Uint8Array(1)
                window.crypto.getRandomValues(arr);
                rand = arr[0] % 16|0
            }
            else rand = Math.random() * 16 | 0;
            return hexs[i === 19 ? rand & 0x3 | 0x8 : rand];
        });
    };

    var proxy = function (fn, context) {
        return function () {
            var args = [].slice.call(arguments, 0);
            args.push(this);

            return fn.apply(context || this, args);
        };
    };

    var $proxy = function (fn, context, arg) {
        if ('bind' in fn)
            return arg ? fn.bind(context, arg) : fn.bind(context);

        return function () {
            var args = arg ? [arg] : []; args.push.apply(args, arguments);
            return fn.apply(context || this, args);
        };
    };

    sf.merge = function (first, second) {
        if (!first || !second) return;

        Array.prototype.push.apply(first, second);
    };

    var isNull = function (val) {
        return val === undefined || val === null;
    };

    var throwError = function (er) {
        try {
            throw new Error(er);
        } catch (e) {
            throw e.message + "\n" + e.stack;
        }
    };

})(window.jQuery, window.Sfusion, window.document);;
(function($, undefined){
    
sf.globalize = {};
sf.cultures = {};

sf.cultures['default'] = sf.cultures['en-US'] = $.extend(true, {
    name: 'en-US',
    englishName: "English",
    nativeName: "English",
    language: 'en',
    isRTL: false,
    numberFormat: {
        pattern: ["-n"],
        decimals: 2,
        ',': ",",
        '.': ".",
        groupSizes: [3],
        '+': "+",
        '-': "-",
        percent: {
            pattern: ["-n %", "n %"],
            decimals: 2,
            groupSizes: [3],
            ',': ",",
            '.': ".",
            symbol: '%'
        },
        currency: {
            pattern: ["($n)", "$n"],
            decimals: 2,
            groupSizes: [3],
            ',': ",",
            '.': ".",
            symbol: '$'
        }
    },
    calendars: {
    	standard: {
	        '/': '/',
	        ':': ':',
	        firstDay: 0,
			week:{
			name:"Week",
			nameAbbr:"Wek",
			nameShort:"Wk"
			},
	        days: {
	            names: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	            namesAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	            namesShort: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
	        },
	        months: {
	            names: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""],
	            namesAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""]
	        },
	        AM: ['AM', 'am', 'AM'],
	        PM: ['PM', 'pm', 'PM'],
            twoDigitYearMax: 2029,
	        patterns: {
                d: "M/d/yyyy",
                D: "dddd, MMMM dd, yyyy",
                t: "h:mm tt",
                T: "h:mm:ss tt",
                f: "dddd, MMMM dd, yyyy h:mm tt",
                F: "dddd, MMMM dd, yyyy h:mm:ss tt",
                M: "MMMM dd",
                Y: "yyyy MMMM",
                S: "yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss"

	        }
    	}
    }
}, sf.cultures['en-US']);

sf.cultures['en-US'].calendar = sf.cultures['en-US'].calendar || sf.cultures['en-US'].calendars.standard; 



// *************************************** Numbers ***************************************
var regexTrim = /^\s+|\s+$/g,
    regexInfinity = /^[+-]?infinity$/i,
    regexHex = /^0x[a-f0-9]+$/i,
	regexExpo = /[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)/,
    regexParseFloat = /^[+-]?\d*\.?\d*(e[+-]?\d+)?$/;
var charMap =  {
                '9': "[0-9 ]",
				'0': "[0-9 ]",
                'a': "[A-Za-z0-9 ]",
                'A': "[A-Za-z0-9]",
                'N': "[0-9]",
                '#': "[0-9]",
                '&': '[^\x7f]+',
                '<': "",
                '>': "",
                'C': "[A-Za-z ]",
                '?': "[A-Za-z]",
            };

function  formatMapper (format, value) {
    var mask = format || "", rules = charMap, value = value.toString(), isDecimal = value.indexOf(".") > -1 || format.indexOf(".") > -1, diff = 0, stIdx = 0, preFormat = "", escFormat = "",
		separator = format.split(","), newChar = "0", expValue, exponentIdx = format.toLowerCase().indexOf("e"), valueColl, formatColl, hashIdx = mask.indexOf("#");
	if(format.indexOf("\\") > -1) {
		escFormat = format.substr(0, format.lastIndexOf("\\") + 1);
		format = format.substr(format.lastIndexOf("\\") + 1, format.length);
		hashIdx = format.indexOf("#");
	}
	if(exponentIdx > -1) {
		var maskFirst = "", mask = "";
		formatColl = format.toLowerCase().split("e");
		expValue = format.indexOf("+") > -1 ? format.split("+")[1] : format.split("-")[1];
		value = parseInt(value).toExponential();
		valueColl = value.split("e");
		diff = formatColl[1].length - valueColl[1].length;
		for(var k = formatColl[1].length - 1; k > 0; k--) {
			if(formatColl[1][k] != "0")
				mask += formatColl[1][k];
			else if(diff > 1) {
				mask += "#";
				diff--;
			}
			else
				mask += "0";
		}
		var oprMask = (format.indexOf("+") > -1) ? "+" : "";
		mask = oprMask + mask.split("").reverse().join("");
		for(var k = 0; k < valueColl[0].length; k++)
			maskFirst = (valueColl[0][k] != ".") ? maskFirst.concat("#") : maskFirst.concat(".");
		if(maskFirst.length > formatColl[0].length)
			maskFirst = formatColl[0];
		mask = escFormat + maskFirst + "e" + mask;
	}
	else if(isDecimal) {
		formatColl = format.split(".");
		valueColl = value.split(".");
		formatColl[1] = formatColl[1].replace(/[,.]/g, "");
		diff = formatColl[0].replace(/[,.]/g, "").length - valueColl[0].replace(/[,.]/g, "").length;
		if(diff < 0 && sf.isNullOrUndefined(format.match(/[\[\(\)\]]/g))) {
			separator = formatColl[0].split(",");
			preFormat = formatColl[0].split(",")
			for(var j = separator.length - 1;j >= 0; j--) {
				if(separator[j]) {
					var cnt = separator[j].length;
					for(var k = 0, len = Math.abs(diff); k < len; k++) {
						if(cnt === 3) {
							break;
							cnt = 0;
						}
						preFormat[j] = "0" + preFormat[j];
						cnt++;
						diff++;
					}
				}
			}
			preFormat = preFormat.join();
			if(diff < 0) {
				(!sf.isNullOrUndefined(cnt) && cnt != 3) && (preFormat = "," + preFormat);
				for(var k = 0, len = Math.abs(diff); k < len; k++) {
					if(cnt === 3) {
						preFormat = "," + preFormat;
						cnt = 0;
					}
					preFormat = "0" + preFormat;
					cnt++;
				}
			}
			diff = 0;
			mask = escFormat + preFormat + "." + formatColl[1];
		}
		else if(sf.isNullOrUndefined(format.match(/[\[\(\)\]]/g))){
			preFormat = formatColl[0].replace(/[,.]/g, "");
			var postFormat = "";
			var cnt = 0;
			for(var i = preFormat.length - 1; i >= 0; i--) {
				if(cnt === 3) {
					postFormat = "," + postFormat;
					cnt = 0;
				}
				else
					cnt++;
				postFormat = preFormat[i] + postFormat;
			}
			mask = escFormat + postFormat + "." + formatColl[1];
		}
	}
	else {
		var hashCount = 0, separatorColl = separator.splice(1, separator.length);
		diff = format.replace(/[,.\[\(\]\)]/g, "").length - value.replace(/[,.]/g, "").length;
		if(hashIdx > -1) {
			for(var f = 0, len = format.length; f < len; f++)
				(format[f] === "#") && hashCount++;
			if(hashCount === 1 || (separator[1] && hashCount === 2))
				newChar = "#";
			(hashCount === 1) && (separatorColl = separator[0]);
		}
		if(diff < 0) {
			formatColl = mask.split(",");
			preFormat = formatColl.splice(1, formatColl.length);	
			for(var j = separator.length - 1;j >= 0; j--) {
				if(separatorColl[j]) {
					var cnt = separatorColl[j].length;
					!preFormat[j] && (preFormat[j] = "");
					for(var k = 0, len = Math.abs(diff) + 1; k < len; k++) {
						if(hashCount != 1 && cnt === 3) {
							cnt = 0;
							break;
						}
						preFormat[j] = preFormat[j].concat(newChar);
						cnt++;
						diff++;
					}
				}
			}
			preFormat = preFormat.join();
			if(diff < 0) {
				(!sf.isNullOrUndefined(cnt) && cnt != 3) && (preFormat = "," + preFormat);
				for(var k = 0, len = Math.abs(diff) + 1; k < len; k++) {
					if(hashCount != 1 && cnt === 3) {
						preFormat = "," + preFormat;
						cnt = 0;
					}
					preFormat = newChar + preFormat;
					cnt++;
				}
			}
			diff = 0;
			mask = escFormat + preFormat;
		}
		stIdx = 0;
	}
	var mapper = [], maskChars = mask.split(""), mapperIdx = 0, i = 0, idx = 0, chr, rule, isEscChar = false, isExp = false, escIdx = format.indexOf("\\");
    for (; i < mask.length; i++) {
        chr = maskChars[i];
		if(chr === "e")
			isExp = true;
        if((chr === "0" && hashIdx < 0)) {
			if((diff > 0 && stIdx <= i)) {
				diff--;
				stIdx++;
			}
			else if(diff > 0)
				diff--;
			else
				rule = rules[chr];
		}
		else if(chr != "0" || (!isExp && chr == "0")) 
			rule = rules[chr];
		if(chr === "0" && escIdx > -1) 
			rule = rules[chr];
		if(i === mask.lastIndexOf("\\"))
			isEscChar = false;
        if (rule && !isEscChar) {
            mapper[mapperIdx] = { rule: rule };
            mapperIdx += 1;
        } else {
            if (chr === "\\") {
                chr = "";
				!(i === mask.lastIndexOf("\\")) && (isEscChar = true);
            }
            chr = chr.split("");
            for (var j = 0; j < chr.length; j++) {
                mapper[mapperIdx] = chr[j];
                mapperIdx += 1;
            }
        }
    }
    rules = mapper;
	return {"rules": rules, "format": mask};
}

function customFormat(value, format, locale) {
	if(sf.isNullOrUndefined(value) || typeof value === "string" || !format)
		throw "Bad Number Format Exception";
	var formatLength, formatObj, formatModel, rules, orgFormat = format;
	formatObj = formatMapper(format, value);
	rules = formatObj.rules;
	format = formatObj.format;
    if (!(format.indexOf("\\") >= 0))
        formatModel = format.replace(/[9?CANa#&]/g, '_');
    else {
		var escIdx = format.lastIndexOf("\\"), first = format.slice(0, escIdx), second = format.slice(escIdx + 1, format.length), altFormat;
		second = second.replace(/[9?CANa#&]/g, '_');
		altFormat = first + second;
        formatModel = altFormat.replace(/[\\]/g, "");
		format = format.replace(/[\\]/g, "");
	}
    formatModel = changeCulture(formatModel, locale);
    return validateValue(value, format, formatModel, rules, locale, orgFormat);
}

function changeCulture(formatModel, locale) {
	if (formatModel.length != 0) {
        var preferredlocale = sf.preferredCulture(locale), groupSep, currecySymbol, decimalSep,unmask = "";
        groupSep = preferredlocale.numberFormat[','];
        currecySymbol = preferredlocale.numberFormat.currency.symbol;
        decimalSep = preferredlocale.numberFormat['.'];
        for (var i = 0; i < formatModel.length; i++) {
            if (formatModel[i] == ",")
                unmask += groupSep;
            else if (formatModel[i] == ".")
                unmask += decimalSep;
            else if (formatModel[i] == "$")
                unmask += currecySymbol;
            else
                unmask += formatModel[i];
        }
        formatModel = unmask;
    }
	return formatModel;
}

function validateValue(value, format, formatModel, rules, locale, orgFormat) {
	if(sf.isNullOrUndefined(value))
		return;
	if(format.toLowerCase().indexOf("e") > -1) {
		var expValue = orgFormat.indexOf("+") > -1 ? orgFormat.split("+")[1] : orgFormat.split("-")[1];
		value = value.toExponential();
		(orgFormat.indexOf("-") > -1) && (value = value.replace("+", "")); 
    }
    var oldvalue, replacestring, i, tvalue;
	var tempValue = oldvalue = replacestring = value.toString(), tempModel = formatModel, maskIndex = i = 0, chr, prompt = "_", rule,
		strBefore, strAfter, charValue, isBracket = format.match(/[\(\[\]\)]/g);
    if (!format.indexOf("\\") >= 0)
        tempValue = value = replacestring.replace(/[\(\)-]/g, "");
    else
        tempValue = tvalue;
	var j = rules.length - 1;
	var v = oldvalue.length - 1;
	if(!sf.isNullOrUndefined(isBracket)) {
		while (j >= 0) {
			chr = oldvalue[v];
			rule = rules[j];
			if (chr == undefined) break;
			if (chr === rule || chr === prompt || (chr === "e" && (chr === rule.toLowerCase()))) {
				chr === prompt ? prompt : "";
				strBefore = tempModel.substring(0, j+1);
				strAfter = tempModel.substring(j+1);
				chr = changeCulture(chr, locale);
				tempModel = strBefore.substr(0, strBefore.length - 1)  + chr + strAfter;
				j--;
				v--;
			}
			else if (rules[j].rule != undefined ) {
				var charCode = oldvalue.charCodeAt(v);
				if (validateChars(format, charCode, j)) {
					strBefore = tempModel.substring(0, j +1);
					strAfter = tempModel.substring(j+1);
					charValue = getRoundValue(oldvalue, v, j, format, formatModel);
					tempModel = strBefore.substr(0, strBefore.length - 1) + charValue + strAfter;
					j--;
					v--;
				} else 
					j--;
			} 
			else
				j--;
			if (i > tempValue.length || j<0) break;
		}
	}
	else {
		while (maskIndex < rules.length) {
			chr = oldvalue[i];
			rule = rules[maskIndex];
			if (chr == undefined) break;
			if (chr === rule || chr === prompt || (chr === "e" && (chr === rule.toLowerCase()))) {
				chr === prompt ? prompt : "";
				strBefore = tempModel.substring(0, maskIndex);
				strAfter = tempModel.substring(maskIndex);
				chr = changeCulture(chr, locale);
				tempModel = strBefore + chr + strAfter.substr(1, strAfter.length);
				i += 1;
				maskIndex += 1;
			}
			else if (rules[maskIndex].rule != undefined ) {
				var charCode = oldvalue.charCodeAt(i);
				if (validateChars(format, charCode, maskIndex)) {
					strBefore = tempModel.substring(0, maskIndex);
					strAfter = tempModel.substring(maskIndex);
					charValue = getRoundValue(oldvalue, i, maskIndex, format, formatModel);
					tempModel = strBefore + charValue + strAfter.substr(1, strAfter.length);
					maskIndex++;
					i++;
				} else
					maskIndex++;
			} 
			else {
				if(rule === "e")
					i = oldvalue.indexOf("e") + 1;
				maskIndex++;
			}
			if (i > tempValue.length || j<0) break;
		}
	}
    if (value) {
		if((tempModel.indexOf("_") - tempModel.indexOf(",") === 1) || (tempModel.indexOf("_") - tempModel.indexOf(".") === 1))
			tempModel = tempModel.slice(0, tempModel.indexOf("_")-1);
        var strippedValue = $.trim(tempModel.replace(/[_]/g, "")) == "" ? null : tempModel.replace(/[_]/g, "");
		return strippedValue;
	}
}

function validateChars (format, keyChar, caretPos){
	var charmap = charMap, match = false, maskChar = format.substr(caretPos, 1), actualkey = String.fromCharCode(keyChar);
    $.each(charmap, function (key, value) {
        if (maskChar == key) {
            if (actualkey.match(new RegExp(value))) match = true;
                else match = false;
        }
    });
    return match;
}

function getRoundValue(value, valIdx, maskIndex, format, formatModel) {
	var isCeil = false;
	if(format.indexOf(".") > -1 && (maskIndex === formatModel.length - 1))
		(value[valIdx + 1] > 5) && (isCeil = true);
	return (isCeil ? (parseInt(value[valIdx]) + 1).toString() : value[valIdx]);
}

function patternStartsWith(value, pattern) {
    return value.indexOf( pattern ) === 0;
}

function patternEndsWith(value, pattern) {
    return value.substr( value.length - pattern.length ) === pattern;
}

function trim(value) {
    return (value+"").replace( regexTrim, "" );
}

function truncate(value){
    if(isNaN(value))
        return NaN;
    
    return Math[value < 0 ? "ceil" : "floor"](value);
}

function padWithZero(str, count, left) {
    for (var l = str.length; l < count; l++) {
        str = (left ? ('0' + str) : (str + '0'));
    }
    return str;
}

function parseNumberWithNegativePattern(value, nf, negativePattern) {
    var neg = nf["-"],
        pos = nf["+"],
        ret;
    switch (negativePattern) {
        case "n -":
            neg = ' ' + neg;
            pos = ' ' + pos;
            // fall through
        case "n-":
            if ( patternEndsWith( value, neg ) ) {
                ret = [ '-', value.substr( 0, value.length - neg.length ) ];
            }
            else if ( patternEndsWith( value, pos ) ) {
                ret = [ '+', value.substr( 0, value.length - pos.length ) ];
            }
            break;
        case "- n":
            neg += ' ';
            pos += ' ';
            // fall through
        case "-n":
            if ( patternStartsWith( value, neg ) ) {
                ret = [ '-', value.substr( neg.length ) ];
            }
            else if ( patternStartsWith(value, pos) ) {
                ret = [ '+', value.substr( pos.length ) ];
            }
            break;
        case "(n)":
            if ( patternStartsWith( value, '(' ) && patternEndsWith( value, ')' ) ) {
                ret = [ '-', value.substr( 1, value.length - 2 ) ];
            }
            break;
    }
    return ret || [ '', value ];
}

function getFullNumber(number, precision, formatInfo) {
    var groupSizes = formatInfo.groupSizes || [3],
        curSize = groupSizes[0],
        curGroupIndex = 1,
        rounded = sf._round(number, precision);
    if (!isFinite(rounded)) {
        rounded = number;
    }
    number = rounded;

    var numberString = number + "",
        right = "",
        split = numberString.split(/e/i),
        exponent = split.length > 1 ? parseInt(split[1], 10) : 0;
    numberString = split[0];
    split = numberString.split(".");
    numberString = split[0];
    right = split.length > 1 ? split[1] : "";

    var l;
    if (exponent > 0) {
        right = padWithZero(right, exponent, false);
        numberString += right.slice(0, exponent);
        right = right.substr(exponent);
    } else if (exponent < 0) {
        exponent = -exponent;
        numberString = padWithZero(numberString, exponent + 1, true);
        right = numberString.slice(-exponent, numberString.length) + right;
        numberString = numberString.slice(0, -exponent);
    }

    var dot = formatInfo['.'] || '.';
    if (precision > 0) {
        right = dot +
            ((right.length > precision) ? right.slice(0, precision) : padWithZero(right, precision));
    } else {
        right = "";
    }

    var stringIndex = numberString.length - 1,
        sep = formatInfo[","] || ',',
        ret = "";

    while (stringIndex >= 0) {
        if (curSize === 0 || curSize > stringIndex) {
            return numberString.slice(0, stringIndex + 1) + (ret.length ? (sep + ret + right) : right);
        }
        ret = numberString.slice(stringIndex - curSize + 1, stringIndex + 1) + (ret.length ? (sep + ret) : "");

        stringIndex -= curSize;

        if (curGroupIndex < groupSizes.length) {
            curSize = groupSizes[curGroupIndex];
            curGroupIndex++;
        }
    }
    return numberString.slice(0, stringIndex + 1) + sep + ret + right;
}

function formatNumberToCulture(value, format, culture) {
    if (!format || format === 'i') {
        return culture.name.length ? value.toLocaleString() : value.toString();
    }
    format = format || "D";

    var nf = culture.numberFormat,
        number = Math.abs(value),
        precision = -1,
        pattern;

    if (format.length > 1) precision = parseInt(format.slice(1), 10);

    var current = format.charAt(0).toUpperCase(),
        formatInfo;

    switch (current) {
        case 'D':
            pattern = 'n';
            number = truncate(number);
            if (precision !== -1) {
                number = padWithZero("" + number, precision, true);
            }
            if (value < 0) number = -number;
            break;
        case 'N':
            formatInfo = nf;
            formatInfo.pattern = formatInfo.pattern || ['-n'];
            // fall through
        case 'C':
            formatInfo = formatInfo || nf.currency;
            formatInfo.pattern = formatInfo.pattern || ['-$n', '$n'];
            // fall through
        case 'P':
            formatInfo = formatInfo || nf.percent;
            formatInfo.pattern = formatInfo.pattern || ['-n %', 'n %'];
            pattern = value < 0 ? (formatInfo.pattern[0] || "-n") : (formatInfo.pattern[1] || "n");
            if (precision === -1) precision = formatInfo.decimals;
            number = getFullNumber(number * (current === "P" ? 100 : 1), precision, formatInfo);
            break;
        default:
			return customFormat(value, format, culture);
    }

    return matchNumberToPattern(number, pattern, nf);
}



function matchNumberToPattern(number, pattern, nf){
    var patternParts = /n|\$|-|%/g,
        ret = "";
    for (;;) {
        var index = patternParts.lastIndex,
            ar = patternParts.exec(pattern);

        ret += pattern.slice(index, ar ? ar.index : pattern.length);

        if (!ar) {
            break;
        }

        switch (ar[0]) {
            case "n":
                ret += number;
                break;
            case "$":
                ret += nf.currency.symbol || "$";
                break;
            case "-":
                // don't make 0 negative
                if (/[1-9]/.test(number)) {
                    ret += nf["-"] || "-";
                }
                break;
            case "%":
                ret += nf.percent.symbol || "%";
                break;
        }
    }

    return ret;
}

function parseValue(value, culture, radix ) {
		// make radix optional
    if (typeof radix === "string") {
        culture = radix;
        radix = 10;
    }
    culture = sf.globalize.findCulture(culture);
    var ret = NaN, nf = culture.numberFormat, npattern = culture.numberFormat.pattern[0];
    value = value.replace(/ /g, '');
    if (value.indexOf(culture.numberFormat.currency.symbol) > -1) {
        // remove currency symbol
        value = value.replace(culture.numberFormat.currency.symbol || "$", "");
        // replace decimal seperator
        value = value.replace(culture.numberFormat.currency["."] || ".", culture.numberFormat["."] || ".");
        // pattern of the currency
        npattern = trim(culture.numberFormat.currency.pattern[0].replace("$", ""));
    } else if (value.indexOf(culture.numberFormat.percent.symbol) > -1) {
        // remove percentage symbol
        value = value.replace(culture.numberFormat.percent.symbol || "%", "");
        // replace decimal seperator
        value = value.replace(culture.numberFormat.percent["."] || ".", culture.numberFormat["."] || ".");
        // pattern of the percent
        npattern = trim(culture.numberFormat.percent.pattern[0].replace("%", ""));
    }

    // trim leading and trailing whitespace
    value = trim( value );

    // allow infinity or hexidecimal
    if (regexInfinity.test(value)) {
        ret = parseFloat(value, "" ,radix);
    }
    else if (regexHex.test(value)) {
        ret = parseInt(value, 16);
    }
    else {
        var signInfo = parseNumberWithNegativePattern( value, nf, npattern ),
            sign = signInfo[0],
            num = signInfo[1];
        // determine sign and number
        if ( sign === "" && nf.pattern[0] !== "-n" ) {
            signInfo = parseNumberWithNegativePattern( value, nf, "-n" );
            sign = signInfo[0];
            num = signInfo[1];
        }
        sign = sign || "+";
        // determine exponent and number
        var exponent,
            intAndFraction,exponentPos = -1;
		if(regexExpo.test(num))
		{
           exponentPos = num.indexOf( 'e' );
        if ( exponentPos < 0 ) exponentPos = num.indexOf( 'E' );
		}
        if ( exponentPos < 0 ) {
            intAndFraction = num;
            exponent = null;
        }
        else {
            intAndFraction = num.substr( 0, exponentPos );
            exponent = num.substr( exponentPos + 1 );
        }
        // determine decimal position
        var integer,
            fraction,
            decSep = nf['.'] || '.',
            decimalPos = intAndFraction.indexOf( decSep );
        if ( decimalPos < 0 ) {
            integer = intAndFraction;
            fraction = null;
        }
        else {
            integer = intAndFraction.substr( 0, decimalPos );
            fraction = intAndFraction.substr( decimalPos + decSep.length );
        }
        // handle groups (e.g. 1,000,000)
        var groupSep = nf[","] || ",";
        integer = integer.split(groupSep).join('');
        var altGroupSep = groupSep.replace(/\u00A0/g, " ");
        if ( groupSep !== altGroupSep ) {
            integer = integer.split(altGroupSep).join('');
        }
        // build a natively parsable number string
        var p = sign + integer;
        if ( fraction !== null ) {
            p += '.' + fraction;
        }
        if ( exponent !== null ) {
            // exponent itself may have a number patternd
            var expSignInfo = parseNumberWithNegativePattern( exponent, nf, npattern );
            p += 'e' + (expSignInfo[0] || "+") + expSignInfo[1];
        }
        if ( !radix && regexParseFloat.test( p ) ) {
            ret = parseFloat( p );
        }
		else if(radix)
			ret = parseInt(p, radix);
    }
    return ret;
}

// *************************************** Dates ***************************************

var dateFormat = {
    DAY_OF_WEEK_THREE_LETTER : "ddd",
    DAY_OF_WEEK_FULL_NAME : "dddd",
    DAY_OF_MONTH_SINGLE_DIGIT : "d",
    DAY_OF_MONTH_DOUBLE_DIGIT : "dd",
    MONTH_THREE_LETTER : "MMM",
    MONTH_FULL_NAME : "MMMM",
    MONTH_SINGLE_DIGIT : "M",
    MONTH_DOUBLE_DIGIT : "MM",
    YEAR_SINGLE_DIGIT : "y",
    YEAR_DOUBLE_DIGIT : "yy",
    YEAR_FULL : "yyyy",
    HOURS_SINGLE_DIGIT_12_HOUR_CLOCK : "h",
    HOURS_DOUBLE_DIGIT_12_HOUR_CLOCK : "hh",
    HOURS_SINGLE_DIGIT_24_HOUR_CLOCK : "H",
    HOURS_DOUBLE_DIGIT_24_HOUR_CLOCK : "HH",
    MINUTES_SINGLE_DIGIT : "m",
    MINUTES_DOUBLE_DIGIT : "mm",
    SECONDS_SINGLE_DIGIT : "s",
    SECONDS_DOUBLE_DIGIT : "ss",
    MERIDIAN_INDICATOR_SINGLE : "t",
    MERIDIAN_INDICATOR_FULL : "tt",
    DECISECONDS : "f",
    CENTISECONDS: "ff",
    MILLISECONDS : "fff",
    TIME_ZONE_OFFSET_SINGLE_DIGIT : "z",
    TIME_ZONE_OFFSET_DOUBLE_DIGIT : "zz",
    TIME_ZONE_OFFSET_FULL : "zzz",
    DATE_SEPARATOR : "/"
};

function valueOutOfRange(value, low, high) {
    return value < low || value > high;
}

function expandYear(cal, year) {
    // expands 2-digit year into 4 digits.
    var now = new Date();
    if ( year < 100 ) {
        var twoDigitYearMax = cal.twoDigitYearMax;
        twoDigitYearMax = typeof twoDigitYearMax === 'string' ? new Date().getFullYear() % 100 + parseInt( twoDigitYearMax, 10 ) : twoDigitYearMax;
        var curr = now.getFullYear();
        year += curr - ( curr % 100 );
        if ( year > twoDigitYearMax ) {
            year -= 100;
        }
    }
    return year;
}

function arrayIndexOf( array, item ) {
    if ( array.indexOf ) {
        return array.indexOf( item );
    }
    for ( var i = 0, length = array.length; i < length; i++ ) {
        if ( array[ i ] === item ) return i;
    }
    return -1;
}

function toUpper(value) {
    // 'he-IL' has non-breaking space in weekday names.
    return value.split( "\u00A0" ).join(' ').toUpperCase();
}

function toUpperArray(arr) {
    var results = [];
    for ( var i = 0, l = arr.length; i < l; i++ ) {
        results[i] = toUpper(arr[i]);
    }
    return results;
}

function getIndexOfDay(cal, value, abbr) {
    var ret,
        days = cal.days,
        upperDays = cal._upperDays;
    if ( !upperDays ) {
        cal._upperDays = upperDays = [
            toUpperArray( days.names ),
            toUpperArray( days.namesAbbr ),
            toUpperArray( days.namesShort )
        ];
    }
    value = toUpper( value );
    if ( abbr ) {
        ret = arrayIndexOf( upperDays[ 1 ], value );
        if ( ret === -1 ) {
            ret = arrayIndexOf( upperDays[ 2 ], value );
        }
    }
    else {
        ret = arrayIndexOf( upperDays[ 0 ], value );
    }
    return ret;
}

function getIndexOfMonth(cal, value, abbr) {
    var months = cal.months,
        monthsGen = cal.monthsGenitive || cal.months,
        upperMonths = cal._upperMonths,
        upperMonthsGen = cal._upperMonthsGen;
    if ( !upperMonths ) {
        cal._upperMonths = upperMonths = [
            toUpperArray( months.names ),
            toUpperArray( months.namesAbbr )
        ];
        cal._upperMonthsGen = upperMonthsGen = [
            toUpperArray( monthsGen.names ),
            toUpperArray( monthsGen.namesAbbr )
        ];
    }
    value = toUpper( value );
    var i = arrayIndexOf( abbr ? upperMonths[ 1 ] : upperMonths[ 0 ], value );
    if ( i < 0 ) {
        i = arrayIndexOf( abbr ? upperMonthsGen[ 1 ] : upperMonthsGen[ 0 ], value );
    }
    return i;
}

function appendMatchStringCount(preMatch, strings) {
    var quoteCount = 0,
        escaped = false;
    for ( var i = 0, il = preMatch.length; i < il; i++ ) {
        var c = preMatch.charAt( i );
        if(c == '\''){
            escaped ? strings.push( "'" ) : quoteCount++;
            escaped = false;
        } else if( c == '\\'){
            if (escaped) strings.push( "\\" );
            escaped = !escaped;
        } else {
            strings.push( c );
            escaped = false;
        }
    }
    return quoteCount;
}


function parseDayByInt(value, format, culture, cal) {
    if (!value) {
        return null;
    }
    var index = 0, valueX = 0, day = null;
    format = format.split("");
    var length = format.length;
    var countDays = function (match) {
        var i = 0;
        while (format[index] === match) {
            i++;
            index++;
        }
        if (i > 0) {
            index -= 1;
        }
        return i;
    },
    getNumber = function (size) {
        var rg = new RegExp('^\\d{1,' + size + '}'),
            match = value.substr(valueX, size).match(rg);

        if (match) {
            match = match[0];
            valueX += match.length;
            return parseInt(match, 10);
        }
        return null;
    },
    getName = function (names, lower) {
        var i = 0,
            length = names.length,
            name, nameLength,
            subValue;

        for (; i < length; i++) {
            name = names[i];
            nameLength = name.length;
            subValue = value.substr(valueX, nameLength);

            if (lower) {
                subValue = subValue.toLowerCase();
            }

            if (subValue == name) {
                valueX += nameLength;
                return i + 1;
            }
        }
        return null;
    },
     lowerArray = function (data) {
         var index = 0,
             length = data.length,
             array = [];

         for (; index < length; index++) {
             array[index] = (data[index] + "").toLowerCase();
         }

         return array;
     },
     lowerInfo = function (localInfo) {
         var newLocalInfo = {}, property;

         for (property in localInfo) {
             newLocalInfo[property] = lowerArray(localInfo[property]);
         }

         return newLocalInfo;
     };
    for (; index < length; index++) {
        var ch = format[index];
        if (ch === "d") {
            var count = countDays("d");
            if (!cal._lowerDays) {
                cal._lowerDays = lowerInfo(cal.days);
            }
            day = count < 3 ? getNumber(2) : getName(cal._lowerDays[count == 3 ? "namesAbbr" : "names"], true)
        }
    }
    return day;
}


function getFullDateFormat(cal, format) {
    // expands unspecified or single character date formats into the full pattern.
    format = format || "F";
    var pattern,
        patterns = cal.patterns,
        len = format.length;
    if ( len === 1 ) {
        pattern = patterns[ format ];
        if ( !pattern ) {
            throw "Invalid date format string '" + format + "'.";
        }
        format = pattern;
    }
    else if ( len === 2  && format.charAt(0) === "%" ) {
        // %X escape format -- intended as a custom format string that is only one character, not a built-in format.
        format = format.charAt( 1 );
    }
    return format;
}

sf.globalize._getDateParseRegExp = function (cal, format) {
    // converts a format string into a regular expression with groups that
    // can be used to extract date fields from a date string.
    // check for a cached parse regex.
    var re = cal._parseRegExp;
    if ( !re ) {
        cal._parseRegExp = re = {};
    }
    else {
        var reFormat = re[ format ];
        if ( reFormat ) {
            return reFormat;
        }
    }

    // expand single digit formats, then escape regular expression characters.
    var expFormat = getFullDateFormat( cal, format ).replace( /([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\\\$1" ),
        regexp = ["^"],
        groups = [],
        index = 0,
        quoteCount = 0,
        tokenRegExp = /\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g,
        match;

    // iterate through each date token found.
    while ( (match = tokenRegExp.exec( expFormat )) !== null ) {
        var preMatch = expFormat.slice( index, match.index );
        index = tokenRegExp.lastIndex;

        // don't replace any matches that occur inside a string literal.
        quoteCount += appendMatchStringCount( preMatch, regexp );
        if ( quoteCount % 2 ) {
            regexp.push( match[ 0 ] );
            continue;
        }

        // add a regex group for the token.
        var m = match[ 0 ],
            len = m.length,
            add;
            
        switch ( m ) {
            case dateFormat.DAY_OF_WEEK_THREE_LETTER: case dateFormat.DAY_OF_WEEK_FULL_NAME:
            case dateFormat.MONTH_FULL_NAME: case dateFormat.MONTH_THREE_LETTER:
                add = "(\\D+)";
                break;
            case dateFormat.MERIDIAN_INDICATOR_FULL: case dateFormat.MERIDIAN_INDICATOR_SINGLE:
                add = "(\\D*)";
                break;
            case dateFormat.YEAR_FULL:
            case dateFormat.MILLISECONDS:
            case dateFormat.CENTISECONDS:
            case dateFormat.DECISECONDS:
                add = "(\\d{" + len + "})";
                break;
            case dateFormat.DAY_OF_MONTH_DOUBLE_DIGIT: case dateFormat.DAY_OF_MONTH_SINGLE_DIGIT:
            case dateFormat.MONTH_DOUBLE_DIGIT: case dateFormat.MONTH_SINGLE_DIGIT:
            case dateFormat.YEAR_DOUBLE_DIGIT: case dateFormat.YEAR_SINGLE_DIGIT:
            case dateFormat.HOURS_DOUBLE_DIGIT_24_HOUR_CLOCK: case dateFormat.HOURS_SINGLE_DIGIT_24_HOUR_CLOCK:
            case dateFormat.HOURS_DOUBLE_DIGIT_12_HOUR_CLOCK: case dateFormat.HOURS_SINGLE_DIGIT_12_HOUR_CLOCK:
            case dateFormat.MINUTES_DOUBLE_DIGIT: case dateFormat.MINUTES_SINGLE_DIGIT:
            case dateFormat.SECONDS_DOUBLE_DIGIT: case dateFormat.SECONDS_SINGLE_DIGIT:
                add = "(\\d\\d?)";
                break;
            case dateFormat.TIME_ZONE_OFFSET_FULL:
                add = "([+-]?\\d\\d?:\\d{2})";
                break;
            case dateFormat.TIME_ZONE_OFFSET_DOUBLE_DIGIT: case dateFormat.TIME_ZONE_OFFSET_SINGLE_DIGIT:
                add = "([+-]?\\d\\d?)";
                break;
            case dateFormat.DATE_SEPARATOR:
                add = "(\\" + cal["/"] + ")";
                break;
            default:
                throw "Invalid date format pattern '" + m + "'.";
                break;
        }
        if ( add ) {
            regexp.push( add );
        }
        groups.push( match[ 0 ] );
    }
    appendMatchStringCount( expFormat.slice( index ), regexp );
    regexp.push( "$" );

    // allow whitespace to differ when matching formats.
    var regexpStr = regexp.join( '' ).replace( /\s+/g, "\\s+" ),
        parseRegExp = {'regExp': regexpStr, 'groups': groups};

    // cache the regex for this format.
    return re[ format ] = parseRegExp;
}

function getParsedDate(value, format, culture) {
    // try to parse the date string by matching against the format string
    // while using the specified culture for date field names.
    value = trim( value );
    format = trim(format);
    var cal = culture.calendar,
        // convert date formats into regular expressions with groupings.
        parseInfo = sf.globalize._getDateParseRegExp(cal, format),
        match = new RegExp(parseInfo.regExp).exec(value);
        if (match === null) 
	   {   
          formats = [];
          var idx = 0;
		  isArray = $.isArray;
		  numRegExp = /^(\+|-?)\d+(\.?)\d*$/,
		  formats.push(format);
		  formats = isArray(formats) ? formats: [formats];
          length = formats.length;
          
		  for (; idx < length; idx++) {
            date = parseExact(value, formats[idx], culture);
            if (date) {
                return date;
            }
        }
		 
		 return date || null;
	}
	
    // found a date format that matches the input.
    var groups = parseInfo.groups,
        year = null, month = null, date = null, weekDay = null,
        hour = 0, hourOffset, min = 0, sec = 0, msec = 0, tzMinOffset = null,
        pmHour = false;
    // iterate the format groups to extract and set the date fields.
    for ( var j = 0, jl = groups.length; j < jl; j++ ) {
        var matchGroup = match[ j + 1 ];
        if ( matchGroup ) {
            var current = groups[ j ],
                clength = current.length,
                matchInt = parseInt( matchGroup, 10 );
            
            switch ( current ) {
                case dateFormat.DAY_OF_MONTH_DOUBLE_DIGIT: case dateFormat.DAY_OF_MONTH_SINGLE_DIGIT:
                    date = matchInt;
                    if ( valueOutOfRange( date, 1, 31 ) ) return null;
                    break;
                case dateFormat.MONTH_THREE_LETTER:
                case dateFormat.MONTH_FULL_NAME:
                    month = getIndexOfMonth( cal, matchGroup, clength === 3 );
                    if ( valueOutOfRange( month, 0, 11 ) ) return null;
                    break;
                case dateFormat.MONTH_SINGLE_DIGIT: case dateFormat.MONTH_DOUBLE_DIGIT:
                    month = matchInt - 1;
                    if ( valueOutOfRange( month, 0, 11 ) ) return null;
                    break;
                case dateFormat.YEAR_SINGLE_DIGIT: case dateFormat.YEAR_DOUBLE_DIGIT:
                case dateFormat.YEAR_FULL:
                    year = clength < 4 ? expandYear( cal, matchInt ) : matchInt;
                    if ( valueOutOfRange( year, 0, 9999 ) ) return null;
                    break;
                case dateFormat.HOURS_SINGLE_DIGIT_12_HOUR_CLOCK: case dateFormat.HOURS_DOUBLE_DIGIT_12_HOUR_CLOCK:
                    hour = matchInt;
                    if ( hour === 12 ) hour = 0;
                    if ( valueOutOfRange( hour, 0, 11 ) ) return null;
                    break;
                case dateFormat.HOURS_SINGLE_DIGIT_24_HOUR_CLOCK: case dateFormat.HOURS_DOUBLE_DIGIT_24_HOUR_CLOCK:
                    hour = matchInt;
                    if ( valueOutOfRange( hour, 0, 23 ) ) return null;
                    break;
                case dateFormat.MINUTES_SINGLE_DIGIT: case dateFormat.MINUTES_DOUBLE_DIGIT:
                    min = matchInt;
                    if ( valueOutOfRange( min, 0, 59 ) ) return null;
                    break;
                case dateFormat.SECONDS_SINGLE_DIGIT: case dateFormat.SECONDS_DOUBLE_DIGIT:
                    sec = matchInt;
                    if ( valueOutOfRange( sec, 0, 59 ) ) return null;
                    break;
                case dateFormat.MERIDIAN_INDICATOR_FULL: case dateFormat.MERIDIAN_INDICATOR_SINGLE:
                    pmHour = cal.PM && ( matchGroup === cal.PM[0] || matchGroup === cal.PM[1] || matchGroup === cal.PM[2] );
                    if ( !pmHour && ( !cal.AM || (matchGroup !== cal.AM[0] && matchGroup !== cal.AM[1] && matchGroup !== cal.AM[2]) ) ) return null;
                    break;
                case dateFormat.DECISECONDS:
                case dateFormat.CENTISECONDS:
                case dateFormat.MILLISECONDS:
                    msec = matchInt * Math.pow( 10, 3-clength );
                    if ( valueOutOfRange( msec, 0, 999 ) ) return null;
                    break;
                case dateFormat.DAY_OF_WEEK_THREE_LETTER:
                    date = parseDayByInt(value, format, culture, cal);
                    break;
                case dateFormat.DAY_OF_WEEK_FULL_NAME:
                     getIndexOfDay( cal, matchGroup, clength === 3 );
                    if ( valueOutOfRange( weekDay, 0, 6 ) ) return null;
                    break;
                case dateFormat.TIME_ZONE_OFFSET_FULL:
                    var offsets = matchGroup.split( /:/ );
                    if ( offsets.length !== 2 ) return null;

                    hourOffset = parseInt( offsets[ 0 ], 10 );
                    if ( valueOutOfRange( hourOffset, -12, 13 ) ) return null;
                    
                    var minOffset = parseInt( offsets[ 1 ], 10 );
                    if ( valueOutOfRange( minOffset, 0, 59 ) ) return null;
                    
                    tzMinOffset = (hourOffset * 60) + (patternStartsWith( matchGroup, '-' ) ? -minOffset : minOffset);
                    break;
                case dateFormat.TIME_ZONE_OFFSET_SINGLE_DIGIT: case dateFormat.TIME_ZONE_OFFSET_DOUBLE_DIGIT:
                    // Time zone offset in +/- hours.
                    hourOffset = matchInt;
                    if ( valueOutOfRange( hourOffset, -12, 13 ) ) return null;
                    tzMinOffset = hourOffset * 60;
                    break;
            }
        }
    }
    var result = new Date(), defaultYear, convert = cal.convert;
    defaultYear = convert ? convert.fromGregorian( result )[ 0 ] : result.getFullYear();
    if ( year === null ) {
        year = defaultYear;
    }
    
    // set default day and month to 1 and January, so if unspecified, these are the defaults
    // instead of the current day/month.
    if ( month === null ) {
        month = 0;
    }
    if ( date === null ) {
        date = 1;
    }
    // now have year, month, and date, but in the culture's calendar.
    if ( convert ) {
        result = convert.toGregorian( year, month, date );
        if ( result === null ) return null;
    }
    else {
        // have to set year, month and date together to avoid overflow based on current date.
        result.setFullYear( year, month, date );
        // check to see if date overflowed for specified month (only checked 1-31 above).
        if ( result.getDate() !== date ) return null;
        // invalid day of week.
        if ( weekDay !== null && result.getDay() !== weekDay ) {
            return null;
        }
    }
    // if pm designator token was found make sure the hours fit the 24-hour clock.
    if ( pmHour && hour < 12 ) {
        hour += 12;
    }
    result.setHours( hour, min, sec, msec );
    if ( tzMinOffset !== null ) {
        var adjustedMin = result.getMinutes() - ( tzMinOffset + result.getTimezoneOffset() );
        result.setHours( result.getHours() + parseInt( adjustedMin / 60, 10 ), adjustedMin % 60 );
    }
    return result;
}
 function lowerArray(data) {
        var idx = 0,
            length = data.length,
            array = [];

        for (; idx < length; idx++) {
            array[idx] = (data[idx] + "").toLowerCase();
        }

        return array;
    }

    function LocalInfo(localInfo) {
        var newLocalInfo = {}, property;

        for (property in localInfo) {
            newLocalInfo[property] = lowerArray(localInfo[property]);
        }

        return newLocalInfo;
    }
 function parseExact(value, format, culture) {
        if (!value) {
            return null;
        }

        var charCount = function (match) {
                var i = 0;
                while (format[idx] === match) {
                    i++;
                    idx++;
                }
                if (i > 0) {
                    idx -= 1;
                }
                return i;
            },
            getNumber = function(size) {
                var rg = numRegExp[size] || new RegExp('^\\d{1,' + size + '}'),
                    match = value.substr(valueIdx, size).match(rg);

                if (match) {
                    match = match[0];
                    valueIdx += match.length;
                    return parseInt(match, 10);
                }
                return null;
            },
            getIndexByName = function (names, lower) {
                var i = 0,
                    length = names.length,
                    name, nameLength,
                    subValue;

                for (; i < length; i++) {
                    name = names[i];
                    nameLength = name.length;
                    subValue = value.substr(valueIdx, nameLength);

                    if (lower) {
                        subValue = subValue.toLowerCase();
                    }

                    if (subValue == name) {
                        valueIdx += nameLength;
                        return i + 1;
                    }
                }
                return null;
            },
            checkLiteral = function() {
                var result = false;
                if (value.charAt(valueIdx) === format[idx]) {
                    valueIdx++;
                    result = true;
                }
                return result;
            },
            calendar = culture.calendars.standard,
            year = null,
            month = null,
            day = null,
            hours = null,
            minutes = null,
            seconds = null,
            milliseconds = null,
            idx = 0,
            valueIdx = 0,
            literal = false,
            date = new Date(),
            twoDigitYearMax = calendar.twoDigitYearMax || 2029,
            defaultYear = date.getFullYear(),
            ch, count, length, pattern,
            pmHour, UTC, ISO8601, matches,
            amDesignators, pmDesignators,
            hoursOffset, minutesOffset,
            hasTime;

        if (!format) {
            format = "d"; //shord date format
        }

        //if format is part of the patterns get real format
        pattern = calendar.patterns[format];
        if (pattern) {
            format = pattern;
        }

        format = format.split("");
        length = format.length;

        for (; idx < length; idx++) {
            ch = format[idx];

            if (literal) {
                if (ch === "'") {
                    literal = false;
                } else {
                    checkLiteral();
                }
            } else {
                if (ch === "d") {
                    count = charCount("d");
                    if (!calendar._lowerDays) {
                        calendar._lowerDays = LocalInfo(calendar.days);
                    }

                    day = count < 3 ? getNumber(2) : getIndexByName(calendar._lowerDays[count == 3 ? "namesAbbr" : "names"], true);

                    if (day === null || outOfRange(day, 1, 31)) {
                        return null;
                    }
                } else if (ch === "M") {
                    count = charCount("M");
                    if (!calendar._lowerMonths) {
                        calendar._lowerMonths = LocalInfo(calendar.months);
                    }
                    month = count < 3 ? getNumber(2) : getIndexByName(calendar._lowerMonths[count == 3 ? 'namesAbbr' : 'names'], true);

                    if (month === null || outOfRange(month, 1, 12)) {
                        return null;
                    }
                    month -= 1; //because month is zero based
                } else if (ch === "y") {
                    count = charCount("y");
                    year = getNumber(count);

                    if (year === null) {
                        return null;
                    }

                    if (count == 2) {
                        if (typeof twoDigitYearMax === "string") {
                            twoDigitYearMax = defaultYear + parseInt(twoDigitYearMax, 10);
                        }

                        year = (defaultYear - defaultYear % 100) + year;
                        if (year > twoDigitYearMax) {
                            year -= 100;
                        }
                    }
                } else if (ch === "h" ) {
                    charCount("h");
                    hours = getNumber(2);
                    if (hours == 12) {
                        hours = 0;
                    }
                    if (hours === null || outOfRange(hours, 0, 11)) {
                        return null;
                    }
                } else if (ch === "H") {
                    charCount("H");
                    hours = getNumber(2);
                    if (hours === null || outOfRange(hours, 0, 23)) {
                        return null;
                    }
                } else if (ch === "m") {
                    charCount("m");
                    minutes = getNumber(2);
                    if (minutes === null || outOfRange(minutes, 0, 59)) {
                        return null;
                    }
                } else if (ch === "s") {
                    charCount("s");
                    seconds = getNumber(2);
                    if (seconds === null || outOfRange(seconds, 0, 59)) {
                        return null;
                    }
                } else if (ch === "f") {
                    count = charCount("f");
                    milliseconds = getNumber(count);

                    if (milliseconds !== null && count > 3) {
                        milliseconds = parseInt(milliseconds.toString().substring(0, 3), 10);
                    }

                    if (milliseconds === null || outOfRange(milliseconds, 0, 999)) {
                        return null;
                    }

                } else if (ch === "t") {
                    count = charCount("t");
                    amDesignators = calendar.AM;
                    pmDesignators = calendar.PM;

                    if (count === 1) {
                        amDesignators = mapDesignators(amDesignators);
                        pmDesignators = mapDesignators(pmDesignators);
                    }

                    pmHour = getIndexByName(pmDesignators);
                    if (!pmHour && !getIndexByName(amDesignators)) {
                        return null;
                    }
                }
                else if (ch === "z") {
                    UTC = true;
                    count = charCount("z");

                    if (value.substr(valueIdx, 1) === "Z") {
                        if (!ISO8601) {
                            return null;
                        }

                        checkLiteral();
                        continue;
                    }

                    matches = value.substr(valueIdx, 6)
                                   .match(count > 2 ? longTimeZoneRegExp : shortTimeZoneRegExp);

                    if (!matches) {
                        return null;
                    }

                    matches = matches[0];
                    valueIdx = matches.length;
                    matches = matches.split(":");

                    hoursOffset = parseInt(matches[0], 10);
                    if (outOfRange(hoursOffset, -12, 13)) {
                        return null;
                    }

                    if (count > 2) {
                        minutesOffset = parseInt(matches[1], 10);
                        if (isNaN(minutesOffset) || outOfRange(minutesOffset, 0, 59)) {
                            return null;
                        }
                    }
                } else if (ch === "T") {
                    ISO8601 = checkLiteral();
                } else if (ch === "'") {
                    literal = true;
                    checkLiteral();
                } else if (!checkLiteral()) {
                    return null;
                }
            }
        }

        hasTime = hours !== null || minutes !== null || seconds || null;

        if (year === null && month === null && day === null && hasTime) {
            year = defaultYear;
            month = date.getMonth();
            day = date.getDate();
        } else {
            if (year === null) {
                year = defaultYear;
            }

            if (day === null) {
                day = 1;
            }
        }

        if (pmHour && hours < 12) {
            hours += 12;
        }

        if (UTC) {
            if (hoursOffset) {
                hours += -hoursOffset;
            }

            if (minutesOffset) {
                minutes += -minutesOffset;
            }

            value = new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));
        } else {
            value = new Date(year, month, day, hours, minutes, seconds, milliseconds);
            adjustDST(value, hours);
        }

        if (year < 100) {
            value.setFullYear(year);
        }

        if (value.getDate() !== day && UTC === undefined) {
            return null;
        }

        return value;
    }
 function outOfRange(value, start, end) {
        return !(value >= start && value <= end);
    }
	
 function adjustDST(date, hours) {
        if (!hours && date.getHours() === 23) {
            date.setHours(date.getHours() + 2);
        }
    }
function formatDateToCulture(value, format, culture) {
    var cal = culture.calendar,
        convert = cal.convert;
    if ( !format || !format.length || format === 'i' ) {
        var ret;
        if ( culture && culture.name.length ) {
            if ( convert ) {
                // non-gregorian calendar, so we cannot use built-in toLocaleString()
                ret = formatDateToCulture( value, cal.patterns.F, culture );
            }
            else {
                ret = value.toLocaleString();
            }
        }
        else {
            ret = value.toString();
        }
        return ret;
    }

    var sortable = format === "s";
        format = getFullDateFormat(cal, format);


    // Start with an empty string
    ret = [];
    var hour,
        zeros = ['0','00','000'],
        foundDay,
        checkedDay,
        dayPartRegExp = /([^d]|^)(d|dd)([^d]|$)/g,
        quoteCount = 0,
        tokenRegExp = /\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g,
        converted;

    function padWithZeros(num, c) {
        var r, s = num+'';
        if ( c > 1 && s.length < c ) {
            r = ( zeros[ c - 2 ] + s);
            return r.substr( r.length - c, c );
        }
        else {
            r = s;
        }
        return r;
    }

    function hasDay() {
        if ( foundDay || checkedDay ) {
            return foundDay;
        }
        foundDay = dayPartRegExp.test( format );
        checkedDay = true;
        return foundDay;
    }

    if ( !sortable && convert ) {
        converted = convert.fromGregorian( value );
    }

    for (;;) {
        // Save the current index
        var index = tokenRegExp.lastIndex,
            // Look for the next pattern
            ar = tokenRegExp.exec( format );

        // Append the text before the pattern (or the end of the string if not found)
        var preMatch = format.slice( index, ar ? ar.index : format.length );
        quoteCount += appendMatchStringCount( preMatch, ret );

        if ( !ar ) {
            break;
        }

        // do not replace any matches that occur inside a string literal.
        if ( quoteCount % 2 ) {
            ret.push( ar[ 0 ] );
            continue;
        }

        var current = ar[ 0 ],
            clength = current.length;


        switch ( current ) {
            case dateFormat.DAY_OF_WEEK_THREE_LETTER:
            case dateFormat.DAY_OF_WEEK_FULL_NAME:
                var names = (clength === 3) ? cal.days.namesAbbr : cal.days.names;
                ret.push( names[ value.getDay() ] );
                break;
            case dateFormat.DAY_OF_MONTH_SINGLE_DIGIT:
            case dateFormat.DAY_OF_MONTH_DOUBLE_DIGIT:
                foundDay = true;
                ret.push( padWithZeros( (converted ? converted[2] : value.getDate()), clength ) );
                break;
            case dateFormat.MONTH_THREE_LETTER:
            case dateFormat.MONTH_FULL_NAME:
                var part = converted ? converted[1] : value.getMonth();
                ret.push( (cal.monthsGenitive && hasDay())
                    ? cal.monthsGenitive[ clength === 3 ? "namesAbbr" : "names" ][ part ]
                    : cal.months[ clength === 3 ? "namesAbbr" : "names" ][ part ] );
                break;
            case dateFormat.MONTH_SINGLE_DIGIT:
            case dateFormat.MONTH_DOUBLE_DIGIT:
                ret.push( padWithZeros((converted ? converted[1] : value.getMonth()) + 1, clength ) );
                break;
            case dateFormat.YEAR_SINGLE_DIGIT:
            case dateFormat.YEAR_DOUBLE_DIGIT:
            case dateFormat.YEAR_FULL:
                part = converted ? converted[ 0 ] : value.getFullYear();
                if ( clength < 4 ) {
                    part = part % 100;
                }
                ret.push( padWithZeros( part, clength ) );
                break;
            case dateFormat.HOURS_SINGLE_DIGIT_12_HOUR_CLOCK:
            case dateFormat.HOURS_DOUBLE_DIGIT_12_HOUR_CLOCK:
                hour = value.getHours() % 12;
                if ( hour === 0 ) hour = 12;
                ret.push( padWithZeros( hour, clength ) );
                break;
            case dateFormat.HOURS_SINGLE_DIGIT_24_HOUR_CLOCK:
            case dateFormat.HOURS_DOUBLE_DIGIT_24_HOUR_CLOCK:
                ret.push( padWithZeros( value.getHours(), clength ) );
                break;
            case dateFormat.MINUTES_SINGLE_DIGIT:
            case dateFormat.MINUTES_DOUBLE_DIGIT:
                ret.push( padWithZeros( value.getMinutes(), clength ) );
                break;
            case dateFormat.SECONDS_SINGLE_DIGIT:
            case dateFormat.SECONDS_DOUBLE_DIGIT:
                ret.push( padWithZeros(value .getSeconds(), clength ) );
                break;
            case dateFormat.MERIDIAN_INDICATOR_SINGLE:
            case dateFormat.MERIDIAN_INDICATOR_FULL:
                part = value.getHours() < 12 ? (cal.AM ? cal.AM[0] : " ") : (cal.PM ? cal.PM[0] : " ");
                ret.push( clength === 1 ? part.charAt( 0 ) : part );
                break;
            case dateFormat.DECISECONDS:
            case dateFormat.CENTISECONDS:
            case dateFormat.MILLISECONDS:
                ret.push( padWithZeros( value.getMilliseconds(), 3 ).substr( 0, clength ) );
                break;
            case dateFormat.TIME_ZONE_OFFSET_SINGLE_DIGIT:
            case dateFormat.TIME_ZONE_OFFSET_DOUBLE_DIGIT:
                hour = value.getTimezoneOffset() / 60;
                ret.push( (hour <= 0 ? '+' : '-') + padWithZeros( Math.floor( Math.abs( hour ) ), clength ) );
                break;
            case dateFormat.TIME_ZONE_OFFSET_FULL:
                hour = value.getTimezoneOffset() / 60;
                ret.push( (hour <= 0 ? '+' : '-') + padWithZeros( Math.floor( Math.abs( hour ) ), 2 ) +
                    ":" + padWithZeros( Math.abs( value.getTimezoneOffset() % 60 ), 2 ) );
                break;
            case dateFormat.DATE_SEPARATOR:
                ret.push( cal["/"] || "/" );
                break;
            default:
                throw "Invalid date format pattern '" + current + "'.";
                break;
        }
    }
    return ret.join( '' );
}

//add new culture into sf 
sf.globalize.addCulture = function (name, culture) {
    sf.cultures[name] = $.extend(true, $.extend(true, {}, sf.cultures['default'], culture), sf.cultures[name]);
	sf.cultures[name].calendar = sf.cultures[name].calendars.standard;
}

//return the specified culture or default if not found
sf.globalize.preferredCulture = function (culture) {
    culture = (typeof culture != "undefined" && typeof culture === typeof this.cultureObject) ? culture.name : culture;
    this.cultureObject = sf.globalize.findCulture(culture);
    return this.cultureObject;
}
sf.globalize.setCulture = function (culture) {
	if (sf.isNullOrUndefined(this.globalCultureObject)) this.globalCultureObject = sf.globalize.findCulture(culture);
	culture = (typeof culture != "undefined" && typeof culture === typeof this.globalCultureObject) ? culture.name : culture;
    if (culture) this.globalCultureObject = sf.globalize.findCulture(culture);
    sf.cultures.current = this.globalCultureObject;
    return this.globalCultureObject;
}
sf.globalize.culture=function(name){
    sf.cultures.current = sf.globalize.findCulture(name);
}

//return the specified culture or current else default if not found
sf.globalize.findCulture = function (culture) {
    var cultureObject;
    if (culture) {

        if ($.isPlainObject(culture) && culture.numberFormat) {
            cultureObject = culture;
        }
        if (typeof culture === "string") {
            var cultures = sf.cultures;
            if (cultures[culture]) {
                return cultures[culture];
            }
            else {
                if (culture.indexOf("-") > -1) {
                    var cultureShortName = culture.split("-")[0];
                    if (cultures[cultureShortName]) {
                        return cultures[cultureShortName];
                    }
                }
                else {
                    var cultureArray = $.map(cultures, function (el) { return el });
                    for (var i = 0; i < cultureArray.length; i++) {
                        var shortName = cultureArray[i].name.split("-")[0];
                        if (shortName === culture) {
                            return cultureArray[i];
                        }
                    };
                }
            }
            return sf.cultures["default"];
        }
    }
    else {
        cultureObject = sf.cultures.current || sf.cultures["default"];
    }

    return cultureObject;
}
//formatting date and number based on given format
sf.globalize.format = function (value, format, culture) {
    var cultureObject =  sf.globalize.findCulture(culture);
    if (typeof(value) === 'number') {
        value = formatNumberToCulture(value, format, cultureObject);
    } else if(value instanceof Date){
    	value = formatDateToCulture(value, format, cultureObject);
    }

    return value;
}

sf.globalize._round = function(number, precision){
	var factor = Math.pow(10, precision);
	return Math.round(number * factor) / factor;
},

//parsing integer takes string as input and return as number
sf.globalize.parseInt = function(value, radix, culture) {
	if(!radix)
		radix = 10;
    return Math.floor( parseValue( value, culture, radix ) );
}

//returns the ISO date string from date object
sf.globalize.getISODate = function(value) {
    if(value instanceof Date) return value.toISOString();
}

//parsing floationg poing number takes string as input and return as number
sf.globalize.parseFloat = function(value, radix, culture) {
	if (typeof radix === "string") {
        culture = radix;
        radix = 10;
    }
    return parseValue( value, culture);
}

//parsing date takes string as input and return as date object
sf.globalize.parseDate = function(value, formats, culture) {
    culture = sf.globalize.findCulture(culture);

    var date, prop, patterns;
    if ( formats ) {
        if ( typeof formats === "string" ) {
            formats = [ formats ];
        }
        if ( formats.length ) {
            for ( var i = 0, l = formats.length; i < l; i++ ) {
                var format = formats[ i ];
                if ( format ) {
                    date = getParsedDate( value, format, culture );
                    if ( date ) break;
                }
            }
        }
    }
    else {
        patterns = culture.calendar.patterns;
        for ( prop in patterns ) {
            date = getParsedDate( value, patterns[prop], culture );
            if ( date ) break;
        }
    }
    return date || null;
}

function getControlObject(obj, stringArray){
    return stringArray.length ? getControlObject(obj[stringArray[0]], stringArray.slice(1)) : obj;
}

//return localized constants as object for the given widget control and culture
sf.globalize.getLocalizedConstants = function(controlName, culture){
    var returnObject,
        controlNameArray = controlName.replace("sf.", "").split(".");
    
    returnObject = getControlObject(sf, controlNameArray);

    return ( $.extend(true, {}, returnObject.Locale['default'], returnObject.Locale[culture ? culture : this.cultureObject.name]) ) ;
}

$.extend(sf, sf.globalize);

}(jQuery));;
/* global jQuery, sf, document */
sf.EjVmlRender = function (element) {
    var doc = document;
    this.vmlNamespace = "urn:schemas-microsoft-com:vml";
    this.vmStyle = "#default#VML";
    doc.namespaces.add('v', 'urn:schemas-microsoft-com:vml');
    this.isdocmode8 = doc.documentMode === 8;
    if (!doc.getElementById("vml_chart")) {
        var cssText
        if (this.isdocmode8) {
            cssText =
                'v\\:fill, v\\:path, v\\:polyline, v\\:line, v\\:rect,v\\:shape,v\\:oval, v\\:stroke' +
                '{ behavior:url(#default#VML); display: inline-block; } ';
        }
        else {
            cssText =
                'v\\:*' +
                '{ behavior:url(#default#VML); display: inline-block; } ';
        }
        var vmlStyleSheet = doc.createStyleSheet();
        vmlStyleSheet.owningElement.id = 'vml_chart';
        vmlStyleSheet.cssText = cssText;
    }
    this._rootId = jQuery(element).attr("id");
    this.svgObj = doc.createElement("div");
    this.svgObj.style.position = 'relative';
    this.svgObj.setAttribute('id', this._rootId + '_vml');
    this.changeOptions = {
        'id': 'id',
        'fill': 'fillcolor', 'stroke': 'strokecolor', 'stroke-width': 'strokeweight', 'd': 'path', 'font-size': 'font-size', 'font-family': 'font-family', 'font-style': 'font-style',
        'font-weight': 'font-weight', 'points': 'points'

    };
};
(function ($) {
    sf.EjVmlRender.prototype = {

        drawPath: function (options, element) {
            var darray = options.d.split(" ");
            if ($.inArray('A', darray) != -1) {
                var w = parseFloat(darray[4]);
                var h = parseFloat(darray[5]);
                options.d = this.drawArc(w, h, options);
            }
            if ($("#" + options.id).length > 0) {
                options.d = this.changePathValue(options.d);
                this.applyVMLStyle($("#" + options.id), options);
            }
            else {
                options.d = this.changePathValue(options.d);
                var shape = document.createElement("v:shape");
                var $shapeEle = $(shape);
                this.applyVMLStyle($shapeEle, options);
                $shapeEle.appendTo(element);
            }
        },
        createLegendSvg: function (element) {
            var doc = document;
            this._rootId = jQuery(element).attr("id");
            this.legendsvgObj = doc.createElement("div");
            this.legendsvgObj.style.position = 'relative';
            this.legendsvgObj.setAttribute('id', "legend_" + this._rootId + '_vml');
            return this.legendsvgObj;
        },

        drawPolyline: function (options, element) {
            var darray = options.points.split(" ");

            if ($("#" + options.id).length > 0) {
                options.points = this.changePathValue(options.points);
                this.applyVMLStyle($("#" + options.id), options);
            }
            else {
                options.points = this.changePathValue(options.points);
                var shape = document.createElement("v:polyline");
                var $shapeEle = $(shape);
                this.applyVMLStyle($shapeEle, options);
                $shapeEle.appendTo(element);
            }
        },
        setFillAttribute: function (element, options) {
            var fill = document.createElement("v:fill");
            var opacity = options["fill-opacity"] ? options["fill-opacity"] : options["opacity"];
            opacity = (!sf.util.isNullOrUndefined(opacity)) ? opacity : (options["opacity"]) ? options["opacity"] : 1;
            var fillcolor = options["fill"];
            if (fillcolor != "none" && !sf.util.isNullOrUndefined(fillcolor)) {

                if (!(fillcolor).match('gradient'))
                    $(element).attr("fillcolor", fillcolor);
                else {
                    var colorName = ((fillcolor).replace('gradient', ""));
                    fill.setAttribute('type', "gradient");
                    fill.setAttribute("colors", colorName);
                }
            }
            else if (fillcolor == 'none') {
                fill.setAttribute('type', "gradient");
                fill.setAttribute('color', options.color);
                fill.setAttribute('color2', options.color2);
                fill.setAttribute('colors', options.colors);
                fill.setAttribute('angle', options.angle);
                opacity = options.fill_opacity;
            }
            else
                opacity = 0.1;


            fill.setAttribute('opacity', opacity);
            $(fill).appendTo(element);
        },
        setStrokeAttribute: function (element, options) {
            var stroke = options['stroke'];
            if (stroke == "transparent")
                options['opacity'] = 0.1;
            if (options.name) {
                $(element).attr('name', options.name);
            }


            var opacity = options["opacity"];
            if (opacity) {
                var fill = document.createElement("v:stroke");



                fill.setAttribute('opacity', opacity);
                $(fill).appendTo(element);
            }
        },
        changePathValue: function (options) {
            if (!options["d"]) {
                var pathArray = options.split(" ");
                for (var i = 0; i < pathArray.length; i++) {
                    var matches = pathArray[i].match(/\d+/g);
                    if (matches != null) {
                        pathArray[i] = Math.round(parseFloat(pathArray[i]));
                    }
                }
                options = pathArray.join(' ');
                return options;
            }
        },


        drawArc: function (w, h, options) {
            var x = 0, y = 0, M;
            var startAngle = options.start,
                endAngle = options.end,
                endAngle = (Number(Math.PI.toFixed(2)) == Number((endAngle + startAngle).toFixed(2))) ? endAngle - 0.01 : endAngle,
                radius = options.r || w || h,
                cosStart = Math.cos(startAngle),
                sinStart = Math.sin(startAngle),
                cosEnd = Math.cos(endAngle),
                sinEnd = Math.sin(endAngle),
                innerRadius = options.innerR,
                circleCorrection = 0.08 / radius,
                innerCorrection = (innerRadius && 0.1 / innerRadius) || 0,
                path;

            if (endAngle - startAngle === 0) {
                return '';

            } else if (2 * Math.PI - endAngle + startAngle < circleCorrection) {
                cosEnd = -circleCorrection;
            } else if (endAngle - startAngle < innerCorrection) {
                cosEnd = Math.cos(startAngle + innerCorrection);
            }

            path = [
                'wa', // To draw clockwise arc
                x - radius,
                y - radius,
                x + radius,
                y + radius,
                x + radius * cosStart,
                y + radius * sinStart,
                x + radius * cosEnd,
                y + radius * sinEnd
            ];

            if (options.open && !innerRadius) {
                path.push(
                    'e',
                    M,
                    x,
                    y
                );
            }

            path.push(
                // To draw anti clockwise arc
                'at',
                x - innerRadius,
                y - innerRadius,
                x + innerRadius,
                y + innerRadius,
                x + innerRadius * cosEnd,
                y + innerRadius * sinEnd,
                x + innerRadius * cosStart,
                y + innerRadius * sinStart,
                'x',
                'e'
            );
            path = path.join(" ");
            return path;

        },
        changeVMLStyle: function ($element, options) {
            var chart = this;
            var strokeColor = options.stroke;
            $element.css("width", options.width).css("visibility", options.visibility).css("height", options.height).css("position", "absolute").css('left', options.x).css('top', options.y);
            $.each(options, function (index, val) {
                if (chart.changeOptions[index] != null || chart.changeOptions[index] != undefined) {
                    if (index == 'd' || index == 'points') {
                        val = chart.changePathValue(options[index]).toLowerCase();
                    }
                    if (val == 'transparent' && !options.fill_opacity) {
                        options[index] = val = 'white';
                        if (index == "fill" && (!options.hasOwnProperty('opacity') || !options['opacity']))
                            options['opacity'] = 0.1;
                    }
                    if (options.fill_opacity) {
                        options['opacity'] = options.fill_opacity;
                    }
                    if ($element[0].tagName === "SPAN") {
                        if (index == "fill") $element.css('color', val);
                        else {
                            if (index == "id") $element.attr(chart.changeOptions[index], val);
                            else
                                $element.css(chart.changeOptions[index], val);
                        }
                    } else {

                        if (chart.isdocmode8) { // IE8 setAttribute bug
                            $element.get(0)[chart.changeOptions[index]] = val;
                        } else {
                            $element.get(0).setAttribute(chart.changeOptions[index], val);
                        }
                    }
                }
            });
            if (options.hasOwnProperty('fill-opacity') || options.hasOwnProperty('opacity') || options.hasOwnProperty('fill'))
                if (!($element[0].tagName === "SPAN")) {
                    chart.setFillAttribute($element, options);
                    if (options.hasOwnProperty('stroke')) {
                        options.stroke = strokeColor;
                        if (options.fill_opacity) {
                            options['opacity'] = options.fill_opacity;
                        }
                        chart.setStrokeAttribute($element, options);
                    }
                }
        },
        applyVMLStyle: function ($element, options) {

            if ($element[0].tagName !== "SPAN") {
                if (sf.util.isNullOrUndefined(options.width)) options.width = "1000px";
                if (sf.util.isNullOrUndefined(options.height)) options.height = "1000px";
            }
            if (sf.util.isNullOrUndefined(options.x)) options.x = "0px";
            if (sf.util.isNullOrUndefined(options.y)) options.y = "0px";

            this.changeVMLStyle($element, options);
        },
        drawLine: function (options, element) {
            if ($("#" + options.id).length > 0) {
                var from = (options.x1) + ',' + (options.y1);
                var to = (options.x2) + ',' + (options.y2);
                $(options).attr("from", from).attr("to", to);
                this.applyVMLStyle($("#" + options.id), options);
            }
            else {
                var line = document.createElement("v:line");
                var $lineEle = $(line);
                var from = (options.x1) + ',' + (options.y1);
                var to = (options.x2) + ',' + (options.y2);
                $lineEle.attr("from", from).attr("to", to);
                this.applyVMLStyle($lineEle, options);
                $lineEle.appendTo(element);
            }
        },
        //drawPolygon: function (options, element) {

        //},
        drawCircle: function (options, element) {
            if ($("#" + options.id).length > 0) {
                options.x = options.cx - options.r;
                options.y = options.cy - options.r;
                options.width = options.height = (2 * options.r);
                this.applyVMLStyle($("#" + options.id), options);
            }
            else {
                var circle = document.createElement("v:oval");
                var $circleEle = $(circle);
                options.x = options.cx - options.r;
                options.y = options.cy - options.r;
                options.width = options.height = (2 * options.r);
                this.applyVMLStyle($circleEle, options);
                if ($("#" + options.id).length == 0)
                    $circleEle.appendTo(element);
            }
        },

        drawEllipse: function (options, element) {
            if ($("#" + options.id).length > 0) {
                options.x = options.cx - options.rx;
                options.y = options.cy - options.ry;
                options.width = (2 * options.rx);
                options.height = (2 * options.ry);
                this.applyVMLStyle($("#" + options.id), options);
            }
            else {
                var ellipse = document.createElement("v:oval");
                var $ellipseEle = $(ellipse);
                options.x = options.cx - options.rx;
                options.y = options.cy - options.ry;
                options.width = (2 * options.rx);
                options.height = (2 * options.ry);
                this.applyVMLStyle($ellipseEle, options);
                $ellipseEle.appendTo(element);
            }
        },
        drawRect: function (options, element) {
            if ($("#" + options.id).length > 0) {
                this.applyVMLStyle($("#" + options.id), options);
            } else {
                var rect = document.createElement("v:rect");
                var $rectEle = $(rect);
                this.applyVMLStyle($rectEle, options);
                $rectEle.appendTo(element);
            }
        },
        drawCylinder: function (options, element, seriesOption) {
            var x = options.x, y = options.y, w = options.width, h = options.height, id = options.id, angle, path, rx, ry, cx2, cx1, cy1, X1, Y1, LX1, LY1, LX2, LY2, cy2, sa, ea, sa2, ea2, X, Y, cx, cy, LX, LY, sa1, ea1, gradientAngle;
            var gradientColor = options.fill;
            var format = sf.EjSvgRender.prototype.checkColorFormat(gradientColor);
            if (!format)
                var gradientColor = sf.datavisualization.Chart.prototype.colorNameToHex(options.fill);
            var opacity = options.opacity, obj = { svgRenderer: sf.EjSvgRender.prototype }, colorz = sf.Ej3DRender.prototype.polygon3D.prototype.applyZLight(gradientColor, obj), colorx = sf.Ej3DRender.prototype.polygon3D.prototype.applyXLight(gradientColor, obj);
            var angleConvertor = 65535; // VML measures angles in degrees/65535
            if (seriesOption.isColumn == true) {
                options.rx = rx = w / 2;
                options.ry = ry = rx / 4;
                cx2 = cx1 = x + rx;
                Y1 = cy1 = (y - ry);
                LY2 = Y = cy2 = y + h - ry;
                LX1 = cx2 + rx;
                X1 = LX2 = X = cx2 - rx;
                sa1 = -Math.round(angleConvertor * 180);
                ea1 = Math.round(angleConvertor * 180);
                sa2 = Math.round(angleConvertor * 360);
                ea2 = -Math.round(angleConvertor * 180);
                gradientAngle = "90";
                if (seriesOption.stacking == true) {
                    if (!seriesOption.isLastSeries) {
                        cy1 = y + ry;
                    }
                }
                LY1 = cy1;
            }
            else {
                options.ry = ry = h / 2;
                options.rx = rx = ry / 4;
                LX1 = X1 = cx1 = x + rx;
                X = cx2 = x + w + rx;
                sa1 = Math.round(angleConvertor * 90); ea1 = Math.round(angleConvertor * 180);
                sa2 = Math.round(angleConvertor * 270);
                ea2 = -Math.round(angleConvertor * 180);
                cy2 = cy1 = y + ry;
                Y = LY1 = cy1 + ry;
                Y1 = LY2 = cy2 - ry;
                gradientAngle = "0";
                if (seriesOption.stacking == true) {
                    if (!seriesOption.isLastSeries) {
                        cx2 = x + w - rx;
                    }
                }
                LX2 = cx2;
            }
            delete options.x;
            delete options.y;
            options.width = 1000;
            options.x = 0;
            options.y = 0;
            delete options.stacking;
            options.height = 1000;
            delete options.isColumn;
            options.fill = colorz;
            options.fill_opacity = opacity;
            options.stroke = colorz;
            options['stroke-width'] = 0;
            for (var i = 1; i <= 4; i++) {

                if (i % 2 == 0) {
                    cx = cx1;
                    cy = cy1; LX = LX2; LY = LY2; sa = sa2; ea = ea2;

                }
                else {
                    cx = cx2; cy = cy2; LX = LX1; LY = LY1; sa = sa1; ea = ea1;
                }
                if (i < 3) {
                    sa = angleConvertor;
                    ea = 23592600;
                }
                if (i < 4) {
                    path = [
                        'M',
                        Math.round(X),
                        Math.round(Y)
                    ];
                }
                path.push(

                    'ae',
                    Math.round(cx),
                    Math.round(cy),
                    Math.round(rx),
                    Math.round(ry),
                    sa,
                    ea
                );
                if (i > 2) {
                    path.push(

                        'l',
                        Math.round(LX),
                        Math.round(LY)
                    );
                    options.fill = "none";
                    options.color = gradientColor;
                    options.color2 = gradientColor;
                    options.colors = ("30% " + colorx + "," + "70% " + colorx);
                    options.angle = gradientAngle;
                }
                if (i != 3) {
                    path.push(
                        'e'
                    );
                    path = path.join(" ");
                    options.d = path;
                    options.id = id + "_" + "Region_" + (i - 1).toString();
                    if (i == 4)
                        options.id = id + "_" + "Region_" + (i - 2).toString();
                    var shape = document.createElement("v:shape");
                    var $shape = $(shape);
                    this.applyVMLStyle($shape, options);
                    $shape.appendTo(element);
                }
                X = X1; Y = Y1;
            }
        },
        _getAttrVal: function (ele, val, option) {
            val = (val == "x") ? "left" : val;
            val = (val == "y") ? "top" : val;
            var value1 = $(ele).attr(val);
            var value = value1 ? value1 : ($(ele).css(val));

            if (value != null)
                return value;
            else
                return option;
        },
        _setAttr: function (element, attribute) {
            if (attribute.transform) {
                var attrTrans = attribute.transform;
                var trans = attrTrans.slice(attrTrans.indexOf('(') + 1, attrTrans.indexOf(')')).split(',');
                attribute.x = trans[0];
                attribute.y = trans[1];
            }
            var $ele = $(element);
            if ($ele.length > 0)
                this.changeVMLStyle($ele, attribute);
        },
        createGradientElement: function (name, colors) {
            var colorName;

            if (Object.prototype.toString.call(colors) == '[object Array]') {
                colorName = "gradient" + " ";
                var appendString = "";
                for (var j = 0, i = colors.length - 1; i >= 0, j < colors.length; j++ , i--) {
                    colorName += appendString + colors[j]["colorStop"] + " " + colors[i]["color"];
                    appendString = ",";
                }
            }
            else {
                colorName = colors;
            }
            return colorName;
        },

        setSpanAttr: function (options, label, element) {
            var fontSize = (options["font-size"] > 0) ? (options["font-size"] + "px") : options["font-size"];
            var font = { size: fontSize, fontStyle: options["font-style"], fontFamily: options["font-family"] };
            var bounds = sf.EjSvgRender.utils._measureText(label, null, font);

            $(element).css("white-space", "nowrap");

            if (options["text-anchor"] === "middle")
                options.x = Math.round(options.x - bounds.width / 2);
            else if (options["text-anchor"] === "end")
                options.x = Math.round(options.x - bounds.width);
            options.y = Math.round(options.y - (font.size.replace("px", "")));
            this.applyVMLStyle(element, options);


        },
        drawText: function (options, label, groupEle, font) {
            var textDoc = document;
            var $Ele = $("#" + options.id);
            if ($Ele.length > 0) {
                this._textAttrReplace(options, label, font, $Ele);
            }
            else if (options.id.indexOf("YAxisTitle") > 0 && !this.isdocmode8) {
                options.on = true;
                var line = document.createElement("v:line");
                line.style.behavior = "url(#default#VML)";
                line.style.display = "inline-block";
                var bounds = sf.EjSvgRender.utils._measureText(label, null, null);

                line.setAttribute("to", (options.x - 1).toString() + "," + (options.y - bounds.width / 2).toString());
                line.setAttribute("from", (options.x).toString() + "," + options.y.toString());

                var path = document.createElement("v:path");
                path.setAttribute("textpathok", true);
                var textpath = document.createElement("v:textpath");
                textpath.setAttribute("on", true);
                textpath.setAttribute("string", label);

                textpath.style["font-style"] = options["font-style"];
                textpath.style["font-size"] = options["font-size"];
                textpath.style["font-family"] = options["font-family"];
                line.appendChild(path);
                line.appendChild(textpath);
                $(line).appendTo(groupEle);
            }
            else {
                var span = textDoc.createElement("span");
                var $spanEle = $(span);
                if (jQuery.type(label) == "array") {
                    this.setSpanAttr(options, label, $spanEle);
                    for (var i = 0; i < label.length; i++) {
                        var textspan = textDoc.createElement("span");
                        $(textspan).html(label[i]);
                        $(textspan).appendTo(span);
                        var brtag = textDoc.createElement("br");
                        $(brtag).appendTo(span);

                    }
                } else {
                    this.setSpanAttr(options, label, $spanEle);
                    $spanEle.html(label);
                }
                $spanEle.appendTo(groupEle);
            }
        },
        //text element attributes values are replaced 
        _textAttrReplace: function (options, label, font, $Ele) {
            if (jQuery.type(label) == "array") {
                var elements = $("#" + options.id).children("span");
                this.setSpanAttr(options, label, $Ele);
                if (elements.length > 0 && elements.length == label.length) {
                    for (var i = 0; i < elements.length; i++) {
                        var element = elements[i];
                        $(element).text(label[i]);
                    }
                }
                else {
                    $("#" + options.id).remove();
                    this.drawText(options, label, this.gTransToolEle, font);

                }
            } else {
                this.setSpanAttr(options, label, $Ele);
                $Ele.text(label);
            }

        },

        drawImage: function (options, element) {
            var imgElement = document.createElement("img");
            var $imgElement = $(imgElement);
            $imgElement.css({ 'position': 'absolute' });
            $.each(options, function (index, val) {
                if (index == "href") index = "src";
                $imgElement.attr(index, val);
            });
            $imgElement.appendTo(element);

        },

        createDefs: function () {

        },

        //createClipPath: function (options) {

        //},
        //createForeignObject: function (options) {

        //},
        createGroup: function (options) {
            var group = document.createElement("div");
            if (!sf.util.isNullOrUndefined(options.transform)) {
                var trans = options.transform.slice(options.transform.indexOf('(') + 1, options.transform.indexOf(')')).split(',');
                $(group).css({ 'position': 'absolute', 'left': trans[0] + 'px', 'top': trans[1] + 'px' });
            }
            if (options.cursor)
                $(group).css({ 'cursor': options.cursor });

            $.each(options, function (index, val) {
                if (index !== 'transform' && index != "clip-path")
                    $(group).attr(index, val);
            });

            return group;
        },

        createText: function (options, label) {
            var text = document.createElement("span");
            $(text).attr(options);
            if (!sf.util.isNullOrUndefined(label))
                text.textContent = label;
            return text;


        },

        //Draw clip path for each series to avoid series overlap in multiple axes zooming
        drawAxesBoundsClipPath: function (gSeriesGroupEle, options, invertedAxis) {
            var clipOptions;
            var element = $(gSeriesGroupEle);
            element.removeAttr("clip-path");
            var trans = this._getTransform(options.xAxis, options.yAxis, invertedAxis);
            clipOptions = {
                'id': gSeriesGroupEle.id + '_ClipRect',
                'x': 0,
                'y': 0,
                'width': (trans.width),
                'height': (trans.height),
                'fill': 'white',
                'stroke-width': 1,
                'stroke': 'transparent'
            };
            this.drawClipPath(clipOptions, gSeriesGroupEle);
            element.attr('clip-path', 'url(#' + clipOptions.id + ')');

        },

        getAttrVal: function (ele, val, option) {
            var value = $(ele).attr(val);
            if (value != null)
                return value;
            else
                return option;
        },

        round: function (value, div, up) {

            return div * (up ? Math.ceil(value / div) : Math.floor(value / div));
        },




        hexFromRGB: function (color) {
            var r = color.R;
            var g = color.G;
            var b = color.B;
            if (color.A) {
                var returncolor = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + color.A + ")";
                return returncolor;
            }
            else {
                var r = color.R;
                var g = color.G;
                var b = color.B;
                var hex = [r.toString(16), g.toString(16), b.toString(16)];
                $.each(hex, function (nr, val) { if (val.length === 1) { hex[nr] = "0" + val; } });
                return "#" + hex.join("").toUpperCase();
            }
        },
        hexToRGB: function (hex) {
            var rgbRegex = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/.test(hex);
            var result;
            if (rgbRegex == true) {
                result = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/.exec(hex);
                return result ? {
                    R: parseInt(result[1]),
                    G: parseInt(result[2]),
                    B: parseInt(result[3]),
                    A: result[4],
                } : null;
            }
            else {
                var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    R: parseInt(result[1], 16),
                    G: parseInt(result[2], 16),
                    B: parseInt(result[3], 16)
                } : null;
            }
        },
        checkColorFormat: function (color) {
            return /(rgba?\((?:\d{1,3}[,\)]){3}(?:\d+\.\d+\))?)|(^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$)/gmi.test(color);
        },
        createDelegate: function (context, handler) {
            return function (e) {
                handler.apply(context, [e, this]);
            };
        },

        drawClipPath: function (options, element) {
            if (options.id.indexOf("ChartAreaClipRect") == -1) {
                var left = Math.round(options.x) + 'px';
                var top = Math.round(options.y) + 'px';
                var right = Math.round(options.width) + Math.round(options.x) + 'px';
                var bottom = Math.round(options.y) + Math.round(options.height) + 'px';
                var cssClip = 'rect(' + top + ' ' + right + ' ' + bottom + ' ' + left + ')';
                $(element).css("position", "absolute").css('clip', cssClip);
            }
        },

        drawCircularClipPath: function (options, element) {
            var radius = Math.round(options.r);
            var x = Math.round(options.cx);
            var y = Math.round(options.cy);
            if (options.id.indexOf("_ClipRect") == -1) {
                var left = (x - radius) + 'px';
                var top = (y - radius) + 'px';
                var right = (x + radius) + 'px';
                var bottom = (y + radius) + 'px';
                var cssClip = 'rect(' + top + ' ' + right + ' ' + bottom + ' ' + left + ')';
                $(element).css("position", "absolute").css('clip', cssClip);
            }
        },

        append: function (childEle, parentEle) {
            $(childEle).appendTo(parentEle);
        }
    };
})(jQuery);;
/* global jQuery, document, sf, $, navigator, window, math */
sf.EjSvgRender = function (element) {

    this.svgLink = "http://www.w3.org/2000/svg";
    this.svgObj = document.createElementNS(this.svgLink, "svg");
    this._rootId = jQuery(element).attr("id");
    var id = this._rootId + '_svg';
    if ($(document).find("#" + id).length > 0) {
        var count = 0
        do {
            count++;
        } while ($(document).find("#" + this._rootId + '_svg' + count).length > 0);
        id = this._rootId + '_svg' + count;
    }
    this.svgObj.setAttribute('id', id);

};
(function ($) {
    sf.EjSvgRender.prototype = {
        drawPath: function (options, element) {
            if ($("#" + options.id).length > 0) {
                $("#" + options.id).attr(options);
            }
            else {
                var path = document.createElementNS(this.svgLink, "path");
                $(path).attr(options).appendTo(element);
            }

        },
        createLegendSvg: function (element) {
            this.svgLink = "http://www.w3.org/2000/svg";
            this.legendsvgObj = document.createElementNS(this.svgLink, "svg");
            this._rootId = jQuery(element).attr("id");
            this.legendsvgObj.setAttribute('id', "legend_" + this._rootId + '_svg');
            return this.legendsvgObj;
        },
        drawPolyline: function (options, element) {
            if ($("#" + options.id).length > 0) {
                $("#" + options.id).attr(options);
            }
            else {
                var polyline = document.createElementNS(this.svgLink, "polyline");
                $(polyline).attr(options).appendTo(element);
            }

        },

        drawLine: function (options, element) {
            if ($("#" + options.id).length > 0) {
                $("#" + options.id).attr(options);
            }
            else {
                var path = document.createElementNS(this.svgLink, "line");
                $(path).attr(options);
                $(path).appendTo(element);
            }
        },
        drawPolygon: function (options, element) {
            if ($("#" + options.id).length > 0) {
                $("#" + options.id).attr(options);
            }
            else {
                var polygon = document.createElementNS(this.svgLink, "polygon");
                $(polygon).attr(options);
                $(polygon).appendTo(element);
            }
        },
        drawCircle: function (options, element) {
            if ($("#" + options.id).length > 0) {
                $("#" + options.id).attr(options);
            }
            else {
                var circle = document.createElementNS(this.svgLink, "circle");
                $(circle).attr(options).appendTo(element);
            }
        },
        drawEllipse: function (options, element) {
            if ($("#" + options.id).length > 0) {
                $("#" + options.id).attr(options);
            }
            else {
                var ellipse = document.createElementNS(this.svgLink, "ellipse");
                $(ellipse).attr(options).appendTo(element);
            }
        },

        drawRect: function (options, element) {
            if ($("#" + options.id).length > 0) {
                $("#" + options.id).attr(options);
            }
            else {
                var rect = document.createElementNS(this.svgLink, "rect");
                $(rect).attr(options).appendTo(element);
            }
        },
        drawCylinder: function (options, element, seriesOption) {
            if ($("#" + options.id).length > 0) {
                $("#" + options.id).attr(options);
            }
            else {
                var x = options.x, y = options.y, id = options.id;
                var gradientColor = options.fill;
                var fillColor = gradientColor;
                var format = this.checkColorFormat(gradientColor);
                if (!format)
                    gradientColor = sf.datavisualization.Chart.prototype.colorNameToHex(gradientColor);
                var AEx, AEy, LX, LY, X, Y, X2, Y2, i = 2, X1, Y1, GX = 0, GY = 0, direction;
                var obj = { svgRenderer: this };
                if (seriesOption.isColumn == true) {
                    var rx = options.width / 2;
                    var length = options.height;
                    var ry = rx / 4;
                    X = X1 = x;
                    Y = ry < y ? y - ry : seriesOption.stacking ? y + ry : (y - ry);
                    Y1 = Y;
                    AEx = 2 * rx;
                    AEy = 0;
                    LX = 0;
                    LY = ry < y ? length : (length < 2 * ry ? length : seriesOption.stacking ? length - (2 * ry) : length);
                    X2 = X;
                    Y2 = ry < y ? Y + length : (length < Y ? length + Y : seriesOption.stacking ? length + (y - ry) : length + Y);
                    GX = 100;
                    if (seriesOption.stacking = true) {
                        if (!seriesOption.isLastSeries) {
                            Y = Y1 = y + ry;
                            LY = length < rx / 2 ? length : length - rx / 2;
                        }
                    }
                }
                else {
                    var ry = options.height / 2;
                    var length = options.width;
                    var rx = ry / 4;
                    Y = Y1 = y;
                    X = X1 = (x + rx);
                    AEx = 0;
                    AEy = 2 * ry;
                    LX = length;
                    LY = 0;
                    X2 = X + length;
                    Y2 = Y;
                    GY = 100;
                    if (seriesOption.stacking = true) {
                        if (!seriesOption.isLastSeries) {
                            X2 = (X + length - rx * 2);
                            LX = length - rx * 2;
                        }
                    }
                }
                delete options.x;
                delete options.y;
                delete options.width;
                delete options.height;
                delete options.isColumn;
                //options.stroke = "black";
                while (i--) {
                    direction = "M" + X.toString() + "," + Y.toString();
                    direction += "a" + rx.toString() + "," + ry.toString() + " 0 1,0 " + AEx.toString() + "," + AEy.toString();
                    direction += "a" + rx.toString() + "," + ry.toString() + " 0 1,0 " + (-1 * AEx).toString() + "," + (-1 * AEy).toString();
                    options.d = direction;
                    options.id = id + "_" + "Region_" + i;
                    options.fill = sf.Ej3DRender.prototype.polygon3D.prototype.applyZLight(gradientColor, obj);
                    this.drawPath(options, element);
                    X = X2;
                    Y = Y2;
                }
                direction = "M" + X1.toString() + "," + Y1.toString();
                direction += "a" + rx.toString() + "," + ry.toString() + " 0 1,0 " + AEx.toString() + "," + AEy.toString();
                direction += "l" + LX.toString() + " " + LY.toString();
                direction += "a" + rx.toString() + "," + ry.toString() + " 0 1,1 " + (-1 * AEx).toString() + "," + (-1 * AEy).toString() + " z";

                options.d = direction;
                options.id = id + "_" + "Region_2";
                if (fillColor.indexOf("url") == -1) {
                    var gradientId = id;
                    if ($("#" + gradientId).length == 0) {

                        var optiong = { 'id': gradientId, x1: "0%", y1: "0%", x2: GX.toString() + "%", y2: GY.toString() + "%" };
                        var gradientele = [];
                        gradientele[0] = { colorStop: "0%", color: gradientColor };
                        gradientele[1] = { colorStop: "30%", color: sf.Ej3DRender.prototype.polygon3D.prototype.applyXLight(gradientColor, obj) };
                        gradientele[2] = { colorStop: "70%", color: sf.Ej3DRender.prototype.polygon3D.prototype.applyXLight(gradientColor, obj) };
                        gradientele[3] = { colorStop: "100%", color: gradientColor };
                        this.drawGradient(optiong, gradientele, element);
                    }
                    options.fill = "url(#" + gradientId + ")";
                }
                this.drawPath(options, element);

            }
        },

        createGradientElement: function (name, colors, x1, y1, x2, y2, element) {
            var colorName;
            if (Object.prototype.toString.call(colors) == '[object Array]') {
                var options = {
                    'id': this.svgObj.id + '_' + name + 'Gradient',
                    'x1': x1 + '%',
                    'y1': y1 + '%',
                    'x2': x2 + '%',
                    'y2': y2 + '%'
                };
                var cName = '#' + this.svgObj.id + '_' + name + 'Gradient';
                this.drawGradient(options, colors, element);
                colorName = 'url(#' + this.svgObj.id + '_' + name + 'Gradient)';
            }
            else {
                colorName = colors;
            }
            return colorName;
        },

        drawGradient: function (options, gradientEle, element) {

            var defs = this.createDefs();
            var linerGradient = document.createElementNS(this.svgLink, "linearGradient");

            $(linerGradient).attr(options);
            for (var i = 0; i < gradientEle.length; i++) {
                var stop = document.createElementNS(this.svgLink, "stop");
                $(stop).attr({
                    'offset': gradientEle[i].colorStop,
                    'stop-color': gradientEle[i].color,
                    'stop-opacity': 1
                });
                $(stop).appendTo(linerGradient);
            }

            $(linerGradient).appendTo(defs);
            $(defs).appendTo(element);
        },

        drawText: function (options, label, groupEle, font) {

            if ($("#" + options.id).length > 0)
                this._textAttrReplace(options, label, font);
            else {
                var text = document.createElementNS(this.svgLink, "text");
                var $text = $(text);


                if (jQuery.type(label) == "array") {
                    var j = 0;
                    $text.attr(options);
                    for (var i = 0; i < label.length; i++) {
                        var textspan = document.createElementNS(this.svgLink, "tspan");
                        textspan.textContent = label[i];
                        $(textspan).attr({ "x": options.x, "dy": j });
                        $(textspan).appendTo(text);
                        font = this.enable3D ? font.font : font;
                        var bounds = sf.EjSvgRender.utils._measureText(label[i], null, font);
                        j = options.isTrackball ? bounds.height + 2 : bounds.height;
                    }
                } else {
                    text.textContent = label;
                    $text.attr(options);
                }
                $text.appendTo(groupEle);


            }
        },
        //text element attributes values are replaced 
        _textAttrReplace: function (options, label, font) {
            $("#" + options.id).attr(options);

            if (jQuery.type(label) == "array") {
                var elements = $("#" + options.id).children("tspan");
                var j = 0;
                if (elements.length > 0 && elements.length == label.length) {
                    for (var i = 0; i < elements.length; i++) {
                        var element = elements[i];
                        $(element).attr({ "x": options.x, "dy": j });
                        element.textContent = label[i];
                        var bounds = sf.EjSvgRender.utils._measureText(label[i], null, font);
                        j = bounds.height + 2;
                    }
                }
                else {
                    $("#" + options.id).remove();
                    this.drawText(options, label, this.gTransToolEle, font);

                }
            } else {
                $("#" + options.id).text(label);
            }

        },

        drawImage: function (options, element) {

            var img = document.createElementNS(this.svgLink, 'image');
            img.setAttributeNS(null, 'height', options.height);
            img.setAttributeNS(null, 'width', options.width);
            img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', options.href);
            img.setAttributeNS(null, 'x', options.x);
            img.setAttributeNS(null, 'y', options.y);
            img.setAttributeNS(null, 'id', options.id);
            img.setAttributeNS(null, 'visibility', options.visibility);
            if (!sf.util.isNullOrUndefined(options.clippath) || !sf.util.isNullOrUndefined(options.preserveAspectRatio)) {
                img.setAttributeNS(null, 'clip-path', options.clippath);
                img.setAttributeNS(null, "preserveAspectRatio", options.preserveAspectRatio);
            }
            $(img).appendTo(element);

        },

        createDefs: function () {
            var defs = document.createElementNS(this.svgLink, "defs");
            return defs;
        },

        createClipPath: function (options) {
            var clipPath = document.createElementNS(this.svgLink, "clipPath");
            $(clipPath).attr(options);
            return clipPath;
        },
        createForeignObject: function (options) {
            var object = document.createElementNS(this.svgLink, "foreignObject");
            $(object).attr(options);
            return object;
        },
        createGroup: function (options) {
            var group = document.createElementNS(this.svgLink, "g");
            $(group).attr(options);
            return group;
        },
        createPattern: function (options, element) {
            var pattern = document.createElementNS(this.svgLink, element);
            for (var name in options) {
                if (options.hasOwnProperty(name)) {
                    pattern.setAttribute(name, options[name]);
                }
            }
            return pattern;
        },
        createText: function (options, label) {
            var text = document.createElementNS(this.svgLink, "text");
            $(text).attr(options);
            if (!sf.util.isNullOrUndefined(label))
                text.textContent = label;
            return text;
        },

        createPath: function (options) {
            var path = document.createElementNS(this.svgLink, "path");
            $(path).attr(options);
            return path;
        },

        createCircle: function (options) {
            var circle = document.createElementNS(this.svgLink, "circle");
            $(circle).attr(options);
            return circle;
        },

        createLine: function (options) {
            var line = document.createElementNS(this.svgLink, "line");
            $(line).attr(options);
            return line;
        },


        _getAttrVal: function (ele, val, option) {
            var value = $(ele).attr(val);
            if (value != null)
                return value;
            else
                return option;
        },


        hexFromRGB: function (color) {
            var r = color.R;
            var g = color.G;
            var b = color.B;
            if (color.A) {
                var returncolor = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + color.A + ")";
                return returncolor;
            }
            else {
                var hex = [r.toString(16), g.toString(16), b.toString(16)];
                $.each(hex, function (nr, val) { if (val.length === 1) { hex[nr] = "0" + val; } });
                return "#" + (hex.join("").toUpperCase());
            }
        },

        checkColorFormat: function (color) {
            return /(rgba?\((?:\d{1,3}[,\)]){3}(?:\d+\.\d+\))?)|(^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$)/gmi.test(color);
        },

        hexToRGB: function (hex) {
            var rgbRegex = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/.test(hex);
            var result;
            if (rgbRegex == true) {
                result = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/.exec(hex);
                return result ? {
                    R: parseInt(result[1]),
                    G: parseInt(result[2]),
                    B: parseInt(result[3]),
                    A: result[4],
                } : null;
            }
            else {
                result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    R: parseInt(result[1], 16),
                    G: parseInt(result[2], 16),
                    B: parseInt(result[3], 16)
                } : null;
            }
        },


        createDelegate: function (context, handler) {
            return function (e) {
                handler.apply(context, [e, this]);
            };
        },

        drawClipPath: function (options, element) {
            //To avoid creating and appending the same element more than once
            if ($(element).find('#' + options.id).length > 0) {
                $(element).find('#' + options.id).attr(options);
            }
            else {
                var defs = this.createDefs();
                var clipPath = this.createClipPath({ 'id': options.id });
				options.id = options.id + '_Rect';
                this.drawRect(options, clipPath);
                this.append(clipPath, defs);
                this.append(defs, element);
            }
        },

        drawCircularClipPath: function (options, element) {
            var defs = this.createDefs();
            var clipPath = this.createClipPath({ 'id': options.id });
            this.drawCircle(options, clipPath);
            this.append(clipPath, defs);
            this.append(defs, element);
        },

        append: function (childEle, parentEle) {
            $(childEle).appendTo(parentEle);
        },
        _setAttr: function (element, attribute) {
            $(element).attr(attribute);
        }
    };

    sf.EjSvgRender.commonChartEventArgs = {
        cancel: false,
        data: null
    };
    sf.EjSvgRender.utils = {



        _decimalPlaces: function (num) {
            var match = ('' + num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
            if (!match) { return 0; }
            return Math.max(
                0,
                // Number of digits right of decimal point.
                (match[1] ? match[1].length : 0)
                // Adjust for scientific notation.
                - (match[2] ? +match[2] : 0));
        },
        _getLabelContent: function (pos, axis, locale) {
            switch (axis._categoryValueType) {
                case 'number':
                    var customFormat = (sf.util.isNullOrUndefined(axis.labelFormat)) ? null : axis.labelFormat.match('{value}');
                    return (sf.util.isNullOrUndefined(axis.labelFormat)) ? axis.labels[Math.floor(pos)] : (customFormat != null) ? axis.labelFormat.replace('{value}', axis.labels[Math.floor(pos)]) : (sf.format(axis.labels[Math.floor(pos)], axis.labelFormat, locale));
                case 'date':
                    return (sf.format(new Date(axis.labels[Math.floor(pos)]), ((sf.util.isNullOrUndefined(axis.labelFormat)) ? "dd/MM/yyyy" : axis.labelFormat), locale));
                case 'string':
                    return axis.labels[Math.floor(pos)];
                default:
                    return "";
            }
        },

        //Calculation for label size in template
        _getSeriesTemplateSize: function (point, pointIndex, series, isLeft, sender) {
            var point;
            var pointIndex;
            var areaType = sender.model.AreaType;

            var chartContainer = sender._id;
            var seriesIndex = $.inArray(series, sender.model._visibleSeries);

            if ($('#template_group_' + chartContainer).length != 0)
                var templateContainer = $('#template_group_' + chartContainer);
            else
                templateContainer = $("<div></div>").attr('id', "template_group_" + chartContainer);

            templateContainer.css('position', 'relative').css('z-index', 1000);
            var cloneNode = $("#" + series.marker.dataLabel.template).clone();
            $(cloneNode).attr("id", series.marker.dataLabel.template + '_' + seriesIndex + '_' + pointIndex + '_' + chartContainer);
            var $cloneNode = $(cloneNode);
            $cloneNode.css("position", "absolute");

            point.count = 1;
            var data = { series: series, point: point };
            $cloneNode.html($cloneNode.html().parseTemplate(data));

            var display = (areaType == "cartesianaxes" || !series.enableAnimation || (series.type.toLowerCase() == "pyramid" || series.type.toLowerCase() == "funnel")) ? "block" : "none";
            $cloneNode.css("display", display).appendTo($(templateContainer));
            $(templateContainer).appendTo('#' + chartContainer);
            point.size = { height: $cloneNode.height(), width: $cloneNode.width() };

            if (isLeft) {
                if (sf.util.isNullOrUndefined(series.LeftLabelMaxHeight) || series.LeftLabelMaxHeight < point.size.height) {
                    series.LeftLabelMaxHeight = point.size.height;
                }
                if (sf.util.isNullOrUndefined(series.LeftLabelMaxWidth) || series.LeftLabelMaxWidth < point.size.width) {
                    series.LeftLabelMaxWidth = point.size.width;
                }
            }
            else {
                if (sf.util.isNullOrUndefined(series.RightLabelMaxHeight) || series.RightLabelMaxHeight < point.size.height) {
                    series.RightLabelMaxHeight = point.size.height;
                }
                if (sf.util.isNullOrUndefined(series.RightLabelMaxWidth) || series.RightLabelMaxWidth < point.size.width) {
                    series.RightLabelMaxWidth = point.size.width;
                }
            }

        },
        getMinPointsDelta: function (axis, chartObj, start) {
            var chart = chartObj;
            var m_minPointsDelta = Number.MAX_VALUE;
            $.each(chart.model._visibleSeries, function (index, series) {
                if (series.visibility.toLowerCase() == 'visible' && axis.name == series._xAxisName) {
                    var xValues = sf.DataManager(series.points, sf.Query().sortBy("xValue")).executeLocal();
                    if ((xValues.length == 1) && (!chart.currentSeries || chart.currentSeries._yAxisName.toLowerCase() == series._yAxisName.toLowerCase())) {
                        var minValue = sf.util.isNullOrUndefined(start) ? series.xAxis.visibleRange.min : start;
                        var delta = xValues[0].xValue - minValue;
                        if (delta != 0)
                            m_minPointsDelta = Math.min(m_minPointsDelta, delta);
                    }
                    else {
                        $.each(xValues, function (pointIndex, point) {
                            if (pointIndex > 0 && point.xValue) {
                                var deltaValue = point.xValue - xValues[pointIndex - 1].xValue;
                                if (deltaValue != 0) {
                                    m_minPointsDelta = Math.min(m_minPointsDelta, deltaValue);
                                }
                            }
                        });
                    }
                }
            });

            if (m_minPointsDelta == Number.MAX_VALUE) {
                m_minPointsDelta = 1;
            }
            return m_minPointsDelta;
        },
        //Calculation for label size
        _getSeriesMaxLabel: function (series) {
            var maxTxtDim = { width: 0, height: 0 };
            var width = $(this.svgObject).width();
            var labels = [], currentLabel, word, dim;
            if (series.labels.length > 0) {
                for (var j = 0; j < series.labels.length; j++) {
                    var dim = this._measureText(series.visibleLabels[j], width, series.marker.dataLabel.font);
                    if (maxTxtDim.width < dim.width) {
                        maxTxtDim.width = dim.width;
                    }
                    if (maxTxtDim.height < dim.height) {
                        maxTxtDim.height = dim.height;
                    }
                }
                series.LabelMaxHeight = maxTxtDim.height;
                series.LabelMaxWidth = maxTxtDim.width;
            }
            else {
                labels.push(series.rightsidePoints);
                labels.push(series.leftsidePoints);

                for (var k = 0; k < labels.length; k++) {
                    for (var j = 0; j < labels[k].length; j++) {
						currentLabel = labels[k][j];
                        word = (currentLabel.text) ? currentLabel.text : currentLabel.y; 
                        dim = this._measureText(word, width, series.marker.dataLabel.font);
                        if (maxTxtDim.width < dim.width) {
                            maxTxtDim.width = dim.width;
                        }
                        if (maxTxtDim.height < dim.height) {
                            maxTxtDim.height = dim.height;
                        }
                    }
                    if (k == 0) {
                        series.RightLabelMaxHeight = maxTxtDim.height;
                        series.RightLabelMaxWidth = maxTxtDim.width;
                    }
                    else {
                        series.LeftLabelMaxHeight = maxTxtDim.height;
                        series.LeftLabelMaxWidth = maxTxtDim.width;
                    }
                }
            }


        },
        // to get highest label from label collection or label with <br> tag
        _getHighestLabel: function (axis, sender, text, intersectAction) {
            var largestLabel, maxWidth = 0, labelCollection = [], label, width, w = 0, labelText;
            if (sf.isNullOrUndefined(text)) {

                var labels = axis.labels.length == 0 ? axis.visibleLabels : axis.labels;
                for (var l = 0; l < labels.length; l++) {
                    var currentLabel = axis.labels.length == 0 ? labels[l].Text : labels[l], w = 0;
                    if (currentLabel.indexOf('<br>') != -1)
                        labelCollection = currentLabel.split('<br>');
                    else
                        labelCollection.push(currentLabel);
                    for (var r = 0; r < labelCollection.length; r++) {
                        label = labelCollection[r];
                        width = this._measureText(label, $(sender.svgObject).width(), axis.font).width;
                        if (w < width) {
                            w = width;
                            largestLabel = label;
                        }
                    }
                    if (maxWidth < w) {
                        maxWidth = w;
                        labelText = largestLabel;
                    }
                }
            }
            else if (text && ((typeof text == "string" && text.indexOf('<br>') != -1) || typeof text == "object")) {
                var w = 0;
                labelCollection = typeof text == "object" ? text : text.split('<br>');
                for (var r = 0; r < labelCollection.length; r++) {
                    label = typeof labelCollection[r] == "object" ? labelCollection[r].Text : labelCollection[r];
                    width = this._measureText(label, sender, axis.font).width;
                    if (w < width) {
                        w = width;
                        largestLabel = label;
                    }
                    labelText = largestLabel;
                }
            }
            return labelText;
        },
        _getMaxLabelWidth: function (axis, sender) {
            this.chartObj = sender;
            var maxTxtDim = { width: 0, height: 0, maxHeight: 0, maxWidth: 0 };
            var rotateLabel = '';
            var currentRow = 1;
            var vmlrendering = sender.svgRenderer.vmlNamespace;
            var range = axis.visibleRange;
            var intersectAction = (axis.labelIntersectAction) ? axis.labelIntersectAction.toLowerCase() : "";
            var labelPlacement = axis.labelPlacement;
            var opposedPosition = axis.opposedPosition;
            var orientation = axis.orientation.toLowerCase();
            var isHorizontal = sender.model.requireInvertedAxes ? (orientation == 'vertical') : orientation == 'horizontal';
            var roundingPlaces = axis.roundingPlaces;
            var labelRotation = axis.labelRotation;
            var orientation = axis.orientation;
            var maxHeight = 0;
            var prevLabels = [];
            var visibleLabels = axis.visibleLabels;
            var visibleLabelsLength = visibleLabels.length, textCollection, label, prevPoint, axisTitle, axisTitleText;
            if (axis.visible) {
                for (var j = 0; j < visibleLabelsLength; j++) {
                    axis.visibleLabels[j].y = 0;
                    if (typeof axis.visibleLabels[j].Text == "string" && axis.visibleLabels[j].Text.indexOf('<br>') != -1 && axis.orientation == "vertical") {
                        textCollection = axis.visibleLabels[j].Text.split('<br>');
                        label = this._getHighestLabel(axis, $(this.svgObject).width(), textCollection);
                        var dim = this._measureText(label, $(this.svgObject).width(), axis.font, axis.labelRotation);
                    }
                    else
                        var dim = this._measureText(axis.visibleLabels[j].Text, $(this.svgObject).width(), axis.font, axis.labelRotation);
                    if (maxTxtDim.width < dim.width) {
                        maxTxtDim.width = dim.width;
                        rotateLabel = axis.visibleLabels[j].Text;
                    }
                    if (maxTxtDim.height < dim.height)
                        maxTxtDim.height = dim.height;
                }

                if (axis.enableTrim || (intersectAction == "trim" && axis.orientation != "vertical")) {   // for enable trim
                    var derivedGap = axis.maximumLabelWidth;
                    maxTxtDim.width = maxTxtDim.width > derivedGap ? derivedGap : maxTxtDim.width;
                }

                // initialize rows to 1
                maxTxtDim.rows = 1;
                maxTxtDim.maxWidth = maxTxtDim.width;
                maxTxtDim.maxHeight = maxTxtDim.height;

                if (!vmlrendering && (labelRotation || intersectAction)) {
                    var intersectRotation = 0;
                    if (intersectAction == 'rotate45')
                        intersectRotation = 45;
                    else if (intersectAction == 'rotate90')
                        intersectRotation = 90;
                    labelRotation = labelRotation != null || orientation == "vertical" ? labelRotation : intersectRotation;
                    axis.rotationValue = labelRotation;
                    if (labelRotation) {
                        rotateLabel = (!sf.isNullOrUndefined(rotateLabel)) ? rotateLabel : '';
                        var labeltextWidth = this._measureText(rotateLabel, $(this.svgObject).width(), axis.font, axis.labelRotation);
                        if ((axis.enableTrim || intersectAction == "trim") && labeltextWidth.width > derivedGap && rotateLabel != "") { // to find trimmed text
                            var t, textWidth, text = rotateLabel;
                            for (t = 1; t < text.toString().length; t++) {
                                text = text.toString().substring(0, t) + '... ';
                                textWidth = this._measureText(text, $(sender.svgObject).width(), axis.font);
                                if (textWidth.width >= derivedGap) {
                                    text = text.toString().substring(0, t - 1) + '... ';
                                    rotateLabel = text;
                                    break;
                                }
                            }
                        }
                        rotateLabel = (intersectAction || axis.enableTrim) && labelRotation ? typeof rotateLabel == "string" && rotateLabel.indexOf('<br>') != -1 ? this._getHighestLabel(axis, sender, null) : rotateLabel : this._getHighestLabel(axis, sender, null);
                        var maxSize = this.rotatedLabel(axis, sender, labelRotation, rotateLabel);
                        if (axis.labelIntersectAction && axis.labelIntersectAction.toLowerCase() == 'multiplerows')
                            maxHeight = maxTxtDim.height + maxSize.height;

                        maxTxtDim.height = axis.rowsCount && axis.rowsCount > 1 && labelRotation != 90 && axis.enableTrim ? (axis.rowsCount) * maxTxtDim.height : maxSize.height;
                        maxTxtDim.width = maxSize.width;
                    }
                }

                if (axis.labelIntersectAction) {
                    if (axis.rowsCount && (intersectAction == "none" || intersectAction == "trim" || intersectAction == "hide" || labelRotation == 0) &&
                        (intersectAction != "wrap" || axis.enableTrim) && (intersectAction != "wrapbyword" || axis.enableTrim) && (intersectAction != "multiplerows" || axis.enableTrim)) {
                        if (labelRotation == 0) {
                            maxTxtDim.rows = axis.rowsCount;
                            maxTxtDim.height = ((axis.rowsCount) * maxTxtDim.height);
                        }
                    }
                    else if (intersectAction == 'wrap' || intersectAction == 'wrapbyword') {
                        // pointX calculation to find the gap between the ticks
                        var pointX, tempInterval;
                        labelPlacement = (!(labelPlacement)) ? sf.datavisualization.Chart.LabelPlacement.BetweenTicks : labelPlacement;
                        if (labelPlacement.toLowerCase() == "betweenticks") {
                            tempInterval = 1 + (axis.labels.length > 1 ? -0.5 : 0);
                            tempInterval = (!(roundingPlaces)) ? parseFloat(tempInterval.toFixed((sf.EjSvgRender.utils._decimalPlaces(range.interval) == 0 ?
                                1 : sf.EjSvgRender.utils._decimalPlaces(range.interval)))) : parseFloat(tempInterval.toFixed(roundingPlaces));
                            pointX = Math.ceil(((tempInterval - range.min) / (range.max - range.min)) * (axis.length));
                        }
                        else {
                            pointX = Math.ceil(axis.length / visibleLabels.length);
                        }
                        if (axis.orientation == "horizontal") {
                            var rowCount = 0, elementSpacing = 20, highestWidth = 0, highestLabel;
                            var labels = axis.labels.length > 0 && axis.valueType != "datetimecategory" ? axis.labels : axis.visibleLabels;
                            var gap = axis.width ? axis.width / labels.length : ((axis.length - (sender.svgWidth - axis.length)) - elementSpacing) / labels.length;
                            axis.labelsCollection = [];
                            for (var l = 0; l < labels.length; l++) {
                                var count = 0, labelsCollection = [], labeltxtcoll = [];
                                var labeltxt = typeof labels[l] === 'object' ? labels[l].Text : labels[l];
                                if (typeof labeltxt == "string" && labeltxt.indexOf('<br>') != -1)
                                    labeltxtcoll = labeltxt.split('<br>');
                                else
                                    labeltxtcoll.push(labeltxt);
                                for (var c = 0; c < labeltxtcoll.length; c++) {
                                    var textcoll = sf.EjAxisRenderer.prototype.rowscalculation(labeltxtcoll[c], sender.model.m_AreaBounds, axis, gap, null);
                                    count = textcoll.length + count;
                                    for (var t = 0; t < textcoll.length; t++)
                                        labelsCollection.push(textcoll[t]);
                                }
                                if (labelRotation) {
                                    rotateLabel = this._getHighestLabel(axis, sender, labelsCollection);
                                    var width = this._measureText(rotateLabel, $(sender.svgObject).width(), axis.font).width;
                                    if (highestWidth < width) {
                                        highestWidth = width;
                                        highestLabel = rotateLabel;
                                    }
                                }
                                rowCount = Math.max(count, rowCount);
                                axis.labelsCollection[l] = labelsCollection;
                            }
                            var maxSize = this.rotatedLabel(axis, sender, labelRotation, highestLabel);
                        }
                        pointX = pointX < 0 ? Math.ceil(axis.length / visibleLabels.length) : pointX;
                        var row = Math.round(maxTxtDim.width / pointX);
                        maxTxtDim.rows = labelRotation ? row - currentRow : row + currentRow;
                        if (maxTxtDim.rows < 0)
                            maxTxtDim.rows = 0;
                        var row1 = rowCount && !labelRotation ? rowCount : maxTxtDim.rows;
                        if (rowCount > row && !labelRotation)
                            row1 = row1 - 1;
                        maxTxtDim.height = labelRotation ? (maxSize.height + (row1) * maxSize.height) : (maxTxtDim.height + (row1) * maxTxtDim.height);
                    }
                    else if (intersectAction == 'multiplerows') {
                        var spaceValue = sender._getLegendSpace();
                        var chartBorderWidth = sender.model.border.width;

                        var verticalaxis = sender.model._axes[1];
                        var realWidth = $(sender.svgObject).width() - sender.model.margin.left - sender.model.margin.right;
						axisTitle = axis.title;
						axisTitleText = axisTitle.text;
                        var axisTitleHeight = (axisTitleText == "" || !(axis.visible)) ? 0 : (this._measureText(axisTitleText, realWidth, axisTitle.font).height + (2 * sender.model.elementSpacing));
                        var vAxesWidth = sender.model.elementSpacing + axisTitleHeight + axis.majorTickLines.size + axis.axisLine.width;
                        var yLabels = sender._getYValues(sender.model._visibleSeries[0].points);
                        var largest = Math.max.apply(Math, yLabels);
                        var vaxis = sender.model._axes[1];
                        var dim = this._measureText(largest, $(this.svgObject).width(), vaxis.font, vaxis.labelRotation);

                        var rightSpacing = spaceValue.rightLegendWidth + vAxesWidth + dim.width + sender.model.margin.right + sender.model.margin.left + (2 * chartBorderWidth);
                        var boundsWidth = $(sender.svgObject).width() - (rightSpacing);
                        if (isHorizontal) {
                            var addedMaxHeight = 0; var count1 = 0; var multipleRowsColl = []; var count2 = 0;
                            var row = 0; var highestLabel, highestWidth = 0;
                            //loop to get current label

                            for (j = 0; j < visibleLabels.length; j++) {
                                //declaration
                                var currentLabel = visibleLabels[j]; var currentLabelColl = [];
                                if (typeof currentLabel.Text == "string" && currentLabel.Text.indexOf('<br>') != -1)
                                    currentLabelColl = currentLabel.Text.split('<br>');
                                else
                                    currentLabelColl.push(currentLabel);
                                var collectionLength = currentLabelColl.length;
                                var isMultiRows = false;
                                maxHeight = Math.max(maxHeight, addedMaxHeight);
                                addedMaxHeight = currentLabel.y = maxTxtDim.height;
                                var text = this._measureText(currentLabel.Text, $(this.svgObject).width(), axis.font);
                                var textHeight = text.height;
                                var currentPoint = Math.abs(Math.floor(((currentLabel.Value - range.min) / (range.delta)) * (boundsWidth)));
                                if (multipleRowsColl.length > 0) {
                                    var previousLabels = multipleRowsColl;
                                    var flag1 = true;
                                    for (var k = 0; k < previousLabels.length && flag1; k++) {
                                        var count = 0; var labelCount = 0;
                                        var prevLabel = previousLabels[k];
                                        for (var l = 0; prevLabel && l < prevLabel.length; l++) {
                                            for (var c = 0; c < collectionLength; c++) {
                                                var temp = 0;
                                                var textWidth = sf.EjSvgRender.utils._measureText(collectionLength == 1 ? currentLabelColl[c].Text : currentLabelColl[c], $(this.svgObject).width(), axis.font).width;
                                                var textHeight = sf.EjSvgRender.utils._measureText(currentLabelColl[c], $(this.svgObject).width(), axis.font).height;
                                                var preLabel = l == prevLabel.length ? prevLabel[l - 1] : prevLabel[l];
                                                var prePoint = Math.abs(Math.floor(((preLabel.Value - range.min) / (range.delta)) * (boundsWidth)));
                                                var preTextWidth = sf.EjSvgRender.utils._measureText(preLabel.Text, $(this.svgObject).width(), axis.font).width;
                                                textWidth = textWidth / 2;
                                                var value = prePoint + ((axis.isInversed) ? -preTextWidth / 2 : preTextWidth / 2);
                                                if (value >= currentPoint - textWidth) {
                                                    addedMaxHeight = currentLabel.y + textHeight;
                                                    currentLabel.y += textHeight;
                                                    count++;
                                                    if (k + 1 == previousLabels.length)
                                                        flag1 = false;

                                                }
                                                else {
                                                    if (l + 1 == prevLabel.length) {
                                                        if (c == collectionLength - 1) flag1 = false;
                                                        else {
                                                            flag1 = true;
                                                        }
                                                        break;
                                                    }
                                                }

                                            }
                                        }
                                    }
                                }
                                currentLabel.y = addedMaxHeight;
                                row = (addedMaxHeight / textHeight) - 1;
                                if (multipleRowsColl[row] == undefined)
                                    multipleRowsColl[row] = [];
                                if (collectionLength == 1) multipleRowsColl[row].push(currentLabel);
                                else {
                                    for (var c = 0; c < collectionLength; c++) {
                                        if (multipleRowsColl[row] == undefined)
                                            multipleRowsColl[row] = [];
                                        multipleRowsColl[row].push({
                                            Text: currentLabelColl[c],
                                            Value: currentLabel.Value
                                        });
                                        if (c != collectionLength - 1) {
                                            row = row + 1;
                                            addedMaxHeight = currentLabel.y + textHeight;
                                        }
                                    }
                                }

                            }

                            maxHeight = (multipleRowsColl.length * textHeight);
                            maxTxtDim.height = maxTxtDim.height > maxHeight ? maxTxtDim.height : maxHeight;
                            //calculating rows
							if(textHeight > 0){
                            if (opposedPosition)
                                maxTxtDim.rows = Math.round((maxHeight + textHeight) / textHeight);
                            else
                                maxTxtDim.rows = Math.round(maxHeight / textHeight);
							}
                            maxTxtDim.rows = labelRotation ? maxTxtDim.rows - 1 : maxTxtDim.rows;
                            if (maxTxtDim.rows < 1) maxTxtDim.rows = 1;
                        }
                        if (!isHorizontal) {
                            var addedMaxWidth = 0;
                            //loop to get current label
                            for (j = 0; j < axis.visibleLabels.length; j++) {
                                currentLabel = axis.visibleLabels[j];
                                text = this._measureText(currentLabel.Text, $(this.svgObject).width(), axis.font);
                                textWidth = text.width;
                                textHeight = text.height;
                                currentPoint = Math.abs(Math.floor(((currentLabel.Value - axis.visibleRange.min) / (axis.visibleRange.delta)) * (axis.length)));
                                for (var i = 0; i < j; i++) {
                                    // loop to get previous labels
                                    prevLabel = axis.visibleLabels[i];
                                    prevPoint = Math.abs(Math.floor(((prevLabel.Value - axis.visibleRange.min) / (axis.visibleRange.delta)) * (axis.length)));
                                    var prevTextHeight = this._measureText(prevLabel.Text, $(this.svgObject).width(), axis.font).height;
                                    value = prevPoint + prevTextHeight / 2;
                                    if (value > currentPoint - textHeight / 2 && axis.visibleLabels[i].y == currentLabel.y) {
                                        addedMaxWidth = currentLabel.y + textWidth;
                                        currentLabel.y = addedMaxWidth;
                                        isMultiRows = true;
                                    }
                                }
                                var maxheight = addedMaxWidth;
                            }
                            // label width + multiple rows width + gap between the rows added only on text render in multiple rows
                            maxTxtDim.width = maxTxtDim.width + maxheight + (isMultiRows ? 5 : 0);
                        }
                    }
                }
            }
            return maxTxtDim;
        },

        rotatedLabel: function (axis, sender, value, rotatedLabel, is3D) {
            // to get height of rotated labels
            var rotatedOptions = {
                'font-size': axis.font.size,
                'transform': 'rotate(' + value + ',0,0)',
                'font-family': axis.font.fontFamily,
                'font-style': axis.font.fontStyle,
                'rotateAngle': 'rotate(' + value + 'deg)',
                'text-anchor': 'middle'
            };
            sender = is3D ? this.chartObj : sender;
            var text = sender.svgRenderer.createText(rotatedOptions, rotatedLabel);
            var height = Math.ceil((this._measureBounds(text, sender).height));
            var width = Math.ceil((this._measureBounds(text, sender).width));
            return { height: height, width: width };
        },

        _getTransform: function (xAxis, yAxis, invertedAxis) {
            var x, y, width, height;
            if (invertedAxis) {
                x = yAxis.x;
                y = xAxis.y;
                width = yAxis.width;
                height = xAxis.height;
            } else {
                {
                    x = xAxis.x;
                    y = yAxis.y;
                    width = xAxis.width;
                    height = yAxis.height;
                }
            }
            return { x: x, y: y, width: width, height: height };
        },
        //calculate path for roundedCorner of the series column,bar,stacking column,stacking bar,range column
        _calculateroundedCorner: function (cornerRadius, options, isArrow, orientation, tipPosition, tracker) {
            var x1 = options.x, y1 = options.y, padding = 5, canvasPadding = (this.chartObj.model.enableCanvasRendering && !tracker) ? padding / 4 : 0,
                width = options.width, height = options.height, topLeft,
                bottomLeft, topRight, bottomRight, d;

            if (typeof (cornerRadius) != "object" || sf.util.isNullOrUndefined(cornerRadius))
                topLeft = bottomLeft = topRight = bottomRight = cornerRadius;
            else {
                topLeft = cornerRadius.topLeft;
                bottomLeft = cornerRadius.bottomLeft;
                topRight = cornerRadius.topRight;
                bottomRight = cornerRadius.bottomRight;
            }
            topLeft = sf.util.isNullOrUndefined(options.rx) ? topLeft : options.rx;
            bottomLeft = sf.util.isNullOrUndefined(options.rx) ? bottomLeft : options.rx;
            topRight = sf.util.isNullOrUndefined(options.ry) ? topRight : options.ry;
            bottomRight = sf.util.isNullOrUndefined(options.ry) ? bottomRight : options.ry;

            d = "M" + " " + x1 + " " + (topLeft + y1) + " Q " + x1 + " " + y1 + " " + (x1 + topLeft) + " " + y1 + " ";
            if (isArrow && orientation == "top")
                d += "L " + (x1 + width / 2 - padding / 2 + canvasPadding) + " " + (y1) + " L " + (x1 + width / 2 + canvasPadding - tipPosition) + " " + (y1 - padding) + " L " + (x1 + width / 2 + padding / 2 + canvasPadding) + " " + (y1) + " ";
            d += "L" + " " + (x1 + width - topRight) + " " + y1 + " Q " + (x1 + width) + " " + y1 + " " + (x1 + width) + " " + (y1 + topRight) + " ";
            if (isArrow && orientation == "right")
                d += "L " + (x1 + width) + " " + (y1 + height / 2 - padding / 2 + canvasPadding) + " L " + (x1 + width + padding) + " " + (y1 + height / 2 + canvasPadding - tipPosition) + " L " + (x1 + width) + " " + (y1 + height / 2 + padding / 2 + canvasPadding) + " ";
            d += "L " + (x1 + width) + " " + (y1 + height - bottomRight) + " Q " + (x1 + width) + " " + (y1 + height) + " " + (x1 + width - bottomRight) + " " + (y1 + height) + " ";
            if (isArrow && orientation == "bottom")
                d += "L " + (x1 + width / 2 - padding / 2 + canvasPadding) + " " + (y1 + height) + " L " + (x1 + width / 2 + canvasPadding - tipPosition) + " " + (y1 + height + padding) + " L " + (x1 + width / 2 + padding / 2 + canvasPadding) + " " + (y1 + height) + " ";
            d += "L " + (x1 + bottomLeft) + " " + (y1 + height) + " Q " + x1 + " " + (y1 + height) + " " + x1 + " " + (y1 + height - bottomLeft) + " ";
            if (isArrow && orientation == "left")
                d += "L " + (x1) + " " + (y1 + height / 2 - padding / 2 + canvasPadding) + " L " + (x1 - padding) + " " + (y1 + height / 2 + canvasPadding - tipPosition) + " L " + (x1) + " " + (y1 + height / 2 + padding / 2 + canvasPadding) + " ";
            d += "L" + " " + x1 + " " + (topLeft + y1) + " " + "z";
            return d;

        },
        browserInfo: function () {
            var browser = {}, clientInfo = [],
                browserClients = {
                    webkit: /(chrome)[ \/]([\w.]+)/i, safari: /(webkit)[ \/]([\w.]+)/i, msie: /(msie) ([\w.]+)/i,
                    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i, mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
                };
            for (var client in browserClients) {
                if (browserClients.hasOwnProperty(client)) {
                    clientInfo = navigator.userAgent.match(browserClients[client]);
                    if (clientInfo) {
                        browser.name = clientInfo[1].toLowerCase();
                        browser.version = clientInfo[2];
                        if (!!navigator.userAgent.match(/Trident\/7\./)) {
                            browser.name = "msie";
                        }
                        break;
                    }
                }
            }
            browser.isMSPointerEnabled = (browser.name == 'msie') && browser.version > 9 && window.navigator.msPointerEnabled;
            browser.pointerEnabled = window.navigator.pointerEnabled;
            return browser;
        },
        _measureText: function (text, maxwidth, font) {
            var element = $(document).find("#measureTex");
            $("#measureTex").css('display', 'block'); // fixed for scroll issue in sample browser
            if (element.length == 0) {
                var textObj = document.createElement('text');
                $(textObj).attr({ 'id': 'measureTex' });
                document.body.appendChild(textObj);
            }
            else {
                var textObj = element[0];
            }

            var style = null, size = null, family = null, weight = null;
            if (typeof (text) == "string" && (text.indexOf("<") > -1 || text.indexOf(">") > -1)) {
                var textArray = text.split(" ");
                for (var i = 0; i < textArray.length; i++) {
                    if (textArray[i].indexOf("<br/>") == -1)
                        textArray[i] = textArray[i].replace(/[<>]/g, '&');
                }
                text = textArray.join(' ');
            }
			if(/<\/?[a-z][\s\S]*>/.test(text))
				$(textObj).html(text);
			else
				textObj.textContent = text;
            if (font != undefined && font.size == undefined) {
                var fontarray = font;
                fontarray = fontarray.split(" ");
                style = fontarray[0];
                size = fontarray[1];
                family = fontarray[2];
                weight = fontarray[3];
            }

            if (font != null) {
                textObj.style.fontSize = (font.size > 0) ? (font.size + "px") : font.size ? font.size : size;
                if (textObj.style.fontStyle)
                    textObj.style.fontStyle = (font.fontStyle) ? font.fontStyle : style;
                textObj.style.fontFamily = font.fontFamily ? font.fontFamily : family;
                if (window.navigator.userAgent.indexOf('MSIE 8.0') == -1)
                    textObj.style.fontWeight = font.fontWeight ? font.fontWeight : weight;
            }
            textObj.style.backgroundColor = 'white';
            textObj.style.position = 'absolute';
            textObj.style.top = -100;
            textObj.style.left = 0;
            textObj.style.visibility = 'hidden';
            textObj.style.whiteSpace = 'nowrap';
            if (maxwidth)
                textObj.style.maxwidth = maxwidth + "px";


            var bounds = { width: textObj.offsetWidth, height: textObj.offsetHeight };
            $("#measureTex").css('display', 'none'); // fixed for scroll issue in sample browser
            return bounds;
        },
        //to trim legend text
        _trimText: function (legendtext, maxwidth, font) {
            var textWidth, text, textLength;
            text = legendtext.toString();
            textLength = text.length;
            for (var t = 1; t < textLength; t++) {
                text = legendtext.substring(0, t) + '...';
                textWidth = sf.EjSvgRender.utils._measureText(text, null, font).width;
                if (textWidth >= maxwidth) {
                    text = text.substring(0, t - 1) + '... ';
                    return text;
                }
            }
            return legendtext;
        },
        _measureBounds: function (element, sender) {
            if (sender.model.enableCanvasRendering)
                $(document.body).append(element);
            else {
                sender.svgRenderer.append(element, sender.svgObject);
                sender.svgRenderer.append(sender.svgObject, sender.element);
            }
            var box = element.getBoundingClientRect();
            var bounds = { left: box.left, right: box.right, top: box.top, bottom: box.bottom, width: (box.right - box.left), height: (box.bottom - box.top) };
            $(element).remove();
            return bounds;
        },
        //Draw clip path for each series to avoid series overlap in multiple axes zooming
        _drawAxesBoundsClipPath: function (gSeriesGroupEle, options, sender) {
            var clipOptions;
            var element = $(gSeriesGroupEle);
            var trans = this._getTransform(options.xAxis, options.yAxis, sender.model.requireInvertedAxes);
            var width = (sender.model.AreaType == "polaraxes") ? $(sender.svgObject).width() : trans.width;
            var height = (sender.model.AreaType == "polaraxes") ? $(sender.svgObject).height() : trans.height;

            var hPlotOffset = sender.model.requireInvertedAxes ? options.yAxis.plotOffset : options.xAxis.plotOffset;
            var vPlotOffset = sender.model.requireInvertedAxes ? options.xAxis.plotOffset : options.yAxis.plotOffset;
            if (sender.model.AreaType == 'polaraxes') {
                clipOptions = {
                    'id': gSeriesGroupEle ? gSeriesGroupEle.id + '_ClipRect' : '',
                    'cx': sender.model.centerX,
                    'cy': sender.model.centerY,
                    'r': sender.model.Radius,
                    'fill': 'white',
                    'stroke-width': 1,
                    'stroke': 'transparent'
                };
                sender.svgRenderer.drawCircularClipPath(clipOptions, gSeriesGroupEle);
            }
            else {
                clipOptions = {
                    'id': gSeriesGroupEle ? gSeriesGroupEle.id + '_ClipRect' : '',
                    'x': (0 - hPlotOffset),
                    'y': (0 - vPlotOffset),
                    'width': (width + 2 * hPlotOffset),
                    'height': (height + 2 * vPlotOffset),
                    'fill': 'white',
                    'stroke-width': 1,
                    'stroke': 'transparent'
                };
                sender.svgRenderer.drawClipPath(clipOptions, gSeriesGroupEle);
            }
			// fixed for duplicate ID attributes values
			if(clipOptions.id.indexOf('_Rect'))
				clipOptions.id = clipOptions.id.replace('_Rect', '');
            element.attr('clip-path', 'url(#' + clipOptions.id + ')');

        },
        _getStringBuilder: function () {

            var data = [];
            var counter = 0;

            return {
                // adds string s to the stringbuilder

                append: function (s) {
                    data[counter++] = s;
                    return this;
                },

                // removes j elements starting at i, or 1 if j is omitted

                remove: function (i, j) {
                    data.splice(i, j || 1);
                    return this;
                },

                // inserts string s at i

                insert: function (i, s) {
                    data.splice(i, 0, s);
                    return this;
                },

                // builds the string

                toString: function (s) { return data.join(s || ""); }
            };


        },
        _addRegion: function (chart, bounds, series, point, pointIndex) {
            var type = series.type;
            var seriesIndex = $.inArray(series, chart.model._visibleSeries);
            if (seriesIndex >= 0) {
                var regionItem = { SeriesIndex: seriesIndex, Region: { PointIndex: pointIndex, Bounds: bounds }, type: type };
                chart.model.chartRegions.push(regionItem);
            }
        },

        AddRegion: function (chart, bounds, isStripLine) {

            if (isStripLine) {
                var regionItem = { isStripLine: isStripLine, Region: { Bounds: bounds } };
                chart.model.chartRegions.push(regionItem);
            }
        },


        _getSvgXY: function (x, y, series, sender) {
            var svgX, svgY;
            if (!(sender.model.requireInvertedAxes)) {
                svgX = x + series.xAxis.x;
                svgY = y + series.yAxis.y;
            } else {
                svgX = x + series.yAxis.x;
                svgY = y + series.xAxis.y;
            }
            return { X: svgX, Y: svgY };
        },
        _getPoint: function (point, series) {
            var x = point.xValue, low, xvalue, yvalue,
                y = series.type == "boxandwhisker" ? point.YValues : point.YValues[0],
                xLength = series._isTransposed ? series.xAxis.height : series.xAxis.width,
                yLength = series._isTransposed ? series.yAxis.width : series.yAxis.height;

            point.location = {};

            if (series._hiloTypes) {
                low = point.YValues[1];
                low = (series.yAxis._valueType == "logarithmic") ? sf.EjSvgRender.utils._logBase((low == 0 ? 1 : low), series.xAxis.logBase) : low;
                low = this._getPointXY(low, series.yAxis.visibleRange, series.yAxis.isInversed);
                point.location.low = (series._isTransposed ? low : (1 - low)) * (yLength);
            }

            xvalue = (series.xAxis._valueType == "logarithmic") ? sf.EjSvgRender.utils._logBase((x == 0 ? 1 : x), series.xAxis.logBase) : x;
            yvalue = (series.yAxis._valueType == "logarithmic") ? sf.EjSvgRender.utils._logBase((y == 0 ? 1 : y), series.xAxis.logBase) : y;

            xvalue = (this._getPointXY(xvalue, series.xAxis.visibleRange, series.xAxis.isInversed));
            yvalue = this._getPointXY(yvalue, series.yAxis.visibleRange, series.yAxis.isInversed);
            point.location.X = series._isTransposed ? yvalue * (yLength) : xvalue * (xLength);
            point.location.Y = series._isTransposed ? (1 - xvalue) * (xLength) : (1 - yvalue) * (yLength);

            return point.location;
        },
        _getPointXY: function (value, Range, isInversed) {

            var result = 0;
            result = (value - Range.min) / (Range.delta);
            result = isNaN(result) ? 0 : result;
            return (isInversed) ? (1 - result) : result;

        },

        _dateTimeLabelFormat: function (intervalType, axis) {
            switch (intervalType.toLowerCase()) {
                case "years":
                    return axis._labelFormat = "MMM, yyyy";
                case "months":
                    return axis._labelFormat = "dd, MMM";
                case "days":
                    return axis._labelFormat = "dd/MM/yyyy";
                case "hours":
                    return axis._labelFormat = "dd, hh:mm";
                case "minutes":
                    return axis._labelFormat = "hh:mm";
                case "seconds":
                    return axis._labelFormat = "mm:ss";
                case "milliseconds":
                    return axis._labelFormat = "ss:fff";
                default:
                    return axis._labelFormat = "dd/MM/yyyy";
            }
        },
        _getFontString: function (fontObj) {
            if (fontObj == null)
                fontObj = {};
            if (!fontObj.FontFamily)
                fontObj.FontFamily = "Arial";
            if (!fontObj.FontStyle)
                fontObj.FontStyle = "Normal";
            if (!fontObj.Size)
                fontObj.Size = "12px";

            return fontObj.FontStyle + " " + fontObj.Size + " " + fontObj.FontFamily;
        },

        _valueToVector: function (axis, value) {
            return this._coefficientToVector(this._valueToPolarCoefficient(axis, value));
        },

        TransformToVisible: function (currentseries, x, y, sender) {
            x = (currentseries.xAxis._valueType == "logarithmic") && x > 0 ? Math.log(x, currentseries.xAxis.logBase) : x;
            y = (currentseries.xAxis._valueType == "logarithmic") && y > 0 ? Math.log(y, currentseries.yAxis.logBase) : y;
            var radius = sender.model.Radius * this._valueToCoefficient(currentseries.yAxis, y);
            //var radius = this.chartObj.model.Radius * sf.EjSvgRender.utils._valueToPolarCoefficient(currentseries.yAxis, y);
            var point = this._valueToVector(currentseries.xAxis, x);
            return { X: sender.model.centerX + radius * point.X, Y: sender.model.centerY + radius * point.Y };
        },

        Transform3DToVisible: function (currentseries, x, y, sender) {
            if (currentseries.xAxis != null && currentseries.yAxis != null) {
                var valueType = currentseries.xAxis._valueType.toLowerCase(), xlogarithmicBase, Point;
                var xIsLogarithmic = (valueType == "logarithmic") ? true : false;
                x = x = xIsLogarithmic && x > 0 ? math.log(x, xlogarithmicBase) : x;
                y = y;

                if (sender.model.requireInvertedAxes) {
                    var left = sender.model.m_AreaBounds.X;
                    var top = sender.model.m_AreaBounds.Y;
                    var pointX = left + currentseries.yAxis.width * sf.EjSvgRender.utils._valueToCoefficient(currentseries.yAxis, y, sender);
                    var pointY = top + currentseries.xAxis.height * (1 - sf.EjSvgRender.utils._valueToCoefficient(currentseries.xAxis, x, sender))
                    return { X: pointX, Y: pointY }
                }
                else {
                    var left = currentseries.xAxis.x;
                    var top = currentseries.yAxis.y;
                    var x = left + Math.round(currentseries.xAxis.width * sf.EjSvgRender.utils._valueToCoefficient(currentseries.xAxis, x, sender));
                    var y = top + Math.round(currentseries.yAxis.height * (1 - sf.EjSvgRender.utils._valueToCoefficient(currentseries.yAxis, y, sender)));
                    return { X: x, Y: y }
                }
            }

            return new Point(0, 0);
        },

        _valueToPolarCoefficient: function (axis, value) {
            var start = axis.visibleRange.min;
            var delta;
            var length, result;
            if (axis._valueType != "category") {
                delta = (axis.visibleRange.max - axis.visibleRange.interval) - axis.visibleRange.min;
                length = axis.visibleLabels.length - 1;
            }
            else {
                delta = axis.visibleRange.delta;
                length = axis.visibleLabels.length;
            }

            result = (value - start) / delta;
            result *= 1 - 1 / (length);
            result = isNaN(result) ? 0 : result;

            return axis.isInversed ? result : 1 - result;
        },

        _coefficientToVector: function (coefficient) {
            var angle = Math.PI * (1.5 - 2 * coefficient);

            return { X: Math.cos(angle), Y: Math.sin(angle) };
        },


        _valueToCoefficient: function (axis, value, sender) {
            if (sender && sender.model.AreaType == 'polaraxes') {
                var yvalue = value;
            }
            else
                var yvalue = (axis._valueType && axis._valueType.toLowerCase() == "logarithmic") ?
                    sf.EjSvgRender.utils._logBase((value == 0 ? 1 : value), axis.logBase) : value;

            yvalue = (yvalue - axis.visibleRange.min) / (axis.visibleRange.delta);

            return (axis.isInversed) ? 1 - yvalue : yvalue;
        },
        _getBoundingClientRect: function (element, sender, series, invertedAxes) {
            var box = element.getBoundingClientRect();
            var position = $("#" + (sender.svgObject.id))[0].getBoundingClientRect();
            var xSeries, ySeries;
            if (invertedAxes) {
                xSeries = this._getTransform(series.xAxis, series.yAxis, true).x;
                ySeries = this._getTransform(series.xAxis, series.yAxis, true).y;
            } else {
                xSeries = this._getTransform(series.xAxis, series.yAxis, false).x;
                ySeries = this._getTransform(series.xAxis, series.yAxis, false).y;
            }
            var x = box.left - (xSeries + position.left);
            var y = box.top - (ySeries + position.top);
            return { x: x, y: y, width: (box.right - box.left), height: (box.bottom - box.top) };
        },
        _minMax: function (value, min, max) {
            return value > max ? max : (value < min ? min : value);
        },
        _inside: function (value, range) {
            if (value === "")
                return false;
            return (value <= range.max) && (value >= range.min);
        },
        _logBase: function (val, base) {
            return Math.log(val) / Math.log(base);
        },
        _correctRect: function (x1, y1, x2, y2) {
            return { X: Math.min(x1, x2), Y: Math.min(y1, y2), Width: Math.abs(x2 - x1), Height: Math.abs(y2 - y1) };
        },
        _getValuebyPoint: function (x, y, series, requireInvertedAxes) {

            var xSize = (requireInvertedAxes) ? series.xAxis.height : series.xAxis.width;
            var ySize = (requireInvertedAxes) ? series.yAxis.width : series.yAxis.height;

            var xValue = (series.xAxis.isInversed) ? (1 - (x / xSize)) : (x / xSize);
            var yValue = (series.yAxis.isInversed) ? (1 - (y / ySize)) : (y / ySize);

            xValue = xValue * (series.xAxis.visibleRange.delta) + series.xAxis.visibleRange.min;

            yValue = yValue * (series.yAxis.visibleRange.delta) + series.yAxis.visibleRange.min;

            xValue = (series.xAxis._valueType == "logarithmic") ? Math.pow(series.xAxis.logBase, xValue) : xValue;

            yValue = (series.yAxis._valueType == "logarithmic") ? Math.pow(series.yAxis.logBase, yValue) : yValue;

            return { PointX: xValue, PointY: yValue };

        }

    };
    sf.EjSvgRender.chartTransform3D = {
        ToRadial: Math.PI / 180,

        transform3D: function (size) {
            if (!this.vector) {
                this.vector = new (new sf.Ej3DRender()).vector3D();
                this.matrixobj = new (new sf.Ej3DRender()).matrix3D();
                this.bsptreeobj = new (new sf.Ej3DRender()).BSPTreeBuilder();
                this.polygon = new (new sf.Ej3DRender()).polygon3D();
            }
            return {
                mViewport: size,
                Rotation: 0,
                Tilt: 0,
                Depth: 0,
                PerspectiveAngle: 0,
                needUpdate: true,
                centeredMatrix: this.matrixobj.getIdentity(),
                Perspective: this.matrixobj.getIdentity(),
                resultMatrix: this.matrixobj.getIdentity(),
                viewMatrix: this.matrixobj.getIdentity(),
                Depth: 0
            };
        },

        transform: function (trans) {
            this.setCenter(this.vector.vector3D(trans.mViewport.Width / 2, trans.mViewport.Height / 2, trans.Depth / 2), trans);
            this.setViewMatrix(this.matrixobj.transform(0, 0, trans.Depth), trans)
            this.setViewMatrix(this.matrixobj.getMatrixMultiplication(trans.viewMatrix, this.matrixobj.turn(-this.ToRadial * trans.Rotation)), trans);
            this.setViewMatrix(this.matrixobj.getMatrixMultiplication(trans.viewMatrix, this.matrixobj.tilt(-this.ToRadial * trans.Tilt)), trans);
            this.updatePerspective(trans.PerspectiveAngle, trans);
            trans.needUpdate = true;

        },

        updatePerspective: function (angle, trans) {
            var width = (((trans.mViewport.Width + trans.mViewport.Height) * Math.tan(this.degreeToRadianConverter((180 - Math.abs(angle % 181)) / 2.0))) + (trans.Depth * 2) / 2);
            trans.Perspective[0][0] = width;
            trans.Perspective[1][1] = width;
            trans.Perspective[2][3] = 1;
            trans.Perspective[3][3] = width;

        },

        degreeToRadianConverter: function (degree) {
            return degree * Math.PI / 180;
        },
        toScreen: function (vector3D, trans, result, chartObj) {
            var result = result ? result : this.result;
            if (!chartObj) {
                trans.chartObj = this.matrixobj;
                vector3D = this.matrixobj.getMatrixVectorMutiple(result(trans), vector3D);
            }
            else {
                this.matrixobj = chartObj;
                vector3D = chartObj.getMatrixVectorMutiple(result(trans, chartObj), vector3D);
            }
            return { x: vector3D.x, y: vector3D.y };
        },

        setViewMatrix: function (value, trans) {
            if (trans.viewMatrix == value) return;
            trans.viewMatrix = value;
            trans.needUpdate = true;

        },

        setCenteredMatrix: function (value, trans) {
            if (trans.viewMatrix == value) return;
            trans.centeredMatrix = value;
            trans.needUpdate = true;

        },

        result: function (trans, matrixobj) {
            var chartObj = trans.chartObj ? trans.chartObj : this.matrixobj;
            if (!chartObj) chartObj = matrixobj;
            if (!trans.needUpdate) return trans.resultMatrix;
			var matrixObj =  this.matrixobj ? this.matrixobj : matrixobj;
            trans.resultMatrix = chartObj.getMatrixMultiplication(matrixObj.getInvertal(trans.centeredMatrix),
                trans.Perspective);
            trans.resultMatrix = chartObj.getMatrixMultiplication(trans.resultMatrix, trans.viewMatrix);
            trans.resultMatrix = chartObj.getMatrixMultiplication(trans.resultMatrix, trans.centeredMatrix);
            trans.needUpdate = false;

            return trans.resultMatrix;
        },


        setCenter: function (center, trans) {
            trans.centeredMatrix = this.matrixobj.transform(-center.x, -center.y, -center.z);
            trans.needUpdate = true;
        },
        toPlane: function (point, plane, trans) {
            var vec1 = this.vector.vector3D(point.x, point.y, 0);
            var vec2 = this.vector.vector3DPlus(vec1, this.vector.vector3D(0, 0, 1));

            vec1 = this.vector.vector3DMultiply(trans.centeredMatrix, vec1);
            vec2 = this.vector.vector3DMultiply(trans.centeredMatrix, vec2);

            vec1 = this.vector.vector3DMultiply(this.matrixobj.getInvertal(trans.Perspective), vec1);
            vec2 = this.vector.vector3DMultiply(this.matrixobj.getInvertal(trans.Perspective), vec2);

            vec1 = this.polygon.getPoint(vec1, this.vector.vector3DMinus(vec2 - vec1));

            vec1 = this.vector.vector3DMultiply(this.matrixobj.getInvertal(trans.viewMatrix), vec1);
            vec1 = this.vector.vector3DMultiply(this.matrixobj.getInvertal(trans.centeredMatrix), vec1);

            return vec1;
        }

    };
    sf.EjSvgRender.chartSymbol =
        {
            _drawSeriesType: function (location, symbolStyle, sender) {
                var seriesType = sender.model.series[symbolStyle.SeriesIndex].type.toLowerCase();
                var trendlinetype = sender.legendItem.drawType;
                seriesType = sf.util.isNullOrUndefined(trendlinetype) ? seriesType : trendlinetype;
                switch (seriesType) {
                    case sf.datavisualization.Chart.Type.Line: {
                        var line;
                        if (sf.util.isNullOrUndefined(trendlinetype))
                            line = this._drawLine(location, symbolStyle, sender, sender.gLegendItemEle);
                        else
                            line = this._drawStraightLine(location, symbolStyle, sender, sender.gLegendItemEle);
                        return line;
                    }

                    case sf.datavisualization.Chart.Type.StepLine:
                        return this._drawStepLine(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.StackingArea:
                    case sf.datavisualization.Chart.Type.StackingArea100:
                    case sf.datavisualization.Chart.Type.Area:
                    case sf.datavisualization.Chart.Type.RangeArea:
                        return this._drawArea(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.StepArea:
                        return this._drawStepArea(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.Bar:
                    case sf.datavisualization.Chart.Type.StackingBar100:
                    case sf.datavisualization.Chart.Type.StackingBar:
                        return this._drawBar(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.Pie:
                        return this._drawPie(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.Doughnut:
                        return this._drawDoughnut(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.Hilo:
                        return this._drawHilo(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.HiloOpenClose:
                        return this._drawHiloOpenClose(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.Candle:
                        return this._drawCandle(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.Pyramid:
                        return this._drawPyramid(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.Funnel:
                        return this._drawFunnel(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.Spline:
                        return this._drawSpline(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.SplineArea:
                    case sf.datavisualization.Chart.Type.StackingSplineArea:
                    case sf.datavisualization.Chart.Type.StackingSplineArea100:
                        return this._drawSplineArea(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.RangeColumn:
                        return this._drawRangeColumn(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.Bubble:
                    case sf.datavisualization.Chart.Type.Scatter:
                        return this._drawCircle(location, symbolStyle, sender, sender.gLegendItemEle);

                    case sf.datavisualization.Chart.Type.Column:
                    case sf.datavisualization.Chart.Type.StackingColumn:
                    case sf.datavisualization.Chart.Type.StackingColumn100:
                    case sf.datavisualization.Chart.Type.Waterfall:
                        return this._drawColumn(location, symbolStyle, sender, sender.gLegendItemEle);

                    default:
                        return this._drawRectangle(location, symbolStyle, sender, sender.gLegendItemEle);

                }

            },

            _drawCircle: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer, svgObj = sender.svgObject, style = symbolStyle.ShapeSize,
                    radius = Math.sqrt(style.height * style.height + style.width * style.width) / 2,
                    symbolstyleStyle = symbolStyle.Style;

                var options = {
                    'id': symbolStyle.ID,
                    'cx': location.startX,
                    'cy': location.startY,
                    'r': radius,
                    'fill': symbolstyleStyle.Color,
                    'stroke-width': symbolstyleStyle.BorderWidth,
                    'stroke': symbolstyleStyle.BorderColor,
                    'opacity': symbolstyleStyle.Opacity,
                    'visibility': symbolstyleStyle.Visibility,
                    'lgndCtx': symbolStyle.context
                };

                svgRender.drawCircle(options, element);

                return (location.startX - radius);
            },

            _drawLeftArrow: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var path;
                path = "M" + " " + ((location.startX - (style.width / 2)) + style.width) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + style.width) + " " + (location.startY + (-style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (-style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + ((location.startX - (style.width / 2))) + " " + (location.startY) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + style.width) + " " + (location.startY + (style.height / 4)) + " z";
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };

                svgRender.drawPath(options, element);

            },


            _drawRightArrow: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var path;
                path = "M" + " " + ((location.startX - (style.width / 2))) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2))) + " " + (location.startY + (-style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (-style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + style.width) + " " + (location.startY) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2))) + " " + (location.startY + (style.height / 4)) + " z";
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };


                svgRender.drawPath(options, element);


            },


            _drawUpArrow: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var path;
                path = "M" + " " + ((location.startX - (style.width / 2) + (style.width / 4))) + " " + (location.startY - (style.height / 2) + (style.height)) + " " + "L" + " " + ((location.startX - (style.width / 2) + (style.width / 4))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX - (style.width / 2))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX)) + " " + (location.startY - (style.height / 2)) + " " + "L" + " " + ((location.startX + (style.width / 2))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX + (style.width / 2) - (style.width / 4))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX + (style.width / 2) - (style.width / 4))) + " " + (location.startY - (style.height / 2) + (style.height)) + " " + "L" + " " + ((location.startX - (style.width / 2) + (style.width / 4))) + " " + (location.startY - (style.height / 2) + (style.height)) + " z";
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };


                svgRender.drawPath(options, element);


            },

            _drawDownArrow: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var path;
                path = "M" + " " + ((location.startX - (style.width / 2) + (style.width / 4))) + " " + (location.startY - (style.height / 2)) + " " + "L" + " " + ((location.startX + (style.width / 2) - (style.width / 4))) + " " + (location.startY - (style.height / 2)) + " " + "L" + " " + ((location.startX + (style.width / 2) - (style.width / 4))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX + (style.width / 2))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX)) + " " + (location.startY - (style.height / 2) + (style.height)) + " " + "L" + " " + ((location.startX - (style.width / 2))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX - (style.width / 2) + (style.width / 4))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX - (style.width / 2) + (style.width / 4))) + " " + (location.startY - (style.height / 2)) + " z";
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };


                svgRender.drawPath(options, element);

            },

            _drawCross: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;

                var path;
                path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY) + " " +
                    "M" + " " + (location.startX) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (-style.height / 2));
                var options = {
                    'id': symbolStyle.ID,
                    'opacity': symbolStyle.Style.Opacity,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.Color,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };

                svgRender.drawPath(options, element);

            },

            _drawHorizLine: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;

                var path;
                path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY);
                var options = {
                    'id': symbolStyle.ID,
                    'opacity': symbolStyle.Style.Opacity,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.Color,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };

                svgRender.drawPath(options, element);


            },
            _drawVertLine: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var path;
                path = "M" + " " + (location.startX) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (-style.height / 2));
                var options = {
                    'id': symbolStyle.ID,
                    'opacity': symbolStyle.Style.Opacity,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.Color,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };


                svgRender.drawPath(options, element);

            },

            _drawTriangle: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var path;
                path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (style.height / 2)) + " z";
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };

                svgRender.drawPath(options, element);

            },

            _drawInvertedTriangle: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;

                var path;
                path = "M" + " " + (location.startX + (style.width / 2)) + " " + (location.startY - (style.height / 2)) + " "
                    + "L" + " " + (location.startX) + " " + (location.startY + (style.height / 2)) + " "
                    + "L" + " " + (location.startX - (style.width / 2)) + " " + (location.startY - (style.height / 2)) + " "
                    + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY - (style.height / 2)) + " z";
                var x = location.startX;
                var y = location.startY;
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };

                svgRender.drawPath(options, element);


            },

            _drawHexagon: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;

                var path;
                path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (-style.width / 4)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 4)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (style.width / 4)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 4)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " z";
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };

                svgRender.drawPath(options, element);

            },

            _drawWedge: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;

                var path;
                path = "M" + " " + (location.startX - style.width) + " " + (location.startY) + " " + "L" + " " + (location.startX + style.width) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (3 * (style.width / 4))) + " " + (location.startY) + " " + "L" + " " + (location.startX + (style.width)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX - style.width) + " " + (location.startY) + " z";
                var options = {
                    'stroke-linecap': 'miter',
                    'stroke-miterlimit': style.width / 4,
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };

                svgRender.drawPath(options, element);

            },

            _drawPentagon: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;

                var eq = 72;
                var radius = Math.sqrt(style.height * style.height + style.width * style.width) / 2;
                var sb = sf.EjSvgRender.utils._getStringBuilder();
                for (var i = 0; i <= 5; i++) {
                    var deg = i * eq;
                    var rad = (Math.PI / 180) * deg;
                    var x1 = radius * Math.cos(rad);
                    var y1 = radius * Math.sin(rad);
                    if (i == 0)
                        sb.append("M" + " " + (location.startX + x1) + " " + (location.startY + y1) + " ");

                    else
                        sb.append("L" + " " + (location.startX + x1) + " " + (location.startY + y1) + " ");


                }
                sb.append("z");
                var path = sb.toString();
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };

                svgRender.drawPath(options, element);


            },

            _drawStar: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var style = symbolStyle.ShapeSize;
                var svgObj = sender.svgObject;

                var path;
                path = "M" + " " + (location.startX + (style.width / 3)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (style.height / 6)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 6)) + " " + "L" + " " + (location.startX + (-style.width / 3)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 3)) + " " + (location.startY + (-style.height / 2)) + " z";
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };

                svgRender.drawPath(options, element);


            },

            _drawRectangle: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;

                var path;
                path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (-style.height / 2)) + " z";
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };

                svgRender.drawPath(options, element);
            },

            _drawTrapezoid: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;

                var path;
                path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (-style.height / 4)) + " " + "L" + " " + (location.startX + (-style.width / 2) + (style.width)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2) + (style.width)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " z";
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };

                svgRender.drawPath(options, element);

            },

            _drawDiamond: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;

                var path;
                path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " " + "L" + " " + (location.startX) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY) + " " + "L" + " " + (location.startX) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " z";

                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'd': path
                };

                svgRender.drawPath(options, element);


            },
            _drawEllipse: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;

                var x = location.startX;
                var y = location.startY;
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'lgndCtx': symbolStyle.context,
                    'cx': x,
                    'cy': y,
                    'rx': style.width,
                    'ry': style.height / 2
                };


                svgRender.drawEllipse(options, element);


            },
            _drawImage: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var x = location.startX + (-style.width / 2);
                var y = location.startY + (-style.width / 2);
                var width = style.width;
                var height = style.height;
                var options = {
                    'id': svgObj.id + '_image' + symbolStyle.PointIndex, 'height': height, 'width': width, 'href': symbolStyle.Imageurl,
                    'x': x, 'y': y, 'visibility': 'visible', 'lgndCtx': symbolStyle.context
                };

                svgRender.drawImage(options, element);


            },

            _drawStraightLine: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var elementspace = symbolStyle.ElementSpace;
                var path;

                path = "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 10)) + " " +
                    "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 10));
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth * 2,
                    'stroke': symbolStyle.Style.Color,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };
                svgRender.drawPath(options, element);
                return (location.startX + (-style.width / 2) + (-elementspace / 4));
            },

            _drawLine: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var elementspace = symbolStyle.ElementSpace;
                var path;

                if (sender.model.enableCanvasRendering === true) {
                    path = "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 10)) + " " + "L" + " " + (location.startX - Math.floor(style.width / 3)) + " " + (location.startY + (style.height / 10)) + " " + "M" + " " + (location.startX + Math.floor(style.width / 3)) + " " + (location.startY + (style.height / 10)) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 10));
                    var options = {
                        'id': symbolStyle.ID,
                        'fill': symbolStyle.Style.Color,
                        'stroke-width': symbolStyle.Style.BorderWidth * 2,
                        'stroke': symbolStyle.Style.Color,
                        'opacity': symbolStyle.Style.Opacity,
                        'visibility': symbolStyle.Style.Visibility,
                        'd': path,
                        'lgndCtx': true
                    };
                    var circlepath = "M" + " " + (location.startX - Math.floor(style.width / 3)) + " " + (location.startY + (style.height / 10)) + " " + "a " + (Math.floor(style.width / 3)) + " " + (Math.floor(style.width / 3)) + " " + 0 + " " + 1 + " " + 0 + " " + 2 * (Math.floor(style.width / 3)) + " " + 0 + " " + "a" + (Math.floor(style.width / 3)) + " " + (Math.floor(style.width / 3)) + " " + 0 + " " + 1 + " " + 0 + " " + (-2 * (Math.floor(style.width / 3))) + " " + 0;
                    var circleoptions = {
                        'id': symbolStyle.ID,
                        'fill': "transparent",
                        'stroke-width': symbolStyle.Style.BorderWidth * 2,
                        'stroke': symbolStyle.Style.Color,
                        'opacity': symbolStyle.Style.Opacity,
                        'visibility': symbolStyle.Style.Visibility,
                        'd': circlepath,
                        'lgndCtx': true
                    };

                    svgRender.drawPath(options, element);
                    svgRender.drawPath(circleoptions, element);
                }
                else {
                    path = "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 10)) + " " + "L" + " " + (location.startX - Math.floor(style.width / 3)) + " " + (location.startY + (style.height / 10)) + " " + "M" + " " + (location.startX + Math.floor(style.width / 3)) + " " + (location.startY + (style.height / 10)) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 10)) + " " + "M" + " " + (location.startX - Math.floor(style.width / 3)) + " " + (location.startY + (style.height / 10)) + " " + "a " + (Math.floor(style.width / 3)) + " " + (Math.floor(style.width / 3)) + " " + 0 + " " + 1 + " " + 0 + " " + 2 * (Math.floor(style.width / 3)) + " " + 0 + " " + "a" + (Math.floor(style.width / 3)) + " " + (Math.floor(style.width / 3)) + " " + 0 + " " + 1 + " " + 0 + " " + (-2 * (Math.floor(style.width / 3))) + " " + 0;
                    var options = {
                        'id': symbolStyle.ID,
                        'fill': "transparent",
                        'stroke-width': symbolStyle.Style.BorderWidth * 2,
                        'stroke': symbolStyle.Style.Color,
                        'opacity': symbolStyle.Style.Opacity,
                        'visibility': symbolStyle.Style.Visibility,
                        'd': path,
                        'lgndCtx': true
                    };
                    svgRender.drawPath(options, element);
                }
                return (location.startX + (-style.width / 2) + (-elementspace / 4));

            },
            _drawColumn: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var elementspace = symbolStyle.ElementSpace;
                var path;
                path = "M" + " " + (location.startX - 3 * (style.width / 5)) + " " + (location.startY - (style.height / 5)) + " " + "L" + " " + (location.startX + 3 * (-style.width / 10)) + " " + (location.startY - (style.height / 5)) + " " + "L" + " " + (location.startX + 3 * (-style.width / 10)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX - 3 * (style.height / 5)) + " " + (location.startY + (style.height / 2)) + " " + "Z" + " " + "M" + " " + (location.startX + (-style.width / 10) - (style.width / 20)) + " " + (location.startY - (style.height / 4) - (elementspace / 2)) + " " + "L" + " " + (location.startX + (style.width / 10) + (style.width / 20)) + " " + (location.startY - (style.height / 4) - (elementspace / 2)) + " " + "L" + " " + (location.startX + (style.width / 10) + (style.width / 20)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 10) - (style.width / 20)) + " " + (location.startY + (style.height / 2)) + " " + "Z" + " " + "M" + " " + (location.startX + 3 * (style.width / 10)) + " " + (location.startY) + " " + "L" + " " + (location.startX + 3 * (style.width / 5)) + " " + (location.startY) + " " + "L" + " " + (location.startX + 3 * (style.width / 5)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + 3 * (style.width / 10)) + " " + (location.startY + (style.height / 2)) + " " + "Z";

                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };

                svgRender.drawPath(options, element);

                return (location.startX - 3 * (style.width / 5));

            },
            _drawRangeColumn: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var elementspace = symbolStyle.ElementSpace;
                var path;
                path = "M" + " " + (location.startX + (-style.width / 5)) + " " + (location.startY + (style.height / 2) + (elementspace / 4)) + " " + "L" + " " + (location.startX + (-style.width / 5)) + " " + (location.startY - (style.height / 2) - (elementspace / 4)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (-style.height / 2) + (-elementspace / 4)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2) + (elementspace / 4)) + " " + "Z";

                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };

                svgRender.drawPath(options, element);

                return (location.startX + (-style.width / 5));

            },

            _drawBar: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var elementspace = symbolStyle.ElementSpace;
                var path;

                path = "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY - 3 * (style.height / 5)) + " " + "L" + " " + (location.startX + 3 * (style.width / 10)) + " " + (location.startY - 3 * (style.height / 5)) + " " + "L" + " " + (location.startX + 3 * (style.width / 10)) + " " + (location.startY - 3 * (style.height / 10)) + " " + "L" + " " + (location.startX - (style.width / 2) + (-elementspace / 4)) + " " + (location.startY - 3 * (style.height / 10)) + " " + "Z" + " " + "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY - (style.height / 5) + (elementspace / 20)) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY - (style.height / 5) + (elementspace / 20)) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 10) + (elementspace / 20)) + " " + "L" + " " + (location.startX - (style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 10) + (elementspace / 20)) + " " + "Z" + " " + "M" + " " + (location.startX - (style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 5) + (elementspace / 10)) + " " + "L" + " " + (location.startX + (-style.width / 4)) + " " + (location.startY + (style.height / 5) + (elementspace / 10)) + " " + "L" + " " + (location.startX + (-style.width / 4)) + " " + (location.startY + (style.height / 2) + (elementspace / 10)) + " " + "L" + " " + (location.startX - (style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 2) + (elementspace / 10)) + " " + "Z";
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };

                svgRender.drawPath(options, element);

                return (location.startX + (-style.width / 2) + (-elementspace / 4));

            },

            _drawStepLine: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var elementspace = symbolStyle.ElementSpace;
                var path;

                path = "M" + " " + (location.startX + (-style.width / 2) - (elementspace / 4)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2) + (style.width / 10)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2) + (style.width / 10)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (-style.width / 10)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (-style.width / 10)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 5)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 5)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (-style.height / 2)) + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + "L" + "" + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 2));
                var options = {
                    'id': symbolStyle.ID,
                    'fill': "transparent",
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.Color,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };

                svgRender.drawPath(options, element);

                return (location.startX + (-style.width / 2) - (elementspace / 4));

            },
            _drawSpline: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var path;
                path = "M" + " " + (location.startX - (style.width / 2)) + " " + (location.startY + (style.height / 5)) + " " + "Q" + " " + location.startX + " " + (location.startY - style.height) + " " + location.startX + " " + (location.startY + (style.height / 5)) + " " + "M" + " " + location.startX + " " + (location.startY + (style.height / 5)) + " " + "Q" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + (location.startX + (style.width / 2)) + " " + (location.startY - (style.height / 2));
                var options = {
                    'id': symbolStyle.ID,
                    'fill': "transparent",
                    'stroke-width': symbolStyle.Style.BorderWidth * 2,
                    'stroke': symbolStyle.Style.Color,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };

                svgRender.drawPath(options, element);

                return (location.startX - (style.width / 2));

            },
            _drawSplineArea: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var path;
                path = "M" + " " + (location.startX - (style.width / 2)) + " " + (location.startY + (style.height / 5)) + " " + "Q" + " " + location.startX + " " + (location.startY - style.height) + " " + location.startX + " " + (location.startY + (style.height / 5)) + " " + "Z" + " " + "M" + " " + location.startX + " " + (location.startY + (style.height / 5)) + " " + "Q" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + (location.startX + (style.width / 2)) + " " + (location.startY - (style.height / 2)) + " " + " Z";
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.Color,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };

                svgRender.drawPath(options, element);

                return (location.startX - (style.width / 2));

            },
            _drawArea: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var elementspace = symbolStyle.ElementSpace;
                var path;
                path = "M" + " " + (location.startX - (style.width / 2) - (elementspace / 4)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 4) + (-elementspace / 8)) + " " + (location.startY - (style.height / 2)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + (location.startX + (style.width / 4) + (elementspace / 8)) + " " + (location.startY + (-style.height / 2) + (style.height / 4)) + " " + "L" + " " + (location.startX + (style.height / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 2)) + " " + "Z";

                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };

                svgRender.drawPath(options, element);

                return (location.startX - (style.width / 2) - (elementspace / 4));

            },
            _drawStepArea: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var elementspace = symbolStyle.ElementSpace;
                var path;

                path = "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX - (style.width / 4)) + " " + (location.startY - (style.height / 2)) + " " + "L" + " " + (location.startX - (style.width / 4)) + " " + (location.startY - (style.height / 4)) + " " + "L" + " " + (location.startX + (style.width / 4)) + " " + (location.startY - (style.height / 4)) + " " + "L" + " " + (location.startX + (style.width / 4)) + " " + (location.startX) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 2)) + " " + "Z";
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };

                svgRender.drawPath(options, element);

                return (location.startX + (-style.width / 2) + (-elementspace / 4));

            },
            _drawPyramid: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var elementspace = symbolStyle.ElementSpace;
                var path;
                path = "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 2) + (elementspace / 8)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (-style.height / 2) + (-elementspace / 8)) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 2) + (elementspace / 8)) + " " + "Z";

                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };

                svgRender.drawPath(options, element);

                return (location.startX + (-style.width / 2) + (-elementspace / 4));


            },
            _drawFunnel: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var elementspace = symbolStyle.ElementSpace;
                var path;
                path = "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 5)) + " " + (location.startY + (-style.height / 2) + (-elementspace / 4)) + " " + "L" + " " + (location.startX + (-style.width / 5)) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + (location.startX + (-style.width / 5)) + " " + (location.startY + (style.height / 2) + (elementspace / 4)) + " " + "L" + " " + (location.startX + (style.width / 5)) + " " + (location.startY + (style.height / 2) + (elementspace / 4)) + " " + "L" + " " + (location.startX + (style.width / 5)) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 5)) + " " + (location.startY + (-style.height / 2) + (-elementspace / 4)) + " " + "Z";

                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };

                svgRender.drawPath(options, element);

                return (location.startX + (-style.width / 2) + (-elementspace / 5));

            },
            _drawCandle: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var elementspace = symbolStyle.ElementSpace;
                var path;

                path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (style.height / 4) + (elementspace / 8)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 4) + (elementspace / 8)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (-style.height / 2) + (elementspace / 8)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (-style.height / 2) + (elementspace / 8)) + " " + "Z" + " " + "M" + " " + (location.startX) + " " + (location.startY + (-style.height / 2) + (elementspace / 8)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (-style.height / 2) + (-elementspace / 4)) + " " + "M" + " " + (location.startX) + " " + (location.startY + (style.height / 4) + (elementspace / 8)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (style.height / 4) + (elementspace / 2));
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.Color,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };

                svgRender.drawPath(options, element);

                return (location.startX + (-style.width / 2));

            },
            _drawHilo: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var elementspace = symbolStyle.ElementSpace;
                var path;
                path = "M" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2) + (elementspace / 4)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (-style.height / 2) + (-elementspace / 4));
                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.Color,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };

                svgRender.drawPath(options, element);

                return (location.startX + (style.width / 2));

            },
            _drawHiloOpenClose: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var cartesian = polarToCartesian(18, 12, 4.0710678118654755, 270);
                var elementspace = symbolStyle.ElementSpace;
                var path;

                path = "M" + " " + (location.startX) + " " + (location.startY - 3 * (style.height / 10)) + " " + "L" + " " + (location.startX - (style.width / 2) - (elementspace / 4)) + " " + (location.startY - 3 * (style.height / 10)) + " " + "M" + " " + (location.startX) + " " + (location.startY - (style.height / 2) - (elementspace / 4)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (style.height / 2) + (elementspace / 4)) + " " + "M" + " " + (location.startX) + " " + (location.startY + 3 * (style.height / 10)) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + 3 * (style.height / 10));
                var options = {
                    'id': symbolStyle.ID,
                    'fill': "transparent",
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.Color,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };

                svgRender.drawPath(options, element);

                return ((location.startX) - (style.width / 2));

            },

            _drawDoughnut: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var elementspace = symbolStyle.ElementSpace;
                var radius = Math.sqrt(style.height * style.width) / 2;
                radius = radius + (elementspace / 5);
                var cartesianlarge = polarToCartesian(location.startX, location.startY, radius, 270);
                var cartesiansmall = polarToCartesian(location.startX + (style.width / 10), location.startY, radius, 270);
                var elementspace = symbolStyle.ElementSpace;
                var path = "M" + " " + location.startX + " " + location.startY + " " + "L" + " " + (location.startX + radius) + " " + (location.startY) + " " + "A" + " " + (radius) + " " + (radius) + " " + 0 + " " + 1 + " " + 1 + " " + cartesianlarge[0] + " " + cartesianlarge[1] + " " + "Z" + " " + "M" + " " + (location.startX + (style.width / 10)) + " " + (location.startY - (style.height / 10)) + " " + "L" + (location.startX + (radius)) + " " + (location.startY - style.height / 10) + " " + "A" + " " + (radius) + " " + (radius) + " " + 0 + " " + 0 + " " + 0 + " " + cartesiansmall[0] + " " + cartesiansmall[1] + " " + "Z";

                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };
                var circle = {
                    'id': symbolStyle.ID, 'cx': location.startX, 'cy': location.startY, 'r': (radius / 2), 'lgndCtx': true,
                    'fill': "white", 'stroke-width': symbolStyle.Style.BorderWidth, 'stroke': symbolStyle.Style.BorderColor, 'opacity': symbolStyle.Style.Opacity, 'visibility': symbolStyle.Style.Visibility
                };

                svgRender.drawPath(options, element);
                svgRender.drawCircle(circle, element);

                return (location.startX - radius);
            },

            _drawPie: function (location, symbolStyle, sender, element) {
                var svgRender = sender.svgRenderer;
                var svgObj = sender.svgObject;
                var style = symbolStyle.ShapeSize;
                var elementspace = symbolStyle.ElementSpace;
                var radius = Math.sqrt(style.height * style.width) / 2;
                radius = radius + (elementspace / 5);
                var cartesianlarge = polarToCartesian(location.startX, location.startY, radius, 270);
                var cartesiansmall = polarToCartesian(location.startX + (style.width / 10), location.startY, radius, 270);
                var elementspace = symbolStyle.ElementSpace;
                var path = "M" + " " + location.startX + " " + location.startY + " " + "L" + " " + (location.startX + radius) + " " + (location.startY) + " " + "A" + " " + (radius) + " " + (radius) + " " + 0 + " " + 1 + " " + 1 + " " + cartesianlarge[0] + " " + cartesianlarge[1] + " " + "Z" + " " + "M" + " " + (location.startX + (style.width / 10)) + " " + (location.startY - (style.height / 10)) + " " + "L" + (location.startX + (radius)) + " " + (location.startY - style.height / 10) + " " + "A" + " " + (radius) + " " + (radius) + " " + 0 + " " + 0 + " " + 0 + " " + cartesiansmall[0] + " " + cartesiansmall[1] + " " + "Z";

                var options = {
                    'id': symbolStyle.ID,
                    'fill': symbolStyle.Style.Color,
                    'stroke-width': symbolStyle.Style.BorderWidth,
                    'stroke': symbolStyle.Style.BorderColor,
                    'opacity': symbolStyle.Style.Opacity,
                    'visibility': symbolStyle.Style.Visibility,
                    'd': path,
                    'lgndCtx': true
                };

                svgRender.drawPath(options, element);
                return (location.startX - radius);
            }

        };
    function polarToCartesian(startX, startY, radius, angleInDegrees) {
        var angleInRadians = angleInDegrees * Math.PI / 180.0;
        var x = startX + radius * Math.cos(angleInRadians);
        var y = startY + radius * Math.sin(angleInRadians);
        return [x, y];
    }
    sf.EjSvgRender.seriesPalette = {
        defaultMetro: ["#E94649", "#F6B53F", "#6FAAB0", "#C4C24A", "#FB954F", "#005277", "#8BC652", "#69D2E7", "#E27F2D", "#6A4B82"],
        defaultHighContrast: ["#F93A00", "#44E2D6", "#DDD10D", "#0AA368", "#0556CB", "#AB40B2", "#5F930A", "#D12E41", "#E0670E", "#008FFF"],
        defaultOffice: ["#005277", "#8BC652", "#6A4B82", "#E94649", "#6FAAB0", "#F7B74F", "#C4C24A", "#EF863F", "#69D2E7", "#FFD13E"],
        defaultMaterial: ["#663AB6", "#EB3F79", "#F8AB1D", "#B82E3D", "#049CB1", "#F2424F", "#C2C924", "#3DA046", "#074D67", "#02A8F4"],
        defaultGradient:
            {
                borderColors: ["#F34649", "#F6D321", "#6EB9B0", "#CBC26A", "#FBAF4F", "#E2CDB1", "#FFC0B7", "#68E1E6", "#E1A62D", "#9C6EBF"],
                seriesColors: [[{ color: "#F34649", colorStop: "0%" }, { color: "#B74143", colorStop: "100%" }],
                [{ color: "#F6D321", colorStop: "0%" }, { color: "#F6AE26", colorStop: "100%" }],
                [{ color: "#6EB9B0", colorStop: "0%" }, { color: "#3F77BD", colorStop: "100%" }],
                [{ color: "#CBC26A", colorStop: "0%" }, { color: "#9AAD21", colorStop: "100%" }],
                [{ color: "#FBAF4F", colorStop: "0%" }, { color: "#F07542", colorStop: "100%" }],
                [{ color: "#E2CDB1", colorStop: "0%" }, { color: "#AAA089", colorStop: "100%" }],
                [{ color: "#8BC652", colorStop: "0%" }, { color: "#6F9E41", colorStop: "100%" }],
                [{ color: "#68E1E6", colorStop: "0%" }, { color: "#3D9CBE", colorStop: "100%" }],
                [{ color: "#E1A62D", colorStop: "0%" }, { color: "#B66824", colorStop: "100%" }],
                [{ color: "#9C6EBF", colorStop: "0%" }], [{ color: "#593F6D", colorStop: "100%" }]]
            },
        blueMetro: ["#005378", "#006691", "#007EB5", "#0D97D4", "#00AEFF", "#14B9FF", "#54CCFF", "#87DBFF", "#ADE5FF", "#C5EDFF"],
        blueGradient:
            {
                seriesColors: [[{ color: "#005277", colorStop: "0%" }, { color: "#00304F", colorStop: "100%" }],
                [{ color: "#006590", colorStop: "0%" }, { color: "#004068", colorStop: "100%" }],
                [{ color: "#007DB4", colorStop: "0%" }, { color: "#00558B", colorStop: "100%" }],
                [{ color: "#0D97D4", colorStop: "0%" }, { color: "#057FC7", colorStop: "100%" }],
                [{ color: "#00ADFE", colorStop: "0%" }, { color: "#008BE9", colorStop: "100%" }],
                [{ color: "#14B8FE", colorStop: "0%" }, { color: "#0798EB", colorStop: "100%" }],
                [{ color: "#53CBFF", colorStop: "0%" }, { color: "#35AFEB", colorStop: "100%" }],
                [{ color: "#86DAFF", colorStop: "0%" }, { color: "#64C0EC", colorStop: "100%" }],
                [{ color: "#ACE5FF", colorStop: "0%" }, { color: "#8DCEED", colorStop: "100%" }],
                [{ color: "#C4ECFF", colorStop: "0%" }], [{ color: "#A3D1E6", colorStop: "100%" }]],
                borderColors: ["#005277", "#006590", "#007DB4", "#0D97D4", "#00ADFE", "#14B8FE", "#53CBFF", "#86DAFF", "#ACE5FF", "#C4ECFF"]
            },
        greenMetro: ["#496612", "#597B15", "#709A1B", "#87B62A", "#9AD926", "#A6DC37", "#BCE654", "#C8E780", "#D5EFA5", "#E2F3BE"],
        greenGradient:
            {

                seriesColors: [[{ color: "#5C7F16", colorStop: "0%" }, { color: "#384C08", colorStop: "100%" }],
                [{ color: "#6A9319", colorStop: "0%" }, { color: "#486009", colorStop: "100%" }],
                [{ color: "#739D1C", colorStop: "0%" }, { color: "#57760B", colorStop: "100%" }],
                [{ color: "#90B546", colorStop: "0%" }, { color: "#6E9215", colorStop: "100%" }],
                [{ color: "#9AD826", colorStop: "0%" }, { color: "#75A010", colorStop: "100%" }],
                [{ color: "#A5DB36", colorStop: "0%" }, { color: "#8EB91D", colorStop: "100%" }],
                [{ color: "#BBE554", colorStop: "0%" }, { color: "#A4C849", colorStop: "100%" }],
                [{ color: "#C8E780", colorStop: "0%" }, { color: "#B4D072", colorStop: "100%" }],
                [{ color: "#D4EEA5", colorStop: "0%" }, { color: "#BFD593", colorStop: "100%" }],
                [{ color: "#E1F2BD", colorStop: "0%" }], [{ color: "#C8D7A8", colorStop: "100%" }]],
                borderColors: ["#5C7F16", "#6A9319", "#739D1C", "#90B546", "#9AD826", "#A5DB36", "#BBE554", "#C8E780", "#D4EEA5", "#E1F2BD"]
            },

        sandleMetro: ["#6C450C", "#82520D", "#A36812", "#C07F1F", "#E69719", "#E89A2B", "#EEB564", "#F3CB93", "#F7DEB4", "#F9E6CA"],
        sandleGradient:
            {


                seriesColors: [[{ color: "#7F602F", colorStop: "0%" }, { color: "#512D04", colorStop: "100%" }],
                [{ color: "#986827", colorStop: "0%" }, { color: "#673803", colorStop: "100%" }],
                [{ color: "#A16C1F", colorStop: "0%" }, { color: "#8A4B05", colorStop: "100%" }],
                [{ color: "#BF812A", colorStop: "0%" }, { color: "#AD630D", colorStop: "100%" }],
                [{ color: "#E49519", colorStop: "0%" }, { color: "#B86607", colorStop: "100%" }],
                [{ color: "#E7992A", colorStop: "0%" }, { color: "#D7780D", colorStop: "100%" }],
                [{ color: "#EDB463", colorStop: "0%" }, { color: "#D98F31", colorStop: "100%" }],
                [{ color: "#F2CA92", colorStop: "0%" }, { color: "#DAAC6F", colorStop: "100%" }],
                [{ color: "#F6DDB3", colorStop: "0%" }, { color: "#DABE8F", colorStop: "100%" }],
                [{ color: "#F8E5C9", colorStop: "0%" }], [{ color: "#DDBE92", colorStop: "100%" }]],
                borderColors: ["#7F602F", "#986827", "#A16C1F", "#BF812A", "#E49519", "#E7992A", "#EDB463", "#F2CA92", "#F6DDB3", "#F8E5C9"]

            }
    };

    sf.EjSvgRender.themes = {
        flatlight:
            {
                highlightColor: 'black',

                background: 'transparent',
                legend:
                    {
                        font: { color: "#282828" },
                        title:
                            {
                                font: { color: "#282828" }
                            }
                    },
                title:
                    {
                        font: { color: '#565656' },
                        subTitle:
                            {
                                font: { color: '#565656' }
                            }
                    },
                primaryXAxis:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        labelBorder:
                            {
                                color: "#8E8E8E"
                            },
                        multiLevelLabelsColor: "#8E8E8E",
                        multiLevelLabelsFontColor: "#282828",
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#282828' },
                        title:
                            {
                                font: { color: '#282828' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, border: { color: '#3D3D3D', width: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },
                secondaryX:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        labelBorder:
                            {
                                color: "#8E8E8E"
                            },
                        multiLevelLabelsColor: "#8E8E8E",
                        multiLevelLabelsFontColor: "#282828",
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#282828' },
                        title:
                            {
                                font: { color: '#282828' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, border: { color: '#3D3D3D', width: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },

                primaryYAxis:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        labelBorder: {
                            color: "#8E8E8E"
                        },
                        multiLevelLabelsColor: "#8E8E8E",
                        multiLevelLabelsFontColor: "#282828",
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#282828' },
                        title:
                            {
                                font: { color: '#282828' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, border: { color: '#3D3D3D', borderWidth: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },
                secondaryY:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        labelBorder: {
                            color: "#8E8E8E"
                        },
                        multiLevelLabelsColor: "#8E8E8E",
                        multiLevelLabelsFontColor: "#282828",
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#282828' },
                        title:
                            {
                                font: { color: '#282828' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, border: { color: '#3D3D3D', width: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },
                commonSeriesOptions:
                    {
                        marker: {
                            dataLabel: { font: { color: '#565656' } }
                        },
                        errorBar: {
                            fill: "#000000",
                            cap:
                                {
                                    fill: "#000000"
                                }
                        },
                        connectorLine: { color: '#565656' }
                    },
                crosshair:
                    {
                        line:
                            {
                                width: 1,
                                color: 'Black'
                            }
                    },

                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.defaultMetro,
                colors: sf.EjSvgRender.seriesPalette.defaultMetro

            },

        flatdark:
            {
                highlightColor: 'white',

                background: '#111111',

                legend:
                    {
                        font: { color: "#C9C9C9" },
                        title:
                            {
                                font: { color: "#C9C9C9" }
                            }
                    },
                title:
                    {
                        font: { color: '#C9C9C9' },
                        subTitle:
                            {
                                font: { color: '#C9C9C9' }
                            }
                    },
                primaryXAxis:
                    {
                        majorGridLines:
                            {
                                color: "#333333"
                            },
                        majorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        minorGridLines:
                            {
                                color: "#333333"
                            },
                        minorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        labelBorder: {
                            color: "#AAAAAA"
                        },
                        multiLevelLabelsColor: "#AAAAAA",
                        multiLevelLabelsFontColor: "#C9C9C9",
                        axisLine: { color: '#AAAAAA' },
                        font: { color: '#C9C9C9' },
                        title:
                            {

                                font: { color: '#C9C9C9' }
                            },
                        crosshairLabel: { rx: 0, ry: 0, fill: '#B5B5B5', border: { color: '#B5B5B5', width: 1 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
                    },
                secondaryX:
                    {
                        majorGridLines:
                            {
                                color: "#333333"
                            },
                        majorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        minorGridLines:
                            {
                                color: "#333333"
                            },
                        minorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        labelBorder: {
                            color: "#AAAAAA"
                        },
                        multiLevelLabelsColor: "#AAAAAA",
                        multiLevelLabelsFontColor: "#C9C9C9",
                        axisLine: { color: '#AAAAAA' },
                        font: { color: '#C9C9C9' },
                        title:
                            {

                                font: { color: '#C9C9C9' }
                            },
                        crosshairLabel: { rx: 0, ry: 0, fill: '#B5B5B5', border: { color: '#B5B5B5', width: 1 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
                    },
                primaryYAxis:
                    {
                        majorGridLines:
                            {
                                color: "#333333"
                            },
                        majorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        minorGridLines:
                            {
                                color: "#333333"
                            },
                        minorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        labelBorder: {
                            color: "#AAAAAA"
                        },
                        multiLevelLabelsColor: "#AAAAAA",
                        multiLevelLabelsFontColor: "#C9C9C9",
                        axisLine: { color: '#AAAAAA' },
                        font: { color: '#C9C9C9' },
                        title:
                            {

                                font: { color: '#C9C9C9' }
                            },
                        crosshairLabel: { rx: 0, ry: 0, fill: '#B5B5B5', border: { color: '#B5B5B5', width: 1 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
                    },
                secondaryY:
                    {
                        majorGridLines:
                            {
                                color: "#333333"
                            },
                        majorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        minorGridLines:
                            {
                                color: "#333333"
                            },
                        minorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        labelBorder: {
                            color: "#AAAAAA"
                        },
                        multiLevelLabelsColor: "#AAAAAA",
                        multiLevelLabelsFontColor: "#C9C9C9",
                        axisLine: { color: '#AAAAAA' },
                        font: { color: '#C9C9C9' },
                        title:
                            {

                                font: { color: '#C9C9C9' }
                            },
                        crosshairLabel: { rx: 0, ry: 0, fill: '#B5B5B5', border: { color: '#B5B5B5', width: 1 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
                    },
                commonSeriesOptions:
                    {
                        marker: {
                            dataLabel: { font: { color: '#C9C9C9' } }
                        },
                        errorBar: {
                            fill: "#ffffff",
                            cap:
                                {
                                    fill: "#ffffff"
                                }
                        },
                        connectorLine: { color: '#C9C9C9' }
                    },
                crosshair:
                    {
                        line:
                            {
                                width: 1,
                                color: 'White'
                            }
                    },

                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.defaultMetro,
                colors: sf.EjSvgRender.seriesPalette.defaultMetro

            },


        gradientlight:
            {
                highlightColor: 'black',

                background: 'transparent',
                legend:
                    {
                        font: { color: "#282828" },
                        title:
                            {
                                font: { color: "#282828" }
                            }
                    },
                title:
                    {
                        font: { color: '#565656' },
                        subTitle:
                            {
                                font: { color: '#565656' }
                            }
                    },
                primaryXAxis:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        labelBorder: {
                            color: "#8E8E8E"
                        },
                        multiLevelLabelsColor: "#8E8E8E",
                        multiLevelLabelsFontColor: "#282828",
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#282828' },
                        title:
                            {

                                font: { color: '#282828' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, fill: '#3D3D3D', border: { color: '#3D3D3D', width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },
                secondaryX:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        labelBorder: {
                            color: "#8E8E8E"
                        },
                        multiLevelLabelsColor: "#8E8E8E",
                        multiLevelLabelsFontColor: "#282828",
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#282828' },
                        title:
                            {

                                font: { color: '#282828' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, fill: '#3D3D3D', border: { color: '#3D3D3D', width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },
                primaryYAxis:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        labelBorder: {
                            color: "#8E8E8E"
                        },
                        multiLevelLabelsColor: "#8E8E8E",
                        multiLevelLabelsFontColor: "#282828",
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#282828' },
                        title:
                            {

                                font: { color: '#282828' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, fill: '#3D3D3D', border: { color: '#3D3D3D', width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },
                secondaryY:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        labelBorder: {
                            color: "#8E8E8E"
                        },
                        multiLevelLabelsColor: "#8E8E8E",
                        multiLevelLabelsFontColor: "#282828",
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#282828' },
                        title:
                            {

                                font: { color: '#282828' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, fill: '#3D3D3D', border: { color: '#3D3D3D', width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },
                commonSeriesOptions:
                    {
                        marker: {
                            dataLabel: { font: { color: '#565656' } }
                        },
                        errorBar: {
                            fill: "#000000",
                            cap:
                                {
                                    fill: "#000000"
                                }
                        },
                        connectorLine: { color: '#565656' }
                    },
                crosshair:
                    {
                        line:
                            {
                                width: 1,
                                color: 'Black'
                            }
                    },

                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.defaultGradient.borderColors,
                colors: sf.EjSvgRender.seriesPalette.defaultGradient.seriesColors

            },

        gradientdark:
            {
                highlightColor: 'white',

                background: '#111111',
                legend:
                    {
                        font: { color: "#C9C9C9" },
                        title:
                            {
                                font: { color: "#C9C9C9" }
                            }
                    },
                title:
                    {
                        font: { color: '#C9C9C9' },
                        subTitle:
                            {
                                font: { color: '#C9C9C9' }
                            }
                    },
                primaryXAxis:
                    {
                        majorGridLines:
                            {
                                color: "#333333"
                            },
                        majorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        minorGridLines:
                            {
                                color: "#333333"
                            },
                        minorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        labelBorder: {
                            color: "#AAAAAA"
                        },
                        multiLevelLabelsColor: "#AAAAAA",
                        multiLevelLabelsFontColor: "#C9C9C9",
                        axisLine: { color: '#AAAAAA' },
                        font: { color: '#C9C9C9' },
                        title:
                            {

                                font: { color: '#C9C9C9' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, fill: '#B5B5B5', border: { color: '#B5B5B5', width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
                    },
                secondaryX:
                    {
                        majorGridLines:
                            {
                                color: "#333333"
                            },
                        majorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        minorGridLines:
                            {
                                color: "#333333"
                            },
                        minorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        labelBorder: {
                            color: "#AAAAAA"
                        },
                        multiLevelLabelsColor: "#AAAAAA",
                        multiLevelLabelsFontColor: "#C9C9C9",
                        axisLine: { color: '#AAAAAA' },
                        font: { color: '#C9C9C9' },
                        title:
                            {

                                font: { color: '#C9C9C9' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, fill: '#B5B5B5', border: { color: '#B5B5B5', width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
                    },
                primaryYAxis:
                    {
                        majorGridLines:
                            {
                                color: "#333333"
                            },
                        majorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        minorGridLines:
                            {
                                color: "#333333"
                            },
                        minorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        labelBorder: {
                            color: "#AAAAAA"
                        },
                        multiLevelLabelsColor: "#AAAAAA",
                        multiLevelLabelsFontColor: "#C9C9C9",
                        axisLine: { color: '#AAAAAA' },
                        font: { color: '#C9C9C9' },
                        title:
                            {

                                font: { color: '#C9C9C9' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, fill: '#B5B5B5', border: { color: '#B5B5B5', width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
                    },
                secondaryY:
                    {
                        majorGridLines:
                            {
                                color: "#333333"
                            },
                        majorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        minorGridLines:
                            {
                                color: "#333333"
                            },
                        minorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        labelBorder: {
                            color: "#AAAAAA"
                        },
                        multiLevelLabelsColor: "#AAAAAA",
                        multiLevelLabelsFontColor: "#C9C9C9",
                        axisLine: { color: '#AAAAAA' },
                        font: { color: '#C9C9C9' },
                        title:
                            {

                                font: { color: '#C9C9C9' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, fill: '#B5B5B5', border: { color: '#B5B5B5', width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
                    },
                commonSeriesOptions:
                    {
                        marker: {
                            dataLabel: { font: { color: '#C9C9C9' } }
                        },
                        errorBar: {
                            fill: "#ffffff",
                            cap:
                                {
                                    fill: "#ffffff"
                                }
                        },
                        connectorLine: { color: "#C9C9C9" }
                    },

                crosshair:
                    {
                        line:
                            {
                                width: 1,
                                color: 'White'
                            }
                    },

                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.defaultGradient.borderColors,
                colors: sf.EjSvgRender.seriesPalette.defaultGradient.seriesColors

            },

        highcontrast01:
            {
                highlightColor: 'white',

                background: '#111111',
                legend:
                    {
                        font: { color: '#ffffff' },
                        title:
                            {
                                font: { color: '#ffffff' }
                            }
                    },
                title:
                    {
                        font: { color: '#ffffff' },
                        subTitle:
                            {
                                font: { color: '#ffffff' }
                            }
                    },
                primaryXAxis:
                    {
                        majorGridLines:
                            {
                                color: "#333333"
                            },
                        majorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        minorGridLines:
                            {
                                color: "#333333"
                            },
                        minorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        labelBorder: {
                            color: "#AAAAAA"
                        },
                        multiLevelLabelsColor: "#AAAAAA",
                        multiLevelLabelsFontColor: "#ffffff",
                        axisLine: { color: '#AAAAAA' },
                        font: { color: '#ffffff' },
                        title:
                            {

                                font: { color: '#ffffff' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, fill: '#B5B5B5', border: { color: '#B5B5B5', width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
                    },
                secondaryX:
                    {
                        majorGridLines:
                            {
                                color: "#333333"
                            },
                        majorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        minorGridLines:
                            {
                                color: "#333333"
                            },
                        minorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        axisLine: { color: '#AAAAAA' },
                        font: { color: '#ffffff' },
                        title:
                            {

                                font: { color: '#ffffff' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, fill: '#B5B5B5', border: { color: '#B5B5B5', width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
                    },
                primaryYAxis:
                    {
                        majorGridLines:
                            {
                                color: "#333333"
                            },
                        majorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        minorGridLines:
                            {
                                color: "#333333"
                            },
                        minorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        labelBorder: {
                            color: "#AAAAAA"
                        },
                        multiLevelLabelsColor: "#AAAAAA",
                        multiLevelLabelsFontColor: "#ffffff",
                        axisLine: { color: '#AAAAAA' },
                        font: { color: '#ffffff' },
                        title:
                            {

                                font: { color: '#ffffff' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, fill: '#B5B5B5', border: { color: '#B5B5B5', width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
                    },
                secondaryY:
                    {
                        majorGridLines:
                            {
                                color: "#333333"
                            },
                        majorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        minorGridLines:
                            {
                                color: "#333333"
                            },
                        minorTickLines:
                            {
                                color: "#AAAAAA"
                            },
                        axisLine: { color: '#AAAAAA' },
                        font: { color: '#ffffff' },
                        title:
                            {

                                font: { color: '#ffffff' }
                            },
                        crosshairLabel: { rx: 3, ry: 3, fill: '#B5B5B5', border: { color: '#B5B5B5', width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
                    },
                commonSeriesOptions:
                    {
                        marker: {
                            dataLabel: { font: { color: '#ffffff' } }
                        },
                        errorBar: {
                            fill: "#ffffff",
                            cap:
                                {
                                    fill: "#ffffff"
                                }
                        },
                        connectorLine: { color: "#C9C9C9" }
                    },

                crosshair:
                    {
                        line:
                            {
                                width: 1,
                                color: 'White'
                            }
                    },

                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.defaultHighContrast,
                colors: sf.EjSvgRender.seriesPalette.defaultHighContrast

            },
        material:
            {
                highlightColor: 'black',

                background: 'transparent',
                legend:
                    {
                        font: { color: "#333333" },
                        title:
                            {
                                font: { color: "#333333" }
                            }
                    },
                title:
                    {
                        font: { color: '#333333' },
                        subTitle:
                            {
                                font: { color: '#333333' }
                            }
                    },
                primaryXAxis:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        labelBorder:
                            {
                                color: "#8E8E8E"
                            },
                        multiLevelLabelsColor: "#8E8E8E",
                        multiLevelLabelsFontColor: "#333333",
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#333333' },
                        title:
                            {
                                font: { color: '#333333' }
                            },
                        crosshairLabel: { rx: 0, ry: 0, border: { color: '#3D3D3D', width: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },
                secondaryX:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#333333' },
                        title:
                            {
                                font: { color: '#333333' }
                            },
                        crosshairLabel: { rx: 0, ry: 0, border: { color: '#3D3D3D', width: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },

                primaryYAxis:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        labelBorder:
                            {
                                color: "#8E8E8E"
                            },
                        multiLevelLabelsColor: "#8E8E8E",
                        multiLevelLabelsFontColor: "#333333",
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#333333' },
                        title:
                            {
                                font: { color: '#333333' }
                            },
                        crosshairLabel: { rx: 0, ry: 0, border: { color: '#3D3D3D', borderWidth: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },
                secondaryY:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#333333' },
                        title:
                            {
                                font: { color: '#333333' }
                            },
                        crosshairLabel: { rx: 0, ry: 0, border: { color: '#3D3D3D', width: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },
                commonSeriesOptions:
                    {
                        marker: {
                            dataLabel: { font: { color: '#333333' } }
                        },
                        errorBar: {
                            fill: "#000000",
                            cap:
                                {
                                    fill: "#000000"
                                }
                        },
                        connectorLine: { color: '#565656' }
                    },
                crosshair:
                    {
                        line:
                            {
                                width: 1,
                                color: 'Black'
                            }
                    },

                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.defaultMaterial,
                colors: sf.EjSvgRender.seriesPalette.defaultMaterial

            },
        office365:
            {
                highlightColor: 'black',

                background: 'transparent',
                legend:
                    {
                        font: { color: "#333333" },
                        title:
                            {
                                font: { color: "#333333" }
                            }
                    },
                title:
                    {
                        font: { color: '#333333' },
                        subTitle:
                            {
                                font: { color: '#333333' }
                            }
                    },
                primaryXAxis:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        labelBorder:
                            {
                                color: "#8E8E8E"
                            },
                        multiLevelLabelsColor: "#8E8E8E",
                        multiLevelLabelsFontColor: "#333333",
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#333333' },
                        title:
                            {
                                font: { color: '#333333' }
                            },
                        crosshairLabel: { rx: 0, ry: 0, border: { color: '#3D3D3D', width: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },
                secondaryX:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#333333' },
                        title:
                            {
                                font: { color: '#333333' }
                            },
                        crosshairLabel: { rx: 0, ry: 0, border: { color: '#3D3D3D', width: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },

                primaryYAxis:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        labelBorder:
                            {
                                color: "#8E8E8E"
                            },
                        multiLevelLabelsColor: "#8E8E8E",
                        multiLevelLabelsFontColor: "#333333",
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#333333' },
                        title:
                            {
                                font: { color: '#333333' }
                            },
                        crosshairLabel: { rx: 0, ry: 0, border: { color: '#3D3D3D', borderWidth: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },
                secondaryY:
                    {
                        majorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        majorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        minorGridLines:
                            {
                                color: "#DFDFDF"
                            },
                        minorTickLines:
                            {
                                color: "#8E8E8E"
                            },
                        axisLine: { color: '#8E8E8E' },
                        font: { color: '#333333' },
                        title:
                            {
                                font: { color: '#333333' }
                            },
                        crosshairLabel: { rx: 0, ry: 0, border: { color: '#3D3D3D', width: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
                    },
                commonSeriesOptions:
                    {
                        marker: {
                            dataLabel: { font: { color: '#333333' } }
                        },
                        errorBar: {
                            fill: "#000000",
                            cap:
                                {
                                    fill: "#000000"
                                }
                        },
                        connectorLine: { color: '#565656' }
                    },
                crosshair:
                    {
                        line:
                            {
                                width: 1,
                                color: 'Black'
                            }
                    },

                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.defaultOffice,
                colors: sf.EjSvgRender.seriesPalette.defaultOffice

            }
    };
    $.extend(sf.EjSvgRender.themes, {

        "azure":
            {

                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.blueMetro,
                colors: sf.EjSvgRender.seriesPalette.blueMetro
            },

        "azuredark":
            {
                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.blueMetro,
                colors: sf.EjSvgRender.seriesPalette.blueMetro
            },
        "gradient-azure":
            {
                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.blueGradient.borderColors,
                colors: sf.EjSvgRender.seriesPalette.blueGradient.seriesColors
            },

        "gradient-azuredark":
            {
                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.blueGradient.borderColors,
                colors: sf.EjSvgRender.seriesPalette.blueGradient.seriesColors
            },

        "lime":
            {
                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.greenMetro,
                colors: sf.EjSvgRender.seriesPalette.greenMetro
            },

        "limedark":
            {
                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.greenMetro,
                colors: sf.EjSvgRender.seriesPalette.greenMetro
            },
        "gradient-lime":
            {
                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.greenGradient.borderColors,
                colors: sf.EjSvgRender.seriesPalette.greenGradient.seriesColors
            },

        "gradient-limedark":
            {
                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.greenGradient.borderColors,
                colors: sf.EjSvgRender.seriesPalette.greenGradient.seriesColors
            },
        "saffron":
            {
                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.sandleMetro,
                colors: sf.EjSvgRender.seriesPalette.sandleMetro
            },

        "saffrondark":
            {
                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.sandleMetro,
                colors: sf.EjSvgRender.seriesPalette.sandleMetro
            },
        "gradient-saffron":
            {
                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.sandleGradient.borderColors,
                colors: sf.EjSvgRender.seriesPalette.sandleGradient.seriesColors
            },

        "gradient-saffrondark":
            {
                seriesBorderDefaultColors: sf.EjSvgRender.seriesPalette.sandleGradient.borderColors,
                colors: sf.EjSvgRender.seriesPalette.sandleGradient.seriesColors
            }
    });
})(jQuery);;
/* global jQuery, sf, navigator, document */
sf.axisTypes = {};

sf.EjAxisRenderer = function () {
};
var _sideBySeriesPadding = function (chartObj, start, end, axis) {
    var visibleSeries = sf.DataManager(chartObj.model._visibleSeries, sf.Query().sortBy("_zOrder")).executeLocal();
    var isPadding = false;
    var data, startPadding, endPadding;
    var visibleSeriesLength = visibleSeries.length;
    var axisOrientation = axis.orientation.toLowerCase();
    for (var i = 0; i < visibleSeriesLength; i++) {
        var type = visibleSeries[i].type.toLowerCase();
        if (((type.indexOf("column") != -1 || type.indexOf("bar") != -1 || type.indexOf("waterfall") != -1 || type == "candle" || type.indexOf("hilo") != -1 || type.indexOf("box") != -1))) {
            isPadding = true;
            break;
        }

    }
    if (chartObj.model.AreaType != "polaraxes" && isPadding) {
        axis.m_minPointsDelta = undefined;
        var padding = sf.EjSvgRender.utils.getMinPointsDelta(axis, chartObj, start) * 0.5;
        start = start - padding;
        end = (end + padding > Number.MAX_VALUE) ? Number.MAX_VALUE : end + padding;
        axis.padding = padding;
    }
    else
        axis.padding = 0;
    return data = { startPadding: start, endPadding: end };
};
sf.EjStripline = function (chartobj) {
    this.chart = chartobj;
};
(function ($) {
    sf.EjAxisRenderer.prototype = {

        //Calculate min/max value for series
        _seriesMinMax: function (chartObj, axis, seriesCollection, type, params) {
            var orientation = axis.orientation.toLowerCase(), seriesLength = seriesCollection.length;
            params.seriesCollection = sf.util.isNullOrUndefined(params.seriesCollection) ? {} : params.seriesCollection;
            var count;
            if ((seriesLength > 0 && chartObj.model._hasSeriesPoints && seriesCollection[0].points.length > 0) || this.chartObj.model.indicators[0]._points.length > 0) {

                var maxX, minY, minX, maxY, min, max, delta;
                var maxMinXValue = { maxX: null, minX: null };
                var maxMinYValue = { maxY: null, minY: null };
                var xMax = maxMinXValue.maxX;
                var xMin = maxMinXValue.minX;
                var yMax = maxMinYValue.maxY;
                var yMin = maxMinYValue.minY;
                var seriesVisibility, pointsLength, visibleLength, seriesType;
                var yIndex = 0, yIndex1 = 1;
                for (var i = 0; i < seriesLength; i++) {
                    seriesVisibility = seriesCollection[i].visibility.toLowerCase();
                    pointsLength = seriesCollection[i].points.length;
                    count = 0;
                    if (seriesVisibility === 'visible') {
                        seriesCollection[i]._visiblePoints = [];
                        for (var j = 0; j < pointsLength; j++) {
                            var point = seriesCollection[i].points[j];
                            if ((point.x != null && point.x != undefined) && ((typeof point.y == "object" || !isNaN(point.y)) && point.y != null && point.y != undefined)
                                || point.showIntermediateSum || point.showTotalSum || point.isEmpty == false) {
                                seriesCollection[i]._visiblePoints[count] = point;
                                seriesCollection[i]._visiblePoints[count].actualIndex = j;
                                count++;
                            }
                        }
                    }
                    axis.maxPointLength = pointsLength;
                }

                for (var i = 0; i < seriesLength; i++) {
                    visibleLength = seriesCollection[i]._visiblePoints.length;
                    var series = seriesCollection[i];
                    if (visibleLength > 0) {
                        seriesVisibility = seriesCollection[i].visibility.toLowerCase();
                        pointsLength = seriesCollection[i].points.length;
                        if (seriesVisibility === 'visible' && pointsLength > 0) {
                            if ((orientation == "horizontal" && !(chartObj.model.requireInvertedAxes)) || (orientation == "vertical" && chartObj.model.requireInvertedAxes)) {
                                minX = maxX = seriesCollection[i]._visiblePoints[0].xValue;
                                for (var j = 0; j < visibleLength; j++) {
                                    var currentPoint = seriesCollection[i]._visiblePoints[j].xValue;
                                    if (minX > currentPoint)
                                        minX = currentPoint;
                                    if (maxX < currentPoint)
                                        maxX = currentPoint;
                                }
                                seriesCollection[i].minX = minX;
                                seriesCollection[i].maxX = maxX;

                                if ((xMin === null || xMin === undefined) && visibleLength > 0) {
                                    xMax = seriesCollection[i].maxX;
                                    xMin = seriesCollection[i].minX;
                                }
                                if (xMin > seriesCollection[i].minX) {
                                    xMin = seriesCollection[i].minX;
                                }
                                if (xMax < seriesCollection[i].maxX) {
                                    xMax = seriesCollection[i].maxX;
                                }
                            }
                            else {
                                var isSpline = (series.type.toLowerCase().indexOf('spline') != -1), controlPoint, naturalSpline, naturalSpline1, getBezierControlPoints, splineVisiblePoints,
                                    controlPointsCount = 0, visiblePoints = seriesCollection[i]._visiblePoints;
                                if (isSpline) {
                                    var seriesKey = series._name = series.name || 'series' + i;
                                    params.seriesCollection[seriesKey] = {};
                                    visiblePoints = sf.ejSplineSeries.prototype._isVisiblePoints(series);
                                    naturalSpline = params.seriesCollection[seriesKey].naturalSpline = sf.ejSplineSeries.prototype.naturalSpline(visiblePoints, series,yIndex, axis);
                                    if(series.type.toLowerCase() == "splinerangearea")
                                    naturalSpline1 = params.seriesCollection[seriesKey].naturalSpline1 = sf.ejSplineSeries.prototype.naturalSpline(visiblePoints, series, yIndex1, axis);
                                    params.seriesCollection[seriesKey].controlPoints = [];
                                    getBezierControlPoints = sf.ejSplineSeries.prototype.getBezierControlPoints;
                                    splineVisiblePoints = visiblePoints.filter(function (currentPt,  index,  array) {
                                        return  !sf.isNullOrUndefined(currentPt.YValues[0])  &&  !isNaN(currentPt.YValues[0]);
                                    });
                                }
                                maxY = minY = !isSpline ? visiblePoints[0].YValues[0] : splineVisiblePoints[0].YValues[0];
                                var minval, maxval;
                                for (var j = 0; j < visiblePoints.length; j++) {
                                    var currentPoint = visiblePoints[j];
                                    if (seriesCollection[i]._hiloTypes && series.type.toLowerCase() != "splinerangearea") {
                                        for (var y = 0; y < 2; y++) {
                                            if (minY > currentPoint.YValues[y])
                                                minY = currentPoint.YValues[y];
                                            if (maxY < currentPoint.YValues[y])
                                                maxY = currentPoint.YValues[y];
                                        }
                                    }
                                    else if (series.type.toLowerCase() == "boxandwhisker") {
                                        minval = visiblePoints[j].YValues[0][0];
                                        maxval = visiblePoints[j].YValues[0][0];
                                        for (var yindex = 0; yindex < currentPoint.YValues[0].length; yindex++) {
                                            if (minval > currentPoint.YValues[0][yindex])
                                                minval = currentPoint.YValues[0][yindex];
                                            if (maxval < currentPoint.YValues[0][yindex])
                                                maxval = currentPoint.YValues[0][yindex];
                                        }
                                        minY = minval > minY ? minY : minval;
                                        maxY = maxval < maxY ? maxY : maxval;
                                    }
                                    else if (isSpline) {
                                        if (j != 0 && currentPoint.visible && visiblePoints[j - 1].visible) {
                                            params.seriesCollection[seriesKey].controlPoints.push(getBezierControlPoints(visiblePoints[j - 1], currentPoint, naturalSpline[j - 1], naturalSpline[j], 0, series, this));
                                            if (series.type.toLowerCase() == "splinerangearea") {
                                                var lowPoints = getBezierControlPoints(visiblePoints[j - 1], currentPoint, naturalSpline1[j - 1], naturalSpline1[j], 1, series, this);
                                                params.seriesCollection[seriesKey].controlPoints[controlPointsCount].controlPoint1.YValues[1] = lowPoints.controlPoint1.YValues[0];
                                                params.seriesCollection[seriesKey].controlPoints[controlPointsCount].controlPoint2.YValues[1] = lowPoints.controlPoint2.YValues[0];
                                            }
                                            controlPoint = params.seriesCollection[seriesKey].controlPoints[controlPointsCount++];
                                            minY = Math.min(minY, currentPoint.YValues[0], controlPoint.controlPoint1.YValues[0], controlPoint.controlPoint2.YValues[0]);
                                            maxY = Math.max(maxY, currentPoint.YValues[0], controlPoint.controlPoint1.YValues[0], controlPoint.controlPoint2.YValues[0]);
                                            if (series.type.toLowerCase() == "splinerangearea") {
                                                minY = Math.min(minY, currentPoint.YValues[1], controlPoint.controlPoint1.YValues[1], controlPoint.controlPoint2.YValues[1]);
                                                maxY = Math.max(maxY, currentPoint.YValues[1], controlPoint.controlPoint1.YValues[1], controlPoint.controlPoint2.YValues[1]);
                                            }
                                        }
                                        else {
                                            if (j != 0 && (series.type.toLowerCase().indexOf("stacking") != -1 || series.type.toLowerCase() == "splinerangearea")) {
                                                params.seriesCollection[seriesKey].controlPoints.push(getBezierControlPoints(visiblePoints[j - 1], currentPoint, naturalSpline[j - 1], naturalSpline[j], 0, series, this));
                                                if (series.type.toLowerCase() == "splinerangearea") {
                                                    var lowPoints = getBezierControlPoints(visiblePoints[j - 1], currentPoint, naturalSpline1[j - 1], naturalSpline1[j], 1, series, this);
                                                    params.seriesCollection[seriesKey].controlPoints[controlPointsCount].controlPoint1.YValues[1] = lowPoints.controlPoint1.YValues[0];
                                                    params.seriesCollection[seriesKey].controlPoints[controlPointsCount].controlPoint2.YValues[1] = lowPoints.controlPoint2.YValues[0];
                                                }
                                                controlPoint = params.seriesCollection[seriesKey].controlPoints[controlPointsCount++];
                                            }
                                            minY = Math.min(minY, isNaN(currentPoint.YValues[0]) ? minY : (currentPoint.YValues[0] || null));
                                            maxY = Math.max(maxY, currentPoint.YValues[0] || null);
                                            if (series.type.toLowerCase() == "splinerangearea") {
                                                minY = Math.min(minY, isNaN(currentPoint.YValues[1]) ? minY : (currentPoint.YValues[1] || null));
                                                maxY = Math.max(maxY, currentPoint.YValues[1] || null);
                                            }
                                        }
                                    }
                                    else {
                                        if (minY > currentPoint.YValues[0])
                                            minY = currentPoint.YValues[0];
                                        if (maxY < currentPoint.YValues[0])
                                            maxY = currentPoint.YValues[0];
                                    }
                                }
                                seriesCollection[i].minY = minY;
                                seriesCollection[i].maxY = maxY;

                                if ((yMin === null || yMin === undefined) && visibleLength > 0) {
                                    yMax = seriesCollection[i].maxY;
                                    yMin = seriesCollection[i].minY;
                                }
                                if (yMin > seriesCollection[i].minY) {
                                    yMin = seriesCollection[i].minY;
                                }
                                if (yMax < seriesCollection[i].maxY) {
                                    yMax = seriesCollection[i].maxY;
                                }

                                // Finding Min and Max for Column and Bar series
                                seriesType = seriesCollection[i].type
                                if ((seriesType == 'column' || seriesType == 'bar') && axis.startFromZero)
                                    yMin = (yMin < 0) ? yMin : 0;
                            }
                        }
                    }
                }
                if ((orientation == "horizontal" && !(chartObj.model.requireInvertedAxes)) || (orientation == "vertical" && chartObj.model.requireInvertedAxes)) {

                    // Find min/max for indicator series
                    if (this.chartObj.model.indicatorRange && this.chartObj.model.indicatorRange[axis.name]) {
                        var value = this.chartObj.model.indicatorRange[axis.name];
                        if (yMin > value.min || yMin == null)
                            yMin = value.min;
                        if (yMax < value.max || yMax == null)
                            yMax = value.max;
                    }

                    if (xMax == xMin)
                        xMax += 1;

                    if (type == "double") {
                        var data = _sideBySeriesPadding(chartObj, xMin, xMax, axis);
                        xMin = data.startPadding;
                        xMax = data.endPadding;
                        var deltaX = xMax - xMin;
                        axis.range = this._getDoubleAutoRange(axis, xMin, xMax, deltaX);
                    }
                    else
                        axis.range = this._getLogAutoRange(axis, xMin, xMax, xMax - xMin);

                }
                else {

                    // Find min/max for stacked series
                    if (this.chartObj.model.stackedValue[axis.name]) {
                        var value = this.chartObj.model.stackedValue[axis.name],
                            isStacked = true;
                        if (yMin > value.min)
                            yMin = value.min;
                        if (yMax < value.max)
                            yMax = value.max;
                    }

                    // Find min/max for indicator series
                    if (this.chartObj.model.indicatorRange && this.chartObj.model.indicatorRange[axis.name]) {
                        var value = this.chartObj.model.indicatorRange[axis.name];
                        if (yMin > value.min || yMin == null)
                            yMin = value.min;
                        if (yMax < value.max || yMax == null)
                            yMax = value.max;
                    }

                    if (yMax == yMin) {                   // max == min
                        if (yMax < 0)                                  // value less than 0
                            yMax = 0;
                        else if (yMax <= 1 && yMax > 0)   // value between 0 and 1
                            yMin = 0;
                        else {                                                      // value greater than 1
                            yMin = 0;
                            yMax += 1;
                        }
                    }

                    if ((seriesType == 'column' || seriesType == 'bar') && !axis.startFromZero) {
                        var maxLimit = (axis.range && axis.range.max) || yMax;
                        var interval = (axis.range && axis.range.interval) || this.calculateNumericNiceInterval(maxLimit - yMin, axis, null, maxLimit);
                        yMax += interval;
                        if ((yMin - interval < 0 && yMin > 0) || isStacked) {
                            yMin = 0;
                        }
                        else
                            yMin -= interval;
                    }

                    var deltaY = yMax - yMin;
                    isStacked = false;

                    if (type == "double")
                        axis.range = this._getDoubleAutoRange(axis, yMin, yMax, deltaY)
                    else
                        axis.range = this._getLogAutoRange(axis, yMin, yMax, deltaY)

                }
            }
            else {
                if (!axis.setRange) {
                    axis.range = { min: 0, max: 5, interval: 1, Delta: 4 };
                }
                else {
                    min = (axis.range.min == null || axis.range.min == undefined) ? 0 : axis.range.min;
                    max = (axis.range.max == null || axis.range.max == undefined) ? 5 : axis.range.max;
                    delta = max - min;
                    axis.range = (type == "double") ? this._getDoubleAutoRange(axis, min, max, delta) : this._getLogAutoRange(axis, min, max, delta);
                }
            }
            var commonAxisEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonAxisEventArgs.data = { range: axis.range, axis: axis };
            this.chartObj._trigger("axesRangeCalculate", commonAxisEventArgs);
            var range = commonAxisEventArgs.data.range;
            axis.range = { min: range.min, max: range.max, interval: range.interval, delta: (range.max - range.min) };

        },

        //Calculate ranges for Trendline series
        _calculateTrendLineRange: function (chart, axis, seriesCollection) {
            var series, trendlines, trendline, count, serLength, trendLength, trendlineType, options;
            var serLength = seriesCollection.length;
            for (var m = 0; m < serLength; m++) {
                series = seriesCollection[m];
                trendlines = series.trendlines;
                if (chart.model.AreaType == "cartesianaxes" && (axis.name == series._xAxisName || axis.name == series._yAxisName)) {
                    trendLength = trendlines.length;
                    for (var i = 0; i < trendLength; i++) {
                        trendline = trendlines[i];
                        if (trendline.visibility.toLowerCase() === 'visible') {

                            if (axis.name == series._xAxisName) {
                                trendlineType = trendline.type.toLowerCase();
                                options = new sf.trendlineTypes[trendlineType]();
                                options.calculateTrendLineSegment(series, trendline, axis, chart);
                            } else
                                if (axis.name == series._yAxisName && !axis.setRange && trendline.points && trendline.points.length > 1) {
                                    count = trendline.points.length - 1;
                                    axis.range.min = axis.range.min > trendline.minY ? trendline.minY : axis.range.min;
                                    axis.range.max = axis.range.max < trendline.maxY ? trendline.maxY : axis.range.max;
                                }
                        }
                    }
                }
            }
            return false;
        },

        AlignRangeStart: function (sDate, intervalSize, intervalType) {
            var sResult = new Date(sDate);
            if (intervalType.toLowerCase() == "days") {
                var day = Math.floor(Math.floor((sDate.getDate()) / intervalSize) * intervalSize);
                sResult = new Date(sDate.getFullYear(), sDate.getMonth(), day, 0, 0, 0);
            } else if (intervalType.toLowerCase() == "hours") {
                var hour = Math.floor(Math.floor((sDate.getHours()) / intervalSize) * intervalSize);
                sResult = new Date(sDate.getFullYear(), sDate.getMonth(), sDate.getDate(), hour, 0, 0);
            } else if (intervalType.toLowerCase() == "milliseconds") {
                var milliseconds = Math.floor(Math.floor((sDate.getMilliseconds()) / intervalSize) * intervalSize);
                sResult = new Date(sDate.getFullYear(), sDate.getMonth(), sDate.getDate(), sDate.getHours(), sDate.getMinutes(), sDate.getSeconds(), milliseconds);
            } else if (intervalType.toLowerCase() == "seconds") {
                var seconds = Math.floor(Math.floor((sDate.getSeconds()) / intervalSize) * intervalSize);
                sResult = new Date(sDate.getFullYear(), sDate.getMonth(), sDate.getDate(), sDate.getHours(), sDate.getMinutes(), seconds, 0);
            } else if (intervalType.toLowerCase() == "minutes") {
                var minutes = Math.floor(Math.floor((sDate.getMinutes()) / intervalSize) * intervalSize);
                sResult = new Date(sDate.getFullYear(), sDate.getMonth(), sDate.getDate(), sDate.getHours(), minutes, 0, 0);
            } else if (intervalType.toLowerCase() == "months") {
                var month = Math.floor(Math.floor((sDate.getMonth()) / intervalSize) * intervalSize);
                sResult = new Date(sDate.getFullYear(), month, sDate.getDate(), 0, 0, 0);
            } else if (intervalType.toLowerCase() == "years") {
                var year = Math.floor(Math.floor(sDate.getFullYear() / intervalSize) * intervalSize);
                sResult = new Date(year, sDate.getMonth(), sDate.getDate(), 0, 0, 0);
            }
            return sResult;
        },
        _increaseDateTimeInterval: function (date, interval, intervalType) {
            var result = new Date(date);
            if (intervalType.toLowerCase() == "days") {
                result.setDate(date.getDate() + interval);
            } else if (intervalType.toLowerCase() == "hours") {
                result.setHours(date.getHours() + interval);
            } else if (intervalType.toLowerCase() == "milliseconds") {
                result.setMilliseconds(date.getMilliseconds() + interval);
            } else if (intervalType.toLowerCase() == "seconds") {
                result.setSeconds(date.getSeconds() + interval);
            } else if (intervalType.toLowerCase() == "minutes") {
                result.setMinutes(date.getMinutes() + interval);
            } else if (intervalType.toLowerCase() == "months") {
                result.setMonth(date.getMonth() + interval);
            } else if (intervalType.toLowerCase() == "years") {
                result.setYear(date.getFullYear() + interval);
            }

            return result;
        },

        _calculatePadding: function (axis) {

            var start = (typeof axis.range.min == "string" && !isNaN(Date.parse(axis.range.min))) ? Date.parse(axis.range.min) : (axis.range.min).getTime();
            var end = (typeof axis.range.max == "string" && !isNaN(Date.parse(axis.range.max))) ? Date.parse(axis.range.max) : (axis.range.max).getTime();
            var interval = ((this._increaseDateTimeInterval(new Date(start), axis.range.interval, axis._intervalType)).getTime()) - start;
            var rangePadding = axis.rangePadding.toLowerCase();
            if (!this.chartObj.zoomed && !axis.setRange) {
                start = new Date(start);
                end = new Date(end);
                var intervalType = axis._intervalType.toLowerCase();
                if (axis.rangePadding.toLowerCase() == 'none') {
                    start = start.getTime();
                    end = end.getTime();
                } else if (rangePadding == 'additional' || rangePadding == 'round') {
                    switch (intervalType) {
                        case 'years':
                            var startYear = start.getFullYear();
                            var endYear = end.getFullYear();
                            if (axis.rangePadding.toLowerCase() == 'additional') {
                                start = (new Date(startYear - axis.range.interval, 1, 1, 0, 0, 0)).getTime();
                                end = (new Date(endYear + axis.range.interval, 1, 1, 0, 0, 0)).getTime();
                            } else {
                                start = new Date(startYear, 0, 0, 0, 0, 0).getTime();
                                end = new Date(endYear, 11, 30, 23, 59, 59).getTime();
                            }
                            break;
                        case 'months':
                            var month = start.getMonth();
                            var endMonth = end.getMonth();
                            if (rangePadding == 'round') {
                                start = (new Date(start.getFullYear(), month, 0, 0, 0, 0)).getTime();
                                end = (new Date(end.getFullYear(), endMonth, new Date(end.getFullYear(), end.getMonth(), 0).getDate(), 23, 59, 59)).getTime();
                            } else {
                                start = (new Date(start.getFullYear(), month + (-axis.range.interval), 1, 0, 0, 0)).getTime();
                                end = (new Date(end.getFullYear(), endMonth + (axis.range.interval), endMonth == 2 ? 28 : 30, 0, 0, 0)).getTime();
                            }
                            break;
                        case 'days':
                            var day = start.getDate();
                            var endDay = end.getDate();
                            if (rangePadding == 'round') {
                                start = (new Date(start.getFullYear(), start.getMonth(), day, 0, 0, 0)).getTime();
                                end = (new Date(end.getFullYear(), end.getMonth(), endDay, 23, 59, 59)).getTime();
                            } else {
                                start = (new Date(start.getFullYear(), start.getMonth(), day + (-axis.range.interval), 0, 0, 0)).getTime();
                                end = (new Date(end.getFullYear(), end.getMonth(), endDay + (axis.range.interval), 0, 0, 0)).getTime();
                            }
                            break;
                        case 'hours':
                            var hour = (start.getHours() / axis.range.interval) * axis.range.interval;
                            var endHour = end.getHours() + (start.getHours() - hour);
                            if (rangePadding == 'round') {
                                start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), hour, 0, 0)).getTime();
                                end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), endHour, 59, 59)).getTime();
                            } else {
                                start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), hour + (-axis.range.interval), 0, 0)).getTime();
                                end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), endHour + (axis.range.interval), 0, 0)).getTime();
                            }
                            break;
                        case 'minutes':
                            var minute = (start.getMinutes() / axis.range.interval) * axis.range.interval;
                            var endMinute = end.getMinutes() + (start.getMinutes() - minute);
                            if (rangePadding == 'round') {
                                start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), start.getHour(), minute, 0)).getTime();
                                end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), end.getHour(), endMinute, 59)).getTime();
                            } else {
                                start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), start.getHours(), minute + (-axis.range.interval), 0)).getTime();
                                end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), end.getHours(), minute + (axis.range.interval), 0)).getTime();
                            }
                            break;
                        case 'seconds':
                            var second = (start.getSeconds() / axis.range.interval) * axis.range.interval;
                            var endSecond = end.getSeconds() + (start.getSeconds() - second);
                            if (rangePadding == 'round') {
                                start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), start.getHours(), start.getMinutes(), second, 0)).getTime();
                                end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), end.getHour(), end.getMinutes(), endSecond, 0)).getTime();
                            } else {
                                start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), start.getHours(), start.getMinutes(), second + (-axis.range.interval), 0)).getTime();
                                end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), end.getHours(), end.getMinutes(), endSecond + (axis.range.interval), 0)).getTime();
                            }
                            break;
                        case 'milliseconds':
                            var milliSecond = (start.getMilliseconds() / axis.range.interval) * axis.range.interval;
                            var endMilliSecond = end.getMilliseconds() + (start.getMilliseconds() - milliSecond);
                            if (rangePadding == 'round') {
                                start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), start.getHours(), start.getMinutes(), start.getSeconds(), milliSecond)).getTime();
                                end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), end.getHours(), end.getMinutes(), end.getSeconds(), endMilliSecond)).getTime();
                            } else {
                                start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), start.getHours(), start.getMinutes(), start.getSeconds(), milliSecond + (-axis.range.interval))).getTime();
                                end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), end.getHours(), end.getMinutes(), end.getSeconds(), endMilliSecond + (axis.range.interval))).getTime();
                            }
                            break;
                    }

                }

            }
            axis.actualRange.interval = interval;
            axis.actualRange.min = start;
            axis.actualRange.max = end;
            axis._interval = axis.range.interval;
            axis.actualRange.delta = (axis.actualRange.max - axis.actualRange.min);
            axis.range.min = new Date(start);
            axis.range.max = new Date(end);
            this._calculateVisibleRange(axis);

        },
        _calculateVisibleRange: function (axis, sender, isScroll) {
            this.chartObj = sender ? sender : this.chartObj;
            axis.visibleRange = (!isScroll) ? $.extend(true, {}, axis.actualRange) : axis.visibleRange;
            if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && this.chartObj.model.AreaType != "polaraxes" && !this.chartObj.model.disableZoom) {

                axis.zoomFactor = axis.zoomFactor > 1 ? 1 : (axis.zoomFactor < 0 ? 0 : axis.zoomFactor);
                axis.zoomPosition = axis.zoomPosition < 0 ? 0 : (axis.zoomPosition > 1 ? 1 : axis.zoomPosition);
                var baseRange = axis.actualRange;
                if (axis.isInversed) {
                    var start = axis.actualRange.max - axis.zoomPosition * axis.actualRange.delta;
                    var end = start - axis.zoomFactor * axis.actualRange.delta;
                }
                else {
                    var start = axis.actualRange.min + axis.zoomPosition * axis.actualRange.delta;
                    var end = start + axis.zoomFactor * axis.actualRange.delta;
                }

                if (start < baseRange.min) {
                    end = end + (baseRange.min - start);
                    start = baseRange.min;
                }

                if (end > baseRange.max) {
                    start = start - (end - baseRange.max);
                    end = baseRange.max;
                }

                var startDate = new Date(start);
                var endDate = new Date(end);
                if (start == end) {
                    startDate = new Date(Date.parse(startDate) - 2592000000);
                    endDate = new Date(Date.parse(endDate) + 2592000000);
                }
                //Use below code to find min,max and interval for visible range
                var min = Math.min(startDate.getTime(), endDate.getTime());
                var max = Math.max(startDate.getTime(), endDate.getTime());
                var intervalX = axis.enableAutoIntervalOnZooming ? this.calculateDateTimeNiceInterval(axis, startDate, endDate) : { 'interval': axis._interval, 'intervalType': axis._intervalType };
                var interval = ((this._increaseDateTimeInterval(startDate, intervalX.interval, intervalX.intervalType)).getTime()) - min;

                if (isScroll) {
                    return { min: min, max: max, interval: interval };
                }
                else {
                    axis._intervalType = intervalX.intervalType;
                    axis.visibleRange.min = min;
                    axis.visibleRange.max = max;
                    axis.visibleRange.interval = interval;
                    axis.visibleRange.delta = Math.abs(axis.visibleRange.max - axis.visibleRange.min);
                    axis._interval = intervalX.interval;
                }
            }

        },
        _calculateAxisLabels: function (axis) {
            var position, text;
            var minRange = axis.enableAutoIntervalOnZooming ? axis.visibleRange.min : axis.actualRange.min;
            if (this.chartObj.zoomed || axis.zoomed || !axis.setRange)
                position = (this.AlignRangeStart(new Date(minRange), axis._interval, axis._intervalType)).getTime();

            else
                position = axis.visibleRange.min;
            while (position <= axis.visibleRange.max) {
                if (position >= axis.visibleRange.min && position <= axis.visibleRange.max) {
                    text = (sf.format(new Date(position), ((!(axis.labelFormat)) ? sf.EjSvgRender.utils._dateTimeLabelFormat(axis._intervalType, axis) : axis.labelFormat), this.chartObj.model.locale));
                    var commonAxesEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                    commonAxesEventArgs.data = { label: { Text: text, Value: position }, axis: axis };
                    this.chartObj._trigger("axesLabelRendering", commonAxesEventArgs);
                    axis.visibleLabels.push({ Value: position, Text: commonAxesEventArgs.data.label.Text });
                }
                position = (this._increaseDateTimeInterval(new Date(position), axis._interval, axis._intervalType)).getTime();

                axis.visibleLabels[axis.visibleLabels.length - 1] = axis.visibleLabels[axis.visibleLabels.length - 1];
            }
            axis._LableMaxWidth = sf.EjSvgRender.utils._getMaxLabelWidth(axis, this.chartObj);
        },
        calculateDateTimeNiceInterval: function (axis, startDate, endDate) {
            var oneDay = 24 * 60 * 60 * 1000;
            //var axisInterval ;
            var totalDays = (Math.abs((startDate.getTime() - endDate.getTime()) / (oneDay)));
            var interval = this.calculateNumericNiceInterval(totalDays / 365, axis, "years");

            if (interval >= 1) {
                return { interval: interval, intervalType: "Years" };
            }

            interval = this.calculateNumericNiceInterval(totalDays / 30, axis, "months");

            if (interval >= 1) {
                return { interval: interval, intervalType: "Months" };
            }

            interval = this.calculateNumericNiceInterval(totalDays, axis, "days");

            if (interval >= 1) {


                return { interval: interval, intervalType: "Days" };
            }

            var totalHours = totalDays * 24;

            interval = this.calculateNumericNiceInterval(totalHours, axis, "hours");

            if (interval >= 1) {

                return { interval: interval, intervalType: "Hours" };
            }

            var totalMinutes = totalDays * 24 * 60;

            interval = this.calculateNumericNiceInterval(totalMinutes, axis, "minutes");

            if (interval >= 1) {

                return { interval: interval, intervalType: "Minutes" };
            }

            var totalSeconds = totalDays * 24 * 60 * 60;

            interval = this.calculateNumericNiceInterval(totalSeconds, axis, "seconds");

            if (interval >= 1) {

                return { interval: interval, intervalType: "Seconds" };
            }

            var totalMilliseconds = totalDays * 24 * 60 * 60 * 1000;

            interval = this.calculateNumericNiceInterval(totalMilliseconds, axis, "milliseconds");

            if (interval >= 1) {

                return { interval: interval, intervalType: "Milliseconds" };
            }

        },
        calculateNumericNiceInterval: function (delta, axis, setInterval, max) {
            var desiredIntervalsCount = this.GetActualDesiredIntervalsCount(axis, axis.length);
            var niceInterval = delta / desiredIntervalsCount;
            if (axis._valueType == 'double') {
                if (axis.desiredIntervals != null)
                    return niceInterval;
            }
            var minInterval = Math.pow(10, Math.floor(sf.EjSvgRender.utils._logBase(niceInterval, 10))),
                intervalDivs = [10, 5, 2, 1],
                maxLimit = max || (axis.range && axis.range.max);


            for (var i = 0; i < intervalDivs.length; i++) {
                var currentInterval = minInterval * intervalDivs[i];
                if (desiredIntervalsCount < (delta / currentInterval)) {
                    if (axis._valueType == "datetime") {
                        return niceInterval = (!sf.util.isNullOrUndefined(axis.intervalType) && axis.intervalType.toLowerCase() == setInterval) ? Math.ceil(niceInterval) : niceInterval;
                    }
                    if (!sf.util.isNullOrUndefined(axis.range) && !sf.util.isNullOrUndefined(axis.range.max))
                        return (niceInterval > maxLimit ? currentInterval : niceInterval);
                    else
                        return niceInterval;
                }

                niceInterval = currentInterval;
            }

            return niceInterval;
        },
        GetActualDesiredIntervalsCount: function (axis, size) {
            if (sf.util.isNullOrUndefined(axis.desiredIntervals)) {
                var desiredIntervalsCount = (axis.orientation.toLowerCase() == "horizontal" ? 0.533 : 1) * axis.maximumLabels;
                desiredIntervalsCount = Math.max((size * (desiredIntervalsCount / 100)), 1);

                return desiredIntervalsCount;
            } else {
                return axis.desiredIntervals;
            }
        },
        _calculateRange: function (axis, seriesCollection, params) {
            if (!this.chartObj.zoomed) {
                var defaultDate = new Date();
				params.seriesCollection = sf.util.isNullOrUndefined(params.seriesCollection) ? {} : params.seriesCollection;
				var orientation = axis.orientation.toLowerCase();
                if (seriesCollection.length > 0 && this.chartObj.model._hasSeriesPoints && seriesCollection[0].points.length > 0 || this.chartObj.model.indicators[0]._points.length > 0) {
                    var maxX, minY;
                    var maxY, minX;
					var yIndex = 0, yIndex1 = 1;
                    var maxMinXValue = { maxX: null, minX: null };
                    var maxMinYValue = { maxY: null, minY: null };
                    var pointLength;
                    for (var i = 0; i < seriesCollection.length; i++) {
						var series = seriesCollection[i];
                        pointLength = seriesCollection[i].points.length;
                        if (pointLength > 0) {
                            if (seriesCollection[i].visibility.toLowerCase() === 'visible' && seriesCollection[i].points.length > 0) {
								var isSpline = (series.type.toLowerCase().indexOf('spline') != -1);
                                if(orientation == "vertical" && isSpline){
									var controlPoint, naturalSpline, naturalSpline1, getBezierControlPoints, splineVisiblePoints,
                                    controlPointsCount = 0, visiblePoints = seriesCollection[i]._visiblePoints;
                                if (isSpline) {
                                    var seriesKey = series._name = series.name || 'series' + i;
                                    params.seriesCollection[seriesKey] = {};
                                    visiblePoints = sf.ejSplineSeries.prototype._isVisiblePoints(series);
                                    naturalSpline = params.seriesCollection[seriesKey].naturalSpline = sf.ejSplineSeries.prototype.naturalSpline(visiblePoints, series,yIndex, axis);
									if(series.type.toLowerCase() == "splinerangearea")
                                    naturalSpline1 = params.seriesCollection[seriesKey].naturalSpline1 = sf.ejSplineSeries.prototype.naturalSpline(visiblePoints, series, yIndex1, axis);
                                    params.seriesCollection[seriesKey].controlPoints = [];
                                    getBezierControlPoints = sf.ejSplineSeries.prototype.getBezierControlPoints;
                                    splineVisiblePoints = visiblePoints.filter(function (currentPt,  index,  array) {
                                        return  !sf.isNullOrUndefined(currentPt.YValues[0])  &&  !isNaN(currentPt.YValues[0]);
                                    });
                                }
                                maxY = minY = !isSpline ? visiblePoints[0].YValues[0] : splineVisiblePoints[0].YValues[0];
                                var minval, maxval;
								}
								else{
								minX = maxX = new Date(seriesCollection[i].points[0].xValue);
                                maxY = minY = seriesCollection[i].points[0].YValues[0];
								}
                                for (var j = 0; j < pointLength; j++) {									
									if(isSpline && orientation == "vertical"){
										var currentPoint = visiblePoints[j];
										if (j != 0 && currentPoint.visible && visiblePoints[j - 1].visible) {
                                            params.seriesCollection[seriesKey].controlPoints.push(getBezierControlPoints(visiblePoints[j - 1], currentPoint, naturalSpline[j - 1], naturalSpline[j], 0, series, this));                                           
                                             if (series.type.toLowerCase() == "splinerangearea") {
                                                var lowPoints = getBezierControlPoints(visiblePoints[j - 1], currentPoint, naturalSpline1[j - 1], naturalSpline1[j], 1, series, this);
                                                params.seriesCollection[seriesKey].controlPoints[controlPointsCount].controlPoint1.YValues[1] = lowPoints.controlPoint1.YValues[0];
                                                params.seriesCollection[seriesKey].controlPoints[controlPointsCount].controlPoint2.YValues[1] = lowPoints.controlPoint2.YValues[0];
                                            }
											controlPoint = params.seriesCollection[seriesKey].controlPoints[controlPointsCount++];
                                            minY = Math.min(minY, currentPoint.YValues[0], controlPoint.controlPoint1.YValues[0], controlPoint.controlPoint2.YValues[0]);
                                            maxY = Math.max(maxY, currentPoint.YValues[0], controlPoint.controlPoint1.YValues[0], controlPoint.controlPoint2.YValues[0]);
											if (series.type.toLowerCase() == "splinerangearea") {
                                                minY = Math.min(minY, currentPoint.YValues[1], controlPoint.controlPoint1.YValues[1], controlPoint.controlPoint2.YValues[1]);
                                                maxY = Math.max(maxY, currentPoint.YValues[1], controlPoint.controlPoint1.YValues[1], controlPoint.controlPoint2.YValues[1]);
                                            }
                                        }
                                        else {
											if (j != 0 && (series.type.toLowerCase().indexOf("stacking") != -1 || series.type.toLowerCase() == "splinerangearea")) {
                                                params.seriesCollection[seriesKey].controlPoints.push(getBezierControlPoints(visiblePoints[j - 1], currentPoint, naturalSpline[j - 1], naturalSpline[j], 0, series, this));
												if (series.type.toLowerCase() == "splinerangearea") {
                                                    var lowPoints = getBezierControlPoints(visiblePoints[j - 1], currentPoint, naturalSpline1[j - 1], naturalSpline1[j], 1, series, this);
                                                    params.seriesCollection[seriesKey].controlPoints[controlPointsCount].controlPoint1.YValues[1] = lowPoints.controlPoint1.YValues[0];
                                                    params.seriesCollection[seriesKey].controlPoints[controlPointsCount].controlPoint2.YValues[1] = lowPoints.controlPoint2.YValues[0];
                                                }
                                                controlPoint = params.seriesCollection[seriesKey].controlPoints[controlPointsCount++];
                                            }
                                            minY = Math.min(minY, isNaN(currentPoint.YValues[0]) ? minY : (currentPoint.YValues[0] || null));
                                            maxY = Math.max(maxY, currentPoint.YValues[0] || null);
											if (series.type.toLowerCase() == "splinerangearea") {
                                                minY = Math.min(minY, isNaN(currentPoint.YValues[1]) ? minY : (currentPoint.YValues[1] || null));
                                                maxY = Math.max(maxY, currentPoint.YValues[1] || null);
                                            }
                                        }
									}
									else{
                                    if (minX != null && minX != undefined) {
                                        if (minX > seriesCollection[i].points[j].xValue)
                                            minX = seriesCollection[i].points[j].xValue;
                                        if (maxX < seriesCollection[i].points[j].xValue)
                                            maxX = seriesCollection[i].points[j].xValue;
                                    }
                                    else {
                                        minX = maxX = new Date(seriesCollection[i].points[j + 1].xValue);
                                    }
                                    if (minY > seriesCollection[i].points[j].YValues[0])
                                        minY = seriesCollection[i].points[j].YValues[0];
                                    if (maxY < seriesCollection[i].points[j].YValues[0])
                                        maxY = seriesCollection[i].points[j].YValues[0];
									}
                                }
                                seriesCollection[i].minX = minX;
                                seriesCollection[i].maxX = maxX;
                                seriesCollection[i].minY = minY;
                                seriesCollection[i].maxY = maxY;
                                if (!axis.maxPointLength || axis.maxPointLength < pointLength)
                                    axis.maxPointLength = pointLength;
                            }
                        }

                        if ((maxMinXValue.minX = (maxMinXValue.minX == null && typeof seriesCollection[i].minX != "number") ? seriesCollection[i].minX : maxMinXValue.minX) > seriesCollection[i].minX) {
                            maxMinXValue.minX = (typeof seriesCollection[i].minX != "number") ? seriesCollection[i].minX : maxMinXValue.minX;
                        }
                        if ((maxMinXValue.maxX = (maxMinXValue.maxX == null && typeof seriesCollection[i].maxX != "number") ? seriesCollection[i].maxX : maxMinXValue.maxX) < seriesCollection[i].maxX) {
                            maxMinXValue.maxX = (typeof seriesCollection[i].maxX != "number") ? seriesCollection[i].maxX : maxMinXValue.maxX;
                        }
                        if (maxMinYValue.minY > seriesCollection[i].minY) {
                            maxMinYValue.minY = seriesCollection[i].minY;
                        }
                        if (maxMinYValue.maxY < seriesCollection[i].maxY) {
                            maxMinYValue.maxY = seriesCollection[i].maxY;
                        }

                    }
                    // Find min/max for indicator series

                    if (this.chartObj.model.indicatorRange && this.chartObj.model.indicatorRange[axis.name]) {
                        var value = this.chartObj.model.indicatorRange[axis.name];
                        if (maxMinXValue.minX > new Date(value.min) || maxMinXValue.minX == null)
                            maxMinXValue.minX = new Date(value.min);
                        if (maxMinXValue.maxX < new Date(value.max) || maxMinXValue.maxX == null)
                            maxMinXValue.maxX = new Date(value.max);
                    }
                    maxMinXValue.minX = (maxMinXValue.minX == null) ? defaultDate : maxMinXValue.minX;
                    maxMinXValue.maxX = (maxMinXValue.maxX == null) ? new Date(new Date().setMonth(defaultDate.getMonth() + 5)) : maxMinXValue.maxX;
                    if (maxMinXValue.minX == maxMinXValue.maxX) {
                        maxMinXValue.minX = new Date(Date.parse(maxMinXValue.minX) - 2592000000);
                        maxMinXValue.maxX = new Date(Date.parse(maxMinXValue.maxX) + 2592000000);
                    }

                    var data = _sideBySeriesPadding(this.chartObj, maxMinXValue.minX.getTime(), maxMinXValue.maxX.getTime(), axis);
                    maxMinXValue.minX = new Date(data.startPadding);
                    maxMinXValue.maxX = new Date(data.endPadding);



                    var intervalX = this.calculateDateTimeNiceInterval(axis, maxMinXValue.minX, maxMinXValue.maxX);
                    axis._intervalType = (axis.intervalType) ? axis.intervalType : intervalX.intervalType;
                    if (axis.intervalType == "auto")
                        axis._intervalType = axis.intervalType = intervalX.intervalType;
                    if (axis.setAxisInterval == null || axis.setAxisInterval == undefined) {
                        axis.setAxisInterval = (axis.range && axis.range.interval) ? true : false;
                    }

                    //condition chechked when changing interval dynamically
                    if (axis._setInterval && !this.chartObj._chartResize && axis.range && axis._setInterval != axis.range.interval)
                        axis._setInterval = null;

                    if (!axis.setRange) {
                        axis.range = { min: maxMinXValue.minX, max: maxMinXValue.maxX, interval: intervalX.interval };
                    } else {
                        if (!axis.range.max)
                            axis.range.max = maxMinXValue.maxX;
                        if (!axis.range.min)
                            axis.range.min = maxMinXValue.minX;
                        if (typeof axis.range.min == "string" && axis.range.min.indexOf("/Date(") != -1)
                            axis.range.min = new Date(parseInt(axis.range.min.substr(6)));
                        if (typeof axis.range.max == "string" && axis.range.max.indexOf("/Date(") != -1)
                            axis.range.max = new Date(parseInt(axis.range.max.substr(6)));
                        if (new Date(axis.range.min).getTime() == new Date(axis.range.max).getTime()) {
                            axis.range.max = new Date(Date.parse(axis.range.max) + 86400000);
                        }
                        intervalX = this.calculateDateTimeNiceInterval(axis, new Date(axis.range.min), new Date(axis.range.max));
                        axis._intervalType = (axis.intervalType) ? axis.intervalType : intervalX.intervalType;
                        if (!axis.setAxisInterval) {
                            axis.range.interval = intervalX.interval; // set auto interval value
                            axis._setInterval = intervalX.interval;
                        }
                        axis.actual_Range = $.extend(true, {}, axis.range);
                        axis.setRange = true;
                        var interval = axis._setInterval ? intervalX.interval : (axis.range.interval || axis.actual_Range.interval);
                        axis.range = { min: axis.actual_Range.min, max: axis.actual_Range.max, interval: interval };
                    }
                } else {
                    if (!axis.setRange) {
                        axis.range = { min: defaultDate, max: new Date(new Date().setMonth(defaultDate.getMonth() + 5)), interval: 1 };
                        axis._intervalType = sf.util.isNullOrUndefined(axis.intervalType) ? "Months" : axis.intervalType;
                    }
                    else {
                        axis.range.min = (axis.range.min === null || axis.range.min === undefined) ? defaultDate : axis.range.min;
                        axis.range.max = (axis.range.max === null || axis.range.max === undefined) ? new Date(new Date().setMonth(defaultDate.getMonth() + 5)) : axis.range.max;
                        axis.range.interval = (axis.range.interval === null || axis.range.interval === undefined) ? 1 : axis.range.interval;
                        axis._intervalType = sf.util.isNullOrUndefined(axis.intervalType) ? "Months" : axis.intervalType;
                    }

                }
                var commonAxisEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonAxisEventArgs.data = { range: axis.range, axis: axis };
                this.chartObj._trigger("axesRangeCalculate", commonAxisEventArgs);
                var range = commonAxisEventArgs.data.range;
                axis.range = { min: range.min, max: range.max, interval: range.interval, delta: (range.max - range.min) };
            }
        },
        _calculateRanges: function (chartObj, axis, seriesCollection, params) {

            this.chartObj = chartObj;
            this._saveRange(chartObj, axis);
            this._calculateRange(axis, seriesCollection, params);
            axis._range = axis.range;
            if (chartObj.model._drawTrendline)
                this._calculateTrendLineRange(chartObj, axis, seriesCollection);

            this._calculatePadding(axis);

            this._calculateAxisLabels(axis);
        },
        _saveRange: function (chartObj, axis) {
            if (chartObj.zoomed || chartObj.resetZooming)
                axis.range = axis.range != null && axis.range.min != null && axis.range.max != null ? axis.range : axis._range
            //To check range is set in while redrawing the chart
            if (axis._initialRange) {
                if (axis._initialRange != axis.range && axis.range != null)
                    axis.setRange = true;
                else if (axis.range == null)
                    if (axis.actual_Range) {
                        axis.range = { min: axis.actual_Range.min, max: axis.actual_Range.max, interval: axis.actual_Range.interval };
                        axis.setRange = true;
                    } else {
                        axis.setRange = false;
                    }
            }
			if(!chartObj.resetZooming && !axis._initialRange)					
                axis._initialRange = axis.range == null ? { min: null, max: null, interval: null } : { min: axis.range.min, max: axis.range.max, interval: axis.range.interval };
        }
    };

    function ejExtendClass(parent, members) {
        var object = function () {
        };
        object.prototype = new parent();
        $.extend(object.prototype, members);
        return object;
    }

    //DateTime calculation
    var ejDateTimeValue = ejExtendClass(sf.EjAxisRenderer);
    sf.axisTypes.datetime = ejDateTimeValue;

    var ejDoubleValue = ejExtendClass(sf.EjAxisRenderer, {


        _calculateRange: function (chartObj, axis, seriesCollection, params) {
            if (!chartObj.zoomed || axis.zoomFactor == 1 || axis.zoomPosition == 0) {
                this._seriesMinMax(chartObj, axis, seriesCollection, "double", params);
            }
        },

        _getDoubleAutoRange: function (axis, min, max) {
            var delta;
            var interval;
            var intervalstr;
            if (!axis.setRange) {
                axis.range = { min: min, max: max };

            } else {

                if (sf.util.isNullOrUndefined(axis.range.max))
                    axis.range.max = max;
                if (sf.util.isNullOrUndefined(axis.range.min))
                    axis.range.min = min;

                axis.actual_Range = $.extend(true, {}, axis.range);
                axis.setRange = true;
            }
            delta = axis.range.max - axis.range.min;
            interval = this.calculateNumericNiceInterval(delta, axis);
            if (sf.EjSvgRender.utils._decimalPlaces(interval) > 20) {
                intervalstr = interval.toString();
                interval = parseFloat((intervalstr.substring(0, intervalstr.indexOf(".")) + intervalstr.substring(intervalstr.indexOf("."), 22)));
            }
            if ((sf.util.isNullOrUndefined(axis.range.interval)) || (axis.range.interval < 0))
                axis.range.interval = interval;
            axis.range.delta = delta;

            return axis.range;
        },
        _calculatePadding: function (chartObj, axis, baseRange) {
            var start = baseRange.min;
            var end = baseRange.max;
            var rangePadding = axis.rangePadding.toLowerCase();
            var interval = baseRange.interval;
            if ((!axis.setRange) && (!chartObj.zoomed)) {

                if (rangePadding == 'normal') {
                    var minimum = 0, remaining;
                    if (start < 0) {
                        start = 0;
                        minimum = baseRange.min + (baseRange.min / 20);

                        remaining = interval + (minimum % interval);

                        if ((0.365 * interval) >= remaining) {
                            minimum -= interval;
                        }

                        if (minimum % interval < 0) {
                            minimum = (minimum - interval) - (minimum % interval);
                        }
                    } else {
                        minimum = start < ((5.0 / 6.0) * end)
                            ? 0
                            : (start - (end - start) / 2);
                        if (minimum % interval > 0) {
                            minimum -= (minimum % interval);
                        }
                    }
                    if (end > 0)
                        var maximum = ((end + (end - start) / 20) > Number.MAX_VALUE) ? Number.MAX_VALUE : (end + (end - start) / 20);
                    else
                        var maximum = (end - (end - start) / 20);

                    remaining = interval - (maximum % interval);

                    if ((0.365 * interval) >= remaining) {
                        maximum = (maximum + interval > Number.MAX_VALUE) ? Number.MAX_VALUE : maximum + interval;
                    }

                    if (maximum % interval > 0) {
                        maximum = ((maximum + interval) - (maximum % interval) > Number.MAX_VALUE) ? Number.MAX_VALUE : (maximum + interval) - (maximum % interval);
                    }
                    if (minimum <= 0) {
                        interval = this.calculateNumericNiceInterval(maximum - minimum, axis);
                        maximum = (Math.ceil(maximum / interval) * interval > Number.MAX_VALUE) ? Number.MAX_VALUE : Math.ceil(maximum / interval) * interval;
                    }
                    start = (!(axis.roundingPlaces)) ? parseFloat(minimum.toFixed((sf.EjSvgRender.utils._decimalPlaces(interval) == 0 ? 1 : sf.EjSvgRender.utils._decimalPlaces(interval)))) : parseFloat(minimum.toFixed(axis.roundingPlaces));
                    end = (!(axis.roundingPlaces)) ? parseFloat(maximum.toFixed((sf.EjSvgRender.utils._decimalPlaces(interval) == 0 ? 1 : sf.EjSvgRender.utils._decimalPlaces(interval)))) : parseFloat(maximum.toFixed(axis.roundingPlaces));

                } else if (rangePadding == 'additional' || rangePadding == 'round') {
                    start = Math.floor(start / interval) * interval;
                    end = (Math.ceil(end / interval) * interval > Number.MAX_VALUE) ? Number.MAX_VALUE : Math.ceil(end / interval) * interval;
                    if (rangePadding == 'additional') {
                        start -= interval;
                        end = end + interval >= Number.MAX_VALUE ? Number.MAX_VALUE : end + interval;
                    }
                }


            }
            axis.actualRange.min = start;
            axis.actualRange.max = end;
            axis.actualRange.interval = interval;
            axis.range.min = start;
            axis.range.max = end;
            axis.range.interval = interval;
            axis.actualRange.delta = end - start >= Number.MAX_VALUE ? end : end - start;
            this._calculateVisibleRange(axis);
            axis.rangePadding = axis._rangePadding;
        },
        _calculateVisibleRange: function (axis, sender, isScroll) {
            this.chartObj = sender ? sender : this.chartObj;
            axis.visibleRange = (!isScroll) ? $.extend(true, {}, axis.actualRange) : axis.visibleRange;
            if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && this.chartObj.model.AreaType != "polaraxes" && !this.chartObj.model.disableZoom) {
                var baseRange = axis.actualRange;

                axis.zoomFactor = axis.zoomFactor > 1 ? 1 : (axis.zoomFactor < 0 ? 0 : axis.zoomFactor);
                axis.zoomPosition = axis.zoomPosition < 0 ? 0 : (axis.zoomPosition > 1 ? 1 : axis.zoomPosition);
                if (axis.isInversed) {
                    var start = axis.actualRange.max - axis.zoomPosition * axis.actualRange.delta;
                    var end = start - axis.zoomFactor * axis.actualRange.delta;
                }
                else {
                    var start = axis.actualRange.min + axis.zoomPosition * axis.actualRange.delta;
                    var end = start + axis.zoomFactor * axis.actualRange.delta;
                }

                if (start < baseRange.min) {
                    end = end + (baseRange.min - start);
                    start = baseRange.min;
                }

                if (end > baseRange.max) {
                    start = start - (end - baseRange.max);
                    end = baseRange.max;
                }

                var delta = Math.abs(end - start);
                var interval = axis.enableAutoIntervalOnZooming ? this.calculateNumericNiceInterval(delta, axis) : axis.actualRange.interval;
                if (isScroll) {
                    return { min: Math.min(start, end), max: Math.max(start, end), delta: delta, interval: interval };
                }
                else {
                    axis.visibleRange.min = Math.min(start, end);
                    axis.visibleRange.max = Math.max(start, end);
                    axis.visibleRange.delta = delta;
                    axis.visibleRange.interval = interval;
                    axis.zoomed = (this.chartObj.zoomed === null || this.chartObj.zoomed === undefined) ? true : this.chartObj.zoomed;
                }
            }

        },
        _calculateAxisLabels: function (chartObj, currentAxis) {

            var tempInterval,
                customFormat,
                round = currentAxis.roundingPlaces,
                tempPlace, labelValue,
                commonAxesEventArgs,
                labelText, locale = this.chartObj.model.locale,
				prevtempInterval,
                labelFormat = currentAxis.labelFormat, labelPrecision, labelPrecisionHighest = 20, labelPrecisionDefault = 6;
			currentAxis.visibleRange.min = parseFloat(currentAxis.visibleRange.min.toPrecision(14));
			currentAxis.visibleRange.max = parseFloat(currentAxis.visibleRange.max.toPrecision(14));
            if (chartObj.zoomed || currentAxis.zoomed || currentAxis.padding)
                tempInterval = currentAxis.visibleRange.min - (currentAxis.visibleRange.min % currentAxis.visibleRange.interval);
            else
                tempInterval = currentAxis.visibleRange.min;
            for (; tempInterval <= currentAxis.visibleRange.max; tempInterval += currentAxis.visibleRange.interval) {

                if (sf.EjSvgRender.utils._inside(tempInterval, currentAxis.visibleRange)) {
					if(tempInterval == prevtempInterval)
						break;											
					prevtempInterval = tempInterval;
                    tempPlace = (tempInterval.toString().split(0).length - 1 > 10) ? 10 : 20;
                    tempInterval = parseFloat(tempInterval.toFixed((!round && round > tempPlace) ? round : tempPlace));
                    //By default axis labels are rounded based on interval. These rounded values are not used to draw labels, so labels are misplaced from ticks
                    labelValue = (!round) ? parseFloat(tempInterval.toFixed((sf.EjSvgRender.utils._decimalPlaces(currentAxis.visibleRange.interval) == 0 ? 1 : sf.EjSvgRender.utils._decimalPlaces(currentAxis.visibleRange.interval)))) : tempInterval;
                    labelText = (!(round)) ? parseFloat(tempInterval.toFixed((sf.EjSvgRender.utils._decimalPlaces(currentAxis.visibleRange.interval) == 0 ? 1 : sf.EjSvgRender.utils._decimalPlaces(currentAxis.visibleRange.interval)))) : parseFloat(tempInterval.toFixed(round));

                    customFormat = currentAxis.labelFormat;
                    if (!(customFormat))
                        labelText = !currentAxis.isStacked100 ? (!locale ? labelText : labelText.toLocaleString(locale)) : labelText + "%";
                    else if (customFormat.match('{value}') != null)
                        labelText = customFormat.replace('{value}', labelText);
                    else if ((customFormat.indexOf('e') == 0 || customFormat.indexOf('E') == 0) && (customFormat.indexOf("sf.format") == -1)) {
                        labelPrecision = customFormat.match(/(\d+)/g);
                        labelPrecision = labelPrecision == null ? labelPrecisionDefault : labelPrecision > labelPrecisionHighest ? labelPrecisionHighest : labelPrecision;
                        labelText = labelText.toExponential(labelPrecision);
                    }
                    else {
                        if (customFormat.indexOf("sf.format") != -1)
                            customFormat = customFormat.substring(customFormat.indexOf("(") + 1, customFormat.indexOf(")"));
                        labelText = sf.format(labelText, customFormat, locale);
                    }

                    // customize label by event
                    commonAxesEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                    commonAxesEventArgs.data = { label: { Text: labelText, Value: tempInterval }, axis: currentAxis };
                    chartObj._trigger("axesLabelRendering", commonAxesEventArgs);
                    currentAxis.visibleLabels.push({ Value: labelValue, Text: commonAxesEventArgs.data.label.Text });

                }
            }
            var rowCount = 0, labels = currentAxis.visibleLabels;
            for (var r = 0; r < labels.length; r++) {
                if (typeof labels[r].Text === 'string') {
                    var labelLength = (labels[r].Text.split('<br>')).length;
                    rowCount = Math.max(labelLength, rowCount);
                }
            }
            currentAxis.rowsCount = rowCount;
            currentAxis._LableMaxWidth = sf.EjSvgRender.utils._getMaxLabelWidth(currentAxis, this.chartObj);

        },

        _calculateRanges: function (chartObj, axis, seriesCollection, params) {
            this.chartObj = chartObj;
            this._saveRange(chartObj, axis);
            this._calculateRange(chartObj, axis, seriesCollection, params);
            axis._range = axis.range;
            if (chartObj.model._drawTrendline)
                this._calculateTrendLineRange(chartObj, axis, seriesCollection);

            this._calculatePadding(chartObj, axis, axis.range);

            if (axis.maximumLabels > 0)  // to calculate only if labels have to be displayed
                this._calculateAxisLabels(chartObj, axis);

        }
    });
    sf.axisTypes.double = ejDoubleValue;
    //log axis
    var ejLogValue = ejExtendClass(sf.EjAxisRenderer, {

        // Get value for log min and max
        _getRoundValue: function (x, div, up) {
            return (up ? Math.ceil(x / div) : Math.floor(x / div)) * div;
        },

        // Caculate log nice interval
        calculateLogNiceInterval: function (delta, axis) {
            var desiredIntervalsCount = this.GetActualDesiredIntervalsCount(axis, axis.length);
            var niceInterval = delta;
            var minInterval = Math.pow(10, Math.floor(sf.EjSvgRender.utils._logBase(niceInterval, 10)));
            var intervalDivs = [10, 5, 2, 1];

            for (var i = 0; i < intervalDivs.length; i++) {
                var currentInterval = minInterval * intervalDivs[i];
                if (desiredIntervalsCount < (delta / currentInterval)) {
                    return niceInterval;
                }

                niceInterval = currentInterval;
            }

            return niceInterval;
        },

        // Get log value for auto range
        _getLogAutoRange: function (axis, min, max, delta) {

            var logStart = sf.EjSvgRender.utils._logBase(min, axis.logBase);
            logStart = $.isNumeric(logStart) ? logStart : min;
            var logEnd = sf.EjSvgRender.utils._logBase(max, axis.logBase);
            logEnd = $.isNumeric(logEnd) ? logEnd : max;

            var mulS = this._getRoundValue(logStart, 1, false);
            var mulE = this._getRoundValue(logEnd, 1, true);
            if (mulS == 0 && mulE == 0) {
                mulS = sf.EjSvgRender.utils._logBase((max - max / 2), axis.logBase);
                mulE = sf.EjSvgRender.utils._logBase((max + max / 2), axis.logBase);
            }
            delta = mulE - mulS;
            var interval = this.calculateLogNiceInterval(delta, axis);

            axis.actual_Range = { min: mulS, max: mulE, interval: interval, Delta: delta };

            mulS = Math.pow(axis.logBase, Math.floor(logStart));
            mulE = Math.pow(axis.logBase, Math.ceil(logEnd));

            delta = mulE - mulS;

            if (!axis.setRange) {

                return axis.range = { min: mulS, max: mulE, interval: interval, Delta: delta };

            } else {
                if (sf.util.isNullOrUndefined(axis.range.interval))
                    axis.range.interval = interval;
                if (sf.util.isNullOrUndefined(axis.range.max))
                    axis.range.max = mulE;
                if (sf.util.isNullOrUndefined(axis.range.min))
                    axis.range.min = mulS;

                axis.actual_Range = $.extend(true, {}, axis.range);

                if (!sf.util.isNullOrUndefined(axis.actual_Range.max)) {
                    axis.actual_Range.max = sf.EjSvgRender.utils._logBase(axis.actual_Range.max, axis.logBase);
                    axis.actual_Range.max = this._getRoundValue(axis.actual_Range.max, 1, true);
                }
                if (!sf.util.isNullOrUndefined(axis.range.min)) {
                    axis.actual_Range.min = sf.EjSvgRender.utils._logBase(axis.actual_Range.min, axis.logBase);
                    axis.actual_Range.min = this._getRoundValue(axis.actual_Range.min, 1, false);
                }

                axis.setRange = true;

                return axis.range;
            }
        },

        //Calcualte auto log range from series
        _calculateLogRange: function (chartObj, axis, seriesCollection, params) {
            if (!chartObj.zoomed) {
                this._seriesMinMax(chartObj, axis, seriesCollection, "logarithmic", params);
            }
        },

        //Assign base range values to actual range
        _calculateLogPadding: function (chartObj, axis, baseRange) {
            // No padding support for log axis
            var start = baseRange.min;
            var end = baseRange.max;
            var interval = baseRange.interval;
            axis.actualRange.min = start;
            axis.actualRange.max = end;
            axis.actualRange.interval = interval;
            axis.actualRange.delta = end - start;
            this._calculateVisibleRange(axis);
        },

        // Calculate visible range for zooming
        _calculateVisibleRange: function (axis, sender, isScroll) {
            this.chartObj = sender ? sender : this.chartObj;
            axis.visibleRange = (!isScroll) ? $.extend(true, {}, axis.actualRange) : axis.visibleRange;
            if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && this.chartObj.model.AreaType != "polaraxes" && !this.chartObj.model.disableZoom) {
                axis.zoomFactor = axis.zoomFactor > 1 ? 1 : (axis.zoomFactor < 0 ? 0 : axis.zoomFactor);
                axis.zoomPosition = axis.zoomPosition < 0 ? 0 : (axis.zoomPosition > 1 ? 1 : axis.zoomPosition);
                var baseRange = axis.actualRange;
                if (axis.isInversed) {
                    var start = axis.actualRange.max - axis.zoomPosition * axis.actualRange.delta;
                    var end = start - axis.zoomFactor * axis.actualRange.delta;
                }
                else {
                    var start = axis.actualRange.min + axis.zoomPosition * axis.actualRange.delta;
                    var end = start + axis.zoomFactor * axis.actualRange.delta;
                }

                if (start < baseRange.min) {
                    end = end + (baseRange.min - start);
                    start = baseRange.min;
                }

                if (end > baseRange.max) {
                    start = start - (end - baseRange.max);
                    end = baseRange.max;
                }
                var delta = Math.abs(end - start);
                var interval = axis.enableAutoIntervalOnZooming ? (this.calculateLogNiceInterval(delta, axis)) : axis.visibleRange.interval;
                var factor = (sf.util.isNullOrUndefined(axis.roundingPlaces)) ?
                    (sf.EjSvgRender.utils._decimalPlaces(axis.visibleRange.interval) == 0 ? 1
                        : sf.EjSvgRender.utils._decimalPlaces(axis.visibleRange.interval)) : axis.roundingPlaces;
                interval = parseFloat(axis.visibleRange.interval.toFixed(factor));
                if (isScroll)
                    return { min: Math.min(start, end), max: Math.max(start, end), interval: interval };
                else {
                    axis.visibleRange.interval = interval;
                    axis.visibleRange.min = Math.min(start, end);
                    axis.visibleRange.max = Math.max(start, end);
                    axis.visibleRange.delta = delta;
                    axis.zoomed = (this.chartObj.zoomed === null || this.chartObj.zoomed === undefined) ? true : this.chartObj.zoomed;
                }
            }

        },

        //Method implementation for Generate Labels in ChartAxis
        _calculateAxisLabels: function (chartObj, currentAxis) {

            var tempInterval, round = currentAxis.roundingPlaces;
            if (chartObj.zoomed || currentAxis.zoomed)
                tempInterval = currentAxis.visibleRange.min - (currentAxis.visibleRange.min % currentAxis.visibleRange.interval);
            else
                tempInterval = currentAxis.visibleRange.min;
            for (; tempInterval <= currentAxis.visibleRange.max; tempInterval += currentAxis.visibleRange.interval) {


                if (sf.EjSvgRender.utils._inside(tempInterval, currentAxis.visibleRange)) {
                    var customFormat = (!(currentAxis.labelFormat)) ? null : currentAxis.labelFormat.match('{value}');
                    var tempIntervaltext = Math.pow(currentAxis.logBase, tempInterval),
                        tempPlace = (tempIntervaltext.toString().split(0).length - 1 > 10) ? 10 : 20;
                    tempIntervaltext = parseFloat(tempIntervaltext.toFixed((!round && round > tempPlace) ? round : tempPlace));

                    var labelText = (!(currentAxis.labelFormat)) ? tempIntervaltext : (customFormat != null) ?
                        currentAxis.labelFormat.replace('{value}', tempIntervaltext) :
                        (sf.format(tempIntervaltext, currentAxis.labelFormat, chartObj.model.locale));
                    // customize label by event
                    var commonAxesEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                    commonAxesEventArgs.data = { label: { Text: labelText, Value: tempInterval }, axis: currentAxis };
                    chartObj._trigger("axesLabelRendering", commonAxesEventArgs);
                    currentAxis.visibleLabels.push({ Value: tempInterval, Text: commonAxesEventArgs.data.label.Text });
                }
            }

            currentAxis._LableMaxWidth = sf.EjSvgRender.utils._getMaxLabelWidth(currentAxis, this.chartObj);

        },


        //Category axis calculation
        _calculateRanges: function (chartObj, axis, seriesCollection, params) {
            this.chartObj = chartObj;
            this._calculateLogRange(chartObj, axis, seriesCollection, params);
            if (chartObj.model._drawTrendline)
                this._calculateTrendLineRange(chartObj, axis, seriesCollection);
            this._calculateLogPadding(chartObj, axis, axis.actual_Range);
            this._calculateAxisLabels(chartObj, axis);
        }


    });
    sf.axisTypes.logarithmic = ejLogValue;

    //Category Axes calculation
    var ejCategoryValue = ejExtendClass(sf.EjAxisRenderer, {
        //axis range calculation and assign indexed value to x value of points
        _calculateCategoryRange: function (axis, seriesCollection) {
            var legendCollapsed = (this.chartObj.model.legendCollapsed == undefined) ? !this.chartObj.zoomed : this.chartObj.model.legendCollapsed;
            if (!this.chartObj.model.excludeDataUpdate || legendCollapsed) {
                var maxXValue = { maxX: null, minX: 0 },
                    labels = [],
                    pointX,
                    intervalX,
                    deltaX,
                    index,
                    pointsLength,
                    isIndex = axis.isIndexed,
                    locale = this.chartObj.model.locale;
                if (seriesCollection.length > 0 && this.chartObj.model._hasSeriesPoints && seriesCollection[0].points.length > 0 || this.chartObj.model.indicators[0]._points.length > 0) {
                    for (var m = 0; m < seriesCollection.length; m++) {
                        pointsLength = seriesCollection[m].points.length;
                        for (var n = 0; n < pointsLength; n++) {
                            if (seriesCollection[m]._xAxisValueType == "date")
                                pointX = sf.format(new Date(seriesCollection[m].points[n].x), (sf.util.isNullOrUndefined(axis.labelFormat) ? "dd/MM/yyyy" : axis.labelFormat), locale);
                            else
                                pointX = seriesCollection[m].points[n].x;
                            if (!isIndex) {
                                index = $.inArray(pointX, labels);
                                if (index < 0)
                                    labels.push(pointX);
                            }
                            else {
                                if (m == 0)
                                    labels[n] = pointX;
                                else
                                    labels[n] = labels[n] + ", " + pointX;
                            }

                        }
                        if (!axis.maxPointLength || axis.maxPointLength < pointsLength)
                            axis.maxPointLength = pointsLength;
                    }
                    for (var l = 0; l < seriesCollection.length; l++) {
                        seriesCollection[l]._pointCollection = [];
                        for (var k = 0; k < seriesCollection[l].points.length; k++) {
                            seriesCollection[l]._pointCollection.push(seriesCollection[l].points[k].x);
                            if (seriesCollection[l]._xAxisValueType == "date")
                                pointX = sf.format(new Date(seriesCollection[l].points[k].x), (sf.util.isNullOrUndefined(axis.labelFormat) ? "dd/MM/yyyy" : axis.labelFormat), locale);
                            else
                                pointX = seriesCollection[l].points[k].x;
                            if (!isIndex)
                                seriesCollection[l].points[k].xValue = $.inArray(pointX, labels);
                            else
                                seriesCollection[l].points[k].xValue = k;

                        }
                        seriesCollection[l].minX = 0;
                        seriesCollection[l].maxX = (seriesCollection[l]._xAxisValueType == "date") ? seriesCollection[l]._pointCollection.length - 1 : labels.length - 1;
                        // To find maximum x value of axis from series collection
                        if (l == 0) {
                            maxXValue.maxX = seriesCollection[l].maxX;
                            axis.labels = (seriesCollection[l]._xAxisValueType == "date") ? seriesCollection[l]._pointCollection : labels;
                            axis._categoryValueType = seriesCollection[l]._xAxisValueType;
                        }
                        if (maxXValue.maxX < (seriesCollection[l].maxX)) {
                            maxXValue.maxX = seriesCollection[l].maxX;
                            axis.labels = [];
                            axis.labels = labels;
                        }
                    }
                    if (this.chartObj.model.indicatorRange && this.chartObj.model.indicatorRange[axis.name]) {
                        var value = this.chartObj.model.indicatorRange[axis.name];
                        if (maxXValue.minX > value.min || maxXValue.minX == null)
                            maxXValue.minX = value.min;
                        if (maxXValue.maxX < value.max || maxXValue.maxX == null)
                            maxXValue.maxX = value.max;
                    }

                    deltaX = maxXValue.maxX - maxXValue.minX;

                    if (axis.setRange && axis.range.interval) {
                        intervalX = Math.ceil(axis.range.interval);
                    }
                    else {
                        intervalX = this._calculateActualInterval(deltaX, axis);
                    }

                    axis.range = { min: maxXValue.minX, max: maxXValue.maxX, interval: intervalX, Delta: deltaX };
                }
                else {
                    var labelLength = axis.labels.length;
                    if (labelLength > 0) {
                        deltaX = labelLength - 1;
                        intervalX = this._calculateActualInterval(deltaX, axis);
                        axis.range = { min: 0, max: labelLength - 1, interval: intervalX, Delta: deltaX };
                    }
                    else if (!axis.range) // set default range when no series points added to category axes
                        axis.range = { min: 0, max: 6, interval: 1, Delta: 6 };
                }
            }
            var rowCount = 0, r, intersectAction = axis.labelIntersectAction, labelRotation = axis.labelRotation;
            if ((intersectAction != "rotate45" || intersectAction != "rotate90") && (labelRotation == 0 || labelRotation == null)) {
                for (r = 0; r < axis.labels.length; r++) {
                    if (typeof axis.labels[r] == "string") {
                        var labelLength = (axis.labels[r].split('<br>')).length;
                        rowCount = Math.max(labelLength, rowCount);
                    }
                }
            }
            axis.rowsCount = rowCount;
        },

        //Calculates actual interval
        _calculateActualInterval: function (delta, axis) {
            if (axis.categoryInterval == null)
                return Math.max(1, Math.floor(delta / this.GetActualDesiredIntervalsCount(axis, axis.length)));
            else
                return axis.categoryInterval;
        },

        //Apply padding based on labelPlacement
        _applyRangePadding: function (axis) {
            if (!this.chartObj.zoomed && !this.chartObj._scrollBarEnabled && !axis.zoomed) {
                // ticks based on labelplacement and polaraxes
                var ticks = 0;
                if (this.chartObj.model.AreaType !== 'polaraxes')
                    ticks = ((axis.labelPlacement === null || axis.labelPlacement === undefined || axis.labelPlacement === "")) ? -0.5 : (axis.labelPlacement.toLowerCase() == "betweenticks") ? (-0.5) : 0;
                if (!this.chartObj.scrollsvgObj) {
                    if (ticks < 0) {
                        axis.range.min = axis.range.min + ticks;
                        axis.range.max = axis.range.max - ticks;
                        axis.range.delta = axis.range.max - axis.range.min;
                        axis.actualRange = axis.range;
                    } else {
                        var data = _sideBySeriesPadding(this.chartObj, axis.range.min, axis.range.max, axis);
                        axis.range.min = data.startPadding;
                        axis.range.max = data.endPadding;
                        axis.range.delta = axis.range.max - axis.range.min;
                        axis.actualRange = axis.range;
                    }
                }
            }
            this._calculateVisibleRange(axis);
        },

        //Calculates the visible range  
        _calculateVisibleRange: function (axis, sender, isScroll) {
            this.chartObj = sender ? sender : this.chartObj;
            axis.visibleRange = (!isScroll) ? $.extend(true, {}, axis.actualRange) : axis.visibleRange;
            if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && this.chartObj.model.AreaType != "polaraxes" && !this.chartObj.model.disableZoom) {
                axis.zoomFactor = axis.zoomFactor > 1 ? 1 : (axis.zoomFactor < 0 ? 0 : axis.zoomFactor);
                axis.zoomPosition = axis.zoomPosition < 0 ? 0 : (axis.zoomPosition > 1 ? 1 : axis.zoomPosition);
                var baseRange = axis.actualRange;
                if (axis.isInversed) {
                    var start = axis.actualRange.max - axis.zoomPosition * axis.actualRange.delta;
                    var end = start - axis.zoomFactor * axis.actualRange.delta;
                }
                else {
                    var start = axis.actualRange.min + (axis.zoomPosition * axis.actualRange.delta);
                    var end = start + axis.zoomFactor * axis.actualRange.delta;
                }

                if (start < baseRange.min) {
                    end = end + (baseRange.min - start);
                    start = baseRange.min;
                }

                if (end > baseRange.max) {
                    start = start - (end - baseRange.max);
                    end = baseRange.max;
                }
                var delta = Math.abs(end - start);
                var interval = this._calculateActualInterval(delta, axis);
                var min = Math.min(start, end);
                var max = Math.max(start, end);
                if (isScroll) {
                    return { min: min, max: max, interval: interval };
                }
                else {
                    var delta = Math.abs(end - start);
                    axis.visibleRange.interval = interval;
                    axis.visibleRange.min = min;
                    axis.visibleRange.max = max;
                    axis.visibleRange.delta = delta;
                    axis.zoomed = (this.chartObj.zoomed === null || this.chartObj.zoomed === undefined) ? true : this.chartObj.zoomed;
                }
            }

        },

        //Generate category label for axis
        _calculateAxisLabels: function (axis) {
            var interval = axis.visibleRange.interval;
            var position = axis.visibleRange.min - (axis.visibleRange.min % axis.range.interval);
            for (; position <= axis.visibleRange.max; position += interval) {
                if (sf.EjSvgRender.utils._inside(position, axis.visibleRange)) {
                    var pos = Math.round(position);
                    axis.visibleLabels.push({ Value: pos, Text: sf.EjSvgRender.utils._getLabelContent(pos, axis, this.chartObj.model.locale) });

                    // customize label by event
                    var commonAxesEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                    commonAxesEventArgs.data = { label: axis.visibleLabels[axis.visibleLabels.length - 1], axis: axis };
                    this.chartObj._trigger("axesLabelRendering", commonAxesEventArgs);
                    axis.visibleLabels[axis.visibleLabels.length - 1] = commonAxesEventArgs.data.label;
                }
            }
            axis._LableMaxWidth = sf.EjSvgRender.utils._getMaxLabelWidth(axis, this.chartObj);
        },

        //Category axis calculation
        _calculateRanges: function (chartObj, axis, seriesCollection) {
            this.chartObj = chartObj;
            this._saveRange(chartObj, axis);
            this._calculateCategoryRange(axis, seriesCollection);
            axis._range = axis.range;
            if (chartObj.model._drawTrendline)
                this._calculateTrendLineRange(chartObj, axis, seriesCollection);
            this._applyRangePadding(axis);

            this._calculateAxisLabels(axis);
        }
    });
    sf.axisTypes.category = ejCategoryValue;

    // for Datetime category axis calculation

    var ejDateTimeCategory = ejExtendClass(sf.EjAxisRenderer, {
        _calculateDateTimeCategoryRange: function (axis, seriesCollection) {
            ///Variables declaration part here ///
            var xRange = { minX: 0, MaxX: null }, xLabels = [], xValue = [], xPoint, index, index1, deltaX, intervalX,
                prevDateVal, points, xVerfiedPoints = [], dateDouble, xValues = [], dateLabels = [],
                xDateVal, xVal, previous, current, pointsLength, point, m, pt, ser;
            for (ser = 0; ser < seriesCollection.length; ser++) {
                seriesCollection[ser]._pointCollection = [], points = [], seriesCollection[ser]._points = [], seriesCollection[ser]._xPoints = [], seriesCollection[ser]._yPoints = [],
                    pointsLength = seriesCollection[ser].points.length;
                for (pt = 0; pt < pointsLength; pt++) {
                    dateDouble = !isNaN(new Date(seriesCollection[ser].points[pt].x).getTime()) ? new Date(seriesCollection[ser].points[pt].x).getTime() : null;
                    if (points.indexOf(dateDouble) != -1) {
                        seriesCollection[ser].points[pt].xValue = points.indexOf(dateDouble);
                    }
                    points.push(dateDouble);
                    seriesCollection[ser]._xPoints.push(dateDouble);
                    seriesCollection[ser]._yPoints.push(seriesCollection[ser].points[pt].y);
                    if (dateDouble != null)
                        xValues.push(dateDouble);
                }
                if (sf.isNullOrUndefined(axis.intervalType)) {
                    intervalX = this.calculateDateTimeNiceInterval(axis, new Date(Math.min.apply(null, xValues)), new Date(Math.max.apply(null, xValues)));
                    axis.intervalType = intervalX.intervalType.toLowerCase();
                }
                for (point = 0; point < points.length; point++) {
                    xPoint = new Date(points[point]);
                    if (seriesCollection[ser]._points.indexOf(xPoint.getTime()) == -1)
                        seriesCollection[ser]._points.push(xPoint.getTime());
                    var ySortPos = $.inArray(points[point], seriesCollection[ser]._xPoints);
                    seriesCollection[ser]._pointCollection.push(new Date(seriesCollection[ser].points[point].x));
                    if (ser == 0) {
                        if (seriesCollection[ser].points[point].x == seriesCollection[ser].points[point].xValue)
                            seriesCollection[ser].points[point].xValue = point;
                    }
                    else {
                        for (var i = 0; i < ser; i++) {
                            index1 = $.inArray(new Date(seriesCollection[ser].points[point].x).getTime(), seriesCollection[i]._points);
                            if (index1 >= 0) {
                                if (i == 0)
                                    seriesCollection[ser].points[point].xValue = index1;
                                else {
                                    seriesCollection[ser].points[point].xValue = seriesCollection[i].points[index1].xValue;
                                }
                                break;
                            }
                            else if (i == ser - 1) {
                                if (seriesCollection[ser].points[point].x == seriesCollection[ser].points[point].xValue) {
                                    seriesCollection[ser].points[point].xValue = axis.maxPointLength++;
                                }
                                else {
                                    var ind = seriesCollection[ser].points[point].xValue;
                                    seriesCollection[ser].points[point].xValue = seriesCollection[ser].points[ind].xValue;
                                }
                                break;
                            }
                        }
                    }
                    index = (ser == 0) ? -1 : $.inArray(xPoint.getTime(), xVerfiedPoints);
                    switch (axis.intervalType) {
                        case "auto": // for auto calculate
                            if (xLabels.indexOf(xPoint.getTime()) == -1)
                                xLabels.push(xPoint.getTime());
                            break;
                        case "years":  // for years calculate
                            xVal = xPoint.getFullYear();
                            break;
                        case "months":  // for months calculate
                            current = xPoint.getFullYear();
                            xDateVal = xPoint.getMonth();
                            if (point <= 0) xVal = point + 1;
                            else {
                                previous = new Date(points[point - 1]).getFullYear();
                                xVal += (current != previous) ? ((12 - prevDateVal) + (xDateVal)) : (xDateVal - prevDateVal);
                            }
                            prevDateVal = xDateVal;
                            break;
                        case "days":  // for days calculate
                            current = xPoint.getMonth();
                            xDateVal = xPoint.getDate();
                            if (point <= 0) xVal = point + 1;
                            else {
                                previous = new Date(points[point - 1]).getMonth();
                                xVal += (current != previous) ? (((new Date(xPoint.getFullYear(), previous, 1).getDate() - prevDateVal) + (xDateVal))) : (xDateVal - prevDateVal);
                                if (current == previous) {
                                    var diff = this._diffDate(xPoint, new Date(points[point - 1]), 1);
                                    var days = (new Date(xPoint.getFullYear(), previous, 0).getDate());
                                    xVal = (diff > days) ? (xValue[xValue.length - 1]) + 1 : xVal;
                                }
                            }
                            prevDateVal = xDateVal;
                            break;
                        case "hours":  // for hours calculate
                            current = xPoint.getDate();
                            xDateVal = xPoint.getHours();
                            if (point <= 0) xVal = point + 1;
                            else {
                                previous = new Date(points[point - 1]).getDate();
                                xVal += (current != previous) ? ((24 - prevDateVal) + (xDateVal)) : (xDateVal - prevDateVal);
                                if (current == previous) {
                                    var diff = this._diffDate(xPoint, new Date(points[point - 1]), 24);
                                    xVal = (diff > 24) ? (xValue[xValue.length - 1]) + 1 : xVal;
                                }
                            }
                            prevDateVal = xDateVal;
                            break;
                        case "minutes": // for minutes calculate
                            current = xPoint.getHours();
                            xDateVal = xPoint.getMinutes();
                            if (point <= 0) xVal = point + 1;
                            else {
                                previous = new Date(points[point - 1]).getHours();
                                xVal += (current != previous) ? ((60 - prevDateVal) + (xDateVal)) : (xDateVal - prevDateVal);
                                if (current == previous) {
                                    var diff = this._diffDate(xPoint, new Date(points[point - 1]), (24 * 60));
                                    xVal = (diff > 60) ? (xValue[xValue.length - 1]) + 1 : xVal;
                                }
                            }
                            prevDateVal = xDateVal;
                            break;
                        case "seconds": // for seconds calculate
                            current = xPoint.getMinutes();
                            xDateVal = xPoint.getSeconds();
                            if (point <= 0) xVal = point + 1;
                            else {
                                previous = new Date(points[point - 1]).getMinutes();
                                xVal += (current != previous) ? ((60 - prevDateVal) + (xDateVal)) : (xDateVal - prevDateVal);
                                if (current == previous) {
                                    var diff = this._diffDate(xPoint, new Date(points[point - 1]), (24 * 60 * 60));
                                    xVal = (diff > 60) ? (xValue[xValue.length - 1]) + 1 : xVal;
                                }
                            }
                            prevDateVal = xDateVal;
                            break;
                        case "milliseconds": // for milliseconds calculate
                            current = xPoint.getSeconds();
                            xDateVal = xPoint.getMilliseconds();
                            if (point <= 0) xVal = point + 1;
                            else {
                                previous = new Date(points[point - 1]).getSeconds();
                                xVal += (current != previous) ? ((1000 - prevDateVal) + (xDateVal)) : (xDateVal - prevDateVal);
                                if (current == previous) {
                                    var diff = this._diffDate(xPoint, new Date(points[point - 1]), (24 * 60 * 60 * 1000));
                                    xVal = (diff > 1000) ? (xValue[xValue.length - 1]) + 1 : xVal;
                                }
                            }
                            prevDateVal = xDateVal;
                            break;
                    }
                    if (axis.intervalType != "auto" && xLabels.indexOf(xPoint.getTime()) == -1)
                        xLabels.push(xPoint.getTime());
                    xVal = (ser == 0) ? xVal : xValue[xValue.length - 1] + xVal;
                    if (xValue.indexOf(xVal) == -1)
                        xValue.push(xVal);
                    dateLabels.push(xVal);
                    xVerfiedPoints.push(new Date(points[point]).getTime());
                }
                if (!axis.maxPointLength) {
                    if (axis.intervalType != "auto")
                        axis.maxPointLength = xValue.length;
                    else
                        axis.maxPointLength = xLabels.length;
                }
            }
            for (m = 0; m < seriesCollection.length; m++) { // set the min and max range for axis
                if (!axis.setRange) axis.range = { min: null, max: null, interval: null };
                if (!sf.isNullOrUndefined(axis.m_minPointsDelta)) axis.m_minPointsDelta = undefined;
                seriesCollection[m].minX = (sf.isNullOrUndefined(axis.range.min)) ? 0 : (axis.range.min < xRange.minX) ? 0 : axis.range.min;
                seriesCollection[m].maxX = (sf.isNullOrUndefined(axis.range.max)) ? xLabels.length - 1 : (axis.range.max > xLabels.length - 1) ? xLabels.length - 1 : axis.range.max;
                xRange.MaxX = seriesCollection[m].maxX;
                xRange.minX = seriesCollection[m].minX;
                axis.labels = xLabels;
                axis.dateLabels = dateLabels;
                axis._categoryValueType = "date";
            }
            if (xRange.minX == xRange.MaxX && axis.labelPlacement.toLowerCase() == "onticks") xRange.MaxX += 1;
            if (seriesCollection.length > 0) {
                deltaX = xRange.MaxX - xRange.minX;
                intervalX = ((axis.range.interval == null || axis.range.interval == undefined)) ? 1 : (axis.range.interval < 1) ? 1 : Math.ceil(axis.range.interval);
                axis.range = { min: xRange.minX, max: xRange.MaxX, interval: intervalX, Delta: deltaX };
            }
            else if (!axis.setInterval) {
                axis.range = { min: 0, max: 6, interval: 1, Delta: 6 };
                axis.dateLabels = [];
                for (var i = 0; i <= axis.range.max; i++) {
                    axis.labels.push("");
                    axis.dateLabels.push("");
                }
            }
        },

        _diffDate: function (currentPoint, previousPoint, mul) {
            var oneDay, diff;
            oneDay = 24 * 60 * 60 * 1000;
            diff = (Math.abs((currentPoint.getTime() - previousPoint.getTime())) / (oneDay));
            return (Math.round(diff * mul));
        },

        _calculateAxisLabels: function (axis) // calculate visible labels for axis
        {
            var interval = axis.visibleRange.interval, currentLabels = [], count = 0, seriesCollection = this.chartObj.model.series.length,
                prevLabelVal, pos, arr, currentLabel, expectLabel, index, i, isCurrentLabel, isNextLabel, commonAxesEventArgs;
            var position = axis.visibleRange.min - (axis.visibleRange.min % axis.range.interval);
            for (; position <= axis.visibleRange.max; position += interval) {
                if (sf.EjSvgRender.utils._inside(position, axis.visibleRange)) {
                    pos = Math.round(position);
                    arr = axis.dateLabels;
                    //Commented for the issue JS-55566
                    //if (axis.intervalType != "auto") {
                    //    if (count > 0 && interval > 1) {
                    //        if (pos > arr.length - 1)
                    //            pos = arr.length - 1;
                    //        currentLabel = arr[count];
                    //        expectLabel = prevLabelVal + interval;
                    //        isCurrentLabel = $.inArray(currentLabel, arr);
                    //        isNextLabel = $.inArray(expectLabel, arr);
                    //        if (isCurrentLabel > 0 && (Math.abs(currentLabel - prevLabelVal) == interval) && currentLabel > prevLabelVal) {
                    //            pos = isCurrentLabel;
                    //            prevLabelVal = arr[pos];
                    //        }
                    //        else {
                    //            for (i = 0; i < i + 1; i++) {
                    //                expectLabel += (i == 0) ? i : 1;
                    //                isNextLabel = $.inArray(expectLabel, arr);
                    //                if (isNextLabel > 0) {
                    //                    pos = isNextLabel;
                    //                    prevLabelVal = arr[pos];
                    //                    break;
                    //                }
                    //            }
                    //        }
                    //    }
                    //}
                    //count++;
                    if (!sf.util.isNullOrUndefined(arr)) {
                        if (((arr[arr.length - 1] - arr[pos]) >= interval) && (axis.visibleRange.max < (position + interval))) axis.visibleRange.max += ((position + interval) - axis.visibleRange.max);
                        index = $.inArray(arr[pos], currentLabels);
                    }
                    if ((index < 0 || axis.intervalType == "auto" || seriesCollection == 0) && (pos < axis.labels.length)) {
                        if (axis.intervalType != "auto") {
                            prevLabelVal = arr[pos];
                            currentLabels.push(prevLabelVal);
                        }
                        axis.visibleLabels.push({ Value: pos, Text: ((!(axis.labelFormat) && axis.labels[Math.floor(pos)] != "") ? sf.format(new Date(axis.labels[Math.floor(pos)]), sf.EjSvgRender.utils._dateTimeLabelFormat(axis.intervalType, axis), this.chartObj.model.locale) : sf.EjSvgRender.utils._getLabelContent(pos, axis, this.chartObj.model.locale)) });
                        commonAxesEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                        commonAxesEventArgs.data = { label: axis.visibleLabels[axis.visibleLabels.length - 1], axis: axis };
                        this.chartObj._trigger("axesLabelRendering", commonAxesEventArgs);
                        axis.visibleLabels[axis.visibleLabels.length - 1] = commonAxesEventArgs.data.label;
                    }
                }
            }
            axis._LableMaxWidth = sf.EjSvgRender.utils._getMaxLabelWidth(axis, this.chartObj);
        },

        //Calculates actual interval
        _calculateActualInterval: function (delta, axis) {
            if (axis.categoryInterval == null)
                return Math.max(1, Math.floor(delta / this.GetActualDesiredIntervalsCount(axis, axis.length)));
            else
                return axis.categoryInterval;
        },

        //Apply padding based on labelPlacement
        _applyRangePadding: function (axis) {
            if (!this.chartObj.zoomed && !this.chartObj._scrollBarEnabled) {
                // ticks based on labelplacement and polaraxes
                var ticks = 0;
                if (this.chartObj.model.AreaType !== 'polaraxes')
                    ticks = ((axis.labelPlacement === null || axis.labelPlacement === undefined)) ? -0.5 : (axis.labelPlacement.toLowerCase() == "betweenticks") ? (-0.5) : 0;
                if (ticks < 0) {
                    axis.range.min = axis.range.min + ticks;
                    axis.range.max = axis.range.max - ticks;
                    axis.range.delta = axis.range.max - axis.range.min;
                    axis.actualRange = axis.range;
                } else {
                    var data = _sideBySeriesPadding(this.chartObj, axis.range.min, axis.range.max, axis);
                    axis.range.min = data.startPadding;
                    axis.range.max = data.endPadding;
                    axis.range.delta = axis.range.max - axis.range.min;
                    axis.actualRange = axis.range;
                }
            }
            this._calculateVisibleRange(axis);
        },

        //Calculates the visible range  
        _calculateVisibleRange: function (axis, sender, isScroll) {
            this.chartObj = sender ? sender : this.chartObj;
            axis.visibleRange = (!isScroll) ? $.extend(true, {}, axis.actualRange) : axis.visibleRange;
            if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && this.chartObj.model.AreaType != "polaraxes" && !this.chartObj.model.disableZoom) {
                axis.zoomFactor = axis.zoomFactor > 1 ? 1 : (axis.zoomFactor < 0 ? 0 : axis.zoomFactor);
                axis.zoomPosition = axis.zoomPosition < 0 ? 0 : (axis.zoomPosition > 1 ? 1 : axis.zoomPosition);
                var baseRange = axis.actualRange;
                if (axis.isInversed) {
                    var start = axis.actualRange.max - axis.zoomPosition * axis.actualRange.delta;
                    var end = start - axis.zoomFactor * axis.actualRange.delta;
                }
                else {
                    var start = axis.actualRange.min + (axis.zoomPosition * axis.actualRange.delta);
                    var end = start + axis.zoomFactor * axis.actualRange.delta;
                }

                if (start < baseRange.min) {
                    end = end + (baseRange.min - start);
                    start = baseRange.min;
                }

                if (end > baseRange.max) {
                    start = start - (end - baseRange.max);
                    end = baseRange.max;
                }
                var delta = Math.abs(end - start);
                var interval = this._calculateActualInterval(delta, axis);
                var min = Math.min(start, end);
                var max = Math.max(start, end);
                if (isScroll) {
                    return { min: min, max: max, interval: interval };
                }
                else {
                    var delta = Math.abs(end - start);
                    axis.visibleRange.interval = interval;
                    axis.visibleRange.min = min;
                    axis.visibleRange.max = max;
                    axis.visibleRange.delta = delta;
                    axis.zoomed = (this.chartObj.zoomed === null || this.chartObj.zoomed === undefined) ? true : this.chartObj.zoomed;
                }
            }

        },

        _calculateRanges: function (chartObj, axis, seriesCollection) {
            this.chartObj = chartObj;
            this._saveRange(chartObj, axis);
            this._calculateDateTimeCategoryRange(axis, seriesCollection);
            if (chartObj.model._drawTrendline)
                this._calculateTrendLineRange(chartObj, axis, seriesCollection);
            axis._range = axis.range;
            this._applyRangePadding(axis);
            this._calculateAxisLabels(axis);
        }
    });

    sf.axisTypes.datetimecategory = ejDateTimeCategory;

    sf.EjAxisRenderer.prototype = {
        _drawGridLines: function (axisIndex, axis, params) {
            if (this.model.AreaType == "cartesianaxes") {
                if (axis.orientation.toLowerCase() == "horizontal")
                    this._drawXAxisGridLine(axisIndex, axis, params);

                else
                    this._drawYAxisGridLine(axisIndex, axis, params);
            }
            else {
                if (axis.orientation.toLowerCase() == "horizontal" && axisIndex == 0) {
                    this._drawPolarGridLine(axis);
                    this._drawPolarLabels(axis);

                }
                else if (axisIndex == 1)
                    this._drawPolarCircle(axis);
            }
        },
        _drawGridRect: function (axisIndex, axis, xAxis) {
            if (this.model.AreaType == "cartesianaxes") {
                if (axis.orientation.toLowerCase() == "horizontal") {
                    this._drawXAxisRect(axisIndex, axis, xAxis);
                }
                else {
                    this._drawYAxisRect(axisIndex, axis);
                }
            }
        },
        _drawAxes: function (axisIndex, axis) {

            if (this.model.AreaType == "cartesianaxes") {
                if (axis.visible && axis.orientation.toLowerCase() == "horizontal") {
                    this._drawXAxisLabels(axisIndex, axis);
                    this._drawXTitle(axisIndex, axis);
                }

                if (axis.visible && axis.orientation.toLowerCase() == "vertical") {
                    this._drawYAxisLabels(axisIndex, axis);
                    this._drawYTitle(axisIndex, axis);
                }
            }
        },
        _getSharpPath: function (width) {
            var value = ((width % 2) == 0) ? 0 : 0.5;
            return value;
        },
        _drawAxisLine: function (axis) {

            // Yaxis MajorGridlines, Ticklines and Labels.
            var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisLine' });
            var sbYMajorTick = sf.EjSvgRender.utils._getStringBuilder();
            var x1 = this.model.centerX;
            var y1 = this.model.centerY;
            var x2 = this.model.centerX;
            var y2 = this.model.centerY - this.model.Radius;
            var axisLine = "M" + " " + x1 + " " + y1 + " " + "L" + " " + x2 + " " + y2;
            if (axis.visible && axis.axisLine.visible) {
                var options = {
                    'id': this.svgObject.id + '_YAxisLines',
                    'fill': 'none',
                    'stroke-width': axis.axisLine.width,
                    'stroke': axis.axisLine.color,
                    'opacity': axis.axisLine.opacity,
                    'stroke-dasharray': axis.axisLine.dashArray,
                    'd': axisLine
                };
                this.svgRenderer.drawPath(options, gEle);

                //Drawing Major Grid Lines 
                $(gEle).appendTo(this.gPolarAxisEle);
            }


            if (axis.visible && axis.majorTickLines.visible) {
                gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisMajorTicks' });
                for (var j = 0; j < axis.visibleLabels.length; j++) {
                    var label = axis.visibleLabels[j];
                    var radius = this.model.Radius * sf.EjSvgRender.utils._valueToCoefficient(axis, label.Value, this);
                    var line = {};
                    line.X1 = this.model.centerX;
                    line.Y1 = this.model.centerY - radius;
                    line.X2 = line.X1 - axis.majorTickLines.size;
                    line.Y2 = line.Y1;
                    sbYMajorTick.append("M" + " " + line.X1 + " " + line.Y1 + " " + "L" + " " + line.X2 + " " + line.Y2 + " ");
                }

                var yMajorTickDir = sbYMajorTick.toString();
                var options = {
                    'id': this.svgObject.id + '_YAxisMajorTicks',
                    'fill': 'none',
                    'stroke-width': axis.majorTickLines.width,
                    'stroke': axis.majorTickLines.color,
                    'd': yMajorTickDir
                };
                //Drawing Major Tickline Lines
                this.svgRenderer.drawPath(options, gEle);
                $(gEle).appendTo(this.gPolarAxisEle);

            }
            if (axis.visible) {
                var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisLabels' }),
                    font = axis.font,
                    bounds,
                    regionX,
                    labelsLength = axis.visibleLabels.length;
                for (var j = 0; j < labelsLength; j++) {
                    var radius = (this.model.Radius || this.model._radius) * sf.EjSvgRender.utils._valueToCoefficient(axis, axis.visibleLabels[j].Value, this);
                    var labelText = axis.visibleLabels[j].Text;

                    var size = sf.EjSvgRender.utils._measureText(labelText, null, axis.font);

                    var X = this.model.centerX - axis.majorTickLines.size - (this.model.elementSpacing / 3);
                    var Y = this.model.centerY - radius + (size.height / 5);


                    var options = {
                        'id': this.svgObject.id + '_' + axis.name + '_YLabel_' + j,
                        'x': X,
                        'y': Y,
                        'fill': font.color,
                        'font-size': font.size,
                        'font-family': font.fontFamily,
                        'font-style': font.fontStyle,
                        'font-weight': font.fontWeight,
                        'opacity': font.opacity,
                        'text-anchor': 'end'
                    };

                    this.svgRenderer.drawText(options, labelText, gEle);
                    regionX = options.x - size.width;
                    bounds = { x: regionX, y: options.y, width: size.width, height: size.height };
                    axis.visibleLabels[j].region = { bounds: bounds, labelText: labelText };
                }
                //Drawing YAxis Labels
                $(gEle).appendTo(this.gPolarAxisEle);
            }


        },
        _drawPolarLabels: function (axis) {
            if (!axis.visible)
                return 0;
            var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisLabels' }),
                aroundRadius = this.model.Radius + axis.majorTickLines.size,
                font = axis.font,
                length = axis.visibleLabels.length,
                firstLabelX,
                bounds,
                regionX,
                lastLabelX;
            for (var j = 0; j < length; j++) {
                var coef = sf.EjSvgRender.utils._valueToPolarCoefficient(axis, axis.visibleLabels[j].Value);

                var vector = sf.EjSvgRender.utils._valueToVector(axis, axis.visibleLabels[j].Value);
                if (!isNaN(vector.X) && !isNaN(vector.Y)) {
                    var labelText = axis.visibleLabels[j].Text;
                    var x = this.model.centerX + aroundRadius * vector.X;
                    var y = this.model.centerY + aroundRadius * vector.Y;
                    var textAnchor = (x < this.model.centerX) ? 'end' : ((x > this.model.centerX) ? 'start' : 'middle');

                    var size = sf.EjSvgRender.utils._measureText(labelText, this.model.m_AreaBounds.Height, axis.font);
                    // calculation for positioning the label along the arc
                    if (coef == 0.25) {
                        x -= this.model.elementSpacing / 2;
                        y += (size.height) / 4;
                    }
                    else if (coef == 0.5) {
                        y += (size.height);
                    }
                    else if (coef == 0.75) {
                        x += this.model.elementSpacing / 2;
                        y += (size.height) / 4;
                    }
                    else if (coef == 1 || coef == 0) {
                        y -= (size.height) / 2;
                    }

                    else if (0.25 < coef && coef < 0.5) {
                        x -= this.model.elementSpacing / 2;
                        y += (size.height) / 2;
                    }
                    else if (0.5 < coef && coef <= 0.75) {
                        x += this.model.elementSpacing / 2;
                        y += (size.height) / 2;
                    }
                    else if (0 < coef && coef < 0.25) {
                        x -= this.model.elementSpacing / 2;
                    }
                    else
                        x += this.model.elementSpacing / 2;

                    if (j == 0) {
                        firstLabelX = x;
                    }
                    if (j == length - 1 && axis._valueType != "category") {
                        lastLabelX = sf.EjSvgRender.utils._measureText(labelText, null, font).width;
                        lastLabelX += x;
                        if (lastLabelX > firstLabelX)
                            labelText = ""; //Hide the last overlapping labels
                    }
                    var options = {
                        'id': this.svgObject.id + '_' + axis.name + '_XLabel_' + j,
                        'x': x,
                        'y': y,
                        'fill': font.color,
                        'font-size': font.size,
                        'font-family': font.fontFamily,
                        'font-style': font.fontStyle,
                        'font-weight': font.fontWeight,
                        'opacity': font.opacity,
                        'text-anchor': textAnchor
                    };

                    this.svgRenderer.drawText(options, labelText, gEle);
                    if (textAnchor == "middle")
                        regionX = options.x - size.width / 2;

                    else if (textAnchor == "end")
                        regionX = options.x - size.width;
                    else
                        regionX = options.x;

                    bounds = { x: regionX, y: options.y, width: size.width, height: size.height };
                    axis.visibleLabels[j].region = { bounds: bounds, labelText: labelText };
                }
            }

            $(gEle).appendTo(this.gXaxisEle);

        },
        _drawPolarCircle: function (axis) {
            if (axis.majorGridLines.visible) {
                var sbYMajorGrid = sf.EjSvgRender.utils._getStringBuilder();
                var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisGrid' });
                if (this.model.isPolar) {
                    for (var j = 0; j < axis.visibleLabels.length; j++) {
                        var label = axis.visibleLabels[j];
                        var radius = this.model.Radius * sf.EjSvgRender.utils._valueToCoefficient(axis, label.Value, this);

                        var options = {
                            'id': this.svgObject.id + '_YAxisGridLines_' + j,
                            'cx': this.model.centerX,
                            'cy': this.model.centerY,
                            'r': radius,
                            'fill': 'transparent',
                            'stroke-width': axis.majorGridLines.width,
                            'stroke': axis.majorGridLines.color,
                            'opacity': (this.vmlRendering) ? 0.3 : axis.majorGridLines.opacity
                        };

                        //Drawing Major Grid Lines for polar
                        this.svgRenderer.drawCircle(options, gEle);

                    }
                }
                else {
                    for (var j = 0; j < axis.visibleLabels.length; j++) {

                        var label = axis.visibleLabels[j];
                        var radius = this.model.Radius * sf.EjSvgRender.utils._valueToCoefficient(axis, label.Value, this);
                        // calculation for spider web
                        for (var i = 0; i < this.model._axes[0].visibleLabels.length; i++) {
                            var xAxis = this.model._axes[0];
                            var vector = sf.EjSvgRender.utils._valueToVector(xAxis, xAxis.visibleLabels[i].Value);
                            if (!isNaN(vector.X) && !isNaN(vector.Y)) {
                                var vector2;
                                if ((i + 1) < xAxis.visibleLabels.length) {
                                    vector2 = sf.EjSvgRender.utils._valueToVector(xAxis, xAxis.visibleLabels[i + 1].Value);
                                }
                                else {
                                    vector2 = sf.EjSvgRender.utils._valueToVector(xAxis, xAxis.visibleLabels[0].Value);
                                }
                                var connectPoint = { X: this.model.centerX + radius * vector.X, Y: this.model.centerY + radius * vector.Y };
                                var endPoint = { X: this.model.centerX + radius * vector2.X, Y: this.model.centerY + radius * vector2.Y };
                                sbYMajorGrid.append("M" + " " + connectPoint.X + " " + connectPoint.Y + " " + "L" + " " + endPoint.X + " " + endPoint.Y + " ");
                            }
                        }
                    }
                    if (axis.majorGridLines.visible) {
                        var yMajorGridDir = sbYMajorGrid.toString();
                        var options = {
                            'id': this.svgObject.id + '_YAxisGridLines',
                            'fill': 'none',
                            'stroke-width': axis.majorGridLines.width,
                            'stroke': axis.majorGridLines.color,
                            'opacity': axis.majorGridLines.opacity,
                            'stroke-dasharray': axis.majorGridLines.dashArray,
                            'd': yMajorGridDir
                        };
                        //Drawing Major Grid Lines for radar
                        this.svgRenderer.drawPath(options, gEle);
                    }
                }
            }
            $(gEle).appendTo(this.gYaxisEle);

        },
        _drawPolarGridLine: function (axis) {

            var chartModel = this.model,
                legend = chartModel.legend,
                legendTitleHeight = sf.EjSvgRender.utils._measureText(legend.title.text, null, legend.title.font).height,
                legendPosition = legend.position.toLowerCase(),
                legXSpace = 0,
                legYSpace = 0,
                sbXMajorGrid = sf.EjSvgRender.utils._getStringBuilder(),
                sbXMajorTick = sf.EjSvgRender.utils._getStringBuilder(),
                borderSize = legend.border.width,
                yOffset, actualWidth, actualHeight,
                isRadar = false, vector, line, xMajorGridDir, xMajorTickDir,
                length = axis.visibleLabels.length,
                chartBorder = chartModel.border.width,
                title = chartModel.title,
                subTitle = chartModel.title.subTitle,
                titleEnable = title.enableTrim && (title.textOverflow == 'wrap' || title.textOverflow == 'wrapandtrim') ? true : false,
                subTitleEnable = subTitle.text != "" && subTitle.visible && subTitle.enableTrim && (subTitle.textOverflow == 'wrap' || subTitle.textOverflow == 'wrapandtrim') ? true : false;
            if (legend.visible && legendPosition != "custom") {
                if (legendPosition == "right" || legendPosition == "left")
                    legXSpace = ((legendPosition == "right") ? chartModel.margin.right : chartModel.margin.left) + chartModel.LegendActualBounds.Width + (borderSize + chartBorder) * 2;
                else
                    legYSpace = ((legendPosition == "top") ? chartModel.margin.top : chartModel.margin.bottom) + chartModel.LegendActualBounds.Height + legendTitleHeight + (borderSize + chartBorder) * 2;

            }
            // calculating the radius of the chart with avaible size
            yOffset = ((chartModel.title.text && chartModel.title.visible) ? chartModel._titleLocation.Y + (titleEnable ? chartModel._titleLocation.size.height : 0) + (subTitleEnable ? chartModel._subTitleLocation.size.height : 0) : 0) + legYSpace;

            actualWidth = chartModel.svgWidth - legXSpace;
            actualHeight = chartModel.svgHeight - yOffset;

            chartModel.centerX = actualWidth * 0.5 + ((legendPosition === "left") ? legXSpace : 0);
            chartModel.centerY = actualHeight * 0.5 + ((legendPosition === "top") ? yOffset : ((title.text && title.visible) ? (chartModel._titleLocation.Y + (titleEnable ? chartModel._titleLocation.size.height : 0) +
                (subTitleEnable ? chartModel._subTitleLocation.size.height : 0)) : 0));

            var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisGrid' });
            chartModel.finalSize = { width: actualWidth, height: actualHeight };

            chartModel.Radius = Math.abs(Math.min(chartModel.finalSize.width, chartModel.finalSize.height) / 2 - (2 * chartModel.elementSpacing) - axis.majorTickLines.size - axis._LableMaxWidth.maxHeight);

            var pos = 0;

            if (axis.majorGridLines.visible) {

                for (var j = 0; j < length; j++) {

                    vector = sf.EjSvgRender.utils._valueToVector(axis, axis.visibleLabels[j].Value);
                    line = {};
                    line.X1 = chartModel.centerX;

                    line.Y1 = chartModel.centerY;
                    line.X2 = chartModel.centerX + chartModel.Radius * vector.X;
                    line.Y2 = chartModel.centerY + chartModel.Radius * vector.Y;
                    sbXMajorGrid.append("M" + " " + line.X1 + " " + line.Y1 + " " + "L" + " " + line.X2 + " " + line.Y2 + " ");
                }

            }
            if (axis.visible && axis.majorTickLines.visible) {
                var radius = chartModel.Radius;
                for (var j = 0; j < length; j++) {
                    vector = sf.EjSvgRender.utils._valueToVector(axis, axis.visibleLabels[j].Value);
                    line = {};
                    line.X1 = chartModel.centerX + radius * vector.X;
                    line.Y1 = chartModel.centerY + radius * vector.Y;
                    line.X2 = line.X1 + axis.majorTickLines.size * vector.X;
                    line.Y2 = line.Y1 + axis.majorTickLines.size * vector.Y;
                    var direction = "M" + " " + line.X1 + " " + line.Y1 + " " + "L" + " " + line.X2 + " " + line.Y2 + " ";
                    if (direction.indexOf("NaN") == -1)
                        sbXMajorTick.append(direction);
                }
            }



            if (axis.majorGridLines.visible) {
                xMajorGridDir = sbXMajorGrid.toString();
                var options = {
                    'id': this.svgObject.id + '_XAxisGridLines',
                    'fill': 'none',
                    'stroke-width': axis.majorGridLines.width,
                    'stroke': axis.majorGridLines.color,
                    'opacity': axis.majorGridLines.opacity,
                    'stroke-dasharray': axis.majorGridLines.dashArray,
                    'd': xMajorGridDir
                };
                //Drawing XAxis Major Grid Lines
                if (xMajorGridDir.indexOf("NaN") == -1) {
                    this.svgRenderer.drawPath(options, gEle);
                    $(gEle).appendTo(this.gXaxisEle);
                }
            }

            if (axis.visible && axis.majorTickLines.visible) {
                xMajorTickDir = sbXMajorTick.toString();
                var options = {
                    'id': this.svgObject.id + '_XAxisMajorTicks',
                    'fill': 'none',
                    'stroke-width': axis.majorTickLines.width,
                    'stroke': axis.majorTickLines.color,
                    'd': xMajorTickDir
                };
                //Drawing XAxis Major Ticks Lines
                this.svgRenderer.drawPath(options, gEle);
                $(gEle).appendTo(this.gXaxisEle);
            }
        },
        _drawXAxisTickLine: function (axisIndex, xAxis, gEle, params) {
            var xMajorTicksDir, xMinorTicksDir;
            var sbXMinorTicks = sf.EjSvgRender.utils._getStringBuilder();
            var sbXMajorTicks = sf.EjSvgRender.utils._getStringBuilder();
            var minorPointX;
            var x1 = Math.floor(xAxis.x);
            var x2 = Math.floor(xAxis.x + xAxis.width);
            var opposedPosition = xAxis._opposed;
            var labelValue, xPointValue = [];
            var isScroll = xAxis._isScroll && !(xAxis.scrollbarSettings.pointsLength != null && xAxis.scrollbarSettings.pointsLength < xAxis.maxPointLength);
            var labelBorder = xAxis.labelBorder;
            var isCrossesAt = params.axes[xAxis.name]._validCross;
            if (axisIndex != 0 && !isCrossesAt && ((xAxis.labelPosition == 'inside' && xAxis.tickLinesPosition == 'inside') || (xAxis.labelPosition == 'inside' && xAxis.tickLinesPosition != 'inside')) && (!(xAxis.y == (this.model.m_AreaBounds.Height + this.model.m_AreaBounds.Y) || (xAxis.y == this.model.m_AreaBounds.Y)))) {
                var y1 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis._LableMaxWidth.height) : Math.floor(xAxis.y - xAxis._LableMaxWidth.height);
                var y2 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis._LableMaxWidth.height) : Math.floor(xAxis.y - xAxis._LableMaxWidth.height);
            }
            else if (axisIndex != 0 && !isCrossesAt && (xAxis.labelPosition != 'inside' && xAxis.tickLinesPosition == 'inside') && (!(xAxis.y == (this.model.m_AreaBounds.Height + this.model.m_AreaBounds.Y) || (xAxis.y == this.model.m_AreaBounds.Y)))) {
                var y1 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis.majorTickLines.size) : Math.floor(xAxis.y - xAxis.majorTickLines.size);
                var y2 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis.majorTickLines.size) : Math.floor(xAxis.y - xAxis.majorTickLines.size);
            }

            else {
                var y1 = y2 = (xAxis._y) ? (!xAxis.showNextToAxisLine) ? xAxis._y : xAxis.y : Math.floor(xAxis.y + xAxis.majorTickLines.size - 5);
            }
            if (!gEle)
                var gTickEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisTicklines' + '_' + axisIndex });
            xAxis.labelPlacement = (!(xAxis.labelPlacement)) ? sf.datavisualization.Chart.LabelPlacement.BetweenTicks : xAxis.labelPlacement;
            var ticksbwtLabel = ((xAxis.labels.length > 0) && (xAxis.labelPlacement.toLowerCase() == "betweenticks")) ? -0.5 : 0;
            var collectionLength = xAxis.visibleLabels.length;
            //For between ticks and gridlines
            if ((xAxis._valueType.toLowerCase() == sf.datavisualization.Chart.ValueType.Category) && ticksbwtLabel < 0) {
                collectionLength = collectionLength > 0 ? xAxis.visibleLabels.length + 1 : collectionLength;
            }
            for (var i = 0; i < collectionLength; i++) {

                labelValue = (!xAxis.visibleLabels[i]) ? xAxis.visibleLabels[i - 1].Value + xAxis.range.interval : xAxis.visibleLabels[i].Value;

                var tempInterval = ((xAxis.labels.length > 0) && (ticksbwtLabel < 0)) ? labelValue + ticksbwtLabel : labelValue;

                tempInterval = (!(xAxis.roundingPlaces)) ? parseFloat(tempInterval.toFixed((sf.EjSvgRender.utils._decimalPlaces(xAxis.visibleRange.interval) == 0 ? 1 : sf.EjSvgRender.utils._decimalPlaces(xAxis.visibleRange.interval)))) : tempInterval;

                if (sf.EjSvgRender.utils._inside(tempInterval, xAxis.visibleRange)) {

                    if ((xAxis.hidePartialLabels) && ((i == 0) || (i == (collectionLength - 1))))
                        continue;
                    if (xAxis.minorGridLines.visible || xAxis.minorTickLines.visible) {
                        var ticksVal = this._getSharpPath(xAxis.minorTickLines.width);
                        var linesVal = this._getSharpPath(xAxis.minorGridLines.width);
                        var yTickPosition;
                        if (xAxis._valueType == "logarithmic") {
                            minorTicks = tempInterval;
                            var logmax = xAxis.visibleRange.max;
                            var logmin = xAxis.visibleRange.min;

                            var logtickstart = Math.pow(xAxis.logBase, minorTicks - xAxis.visibleRange.interval);
                            var logtickend = Math.pow(xAxis.logBase, minorTicks);
                            var logtickInterval = (logtickend - logtickstart) / (xAxis.minorTicksPerInterval + 1);
                            var logtickPos = logtickstart + logtickInterval;
                            minorTicks = sf.EjSvgRender.utils._logBase(logtickPos, xAxis.logBase);
                            for (var j = 0; j < xAxis.minorTicksPerInterval; j++) {


                                if (minorTicks < logmax && minorTicks > logmin) {

                                    minorPointX = Math.ceil(((minorTicks - logmin) / (logmax - logmin)) * (xAxis.width));

                                    //Calculate Minor Ticks
                                    if ((xAxis.minorTickLines) && xAxis.minorTickLines.visible) {
                                        var xTickPosition = Math.floor(minorPointX + x1);
                                        if ((xAxis.tickLinesPosition != 'inside' && xAxis.labelPosition != 'inside') || (xAxis.tickLinesPosition != 'inside' && xAxis.labelPosition == 'inside'))
                                            yTickPosition = (opposedPosition) ? Math.floor(y1 - xAxis.minorTickLines.size) : Math.floor(xAxis.minorTickLines.size + y1);
                                        else
                                            yTickPosition = (opposedPosition) ? Math.floor(y1 + xAxis.minorTickLines.size) : y1 - Math.floor(xAxis.minorTickLines.size);
                                        sbXMinorTicks.append("M" + " " + (xTickPosition + ticksVal) + " " + (yTickPosition + ticksVal) + " " + "L" + " " + (xTickPosition + ticksVal) + " " + (y1 + ticksVal) + " ");
                                    }
                                }
                            }
                        }
                        else {
                            for (var j = 0, minorTicks = tempInterval; j < xAxis.minorTicksPerInterval; j++) {
                                minorTicks += xAxis.visibleRange.interval / (xAxis.minorTicksPerInterval + 1);
                                if (minorTicks < xAxis.visibleRange.max && minorTicks > xAxis.visibleRange.min) {
                                    minorPointX = Math.ceil(((minorTicks - xAxis.visibleRange.min) / (xAxis.visibleRange.max - xAxis.visibleRange.min)) * (xAxis.width));

                                    //Calculate Minor Ticks
                                    if ((xAxis.minorTickLines) && xAxis.minorTickLines.visible) {
                                        if ((xAxis.tickLinesPosition != 'inside' && xAxis.labelPosition != 'inside') || (xAxis.tickLinesPosition != 'inside' && xAxis.labelPosition == 'inside'))
                                            yTickPosition = (opposedPosition) ? Math.floor(y1 - xAxis.minorTickLines.size) : Math.floor(xAxis.minorTickLines.size + y1);
                                        else
                                            yTickPosition = (opposedPosition) ? Math.floor(y1 + xAxis.minorTickLines.size) : Math.floor(y1 - xAxis.minorTickLines.size);
                                        var points = Math.floor(minorPointX + x1);
                                        sbXMinorTicks.append("M" + " " + (points + ticksVal) + " " + (yTickPosition + ticksVal) + " " + "L" + " " + (points + ticksVal) + " " + (y1 + ticksVal) + " ");
                                    }
                                }
                            }
                        }

                    }

                    //calculate major ticks
                    if (xAxis.majorTickLines.visible || xAxis.majorGridLines.visible || labelBorder.width > 0) {
                        var mtVal = this._getSharpPath(xAxis.majorTickLines.width);
                        var mlVal = this._getSharpPath(xAxis.majorGridLines.width);
                        //Calculate Major Ticks and Grid lines
                        var pointX = xPointValue[i] = this.pointX = Math.ceil(sf.EjSvgRender.utils._getPointXY(tempInterval, xAxis.visibleRange, xAxis.isInversed) * (xAxis.width));
                        //Calculate Major Ticks
                        if (xAxis.majorTickLines.visible) {

                            var lineStart = xAxis.majorTickLines.size + xAxis.axisLine.width / 2;
                            if ((xAxis.tickLinesPosition == 'inside' && xAxis.labelPosition == 'inside') || (xAxis.tickLinesPosition == 'inside' && xAxis.labelPosition != 'inside'))
                                var yPosition = (opposedPosition) ? y1 + lineStart : y1 - lineStart;
                            else
                                var yPosition = ((opposedPosition) ? y1 - lineStart : lineStart + y1) - ((isScroll) ? opposedPosition ? this.model.scrollerSize : -this.model.scrollerSize : 0);
                            sbXMajorTicks.append("M" + " " + (Math.floor(pointX + x1) + mtVal) + " " + (Math.floor(yPosition) + mtVal) + " " + "L" + " " + (Math.floor(pointX + x1) + mtVal) + " " + (Math.floor(y1 + ((opposedPosition) ? (-xAxis.axisLine.width / 2) : (xAxis.axisLine.width / 2))) + mtVal) + " ");
                        }
                    }
                }
            }
            // draw xAxis label border
            if (labelBorder.width > 0) {
                var xLabelGrid = sf.EjSvgRender.utils._getStringBuilder(), scrollSize = isScroll ? this.model.scrollerSize : 0,
                    lineStart = xAxis.axisLine.width, yPosition, endY, startX, endX, i, gap, labelPosition = xAxis.labelPosition.toLowerCase(), boundsX = this.model.m_AreaBounds.X,
                    boundsWidth = this.model.m_AreaBounds.Width, borderSize = labelBorder.width, length = xAxis._LableMaxWidth.height + xAxis.axisLine.width / 2 + 2,
                    collectionLength = xAxis.visibleLabels.length;
				y1 =  xAxis.y;
                if (xAxis.tickLinesPosition == labelPosition) length += xAxis.majorTickLines.size;
                if (labelPosition == 'inside') {
                    yPosition = (opposedPosition) ? y1 + lineStart : y1 + lineStart;
                    endY = opposedPosition ? y1 + length : y1 - length;
                }
                else {
                    yPosition = (opposedPosition) ? y1 - lineStart : lineStart + y1 + ((xAxis.zoomFactor < 1 && this.model.zooming.enableScrollbar
                        && axisIndex == 0) ? this.model.scrollerSize : 0);
                    endY = opposedPosition ? y1 - length - scrollSize : y1 + length + scrollSize;
                }

                for (i = 0; i < collectionLength; i++) {
                    gap = (xPointValue[xPointValue.length - 1] - xPointValue[xPointValue.length - 2]) / 2;
                    if (!sf.util.isNullOrUndefined(xPointValue[i]) && xPointValue.length >= 1 && !isNaN(gap)) {
                        if (xAxis._valueType == "category" && xAxis.labelPlacement.toLowerCase() == "betweenticks") {
                            startX = xPointValue[i] + x1;
                            endX = xPointValue[i] + (gap * 2) + x1;
                        } else {
                            startX = xPointValue[i] - gap + x1;
                            endX = xPointValue[i] + gap + x1;
                        }
                        endX = Math.floor(endX);
                        endY = Math.floor(endY);
                        startX = Math.floor(startX);
                        yPosition = Math.floor(yPosition);
                        if (startX < xAxis.x)
                            xLabelGrid.append("M" + " " + Math.floor(x1) + " " + endY + " " +
                                "L" + " " + endX + " " + endY + " ");
                        else if (endX > xAxis.width + xAxis.x) {
                            xLabelGrid.append("M" + " " + startX + " " + yPosition + " " + "L" + " " + startX + " " + endY + " " +
                                "L" + " " + Math.floor(xAxis.width + x1) + " " + endY + " ");
                            if (endX - borderSize <= xAxis.width + xAxis.x)
                                xLabelGrid.append("M " + Math.floor(xAxis.width + x1) + " " + endY + " L " + (xAxis.x + xAxis.width) + " " + yPosition);
                        }
                        else {
                            if (i == 0)
                                xLabelGrid.append("M " + xAxis.x + " " + endY + " L " + startX + " " + endY + " ");
                            xLabelGrid.append("M" + " " + startX + " " + yPosition + " " + "L" + " " + startX + " " + endY + " " +
                                "L" + " " + endX + " " + endY + " ");
                            if (i == collectionLength - 1)
                                xLabelGrid.append("M" + " " + endX + " " + yPosition + " " + "L" + " " + endX + " " + endY + " " +
                                    "M " + endX + " " + endY + " L " + (xAxis.x + xAxis.width) + " " + endY);
                        }
                    }
                }
                var labelGridOptions = {
                    'id': this.svgObject.id + '_XAxisLabelBorder_' + axisIndex,
                    'fill': 'transparent',
                    'stroke-width': labelBorder.width,
                    'stroke': labelBorder.color,
                    'd': xLabelGrid.toString()
                };
                this.svgRenderer.drawPath(labelGridOptions, gEle);
                $(gEle).appendTo(this.gXaxisEle);
            }

            //draw minor ticks
            if (xAxis.minorTickLines.visible && xAxis.visible && xAxis.minorTicksPerInterval > 0) {
                xMinorTicksDir = sbXMinorTicks.toString();
                var optionsMinorTicks = {
                    'id': this.svgObject.id + '_XAxisMinorTicks_' + axisIndex,
                    'fill': 'none',
                    'stroke-width': xAxis.minorTickLines.width,
                    'stroke': xAxis.minorTickLines.color,
                    'd': xMinorTicksDir
                };
                if (!gEle)
                    this.svgRenderer.drawPath(optionsMinorTicks, gTickEle);
                else
                    this.svgRenderer.drawPath(optionsMinorTicks, gEle);

            }
            if (xAxis.majorTickLines.visible && xAxis.visible) {
                xMajorTicksDir = sbXMajorTicks.toString();
                var optionsMajorTicks = {
                    'id': this.svgObject.id + '_XAxisMajorTicks_' + axisIndex,
                    'fill': 'none',
                    'stroke-width': xAxis.majorTickLines.width,
                    'stroke': xAxis.majorTickLines.color,
                    'd': xMajorTicksDir
                };
                if (!gEle) {

                    this.svgRenderer.drawPath(optionsMajorTicks, gTickEle);
                }
                else
                    this.svgRenderer.drawPath(optionsMajorTicks, gEle);
            }
            if (xAxis.tickLinesPosition == 'inside')
                $(gTickEle).appendTo(this.gXaxisEle);

        },
        _drawXAxisGridLine: function (axisIndex, xAxis, params) {
            var xMajorGridDir, xMinorGridDir,
                sbXMinorGrid = sf.EjSvgRender.utils._getStringBuilder(),
                sbXMajorGrid = sf.EjSvgRender.utils._getStringBuilder(),
                minorPointX,
                xPoint = [], padding = this.model.elementSpacing + 5,
                labelValue,
                opposedPosition = xAxis._opposed,
                x1 = Math.floor(xAxis.x),
                x2 = Math.floor(xAxis.x + xAxis.width),
                gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisGrid' + '_' + axisIndex }),
                gAgb = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisAlternateGridBand' + '_' + axisIndex });
            var isCrossesAt = params.axes[xAxis.name]._validCross;
            if (axisIndex != 0 && !isCrossesAt && (xAxis.labelPosition == 'inside' && xAxis.tickLinesPosition == 'inside') && (!(xAxis.y == (this.model.m_AreaBounds.Height + this.model.m_AreaBounds.Y) || (xAxis.y == this.model.m_AreaBounds.Y)))) {
                var y1 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis._LableMaxWidth.height) : Math.floor(xAxis.y - xAxis._LableMaxWidth.height);
                var y2 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis._LableMaxWidth.height) : Math.floor(xAxis.y - xAxis._LableMaxWidth.height);
            }
            else if ((xAxis.labelPosition == 'inside' && xAxis.tickLinesPosition != 'inside') && (!(xAxis.y == (this.model.m_AreaBounds.Height + this.model.m_AreaBounds.Y) || (xAxis.y == this.model.m_AreaBounds.Y)))) {
                var y1 = y2 = (!opposedPosition) ? (xAxis.showNextToAxisLine) ? Math.floor(xAxis.y + xAxis._LableMaxWidth.height) - padding : Math.floor(xAxis.y + xAxis._LableMaxWidth.height) : Math.floor(xAxis.y - xAxis._LableMaxWidth.height) + padding;
            }
            else if (axisIndex != 0 && !isCrossesAt && (xAxis.labelPosition != 'inside' && xAxis.tickLinesPosition == 'inside') && (!(xAxis.y == (this.model.m_AreaBounds.Height + this.model.m_AreaBounds.Y) || (xAxis.y == this.model.m_AreaBounds.Y)))) {
                var y1 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis.majorTickLines.size) : Math.floor(xAxis.y - xAxis.majorTickLines.size);
                var y2 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis.majorTickLines.size) : Math.floor(xAxis.y - xAxis.majorTickLines.size);
            }
            else {
                var y1 = Math.floor(xAxis.y);
                var y2 = Math.floor(xAxis.y);
            }

            if (xAxis.visible && xAxis.axisLine.visible) {
                var offset = xAxis.axisLine.offset > 0 ? xAxis.axisLine.offset : 0;
                var val = this._getSharpPath(xAxis.axisLine.width);
                var optionsLine = {
                    'id': this.svgObject.id + '_XAxisLine_' + axisIndex,
                    x1: (x1 - xAxis.plotOffset) + val + offset,
                    y1: y1 + val,
                    x2: (x2 + xAxis.plotOffset) - offset + val,
                    y2: y2 + val,
                    'stroke-dasharray': xAxis.axisLine.dashArray,
                    'stroke-width': xAxis.axisLine.width,
                    'stroke': xAxis.axisLine.color,
                    'opacity': xAxis.axisLine.opacity || 1
                };

                params.axes[xAxis.name]._lineOption = [optionsLine, this.gXaxisEle];
            }
            else
                params.axes[xAxis.name]._lineOption = [null, this.gXaxisEle];
            xAxis.labelPlacement = (!(xAxis.labelPlacement)) ? sf.datavisualization.Chart.LabelPlacement.BetweenTicks : xAxis.labelPlacement;
            var ticksbwtLabel = ((xAxis.labels.length > 0) && (xAxis.labelPlacement.toLowerCase() == "betweenticks")) ? -0.5 : 0;
            var collectionLength = xAxis.visibleLabels.length;
            //For between ticks and gridlines
            if ((xAxis._valueType.toLowerCase() == sf.datavisualization.Chart.ValueType.Category) && ticksbwtLabel < 0) {
                collectionLength = collectionLength > 0 ? xAxis.visibleLabels.length + 1 : collectionLength;
            }
            for (var i = 0; i < collectionLength; i++) {
                labelValue = (!xAxis.visibleLabels[i]) ? xAxis.visibleLabels[i - 1].Value + xAxis.range.interval : xAxis.visibleLabels[i].Value;

                var tempInterval = ((xAxis.labels.length > 0) && (ticksbwtLabel < 0)) ? labelValue + ticksbwtLabel : labelValue;

                tempInterval = (!(xAxis.roundingPlaces)) ? parseFloat(tempInterval.toFixed((sf.EjSvgRender.utils._decimalPlaces(xAxis.visibleRange.interval) == 0 ? 1 : sf.EjSvgRender.utils._decimalPlaces(xAxis.visibleRange.interval)))) : tempInterval;

                if (sf.EjSvgRender.utils._inside(tempInterval, xAxis.visibleRange)) {

                    if ((xAxis.hidePartialLabels) && ((i == 0) || (i == (collectionLength - 1))))
                        continue;

                    //Calculate Minor Ticks and Grid lines
                    if (xAxis.minorGridLines.visible || xAxis.minorTickLines.visible) {
                        var ticksVal = this._getSharpPath(xAxis.minorTickLines.width);
                        var linesVal = this._getSharpPath(xAxis.minorGridLines.width);
                        var yTickPosition;
                        if (xAxis._valueType == "logarithmic") {
                            minorTicks = tempInterval;
                            var logmax = xAxis.visibleRange.max;
                            var logmin = xAxis.visibleRange.min;

                            var logtickstart = Math.pow(xAxis.logBase, minorTicks - xAxis.visibleRange.interval);
                            var logtickend = Math.pow(xAxis.logBase, minorTicks);
                            var logtickInterval = (logtickend - logtickstart) / (xAxis.minorTicksPerInterval + 1);
                            var logtickPos = logtickstart + logtickInterval;
                            minorTicks = sf.EjSvgRender.utils._logBase(logtickPos, xAxis.logBase);
                            for (var j = 0; j < xAxis.minorTicksPerInterval; j++) {


                                if (minorTicks < logmax && minorTicks > logmin) {

                                    minorPointX = Math.ceil(((minorTicks - logmin) / (logmax - logmin)) * (xAxis.width));



                                    //Calculate Minor Gridlines
                                    if ((xAxis.minorGridLines) && xAxis.minorGridLines.visible) {
                                        var tickPosition = Math.floor(minorPointX + x1);
                                        sbXMinorGrid.append("M" + " " + (tickPosition + linesVal) + " " + (y1 + linesVal) + " " + "L" + " " + (tickPosition + linesVal) + " " + (Math.floor(opposedPosition ? this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height : this.model.m_AreaBounds.Y) + linesVal) + " ");
                                    }

                                }
                                logtickPos += logtickInterval;
                                minorTicks = sf.EjSvgRender.utils._logBase(logtickPos, xAxis.logBase);
                            }
                        } else {
                            for (var j = 0, minorTicks = tempInterval; j < xAxis.minorTicksPerInterval; j++) {
                                minorTicks += xAxis.visibleRange.interval / (xAxis.minorTicksPerInterval + 1);
                                if (minorTicks < xAxis.visibleRange.max && minorTicks > xAxis.visibleRange.min) {
                                    minorPointX = Math.ceil(((minorTicks - xAxis.visibleRange.min) / (xAxis.visibleRange.max - xAxis.visibleRange.min)) * (xAxis.width));


                                    //Calculate Minor Gridlines
                                    if ((xAxis.minorGridLines) && xAxis.minorGridLines.visible)
                                        sbXMinorGrid.append("M" + " " + (Math.floor(minorPointX + x1) + linesVal) + " " + (y1 + linesVal) + " " + "L" + " " + (Math.floor(minorPointX + x1) + linesVal) + " " + (Math.floor(opposedPosition ? this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height : this.model.m_AreaBounds.Y) + linesVal) + " ");
                                }
                            }
                        }
                    }

                    if (xAxis.majorTickLines.visible || xAxis.majorGridLines.visible) {
                        var mtVal = this._getSharpPath(xAxis.majorTickLines.width);
                        var mlVal = this._getSharpPath(xAxis.majorGridLines.width);
                        var pointX = this.pointX = Math.ceil(sf.EjSvgRender.utils._getPointXY(tempInterval, xAxis.visibleRange, xAxis.isInversed) * (xAxis.width));
                        var mX1 = (Math.floor(pointX + x1));
                        if (xAxis.zoomed)
                            xPoint[0] = xAxis.x;
                        if (i == 0) {
                            if (mX1 == Math.floor(this.model.m_AreaBounds.X)) {
                                xPoint.push(mX1 + mlVal);
                                continue;

                            }
                        }
                        if ((i == (collectionLength - 1)) && (this.model.chartArea.border.color != "transparent" && this.model.chartArea.border.width > 0)) {
                            if (mX1 == Math.floor(this.model.m_AreaBounds.X + this.model.m_AreaBounds.Width))
                                continue;
                            if (xAxis.zoomed)
                                xPoint[collectionLength] = mX1 + mlVal;

                        }

                        //Calculate Major Gridlines
                        if (xAxis.majorGridLines.visible)
                            sbXMajorGrid.append("M" + " " + (mX1 + mlVal) + " " + (Math.floor(this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height) + mlVal) + " " + "L" + " " + (mX1 + mlVal) + " " + (Math.floor(this.model.m_AreaBounds.Y) + mlVal) + " ");
                        if ((xAxis._valueType.toLowerCase() != "category") && i == collectionLength - 1)
                            continue;
                        xPoint.push((mX1 + mlVal));
                    }

                }

            }


            if (xAxis.alternateGridBand.odd.fill != "transparent" || xAxis.alternateGridBand.even.fill != "transparent") {
                var height = this.model.m_AreaBounds.Height, optionsAlternateeven;

                if (xPoint.length === 0) {
                    optionsAlternateeven = {
                        'id': this.svgObject.id + '_XAxis' + axisIndex + '_Alternateeven' + 0,
                        'x': xAxis.x,
                        'y': Math.floor(this.model.m_AreaBounds.Y),
                        'width': xAxis.width,
                        'height': height,
                        'fill': xAxis.alternateGridBand.even.fill,
                        'opacity': xAxis.alternateGridBand.even.opacity,
                        'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)',
                        'stroke': "transparent"
                    };
                    this.svgRenderer.drawRect(optionsAlternateeven, gAgb);
                }

                for (var i = 1; i < xPoint.length; i += 2) {
                    var width = xPoint[i + 1] - xPoint[i];
                    width = (width || xAxis.labelPlacement.toLowerCase() == 'onticks') ? width : (xAxis.width + xAxis.x) - xPoint[i];
                    if (i == xPoint.length - 1 && xAxis.zoomed)
                        width = this.model.m_AreaBounds.X + this.model.m_AreaBounds.Width - xPoint[xPoint.length - 1] - xAxis.plotOffset;
                    var optionsAlternateodd = {
                        'id': this.svgObject.id + '_XAxis' + axisIndex + '_Alternateodd' + [i],
                        'x': xPoint[i],
                        'y': Math.floor(this.model.m_AreaBounds.Y),
                        'width': width,
                        'height': height,
                        'fill': xAxis.alternateGridBand.odd.fill,
                        'opacity': xAxis.alternateGridBand.odd.opacity,
                        'stroke': "transparent",
                        'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)'

                    };
                    if (width > 0)
                        this.svgRenderer.drawRect(optionsAlternateodd, gAgb);
                }

                for (var i = 0; i < xPoint.length; i += 2) {
                    var width = xPoint[i + 1] - xPoint[i];
                    width = (width || xAxis.labelPlacement.toLowerCase() == 'onticks') ? width : (xAxis.width + xAxis.x) - xPoint[i];
                    if (i == 0 && xAxis.zoomed)
                        width = xPoint[1] - xAxis.x;

                    if (i == xPoint.length - 1 && xAxis.zoomed)
                        width = this.model.m_AreaBounds.X + this.model.m_AreaBounds.Width - xPoint[xPoint.length - 1] - xAxis.plotOffset;

                    optionsAlternateeven = {
                        'id': this.svgObject.id + '_XAxis' + axisIndex + '_Alternateeven' + [i],
                        'x': xPoint[i],
                        'y': Math.floor(this.model.m_AreaBounds.Y),
                        'width': width,
                        'height': height,
                        'fill': xAxis.alternateGridBand.even.fill,
                        'opacity': xAxis.alternateGridBand.even.opacity,
                        'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)',
                        'stroke': "transparent"
                    };
                    if (width > 0)
                        this.svgRenderer.drawRect(optionsAlternateeven, gAgb);
                }
                $(gAgb).appendTo(gEle);
            }
            if (xAxis.minorGridLines.visible && xAxis.minorTicksPerInterval > 0) {
                xMinorGridDir = sbXMinorGrid.toString();
                //Drawing Minor Grid Lines
                var optionsMinorGrid = {
                    'id': this.svgObject.id + '_XAxisMinorGridLines_' + axisIndex,
                    'fill': 'none',
                    'stroke-width': xAxis.minorGridLines.width,
                    'stroke': xAxis.minorGridLines.color,
                    'stroke-dasharray': xAxis.minorGridLines.dashArray,
                    'd': xMinorGridDir
                };
                this.svgRenderer.drawPath(optionsMinorGrid, gEle);
            }
            xMajorGridDir = sbXMajorGrid.toString();
            if (xAxis.majorGridLines.visible) {
                var options = {
                    'id': this.svgObject.id + '_XAxisMajorGridLines_' + axisIndex,
                    'fill': 'none',
                    'stroke-width': xAxis.majorGridLines.width,
                    'stroke': xAxis.majorGridLines.color,
                    'opacity': xAxis.majorGridLines.opacity,
                    'stroke-dasharray': xAxis.majorGridLines.dashArray,
                    'd': xMajorGridDir
                };

                //Drawing Major Grid Lines
                if (options.d != '')
                    this.svgRenderer.drawPath(options, gEle);

            }
            $(gEle).appendTo(this.svgObject);


        },

        _drawYAxisTickLine: function (axisIndex, yAxis, gEle, isValidCross) {
            var yMajorTicksDir = "", yMinorTicksDir = "";
            var pointY = 0;
            var isScroll = yAxis._isScroll && !(yAxis.scrollbarSettings.pointsLength != null && yAxis.scrollbarSettings.pointsLength < yAxis.maxPointLength);
            var opposedPosition = yAxis._opposed;
            var labelValue, yPointValue = [];
            var labelBorder = yAxis.labelBorder;

            if (axisIndex != 1 && ((yAxis.labelPosition == 'inside' && yAxis.tickLinesPosition == 'inside') || (yAxis.labelPosition == 'inside' && yAxis.tickLinesPosition != 'inside')) && (!(yAxis.x == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) || (yAxis.x == (this.model.m_AreaBounds.X))))) {
                var x1 = (!opposedPosition && !isValidCross) ? Math.floor(yAxis.x - yAxis._LableMaxWidth.width - this.model.elementSpacing) : yAxis.showNextToAxisLine ? yAxis.x : Math.floor(yAxis.x + yAxis._LableMaxWidth.width + this.model.elementSpacing);
                var x2 = (!opposedPosition && !isValidCross) ? Math.floor(yAxis.x - yAxis._LableMaxWidth.width - this.model.elementSpacing) : yAxis.showNextToAxisLine ? yAxis.x : Math.floor(yAxis.x + yAxis._LableMaxWidth.width + this.model.elementSpacing);
            }
            else if (axisIndex != 1 && !isValidCross && (yAxis.labelPosition != 'inside' && yAxis.tickLinesPosition == 'inside') && (!(yAxis.x == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) || (yAxis.x == (this.model.m_AreaBounds.X))))) {
                var x1 = Math.floor(yAxis.x + yAxis.majorTickLines.size);
                var x2 = Math.floor(yAxis.x + yAxis.majorTickLines.size);
            }
            else {
                var x1 = x2 = (!yAxis.showNextToAxisLine) ? yAxis._x : !yAxis.showNextToAxisLine && yAxis.tickLinesPosition == "inside" ? yAxis.x + yAxis.majorTickLines.size : yAxis.x;
            }

            var y1 = Math.floor(yAxis.y + yAxis.height);
            var y2 = Math.floor(yAxis.y);


            var sbYMinorTicks = sf.EjSvgRender.utils._getStringBuilder();
            var sbYMajorTicks = sf.EjSvgRender.utils._getStringBuilder();
            var gTickEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisTicklines' + '_' + axisIndex });

            yAxis.labelPlacement = (!(yAxis.labelPlacement)) ? sf.datavisualization.Chart.LabelPlacement.BetweenTicks : yAxis.labelPlacement;
            var ticksbwtLabel = ((yAxis.labels.length > 0) && (yAxis.labelPlacement.toLowerCase() == "betweenticks")) ? -0.5 : 0;
            var collectionLength = yAxis.visibleLabels.length;
            //For between ticks and gridlines
            if ((yAxis._valueType.toLowerCase() == sf.datavisualization.Chart.ValueType.Category) && ticksbwtLabel < 0) {
                collectionLength = collectionLength > 0 ? yAxis.visibleLabels.length + 1 : collectionLength;
            }
            for (var i = 0; i < collectionLength; i++) {
                labelValue = (!yAxis.visibleLabels[i]) ? yAxis.visibleLabels[i - 1].Value + yAxis.range.interval : yAxis.visibleLabels[i].Value;
                var tempInterval = ((yAxis.labels.length > 0) && (ticksbwtLabel < 0)) ? labelValue + ticksbwtLabel : labelValue;
                tempInterval = (!(yAxis.roundingPlaces)) ? parseFloat(tempInterval.toFixed((sf.EjSvgRender.utils._decimalPlaces(yAxis.visibleRange.interval) == 0 ? 1 : sf.EjSvgRender.utils._decimalPlaces(yAxis.visibleRange.interval)))) : tempInterval;

                if (sf.EjSvgRender.utils._inside(tempInterval, yAxis.visibleRange)) {

                    if ((yAxis.hidePartialLabels) && ((i == 0) || (i == (yAxis.visibleLabels.length - 1))))
                        continue;

                    // Calculate Minor Ticks and Grid lines      
                    if (yAxis.minorGridLines.visible || yAxis.minorTickLines.visible) {
                        var minorPointY;
                        var tickVal = this._getSharpPath(yAxis.minorTickLines.width);
                        var lineVal = this._getSharpPath(yAxis.minorGridLines.width);
                        if (yAxis._valueType == "logarithmic") {
                            minorTicks = tempInterval;
                            var logmax = yAxis.visibleRange.max;
                            var logmin = yAxis.visibleRange.min;

                            var logtickstart = Math.pow(yAxis.logBase, minorTicks - yAxis.visibleRange.interval);
                            var logtickend = Math.pow(yAxis.logBase, minorTicks);
                            var logtickInterval = (logtickend - logtickstart) / (yAxis.minorTicksPerInterval + 1);
                            var logtickPos = logtickstart + logtickInterval;
                            minorTicks = sf.EjSvgRender.utils._logBase(logtickPos, yAxis.logBase);
                            for (var j = 0; j < yAxis.minorTicksPerInterval; j++) {


                                if (minorTicks < logmax && minorTicks > logmin) {

                                    minorPointY = Math.ceil(((minorTicks - logmin) / (logmax - logmin)) * (yAxis.height));

                                    //Calculate Minor Ticks
                                    if ((yAxis.minorTickLines) && yAxis.minorTickLines.visible) {

                                        if (yAxis.minorTickLines.visible) {
                                            if ((yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition != 'inside') || (yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition == 'inside'))
                                                ytickPosition = (opposedPosition) ? yAxis.minorTickLines.size : -yAxis.minorTickLines.size;
                                            else
                                                var ytickPosition = (opposedPosition) ? -yAxis.minorTickLines.size : yAxis.minorTickLines.size;
                                            sbYMinorTicks.append("M" + " " + (Math.floor(ytickPosition + x1) + tickVal) + " " + (Math.floor((minorPointY * -1) + y1) + tickVal) + " " + "L" + " " + (x1 + tickVal) + " " + (Math.floor((minorPointY * -1) + y1) + tickVal) + " ");
                                        }
                                    }
                                }
                                logtickPos += logtickInterval;
                                minorTicks = sf.EjSvgRender.utils._logBase(logtickPos, yAxis.logBase);
                            }
                        }
                        else {
                            for (var j = 0, minorTicks = tempInterval; j < yAxis.minorTicksPerInterval; j++) {

                                minorTicks += yAxis.visibleRange.interval / (yAxis.minorTicksPerInterval + 1);
                                if (minorTicks < yAxis.visibleRange.max && minorTicks > yAxis.visibleRange.min) {
                                    minorPointY = ((minorTicks - yAxis.visibleRange.min) / (yAxis.visibleRange.delta)) * (yAxis.height);
                                    // Calculate Minor Ticks   
                                    if (yAxis.minorTickLines.visible) {
                                        if ((yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition != 'inside') || (yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition == 'inside'))
                                            var ytickPosition = (opposedPosition) ? yAxis.minorTickLines.size : -yAxis.minorTickLines.size;
                                        else
                                            var ytickPosition = (opposedPosition) ? -yAxis.minorTickLines.size : yAxis.minorTickLines.size;
                                        sbYMinorTicks.append("M" + " " + (Math.floor(ytickPosition + x1) + tickVal) + " " + (Math.floor((minorPointY * -1) + y1) + tickVal) + " " + "L" + " " + (x1 + tickVal) + " " + (Math.floor((minorPointY * -1) + y1) + tickVal) + " ");
                                    }

                                }
                            }
                        }
                    }
                    // Calculate Major Ticks and Grid lines
                    if (yAxis.majorTickLines.visible || yAxis.majorGridLines.visible || labelBorder.width > 0) {
                        var mtVal = this._getSharpPath(yAxis.minorTickLines.width);
                        var mlVal = this._getSharpPath(yAxis.majorGridLines.width);
                        pointY = yPointValue[i] = sf.EjSvgRender.utils._getPointXY(tempInterval, yAxis.visibleRange, yAxis.isInversed) * (yAxis.height);
                        // Calculate Major Ticks
                        if (yAxis.majorTickLines.visible) {
                            if ((yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition != 'inside') || (yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition == 'inside'))
                                var xPosition = ((opposedPosition) ? yAxis.majorTickLines.size + yAxis.axisLine.width / 2 : -(yAxis.majorTickLines.size + yAxis.axisLine.width / 2)) + ((isScroll) ? opposedPosition ? this.model.scrollerSize : opposedPosition - this.model.scrollerSize : 0);
                            else if ((yAxis.tickLinesPosition == 'inside' && yAxis.labelPosition != 'inside') || (yAxis.tickLinesPosition == 'inside' && yAxis.labelPosition == 'inside'))
                                var xPosition = (opposedPosition) ? -(yAxis.majorTickLines.size + yAxis.axisLine.width / 2) : (yAxis.majorTickLines.size + yAxis.axisLine.width / 2);

                            sbYMajorTicks.append("M" + " " + (Math.floor(xPosition + x1) + mtVal) + " " + (Math.floor((pointY * -1) + y1) + mtVal) + " " + "L" + " " + (Math.floor(x1 + ((opposedPosition) ? (yAxis.axisLine.width / 2) : (yAxis.axisLine.width / 2))) + mtVal) + " " + (Math.floor((pointY * -1) + y1) + mtVal) + " ");

                        }



                    }
                }
            }

            // draw yAxis label border
            if (labelBorder.width > 0) {
                var yLabelGrid = sf.EjSvgRender.utils._getStringBuilder(), xPosition = yAxis.axisLine.width / 2, i,
                    startY, endY, endX, gap, scrollSize = isScroll ? this.model.scrollerSize : 0, length = yAxis._LableMaxWidth.maxWidth + 10;
				x1 = yAxis.x;
                if (yAxis.tickLinesPosition == yAxis.labelPosition) length += yAxis.majorTickLines.size;
                endX = Math.floor(x1 - length);
                if (yAxis.labelPosition == "outside")
                    endX = opposedPosition ? Math.floor(x1 + length) + scrollSize : Math.floor(x1 - length) - scrollSize;
                else
                    endX = opposedPosition ? Math.floor(x1 - length) : Math.floor(x1 + length);

                for (var i = 0; i < collectionLength; i++) {
                    gap = (yPointValue[yPointValue.length - 1] - yPointValue[yPointValue.length - 2]) / 2;
                    if (!sf.util.isNullOrUndefined(yPointValue[i]) && yPointValue.length > 1 && !isNaN(gap)) {
                        if (yAxis._valueType == "category" && yAxis.labelPlacement.toLowerCase() == "betweenticks") {
                            startY = Math.floor((yPointValue[i] * -1) + y1);
                            endY = Math.floor((yPointValue[i] * -1) - (gap * 2) + y1);
                        } else {
                            startY = Math.floor((yPointValue[i] * -1) + gap + y1);
                            endY = Math.floor((yPointValue[i] * -1) - gap + y1);
                        }
                        if (startY > y1)
                            yLabelGrid.append("M" + " " + endX + " " + y1 + " " + "L" + " " + endX + " " + endY + " ");
                        else if (endY < this.model.m_AreaBounds.Y)
                            yLabelGrid.append("M" + " " + Math.floor(xPosition + x1) + " " + startY + " " + "L" + " " + endX + " " + startY + " "
                                + "L" + " " + endX + " " + this.model.m_AreaBounds.Y + " ");
                        else {
                            yLabelGrid.append("M" + " " + Math.floor(xPosition + x1) + " " + startY + " " + "L" + " " + endX + " " + startY + " "
                                + "L" + " " + endX + " " + endY + " ");
                            if (i == collectionLength - 1)
                                yLabelGrid.append("M" + " " + Math.floor(xPosition + x1) + " " + endY + " " + "L" + " " + endX + " " + endY + " ");
                        }
                    }
                }
                var labelGridOptions = {
                    'id': this.svgObject.id + '_YAxisLabelBorder_' + axisIndex,
                    'fill': 'none',
                    'stroke-width': labelBorder.width,
                    'stroke': labelBorder.color,
                    'd': yLabelGrid.toString()
                };
                this.svgRenderer.drawPath(labelGridOptions, gEle);
                $(gEle).appendTo(this.gYaxisEle);
            }

            //Drawning Minor Ticks
            if (yAxis.minorTickLines.visible && yAxis.visible && yAxis.minorTicksPerInterval > 0) {
                yMinorTicksDir = sbYMinorTicks.toString();
                var optionsMinotTick = {
                    'id': this.svgObject.id + '_YAxisMinorTicks_' + axisIndex,
                    'fill': 'none',
                    'stroke-width': yAxis.minorTickLines.width,
                    'stroke': yAxis.minorTickLines.color,
                    'd': yMinorTicksDir
                };
                this.svgRenderer.drawPath(optionsMinotTick, gEle);
            }


            if (yAxis.majorTickLines.visible && yAxis.visible) {
                yMajorTicksDir = sbYMajorTicks.toString();
                //Drawning Major Ticks
                var optionsMajorTick = {
                    'id': this.svgObject.id + '_YAxisMajorTicks_' + axisIndex,
                    'fill': 'none',
                    'stroke-width': yAxis.majorTickLines.width,
                    'stroke': yAxis.majorTickLines.color,
                    'd': yMajorTicksDir
                };
                this.svgRenderer.drawPath(optionsMajorTick, gEle);
            }
        },

        _drawYAxisGridLine: function (axisIndex, yAxis, params) {

            var yMajorGridDir = "", yMajorTicksDir = "", yMinorTicksDir = "", yMinorGridDir = "";
            var pointY = 0;
            var labelValue;
            var y1 = Math.floor(yAxis.y + yAxis.height);
            var y2 = Math.floor(yAxis.y);
            var opposedPosition = yAxis._opposed;
            var yPoint = [];
            var isCrossesAt = params.axes[yAxis.name]._validCross;
            var axisName = (yAxis.name).replace(/[^a-zA-Z0-9]/g, "");
            if (axisIndex != 1 && !isCrossesAt && ((yAxis.labelPosition == 'inside' && yAxis.tickLinesPosition == 'inside') || (yAxis.labelPosition == 'inside' && yAxis.tickLinesPosition != 'inside')) && (!(yAxis.x == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) || (yAxis.x == (this.model.m_AreaBounds.X))))) {
                var x1 = (!opposedPosition) ? Math.floor(yAxis.x - yAxis._LableMaxWidth.width - this.model.elementSpacing) : Math.floor(yAxis.x + yAxis._LableMaxWidth.width + this.model.elementSpacing);
                var x2 = (!opposedPosition) ? Math.floor(yAxis.x - yAxis._LableMaxWidth.width - this.model.elementSpacing) : Math.floor(yAxis.x + yAxis._LableMaxWidth.width + this.model.elementSpacing);
            }
            else if (axisIndex != 1 && !isCrossesAt && (yAxis.labelPosition != 'inside' && yAxis.tickLinesPosition == 'inside') && (!(yAxis.x == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) || (yAxis.x == (this.model.m_AreaBounds.X))))) {

                var x1 = (!opposedPosition) ? Math.floor(yAxis.x - yAxis.majorTickLines.size) : Math.floor(yAxis.x + yAxis.majorTickLines.size);
                var x2 = (!opposedPosition) ? Math.floor(yAxis.x - yAxis.majorTickLines.size) : Math.floor(yAxis.x + yAxis.majorTickLines.size);
            }
            else {
                var x1 = Math.floor(yAxis.x);
                var x2 = Math.floor(yAxis.x);
            }
            var sbYMinorGrid = sf.EjSvgRender.utils._getStringBuilder();
            var sbYMajorGrid = sf.EjSvgRender.utils._getStringBuilder();
            var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisGrid' + '_' + axisIndex });
            var gAgb = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisAlternateGridBand' + '_' + axisIndex });

            if (yAxis.visible && yAxis.axisLine.visible) {
                var offset = yAxis.axisLine.offset > 0 ? yAxis.axisLine.offset : 0;
                var val = this._getSharpPath(yAxis.axisLine.width);

                var optionsLine = {
                    'id': this.svgObject.id + axisName + '_YAxisLine_' + axisIndex,
                    x1: x1 + val,
                    y1: (y2 - yAxis.plotOffset) + offset + val,
                    x2: x2 + val,
                    y2: (y1 + yAxis.plotOffset) - offset + val,
                    'stroke-width': yAxis.axisLine.width,
                    'stroke-dasharray': yAxis.axisLine.dashArray,
                    'stroke': yAxis.axisLine.color,
                    'opacity': yAxis.axisLine.opacity || 1
                };
                params.axes[yAxis.name]._lineOption = [optionsLine, this.gYaxisEle];
            }
            else
                params.axes[yAxis.name]._lineOption = [null, this.gYaxisEle];

            if (yAxis.axisBottomLine) {
                if (yAxis.axisBottomLine.visible) {
                    var optionsBottomLine = {
                        'id': this.svgObject.id + axisName + '_YAxisBottomLine_' + axisIndex,
                        x1: this.model.m_AreaBounds.X,
                        y1: y1,
                        x2: this.model.m_AreaBounds.X + this.model.m_AreaBounds.Width,
                        y2: y1,
                        'stroke-width': yAxis.axisBottomLine.width,
                        'stroke': yAxis.axisBottomLine.color
                    };
                    this.svgRenderer.drawLine(optionsBottomLine, gEle);
                }
            }
            yAxis.labelPlacement = (!(yAxis.labelPlacement)) ? sf.datavisualization.Chart.LabelPlacement.BetweenTicks : yAxis.labelPlacement;
            var ticksbwtLabel = ((yAxis.labels.length > 0) && (yAxis.labelPlacement.toLowerCase() == "betweenticks")) ? -0.5 : 0;
            var collectionLength = yAxis.visibleLabels.length;
            for (var i = 0; i < collectionLength; i++) {
                labelValue = yAxis.visibleLabels[i].Value;
                var tempInterval = ((yAxis.labels.length > 0) && (ticksbwtLabel < 0)) ? labelValue + ticksbwtLabel : labelValue;
                tempInterval = (!(yAxis.roundingPlaces)) ? parseFloat(tempInterval.toFixed((sf.EjSvgRender.utils._decimalPlaces(yAxis.visibleRange.interval) == 0 ? 1 : sf.EjSvgRender.utils._decimalPlaces(yAxis.visibleRange.interval)))) : tempInterval;

                if (sf.EjSvgRender.utils._inside(tempInterval, yAxis.visibleRange)) {

                    if ((yAxis.hidePartialLabels) && ((i == 0) || (i == (yAxis.visibleLabels.length - 1))))
                        continue;

                    // Calculate Minor Ticks and Grid lines      
                    if (yAxis.minorGridLines.visible || yAxis.minorTickLines.visible) {
                        var minorPointY;
                        var tickVal = this._getSharpPath(yAxis.minorTickLines.width);
                        var lineVal = this._getSharpPath(yAxis.minorGridLines.width);
                        if (yAxis._valueType == "logarithmic") {
                            minorTicks = tempInterval;
                            var logmax = yAxis.visibleRange.max;
                            var logmin = yAxis.visibleRange.min;

                            var logtickstart = Math.pow(yAxis.logBase, minorTicks - yAxis.visibleRange.interval);
                            var logtickend = Math.pow(yAxis.logBase, minorTicks);
                            var logtickInterval = (logtickend - logtickstart) / (yAxis.minorTicksPerInterval + 1);
                            var logtickPos = logtickstart + logtickInterval;
                            minorTicks = sf.EjSvgRender.utils._logBase(logtickPos, yAxis.logBase);
                            for (var j = 0; j < yAxis.minorTicksPerInterval; j++) {


                                if (minorTicks < logmax && minorTicks > logmin) {

                                    minorPointY = Math.ceil(((minorTicks - logmin) / (logmax - logmin)) * (yAxis.height));



                                    //Calculate Minor Gridlines
                                    if (yAxis.minorGridLines.visible)
                                        sbYMinorGrid.append("M" + " " + (Math.floor(this.model.m_AreaBounds.X) + lineVal) + " " + (Math.floor((minorPointY * -1) + y1) + lineVal) + " " + "L" + " " + (Math.floor(this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) + lineVal) + " " + (Math.floor((minorPointY * -1) + y1) + lineVal) + " ");

                                }
                                logtickPos += logtickInterval;
                                minorTicks = sf.EjSvgRender.utils._logBase(logtickPos, yAxis.logBase);
                            }
                        } else {
                            for (var j = 0, minorTicks = tempInterval; j < yAxis.minorTicksPerInterval; j++) {

                                minorTicks += yAxis.visibleRange.interval / (yAxis.minorTicksPerInterval + 1);
                                if (minorTicks < yAxis.visibleRange.max && minorTicks > yAxis.visibleRange.min) {
                                    minorPointY = ((minorTicks - yAxis.visibleRange.min) / (yAxis.visibleRange.delta)) * (yAxis.height);

                                    // Calculate Minor Grid lines   
                                    if (yAxis.minorGridLines.visible)
                                        sbYMinorGrid.append("M" + " " + (Math.floor(this.model.m_AreaBounds.X) + lineVal) + " " + (Math.floor((minorPointY * -1) + y1) + lineVal) + " " + "L" + " " + (Math.floor(this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) + lineVal) + " " + (Math.floor((minorPointY * -1) + y1) + lineVal) + " ");
                                }
                            }
                        }
                    }
                    // Calculate Grid lines
                    if (yAxis.majorTickLines.visible || yAxis.majorGridLines.visible) {
                        var mtVal = this._getSharpPath(yAxis.minorTickLines.width);
                        var mlVal = this._getSharpPath(yAxis.majorGridLines.width);

                        // Calculate Major Grid lines
                        if (yAxis.majorGridLines.visible) {
                            pointY = sf.EjSvgRender.utils._getPointXY(tempInterval, yAxis.visibleRange, yAxis.isInversed) * (yAxis.height);
                            var mX1 = (Math.floor(this.model.m_AreaBounds.X) + mlVal);
                            var mY1 = (Math.floor((pointY * -1) + y1));
                            var mX2 = (Math.floor(this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) + mlVal);
                            if (i == 0) {
                                if (mY1 == Math.floor(this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height))
                                    continue;
                                if (yAxis.zoomed)
                                    yPoint[0] = mY1 + mlVal;

                            }
                            if ((i == (yAxis.visibleLabels.length - 1)) && (this.model.chartArea.border.color != "transparent" && this.model.chartArea.border.width > 0)) {

                                if (mY1 == (Math.floor(this.model.m_AreaBounds.Y))) {
                                    yPoint.push(mY1 + mlVal);
                                    continue;
                                }

                            }



                            sbYMajorGrid.append("M" + " " + mX1 + " " + (mY1 + mlVal) + " " + "L" + " " + mX2 + " " + (mY1 + mlVal) + " ");
                            if (i == 0)
                                continue;

                            yPoint.push(mY1 + mlVal);

                        }
                    }
                }
            }

            if (yAxis.alternateGridBand.odd.fill != "transparent" || yAxis.alternateGridBand.even.fill != "transparent") {

                var width = this.model.m_AreaBounds.Width;
                if (yAxis.zoomed) {
                    yPoint[yPoint.length] = yAxis.y;

                }
                for (var i = 1; i < yPoint.length; i += 2) {
                    var height = yPoint[0] - yPoint[1];
                    if (i == yPoint.length - 1 && yAxis.zoomed) {
                        var zoomHeight = yPoint[yPoint.length - 2] - yAxis.y;
                        height = zoomHeight;
                    }
                    var yoptionsAlternateodd = {
                        'id': this.svgObject.id + '_YAxisAlternateodd' + [i],
                        'x': Math.floor(this.model.m_AreaBounds.X),
                        'y': yPoint[i],
                        'width': width,
                        'height': height,
                        'fill': yAxis.alternateGridBand.odd.fill,
                        'opacity': yAxis.alternateGridBand.odd.opacity,
                        'stroke': "transparent",
                        'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)'
                    };
                    this.svgRenderer.drawRect(yoptionsAlternateodd, gAgb);
                }

                for (var i = 0; i < yPoint.length; i += 2) {
                    var height = yPoint[0] - yPoint[1];
                    if (i == yPoint.length - 1 && yAxis.zoomed) {
                        var zoomHeight = yPoint[yPoint.length - 2] - yAxis.y;
                        height = zoomHeight;
                    }
                    if (i == 0 && yAxis.zoomed) {
                        var zoomHeight = yAxis.y + yAxis.height - yPoint[0] - yAxis.plotOffset;
                        height = zoomHeight;
                    }
                    var yoptionsAlternateeven = {
                        'id': this.svgObject.id + '_YAxisAlternateeven' + [i],
                        'x': Math.floor(this.model.m_AreaBounds.X),
                        'y': yPoint[i],
                        'width': width,
                        'height': height,
                        'fill': yAxis.alternateGridBand.even.fill,
                        'opacity': yAxis.alternateGridBand.even.opacity,
                        'stroke': "transparent",
                        'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)'
                    };
                    this.svgRenderer.drawRect(yoptionsAlternateeven, gAgb);
                }
                $(gAgb).appendTo(gEle);
            }


            if (yAxis.minorGridLines.visible && yAxis.minorTicksPerInterval > 0) {
                //Drawning Minor Grid Lines
                yMinorGridDir = sbYMinorGrid.toString();
                var optionsMinorGrid = {
                    'id': this.svgObject.id + '_YAxisMinorGridLines_' + axisIndex,
                    'fill': 'none',
                    'stroke-width': yAxis.minorGridLines.width,
                    'stroke': yAxis.minorGridLines.color,
                    'stroke-dasharray': yAxis.minorGridLines.dashArray,
                    'd': yMinorGridDir
                };
                this.svgRenderer.drawPath(optionsMinorGrid, gEle);

            }

            //Drawing Major Grid Lines
            yMajorGridDir = sbYMajorGrid.toString();
            if (yAxis.majorGridLines.visible) {
                var options = {
                    'id': this.svgObject.id + '_YAxisMajorGridLines_' + axisIndex,
                    'fill': 'none',
                    'stroke-width': yAxis.majorGridLines.width,
                    'opacity': yAxis.majorGridLines.opacity,
                    'stroke-dasharray': yAxis.majorGridLines.dashArray,
                    'stroke': yAxis.majorGridLines.color,
                    'd': yMajorGridDir
                };

                if (options.d != '')
                    this.svgRenderer.drawPath(options, gEle);

            }
            $(gEle).appendTo(this.svgObject);
        },

        textOverflowMultiLevelLabels: function (axis, gap, text, actualText, textOverflow, font, labelSize, textOptions, gMultiLevelEle, chartObj) {
            var yVal = textOptions.y, count = 0, bounds, collection, textCollection, rows, unTrimmedText;
            if (textOverflow == "wrap" || textOverflow == "wrapandtrim") {
                collection = chartObj._wrap(axis, gap, text, textOverflow, font, labelSize);
                textCollection = collection["text"];
                rows = textCollection.length;
                for (var j = 0; j < rows; j++) {
                    textOptions.y += labelSize.height;
                    if (!chartObj.model.enable3D) {
                        textOptions.id += "_" + j;
                        chartObj.svgRenderer.drawText(textOptions, textCollection[j], gMultiLevelEle);
                    }
                    if (textOverflow == "wrapandtrim" && textCollection[j].indexOf("...") > -1) {
                        if (chartObj.model.enable3D && count == 0)
                            textOptions.y -= labelSize.height;
                        unTrimmedText = collection["unTrimmedText"];
                        labelSize = sf.EjSvgRender.utils._measureText(textCollection[j], null, font);
                        bounds = { X: textOptions.x - labelSize.width / 2, Y: textOptions.y, Width: labelSize.width, Height: labelSize.height };
                        chartObj.model.axisMultiLevelLabelRegions.push({ trimText: textCollection[j], labelText: unTrimmedText[count], Bounds: bounds });
                        count++;
                    }
                }
                return textCollection;
            } else {
                text = (textOverflow == "trim") ? sf.EjSvgRender.utils._trimText(actualText, gap, font) : actualText;
                // to store region
                if (!chartObj.model.enable3D)
                    yVal = textOptions.y + labelSize.height;
                if (axis.orientation.toLowerCase() == "vertical")
                    yVal = textOptions.y - labelSize.height / 4;
                labelSize = sf.EjSvgRender.utils._measureText(text, null, font);
                bounds = { X: textOptions.x - labelSize.width / 2, Y: yVal, Width: labelSize.width, Height: labelSize.height };
                chartObj.model.axisMultiLevelLabelRegions.push({ trimText: text, labelText: actualText, Bounds: bounds });
                return text;
            }
        },

        _triggerMultiLevelLabelsRendering: function (text, x, y, textOverflow, font, border, chart) {
            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);          // trigger event
            commonEventArgs.data = {
                text: text, location: { x: x, y: y },
                textOverflow: textOverflow, font: font, border: border
            };
            chart._trigger("multiLevelLabelRendering", commonEventArgs);
            return commonEventArgs.data;
        },

        _drawXAxisMultiLevelLabels: function (axisIndex, xAxis) {          // to render x axis multi level labels
            // declaration 
            var i, j, x, y, rows, count, gap, actualText, text, labelSize, grpLabel, font, startX, startY, endX, textOptions, level, textOverflow, clipX, clipY, clipWidth, clipHeight, anchor, height, width, labelHeight,
                textCollection, borderOptions, border, style, alignment, svgId = this.svgObject.id, range = xAxis.visibleRange,
                gMultiLevelEle = this.svgRenderer.createGroup({
                    'id': svgId + '_XAxisMultiLevelLabels' + '_' + axisIndex, 'clip-path': 'url(#' + this.svgObject.id +
                        '_XAxis_Clippath_' + axisIndex + ")"
                }), areaBounds = this.model.m_AreaBounds, opposedPosition = xAxis.opposedPosition, borderWidth,
                labelPosition = xAxis.labelPosition.toLowerCase(), labelBorder = xAxis.labelBorder, padding = 10,
                scrollerSize = xAxis._isScroll ? this.model.scrollerSize : 0;

            // create clip path
            startY = xAxis.majorTickLines.size + xAxis._LableMaxWidth.height + (labelBorder.width);
            clipX = xAxis.x;
            clipY = xAxis.y + startY + scrollerSize;
            clipWidth = xAxis.width + this.model.chartArea.border.width;
            clipHeight = xAxis._multiLevelLabelHeight + padding - 2;

            if (opposedPosition) {
                if (labelPosition == "outside")
                    clipY = xAxis.y - startY - xAxis._multiLevelLabelHeight - padding / 2 - scrollerSize;
                else
                    clipY = xAxis.y + startY - padding / 2;
            } else {
                if (labelPosition == "inside")
                    clipY = xAxis.y - startY - xAxis._multiLevelLabelHeight;
            }

            // to clip multi level labels
            var clipRectOptions = {
                'id': this.svgObject.id + '_XAxis_Clippath_' + axisIndex,
                'x': clipX,
                'y': clipY,
                'width': clipWidth,
                'height': clipHeight,
                'fill': 'white',
                'stroke-width': 1,
                'stroke': 'Gray'
            };
            this.svgRenderer.drawClipPath(clipRectOptions, gMultiLevelEle);

            for (i = 0; i < xAxis.multiLevelLabels.length; i++) {
                // assignment
                grpLabel = xAxis.multiLevelLabels[i];
                if (typeof grpLabel.start == "string" && grpLabel.start.indexOf("/Date(") != -1)
                    grpLabel.start = parseInt(grpLabel.start.substr(6));
                if (typeof grpLabel.end == "string" && grpLabel.end.indexOf("/Date(") != -1)
                    grpLabel.end = parseInt(grpLabel.end.substr(6));
                if (grpLabel.visible && ((grpLabel.start >= range.min && grpLabel.start <= range.max)
                    || (grpLabel.end >= range.min && grpLabel.end <= range.max) ||
                    (grpLabel.start < range.min && grpLabel.end > range.max))) {
                    font = grpLabel.font;
                    border = grpLabel.border;
                    borderWidth = border.width;
                    level = grpLabel._level;
                    textOverflow = grpLabel.textOverflow.toLowerCase();
                    style = border.type.toLowerCase();
                    alignment = grpLabel.textAlignment.toLowerCase();
                    startX = Math.ceil(sf.EjSvgRender.utils._getPointXY(grpLabel.start, range, xAxis.isInversed) * (xAxis.width));
                    endX = Math.ceil(sf.EjSvgRender.utils._getPointXY(grpLabel.end, range, xAxis.isInversed) * (xAxis.width));
                    if (xAxis.isInversed) {
                        startX = startX - endX;
                        endX = startX + endX;
                        startX = endX - startX;
                    }
                    actualText = grpLabel.text;
                    labelSize = sf.EjSvgRender.utils._measureText(actualText, null, font);
                    gap = sf.util.isNullOrUndefined(grpLabel.maximumTextWidth) ? endX - startX - borderWidth - padding : grpLabel.maximumTextWidth - padding;
                    rows = 1;
                    count = 0;
                    x = startX + xAxis.x + padding / 2;
                    y = startY + xAxis.y;

                    // to position text
                    if (opposedPosition) {
                        if (labelPosition == "outside")
                            y = xAxis.y - startY - xAxis.multiLevelLabelHeight[level] - padding - xAxis.prevHeight[level] - scrollerSize;
                        else
                            y = xAxis.y + startY - padding / 2 + xAxis.prevHeight[level];
                    } else {
                        if (labelPosition == "inside")
                            y = xAxis.y - startY - xAxis.multiLevelLabelHeight[level] - xAxis.prevHeight[level];
                        else
                            y = startY + xAxis.y + xAxis.prevHeight[level] + scrollerSize;
                    }

                    // to clip canvas
                    if (this.model.enableCanvasRendering) {
                        this.svgRenderer.ctx.save();
                        this.svgRenderer.ctx.beginPath();
                        this.svgRenderer.ctx.rect(clipX, clipY, clipWidth, clipHeight);
                        this.svgRenderer.ctx.clip();
                    }

                    // text alignment calculation
                    if (alignment == "center") {
                        x += gap / 2;
                        anchor = "middle";
                    } else if (alignment == "far") {
                        x = x + gap - borderWidth / 2;
                        anchor = "end";
                    } else {
                        anchor = "start";
                        x += borderWidth / 2;
                    }

                    var data = this._triggerMultiLevelLabelsRendering(actualText, x, y, textOverflow, font, grpLabel.border, this);
                    var actualText = data.text;
                    x = data.location.x;
                    y = data.location.y;
                    textOverflow = data.textOverflow.toLowerCase();
                    font = data.font;
                    border = data.border;
                    style = data.border.type.toLowerCase();
                    borderWidth = data.border.width;

                    // options required to render text
                    textOptions = {
                        'id': svgId + '_XAxisMultiLevelLabels_Text_' + axisIndex + '_' + i,
                        'x': x,
                        'y': style == "curlybrace" ? y + 10 : y,
                        'fill': font.color ? font.color : xAxis.multiLevelLabelsFontColor,
                        'font-size': font.size,
                        'font-family': font.fontFamily,
                        'font-style': font.fontStyle,
                        'font-weight': font.fontWeight,
                        'opacity': font.opacity,
                        'text-anchor': anchor
                    };
                    text = actualText;
                    // calculation for wrap and wrapbyword
                    if (textOverflow != "none")
                        text = this.textOverflowMultiLevelLabels(xAxis, gap, text, actualText, textOverflow, font, labelSize, textOptions, gMultiLevelEle, this);

                    if (textOverflow != "wrap" && textOverflow != "wrapandtrim") {
                        textOptions.y += labelSize.height;
                        if (labelSize.height < xAxis.multiLevelLabelHeight[level])
                            textOptions.y = textOptions.y + xAxis.multiLevelLabelHeight[level] / 2 - labelSize.height / 2;
                        this.svgRenderer.drawText(textOptions, text, gMultiLevelEle);   // to draw text
                    }

                    // border calculation
                    if (opposedPosition) {
                        if (labelPosition == "inside")
                            y = startY + xAxis.y + xAxis.prevHeight[level] - padding / 2;
                        else
                            y = xAxis.y - startY - xAxis.multiLevelLabelHeight[level] - padding + 2 - xAxis.prevHeight[level] - scrollerSize;
                    } else {
                        if (labelPosition == "inside")
                            y = xAxis.y - startY - xAxis.multiLevelLabelHeight[level] - 3 - xAxis.prevHeight[level];
                        else
                            y = startY + xAxis.y + xAxis.prevHeight[level] + scrollerSize;
                    }
                    x = startX + xAxis.x;
                    y += borderWidth;
                    height = xAxis.multiLevelLabelHeight[level] + padding / 2;
                    width = gap + padding + borderWidth;

                    // storing region for multi level labels click event
                    var region = { bounds: { x: x, y: y, height: height, width: width }, axisIndex: axisIndex, multiLevelLabel: grpLabel };
                    this.model.multiLevelLabelRegions.push(region);

                    var path = "",
                        braceGap = ((width + borderWidth) - labelSize.width) / 2 - 2;
                    if (style == "rectangle") {
                        borderOptions = {
                            'id': svgId + '_XAxisMultiLevelLabels_Rect_' + axisIndex + '_' + i,
                            'x': x,
                            'y': y,
                            'width': width,
                            'height': height,
                            'fill': "transparent",
                            'stroke': border.color ? border.color : xAxis.multiLevelLabelsColor,
                            'stroke-width': borderWidth,
                        };
                        this.svgRenderer.drawRect(borderOptions, gMultiLevelEle);
                    } else {
                        switch (style) {
                            case "withouttopandbottomborder":
                                path = "M " + x + " " + y + " L " + x + " " + (y + height) +
                                    " M " + (x + width) + " " + y + " L " + (x + width) + " " + (y + height);
                                break;
                            case "withouttopborder":
                                if ((!opposedPosition && labelPosition == "outside") || (opposedPosition && labelPosition == "inside"))
                                    labelHeight = height;
                                else
                                    labelHeight = 0;
                                path = "M " + x + " " + (y + labelHeight) + " L " + (x + width) + " " + (y + labelHeight) + " M " + x + " " + y + " L " + x + " " +
                                    (y + height) + " M " + (x + width) + " " + y + " L " + (x + width) + " " + (y + height);
                                break;
                            case "brace":
                                if (alignment == "near") {
                                    var value = textOptions.x;
                                    value2 = textOptions.x + labelSize.width + 2;
                                }
                                else if (alignment == "center") {
                                    var value = textOptions.x - labelSize.width / 2 - 2 <= areaBounds.X + startX ? areaBounds.X + startX + padding :
                                        textOptions.x - labelSize.width / 2 - 2;
                                    var value2 = textOptions.x + labelSize.width / 2 + 2 > areaBounds.X + endX ? areaBounds.X + endX - padding :
                                        textOptions.x + labelSize.width / 2 + 2
                                } else {
                                    var value = textOptions.x - labelSize.width - 2;
                                    value2 = textOptions.x;
                                }
                                if ((!opposedPosition && labelPosition == "outside") || (opposedPosition && labelPosition == "inside"))
                                    path = "M " + x + " " + y + " L " + x + " " + (y + height / 2) +
                                        " M " + x + " " + (y + height / 2) + " L " + (value - 2) + " " + (y + height / 2) +
                                        " M " + (value2) + " " + (y + height / 2) + " L " + (x + width) + " " + (y + height / 2) +
                                        " M " + (x + width) + " " + (y + height / 2) + " L " + (x + width) + " " + (y);
                                else
                                    path = "M " + (x) + " " + (y + height) + " L " + (x) + " " + (y + height / 2) +
                                        " M " + x + " " + (y + height / 2) + " L " + (value) + " " + (y + height / 2) +
                                        " M " + (value2) + " " + (y + height / 2) + " L " + (x + width) + " " + (y + height / 2) +
                                        " M " + (x + width) + " " + (y + height) + " L " + (x + width) + " " + (y + height / 2);
                                break;
                            case "curlybrace":        // using constant values to render a curely brace
                                y = xAxis.y + startY + xAxis.prevHeight[level];
                                if (width < 30) {
                                    path = "M " + (x + width / 2 - 5) + " " + (y + 10) + " L " + (x + width / 2) + " " + (y + 15) + " L " + (x + width / 2 + 5) + " " + (y + 10);
                                }
                                else if (!opposedPosition) {
                                    if (alignment == "center") {
                                        path = "M " + x + " " + y + " C " + x + " " + y + " " + (x + 5) + " " + (y + 10) + " " + (x + 10) + " " + (y + 10) +
                                            " L " + (x + width / 2 - 5) + " " + (y + 10) + " L " + (x + width / 2) + " " + (y + 15) +
                                            " L " + (x + width / 2 + 5) + " " + (y + 10) + " L " + (x + width - 10) + " " + (y + 10) +
                                            " C " + (x + width - 10) + " " + (y + 10) + " " + (x + width) + " " + (y + 5) + " " + (x + width) + " " + (y);
                                    } else if (alignment == "near") {
                                        path = "M " + x + " " + y + " C " + x + " " + y + " " + (x + 5) + " " + (y + 10) + " " + (x + 10) + " " + (y + 10) +
                                            " L " + (x + 15) + " " + (y + 15) +
                                            " L " + (x + 15 + 5) + " " + (y + 10) + " L " + (x + width - 10) + " " + (y + 10) +
                                            " C " + (x + width - 10) + " " + (y + 10) + " " + (x + width) + " " + (y + 5) + " " + (x + width) + " " + (y);
                                    } else {
                                        path = "M " + x + " " + y + " C " + x + " " + y + " " + (x + 5) + " " + (y + 10) + " " + (x + 10) + " " + (y + 10) +
                                            " L " + (x + width - 20) + " " + (y + 10) + " L " + (x + width - 15) + " " + (y + 15) +
                                            " L " + (x + width - 10) + " " + (y + 10) + " L " + (x + width - 10) + " " + (y + 10) +
                                            " C " + (x + width - 10) + " " + (y + 10) + " " + (x + width) + " " + (y + 5) + " " + (x + width) + " " + (y);
                                    }
                                }
                                else {
                                    path = "M " + x + " " + y + " C " + x + " " + y + " " + (x + 5) + " " + (y + 10) + " " + (x + 10) + " " + (y + 10) +
                                        " L " + (x + width / 2 - 5) + " " + (y + 10) + " L " + (x + width / 2) + " " + (y + 15) +
                                        " L " + (x + width / 2 + 5) + " " + (y + 10) + " L " + (x + width - 10) + " " + (y + 10) +
                                        " C " + (x + width - 10) + " " + (y + 10) + " " + (x + width) + " " + (y + 5) + " " + (x + width) + " " + (y);
                                }
                                break;
                        }
                        if (path) {
                            borderOptions = {
                                'id': svgId + '_XAxisMultiLevelLabels_Rect_' + axisIndex + '_' + i,
                                'd': path,
                                'stroke': border.color ? border.color : xAxis.multiLevelLabelsColor,
                                'stroke-width': border.width,
                                'fill': 'none'
                            }
                            this.svgRenderer.drawPath(borderOptions, gMultiLevelEle);
                        }
                    }
                    if (this.model.enableCanvasRendering)
                        this.svgRenderer.ctx.restore();

                    $(gMultiLevelEle).appendTo(this.gXaxisEle);
                }
            }
        },

        _drawYAxisMultiLevelLabels: function (axisIndex, yAxis) {          // to render y axis multi level labels
            // declaration 
            var i, j, x, y, rows, gap, labelSize, grpLabel, font, startX, startY, endX, endY, textOptions, textOverflow, padding = 5, level, maximumTextWidth, actualText, space, count, text, height, width, value1, value2, labelWidth,
                textCollection, borderOptions, border, style, alignment, svgId = this.svgObject.id, range = yAxis.visibleRange, clipX, clipY, clipWidth, clipHeight, textX, data, borderWidth, path, braceGap, newHeight,
                gMultiLevelEle = this.svgRenderer.createGroup({
                    'id': svgId + '_YAxisMultiLevelLabels' + '_' + axisIndex, 'clip-path': 'url(#' + this.svgObject.id +
                        '_YAxis_Clippath_' + axisIndex + ")"
                }), anchor = "middle", areaBounds = this.model.m_AreaBounds, opposedPosition = yAxis.opposedPosition,
                labelPosition = yAxis.labelPosition.toLowerCase(), labelBorder = yAxis.labelBorder, multiLevelLabelWidth = yAxis._multiLevelLabelHeight,
                startX = yAxis.majorTickLines.size + yAxis._LableMaxWidth.width + (labelBorder.width) + 2 * padding,
                scrollerSize = yAxis._isScroll ? this.model.scrollerSize : 0;

            // to clip the multi level labels
            clipY = yAxis.y;
            clipWidth = multiLevelLabelWidth + padding;
            clipHeight = yAxis.height + padding;
            if (opposedPosition) {
                if (labelPosition == "outside")
                    clipX = yAxis.x + startX - padding + scrollerSize;
                else
                    clipX = yAxis.x - multiLevelLabelWidth - startX + padding;
            }
            else {
                if (labelPosition == "outside")
                    clipX = yAxis.x - multiLevelLabelWidth - startX - scrollerSize;
                else
                    clipX = yAxis.x + startX - padding;
            }
            var clipRectOptions = {
                'id': this.svgObject.id + '_YAxis_Clippath_' + axisIndex,
                'x': clipX,
                'y': yAxis.y,
                'width': clipWidth,
                'height': clipHeight,
                'fill': 'white',
                'stroke-width': 1,
                'stroke': 'Gray'
            };
            this.svgRenderer.drawClipPath(clipRectOptions, gMultiLevelEle);

            for (i = 0; i < yAxis.multiLevelLabels.length; i++) {
                // assignment
                grpLabel = $.extend(true, {}, this.model.multiLevelLabelsDefault, yAxis.multiLevelLabels[i]);
                if (grpLabel.visible && ((grpLabel.start >= range.min && grpLabel.start <= range.max)
                    || (grpLabel.end >= range.min && grpLabel.end <= range.max) ||
                    (grpLabel.start < range.min && grpLabel.end > range.max))) {
                    font = grpLabel.font;
                    border = grpLabel.border;
                    level = grpLabel._level;
                    maximumTextWidth = grpLabel.maximumTextWidth;
                    textOverflow = grpLabel.textOverflow.toLowerCase();
                    style = border.type.toLowerCase();
                    alignment = grpLabel.textAlignment.toLowerCase();
                    startY = Math.ceil(sf.EjSvgRender.utils._getPointXY(grpLabel.start, range, yAxis.isInversed) * (yAxis.height));
                    endY = Math.ceil(sf.EjSvgRender.utils._getPointXY(grpLabel.end, range, yAxis.isInversed) * (yAxis.height));
                    if (yAxis.isInversed) {
                        startY = startY - endY;
                        endY = startY + endY;
                        startY = endY - startY;
                    }
                    actualText = grpLabel.text;
                    labelSize = sf.EjSvgRender.utils._measureText(actualText, null, font);
                    gap = endY - startY - border.width;
                    space = sf.util.isNullOrUndefined(maximumTextWidth) ? yAxis.multiLevelLabelHeight[level] + padding : maximumTextWidth - padding;
                    rows = 1; count = 0; textX = 0;
                    x = yAxis.x - startX - yAxis.prevHeight[level] - yAxis.multiLevelLabelHeight[level] / 2 + border.width - padding / 2;
                    y = yAxis.height + yAxis.y - startY - (gap / 2);

                    // for text position
                    if ((opposedPosition)) {
                        if (labelPosition == "outside")
                            x = yAxis.x + startX + yAxis.multiLevelLabelHeight[level] / 2 + yAxis.prevHeight[level] + border.width + scrollerSize;
                        else
                            x = yAxis.x - startX - yAxis.multiLevelLabelHeight[level] / 2 - yAxis.prevHeight[level] + border.width + padding / 2;
                    }
                    else {
                        if (labelPosition == "inside")
                            x = yAxis.x + startX + yAxis.multiLevelLabelHeight[level] / 2 + yAxis.prevHeight[level] - padding / 2;
                        else
                            x = x + textX - scrollerSize;
                    }
                    if (this.model.enableCanvasRendering) {
                        this.svgRenderer.ctx.save();
                        this.svgRenderer.ctx.beginPath();
                        this.svgRenderer.ctx.rect(clipX, clipY, clipWidth, clipHeight);
                        this.svgRenderer.ctx.clip();
                    }

                    // text alignment calculation
                    if (alignment == "far")
                        y = y + gap / 2 - labelSize.height / 2;
                    else if (alignment == "near")
                        y = y - gap / 2 + labelSize.height;
                    else
                        y = y + labelSize.height / 4;
                    data = this._triggerMultiLevelLabelsRendering(actualText, x, y, textOverflow, font, grpLabel.border, this);
                    var actualText = data.text;
                    x = data.location.x;
                    y = data.location.y;
                    textOverflow = data.textOverflow;
                    font = data.font;
                    border = data.border;
                    style = border.type.toLowerCase();
                    borderWidth = border.width;

                    // options required to render text
                    textOptions = {
                        'id': svgId + '_YAxisMultiLevelLabels_Text_' + axisIndex + '_' + i,
                        'x': style == "curlybrace" ? (opposedPosition ? x + textX + 10 : x + textX - 10) : x + textX,
                        'y': y,
                        'fill': font.color ? font.color : yAxis.multiLevelLabelsFontColor,
                        'font-size': font.size,
                        'font-family': font.fontFamily,
                        'font-style': font.fontStyle,
                        'font-weight': font.fontWeight,
                        'opacity': font.opacity,
                        'text-anchor': anchor
                    };

                    text = actualText;
                    // calculation for wrap and wrapandtrim
                    if (textOverflow != "none")
                        text = this.textOverflowMultiLevelLabels(yAxis, space, text, actualText, textOverflow, font, labelSize, textOptions, gMultiLevelEle, this);
                    if (textOverflow != "wrap" && textOverflow != "wrapandtrim")
                        this.svgRenderer.drawText(textOptions, text, gMultiLevelEle);   // to draw text
                    x = x - padding / 2 - yAxis.multiLevelLabelHeight[level] / 2;
                    y = yAxis.y + yAxis.height - endY + border.width;
                    height = endY - startY;
                    width = yAxis.multiLevelLabelHeight[level] + padding;
                    path = "";
                    braceGap = ((width + border.width) - multiLevelLabelWidth) / 2 - 2;

                    // storing region for multi level labels click event
                    var region = { bounds: { x: x, y: y, height: height, width: width }, axisIndex: axisIndex, multiLevelLabel: grpLabel };
                    this.model.multiLevelLabelRegions.push(region);

                    if (style == "rectangle") {
                        borderOptions = {
                            'id': svgId + '_YAxisMultiLevelLabels_Rect_' + axisIndex + '_' + i,
                            'x': x,
                            'y': y,
                            'width': width,
                            'height': height,
                            'fill': "transparent",
                            'stroke': border.color ? border.color : yAxis.multiLevelLabelsColor,
                            'stroke-width': border.width,
                        };
                        this.svgRenderer.drawRect(borderOptions, gMultiLevelEle);
                    } else {
                        switch (style) {
                            case "withouttopandbottomborder":
                                path = "M" + " " + x + " " + (y + height) + " " + "L" + " " + (x + width) + " " + (y + height) + " " +
                                    "M" + " " + x + " " + y + " " + "L" + " " + (x + width) + " " + y;
                                break;
                            case "withouttopborder":
                                if ((!opposedPosition && labelPosition == "outside") || (opposedPosition && labelPosition == "inside"))
                                    labelWidth = 0;
                                else
                                    labelWidth = width;
                                path = "M" + " " + x + " " + (y + height) + " " + "L" + " " + (x + width) + " " + (y + height) + " " +
                                    "M" + " " + x + " " + y + " " + "L" + " " + (x + width) + " " + y +
                                    " M" + " " + (x + labelWidth) + " " + (y + height) + " " + "L" + " " + (x + labelWidth) + " " + (y);
                                break;
                            case "brace":
                                value1 = textOptions.y - labelSize.height / 2 - 4;
                                value2 = textOptions.y + labelSize.height / 4 + 2;
                                if ((!opposedPosition && labelPosition == "outside") || (opposedPosition && labelPosition == "inside"))
                                    path = "M " + (x + width) + " " + y + " L " + (x + width / 2) + " " + y +
                                        " M " + (x + width / 2) + " " + y + " L " + (x + width / 2) + " " + value1 +
                                        " M " + (x + width / 2) + " " + value2 + " L " + (x + width / 2) + " " + (y + height) +
                                        " M " + (x + width / 2) + " " + (y + height) + " L " + (x + width) + " " + (y + height);
                                else
                                    path = "M " + (x) + " " + y + " L " + (x + width / 2) + " " + y +
                                        " M " + (x + width / 2) + " " + y + " L " + (x + width / 2) + " " + value1 +
                                        " M " + (x + width / 2) + " " + value2 + " L " + (x + width / 2) + " " + (y + height) +
                                        " M " + (x + width / 2) + " " + (y + height) + " L " + (x) + " " + (y + height);
                                break;
                            case "curlybrace":               // using constant values to render a curely brace
                                x = yAxis.x - startX - yAxis.prevHeight[level];
                                newHeight = height - 10;
                                if (height < 30) {
                                    if (opposedPosition) {
                                        x = yAxis.x + startX + yAxis.prevHeight[level];
                                        newHeight = height - 10;
                                        path =
                                            " M " + (x + 10) + " " + (y + newHeight / 2) + " " + " L " + (x + 15) + " " + (y + newHeight / 2 + 5) +
                                            " L " + (x + 10) + " " + (y + newHeight / 2 + 10);
                                    }
                                    else
                                        path = "M " + (x - 10) + " " + (y + height / 2 - 5) + " L " + (x - 15) + " " + (y + height / 2) + " L " + (x - 10) + " " + (y + height / 2 + 5);
                                }
                                else if (!opposedPosition) {
                                    if (alignment == "center") {
                                        path = "M " + x + " " + y + " C " + x + " " + y + " " + (x - 10) + " " + y + " " + (x - 10) + " " + (y + 10) +
                                            " L " + (x - 10) + " " + (y + newHeight / 2) + " L " + (x - 15) + " " + (y + newHeight / 2 + 5) +
                                            " L " + (x - 10) + " " + (y + newHeight / 2 + 10) + " L " + (x - 10) + " " + (y + newHeight) +
                                            " C " + (x - 10) + " " + (y + newHeight) + " " + (x - 5) + " " + (y + newHeight + 10) + " " + x + " " + (y + newHeight + 10);
                                    } else if (alignment == "far") {
                                        path = "M " + x + " " + y + " C " + x + " " + y + " " + (x - 10) + " " + y + " " + (x - 10) + " " + (y + 10) +
                                            " L " + (x - 10) + " " + (y + newHeight - 10) + " " + " L " + (x - 15) + " " + (y + newHeight - 10 + 5) +
                                            " L " + (x - 10) + " " + (y + newHeight) + " L " + (x - 10) + " " + (y + newHeight) +
                                            " C" + (x - 10) + " " + (y + newHeight) + " " + (x - 10) + " " + (y + newHeight + 10) + " " + x + " " + (y + newHeight + 10);
                                    } else {
                                        path = "M " + x + " " + y + " C " + x + " " + y + " " + (x - 10) + " " + y + " " + (x - 10) + " " + (y + 10) +
                                            " L " + (x - 15) + " " + (y + 10 + 5) +
                                            " L " + (x - 10) + " " + (y + 10 + 10) + " L " + (x - 10) + " " + (y + newHeight) +
                                            " C" + (x - 10) + " " + (y + newHeight) + " " + (x - 5) + " " + (y + newHeight + 10) + " " + x + " " + (y + newHeight + 10);
                                    }
                                } else {
                                    x = yAxis.x + startX + yAxis.prevHeight[level];
                                    newHeight = height - 10;
                                    path = "M " + x + " " + y + " C " + x + " " + y + " " + (x + 10) + " " + y + " " + (x + 10) + " " + (y + 10) +
                                        " L " + (x + 10) + " " + (y + newHeight / 2) + " " + " L " + (x + 15) + " " + (y + newHeight / 2 + 5) +
                                        " L " + (x + 10) + " " + (y + newHeight / 2 + 10) + " L " + (x + 10) + " " + (y + newHeight) +
                                        " C" + (x + 10) + " " + (y + newHeight) + " " + (x + 5) + " " + (y + newHeight + 10) + " " + x + " " + (y + newHeight + 10);
                                }
                        }
                        if (path) {
                            borderOptions = {
                                'id': svgId + '_YAxisMultiLevelLabels_Rect_' + axisIndex + '_' + i,
                                'd': path,
                                'stroke': border.color ? border.color : yAxis.multiLevelLabelsColor,
                                'stroke-width': border.width,
                                'fill': "none"
                            }
                            this.svgRenderer.drawPath(borderOptions, gMultiLevelEle);
                        }
                    }
                    if (this.model.enableCanvasRendering)
                        this.svgRenderer.ctx.restore();
                    $(gMultiLevelEle).appendTo(this.gYaxisEle);
                }
            }
        },
        // to find highest label textwidth for textanchor positions
        _getLabelCollection: function (labelText, areaBoundWidth, xAxis, gap, options) {
            var labelTextColl = [], arrColl = [], length, textcoll;
            if (typeof labelText == "string" && labelText.indexOf('<br>') != -1)
                labelTextColl = labelText.split('<br>');
            else
                labelTextColl.push(labelText);
            gap = gap <= 0 ? xAxis.width / xAxis.labels.length : gap;
			length = labelTextColl.length;
            for (var col = 0; col < length; col++) {
                textcoll = this.rowscalculation(labelTextColl[col].toString(), areaBoundWidth, xAxis, gap, options);
                for (var t = 0; t < textcoll.length; t++) {
                    arrColl.push(textcoll[t]);
                }
            }
            return arrColl;
        },

        _drawXAxisLabels: function (axisIndex, xAxis) {
            var gTickEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisLabels' + '_' + axisIndex, 'cursor': 'default' }),
                gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisLabels' + '_' + axisIndex, 'cursor': 'default' }),
                prevLabels = [],
                bounds, areaBounds = this.model.m_AreaBounds,
                isCanvas = this.model.enableCanvasRendering,
                labelSize,
                axisName = (xAxis.name).replace(/[^a-zA-Z0-9]/g, ""),
                opposedPosition = xAxis._opposed,
                valueType = xAxis._valueType,
                pixel = 3,
                xAxisAignment = xAxis.alignment.toLowerCase(),
                labelIntersectAction = xAxis.labelIntersectAction,
                labelPlacement = xAxis.labelPlacement.toLowerCase(),
                x, y, flag = false, count = 0,
                insideTicks = xAxis.tickLinesPosition == 'inside',
                labelMaxWidth = xAxis._LableMaxWidth,
                labelMaxHeight = labelMaxWidth.height,
                labelMaxRow = labelMaxWidth.rows == 0 ? 1 : labelMaxWidth.rows,
                vmlrendering = this.svgRenderer.vmlNamespace,
                lineWidth = xAxis.axisLine.width,
                font = xAxis.font,
                labelRotation = xAxis.rotationValue,
                textSize, trimLabelText,
                textWidth,
                textHeight,
                chartAreaWidth = areaBounds.Width,
                chartAreaX = areaBounds.X, anchor,
                intersectAction = xAxis.labelIntersectAction.toLowerCase(),
                svgWidth = $(this.svgObject).width(), maxLineWidth, gap,
                textanchor = null, newGapVal1, newGapVal2, nextPointX, nextLabel, nextLabelValue,
                nextPoint, nextTextWidth, value, flag1, otherLabel, trimLabel, newTextWidth,
                textcollection = [], label, labelText,
                trimGap = xAxis.maximumLabelWidth, // this holds maximumLabelWidth value      
                range = xAxis.visibleRange,
                areaBoundWidth = chartAreaWidth,
                majorTickSize = xAxis.majorTickLines.size,
                labels = xAxis.visibleLabels,
                valueType = (xAxis.valueType && xAxis.valueType.toLowerCase()),
                axisWidth = xAxis.width,
                inversed = xAxis.isInversed,
                textheight,
                majorTickWidth = xAxis.majorTickLines.width,
                position, lastLabel, diff,
                current = false, scrollerSize = this.model.scrollerSize,
                line, textcoll, count, displayText,
                preLabel,
                temp,
                prePoint,
                preTextWidth,
				padding = (isCanvas) ?(opposedPosition && labelRotation != 0) ? 16 : 4 : 8,
                textAnchor = xAxis.rotateOn.toLowerCase(),
                insideLabels = xAxis.labelPosition == 'inside',
                count1 = 0, multipleRowsColl = [], nextLabelCollection = [], lblCollection = [], highestText, isScroll;
            isScroll = xAxis._isScroll && !(xAxis.scrollbarSettings.pointsLength != null && xAxis.scrollbarSettings.pointsLength < xAxis.maxPointLength);

            this.edgeLabel = false;

            if (axisIndex != 0 && ((insideLabels && insideTicks) || (insideLabels && !insideTicks)) && (!(xAxis.y == (areaBounds.Height + areaBounds.Y) || (xAxis.y == areaBounds.Y))))
                xAxis.y = (!opposedPosition) ? Math.floor(xAxis.y + labelMaxHeight) : Math.floor(xAxis.y - labelMaxHeight);

            else if (axisIndex != 0 && (insideLabels && insideTicks) && (!(xAxis.y == (areaBounds.Height + areaBounds.Y) || (xAxis.y == areaBounds.Y))))
                xAxis.y = (!opposedPosition) ? Math.floor(xAxis.y + majorTickSize) : Math.floor(xAxis.y - majorTickSize);

            else {
                xAxis._y = Math.floor(xAxis.y);//to store the current positons of the labels,before the property showNextToAxisLine as false.
                xAxis.y = (!xAxis.showNextToAxisLine) ? opposedPosition ? Math.floor(areaBounds.Y) : Math.floor(areaBounds.Height + areaBounds.Y) : Math.floor(xAxis.y);
            }

            // loop to draw labels
            for (var i = 0; i < labels.length; i++) {
                label = labels[i];
                labelText = label.displayText = sf.util.isNullOrUndefined(label.displayText) ? label.Text : label.displayText;
                if (sf.EjSvgRender.utils._inside(label.Value, range)) {
                    gap = axisWidth / labels.length;       //space between ticks					 
                    if (!sf.isNullOrUndefined(valueType)) {
                        if (i < labels.length - 1 && valueType == "datetimecategory" && intersectAction == "wrap" && labelPlacement == "betweenticks") {
                            nextLabel = labels[i + 1];
                            label.Value -= .5;
                            nextLabelValue = nextLabel.Value - .5;
                        }
                    }
                    var pointX = Math.abs(Math.floor(sf.EjSvgRender.utils._getPointXY(label.Value, range, inversed) * (axisWidth)));
                    if (!sf.isNullOrUndefined(valueType)) {
                        if (i < labels.length - 1 && valueType == "datetimecategory" && intersectAction == "wrap" && labelPlacement == "betweenticks") {
                            nextPointX = Math.abs(Math.floor(sf.EjSvgRender.utils._getPointXY(nextLabelValue, range, inversed) * (axisWidth)));
                            newGapVal1 = (i == 0) ? (xAxis.x + pointX) + (majorTickWidth - 0.5) : (xAxis.x + pointX) + (majorTickWidth + 0.5);
                            newGapVal2 = (xAxis.x + nextPointX) + (majorTickWidth + 0.5);
                            gap = newGapVal2 - newGapVal1;
                        }
                        else if (valueType == "datetimecategory" && intersectAction == "wrap" && labelPlacement == "betweenticks") {
                            gap = (axisWidth + xAxis.x) - newGapVal2;
                            newGapVal1 = newGapVal2;
                        }
                        else if (valueType == "datetimecategory" && intersectAction == "wrap" && labelPlacement == "onticks") {
                            gap = axisWidth / xAxis.labels.length;
                        }
                    }
                    xAxis._gap = newGapVal1;

                    this.edgeLabel = false; // flag to find the supprot for edge labels
                    if (typeof labelText == "string" && labelText.indexOf('<br>') != -1)
                        highestText = sf.EjSvgRender.utils._getHighestLabel(xAxis, svgWidth, labelText);
                    else
                        highestText = labelText;
                    textSize = sf.EjSvgRender.utils._measureText(highestText, areaBoundWidth, xAxis.font);
                    textWidth = textSize.width;
                    textHeight = textSize.height;
                    count = 0;
                    flag = false;

                    //To Perform trim 
                    if (intersectAction == "trim" || xAxis.enableTrim) {
                        if (labelPlacement == "onticks") {
                            if (i != labels.length - 1) {
                                var firstLabel = label;
                                var secondLabel = labels[i + 1];
                                lblCollection = [], nextLabelCollection = [];
                                nextLabel = labels[i + 1];
                                if ((typeof nextLabel.Text == "string" && nextLabel.Text.indexOf('<br>') != -1) || (typeof label.Text == "string" && label.Text.indexOf('<br>') != -1)) {
                                    lblCollection = label.Text.split('<br>');
                                    nextLabelCollection = nextLabel.Text.split('<br>');
                                }
                                else {
                                    nextLabelCollection.push(nextLabel.Text);
                                    if (label.displayText)
                                        lblCollection.push(label.displayText);
                                    else
                                        lblCollection.push(label.Text);
                                }
                                for (var q = 0; q < nextLabelCollection.length; q++) {
                                    nextPoint = Math.abs(Math.floor(sf.EjSvgRender.utils._getPointXY(nextLabel.Value, range, inversed) * (axisWidth)));
                                    nextTextWidth = sf.EjSvgRender.utils._measureText(nextLabelCollection[q], chartAreaWidth, font).width;
                                    value = nextPoint - nextTextWidth / 2;
                                    count = 0;
                                    flag1 = true;
                                    for (var q1 = 0; q1 < lblCollection.length && flag1; q1++) {
                                        var textWidth = sf.EjSvgRender.utils._measureText(lblCollection[q1], areaBoundWidth, xAxis.font).width;
                                        while (value < pointX + textWidth / 2 && count < 2) {             // intersect
                                            count++;
                                            if (nextTextWidth > textWidth) {                            // getting max label
                                                otherLabel = trimLabel = nextLabelCollection[q];
                                                current = false;
                                            }
                                            else {
                                                trimLabel = lblCollection[q1];
                                                current = true;
                                            }
                                            trimLabelText = trimLabel;
                                            var trimmedLabel = {};
                                            trimmedLabel.displayText = trimLabel;
                                            for (var t = 1; t < trimLabelText.length; t++) {
                                                trimLabelText = trimmedLabel.displayText.substring(0, t) + '... ';
                                                newTextWidth = sf.EjSvgRender.utils._measureText(trimLabelText, chartAreaWidth, font).width;
                                                if (!current) {                                                  // to trim next label
                                                    value = nextPoint - newTextWidth / 2;
                                                    if (value < pointX + textWidth / 2) {
                                                        if (t - 1 != 0)
                                                            trimLabelText = trimLabelText.toString().substring(0, t - 1) + '... ';
                                                        nextTextWidth = newTextWidth;
                                                        trimmedLabel.displayText = secondLabel.displayText = trimLabelText;
                                                        nextLabelCollection[q] = trimLabelText;
                                                        flag1 = false;
                                                        break;
                                                    }
                                                }
                                                else {                                                           // to trim current label
                                                    value = nextPoint - nextTextWidth / 2;
                                                    if (value < pointX + newTextWidth / 2) {
                                                        if (t - 1 != 0)
                                                            trimLabelText = trimLabelText.toString().substring(0, t - 1) + '... ';
                                                        textWidth = newTextWidth;
                                                        labelText = trimmedLabel.displayText = firstLabel.displayText = trimLabelText;
                                                        lblCollection[q1] = trimLabelText;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else if (i == labels.length - 1)
                                lblCollection = nextLabelCollection;
                        }
                        else if (labelPlacement == "betweenticks") {
                            var derivedGap = (xAxis.enableTrim) ? trimGap : gap;
                            var lblCollection = [];
                            if (typeof labelText == "string" && labelText.indexOf('<br>') != -1)
                                lblCollection = labelText.split('<br>');
                            else
                                lblCollection.push(labelText);
                            var lblColLength = lblCollection.length;
                            for (var q = 0; q < lblColLength; q++) {
                                label.displayText = lblCollection[q];
                                textSize = sf.EjSvgRender.utils._measureText(lblCollection[q], areaBoundWidth, xAxis.font);
                                textWidth = textSize.width;
                                if (textWidth > derivedGap && lblCollection[q] != "") { // check textwidth is greater than gap
                                    for (var t = 1; t < lblCollection[q].toString().length; t++) {
                                        lblCollection[q] = label.displayText.toString().substring(0, t) + '... ';
                                        textWidth = sf.EjSvgRender.utils._measureText(lblCollection[q], chartAreaWidth, font).width;
                                        if (textWidth >= derivedGap) {
                                            lblCollection[q] = lblCollection[q].toString().substring(0, t - 1) + '... ';
                                            label.displayText = lblCollection[q];
                                            if (i == labels.length - 1) {
                                                if (((pointX + xAxis.x) + (textWidth / 2) > (svgWidth)) && derivedGap == gap) {
                                                    derivedGap -= (textWidth / 2);
                                                    t = 1;
                                                    continue;
                                                }
                                            }
                                            break;
                                        }
                                    }
                                    label.displayText = lblCollection[q]; // trimed text is assigned to displayText
                                }
                            }
                        }
                        if (xAxis._valueType != "double" || typeof label.displayText == "string") {
                            highestText = lblCollection.length > 0 ? sf.EjSvgRender.utils._getHighestLabel(xAxis, svgWidth, lblCollection, null) : highestText;
                            textSize = sf.EjSvgRender.utils._measureText(highestText, chartAreaWidth, font);
                        }
                    }
                    else {
                        if (typeof labelText == "string" && labelText.indexOf('<br>') != -1)
                            textSize = sf.EjSvgRender.utils._measureText(highestText, chartAreaWidth, font);
                        else
                            textSize = sf.EjSvgRender.utils._measureText(label.displayText, chartAreaWidth, font);
                    }
                    anchor = textSize.width / 2;
                    textHeight = textSize.height;
                    textWidth = textSize.width;
                    if (xAxis.majorGridLines.width > majorTickWidth)
                        maxLineWidth = xAxis.majorGridLines.width
                    else maxLineWidth = majorTickWidth;
                    if (!sf.util.isNullOrUndefined(label.Text)) {
                        if (xAxisAignment == "near")
                            x = pointX + xAxis.x + maxLineWidth + ((valueType == "category" && labelPlacement != "onticks") ? -(axisWidth / xAxis.actualRange.delta) / 2 + pixel : -textSize.width - pixel);
                        else if (xAxisAignment == "far")
                            x = (pointX + xAxis.x) + ((valueType == "category" && labelPlacement != "onticks") ? +((axisWidth / xAxis.actualRange.delta) / 2) - textSize.width : +maxLineWidth + pixel);
                        else
                            x = pointX + xAxis.x - anchor;
                        if ((insideLabels && insideTicks) || ((insideLabels && !insideTicks) && intersectAction == 'multiplerows')) {
                            y = (opposedPosition) ? (xAxis.y + majorTickSize + textHeight / 2 + (lineWidth / 2)
                                + (labelMaxHeight / (2 * labelMaxRow)) - padding) : (xAxis.y - majorTickSize - (lineWidth / 2)
                                    - (labelMaxHeight / (2 * labelMaxRow)) + padding);
                        }
                        else if (insideLabels && !insideTicks) {
                            y = (opposedPosition) ? (xAxis.y + textHeight / 2 + (lineWidth / 2)
                                + (labelMaxHeight / (2 * labelMaxRow)) - padding) : (xAxis.y - (lineWidth / 2)
                                    - (labelMaxHeight / (2 * labelMaxRow)) + padding);
                        }
                        else if ((!insideLabels && !insideTicks) || ((!insideLabels && insideTicks) && intersectAction == 'multiplerows')) {
                            y = (opposedPosition) ? (xAxis.y - majorTickSize + textHeight / 2 - (lineWidth / 2)
                                - (labelMaxHeight / (2 * labelMaxRow)) - padding) : (xAxis.y + majorTickSize + (lineWidth / 2)
                                    + (labelMaxHeight / (2 * labelMaxRow)) + padding);
                            y = y + ((isScroll ? (opposedPosition ? - scrollerSize : scrollerSize) : 0));
                        }
                        else if (!insideLabels && insideTicks) {
                            y = (opposedPosition) ? (xAxis.y + textHeight / 2 - (lineWidth / 2)
                                - (labelMaxHeight / (2 * labelMaxRow)) - padding) : (xAxis.y + (lineWidth / 2)
                                    + (labelMaxHeight / (2 * labelMaxRow)) + padding);
                            y = y + ((isScroll ? (opposedPosition ? - scrollerSize : scrollerSize) : 0));
                        }


                        if (insideLabels && !insideTicks) {
                            if (labelRotation == 90 || intersectAction == 'rotate90')
                                y = (opposedPosition) ? y : y - majorTickSize;
                        }
                        else if (!insideLabels && insideTicks) {
                            if (xAxis.labelRotation == 90 || intersectAction == 'rotate90')
                                y = (opposedPosition) ? y - majorTickSize : y - majorTickSize;
                        }
                        else if (insideLabels && insideTicks) {
                            if (xAxis.labelRotation == 90 || intersectAction == 'rotate90')
                                y = (opposedPosition) ? y : y - majorTickSize;
                        }

                        var options = {
                            'id': this.svgObject.id + '_' + axisName + '_XLabel_' + i,
                            'x': x,
                            'y': y,
                            'fill': font.color,
                            'font-size': font.size,
                            'font-family': font.fontFamily,
                            'font-style': font.fontStyle,
                            'font-weight': font.fontWeight,
                            'opacity': font.opacity
                        };

                        // To set position of edge labels
                        if (xAxis.edgeLabelPlacement) {
                            position = xAxis.edgeLabelPlacement.toLowerCase();
                            lastLabel = labels.length - 1;
                            switch (position) {
                                case "none":
                                    break;
                                case "shift":
                                    {
                                        if (i == 0) {  // Shift first label
                                            if (options.x < xAxis.x) {
                                                diff = xAxis.x - options.x;
                                                options.x = x = options.x + diff;
                                                this.diff = diff;
                                                this.edgeLabel = true;
                                            }
                                        } else if (i == lastLabel)  // Shift last label
                                            if (options.x + textSize.width > xAxis.x + xAxis.width) {
                                                diff = (options.x + textSize.width) - (xAxis.x + xAxis.width);
                                                options.x = x = options.x - diff;
                                                this.diff = diff;
                                                this.edgeLabel = true;
                                            }
                                        break;
                                    }
                                case "hide": // to hide the edge labels
                                    if ((i == 0 && options.x < xAxis.x) || (i == lastLabel && options.x + textWidth > chartAreaWidth + chartAreaX)) {
                                        labelText = "";
                                    }
                            }
                        }
                        if (intersectAction == "wrap" || intersectAction == "wrapbyword") {
                            var arrColl = this._getLabelCollection(labelText, areaBoundWidth, xAxis, gap, options);                                     
                            var text = sf.EjSvgRender.utils._getHighestLabel(xAxis, $(this.svgObject).width(), arrColl, null);
                            textWidth = sf.EjSvgRender.utils._measureText(text, chartAreaWidth, font).width;
                        }
                        //To perform rotation             
                        if (labelRotation != 0 && !vmlrendering) {
                            label.displayText = typeof label.displayText == "string" && label.displayText.indexOf('<br>') != -1 ? sf.EjSvgRender.utils._getHighestLabel(xAxis, svgWidth, label.displayText) : label.displayText;
                            this.labelRotation(xAxis, x + anchor, y, options, label, labelRotation);
                        }
                        //To perform labelIntersect Actions none , wrap, hide ,multiplerows
                        if (xAxis.labelIntersectAction || xAxis.enableTrim) {
                            this.diff = sf.util.isNullOrUndefined(this.diff) ? 0 : this.diff;
                            if (intersectAction == 'none' && !xAxis.enableTrim) {
                                if (typeof labelText == "string" && labelText.indexOf('<br>') != -1) {
                                    var labelTextColl = labelText.split('<br>');

                                    if (!insideLabels)
                                        options.y = (opposedPosition) ? options.y - (textHeight * (labelTextColl.length - 1)) : options.y;
                                    else
                                        options.y = (opposedPosition) ? options.y : options.y - (textHeight * (labelTextColl.length - 1));
                                    if (labelRotation != 0) {
                                        options.x = options.x + textWidth / 2;
                                        options['text-anchor'] = textAnchor;
                                    }

                                    this.svgRenderer.drawText(options, labelTextColl, isCanvas ? highestText : gTickEle);
                                }
                                else {
                                    if ((textAnchor == "start" || textAnchor == "end") && labelRotation !=0 && labelRotation != -360 && labelRotation != 360) {
                                        options.x = options.x + textWidth / 2;
                                        options['text-anchor'] = textAnchor;
                                    }
                                    this.svgRenderer.drawText(options, labelText, isCanvas ? highestText : gTickEle);
                                }
                                //create region to chart axis labels
                                labels[i].region = this.calculateRegion(labelText, font, options, label);
                                this.model.xAxisLabelRegions.push(labels[i].region)
                                if (insideLabels)
                                    $(gTickEle).appendTo(this.gXaxisTickEle);
                                else
                                    $(gTickEle).appendTo(this.gXaxisEle);
                                continue;
                            }
                            else if ((intersectAction == 'wrap' || intersectAction == 'wrapbyword') && !xAxis.enableTrim) {

                                line = 0;
                                var labelTextColl = [], arrColl = [];
                                if (typeof labelText == "string" && labelText.indexOf('<br>') != -1)
                                    labelTextColl = labelText.split('<br>');
                                else
                                    labelTextColl.push(labelText);
                                displayText = '';
                                gap = gap <= 0 ? axisWidth / labels.length : gap;
                                for (var col = 0; col < labelTextColl.length; col++) {
                                    textcoll = this.rowscalculation(labelTextColl[col].toString(), areaBoundWidth, xAxis, gap, options);
                                    for (var t = 0; t < textcoll.length; t++) {
                                        arrColl.push(textcoll[t]);
                                        displayText = displayText + textcoll[t];
                                    }
                                }
                                options.x = options.x + anchor;
                                if (!(displayText.indexOf("...") != -1))
                                    displayText = labelText;
                                var highestText = sf.EjSvgRender.utils._getHighestLabel(xAxis, svgWidth, arrColl, null);
                                var textSize = sf.EjSvgRender.utils._measureText(highestText, chartAreaWidth, font);
                                var textWidth = textSize.width;
                                options.x = options.x - (textWidth / 2);
                                if (!insideLabels)
                                    options.y = (opposedPosition) ? options.y - (textHeight * (arrColl.length - 1)) : options.y;
                                else
                                    options.y = (opposedPosition) ? options.y : options.y - (textHeight * (arrColl.length - 1));

                                if (labelRotation != 0 && labelRotation != -360 && labelRotation != 360) {
                                    options['text-anchor'] = textAnchor;
                                    options.x = options.x + (textWidth / 2);
                                }
                                this.svgRenderer.drawText(options, arrColl, isCanvas ? highestText : gTickEle);

                                labelSize = sf.EjSvgRender.utils._measureText(arrColl[0], null, font);
                                var colLength = arrColl.length;
                                textheight = labelSize.height * arrColl.length;
                                bounds = { x: options.x, y: options.y, width: textWidth, height: textheight - textheight / (colLength) };
                                labels[i].region = { bounds: bounds, labelText: label.Text, displayText: displayText };
                                labels[i].displayText = displayText;
                                this.model.xAxisLabelRegions.push(labels[i].region)
                                continue;
                            }
                            else if (intersectAction == 'hide') {
                                var xAxisLabelLength = labels.length - 1;
                                for (var j = 0; j < i; j++) {
                                    // loop to get previous label

                                    preLabel = labels[j];
                                    temp = 0;
                                    prePoint = Math.abs(Math.floor(sf.EjSvgRender.utils._getPointXY(preLabel.Value, range, xAxis.isInversed) * (xAxis.width)));
                                    preTextWidth = sf.EjSvgRender.utils._measureText(preLabel.displayText, areaBoundWidth, xAxis.font).width;
                                    value = prePoint + ((xAxis.isInversed) ? -preTextWidth / 2 : preTextWidth / 2);
                                    value = (j == 0) ? value + this.diff : value;
                                    var width = (preTextWidth == 0) ? preTextWidth : textWidth;
                                    if ((i != xAxisLabelLength) || (i == xAxisLabelLength && textWidth <= preTextWidth))
                                        width = width / 2;
                                    if (position == "shift" && i == xAxisLabelLength) {
                                        var nextXLabel = labels[i],
                                            nextPoint = Math.abs(Math.floor(sf.EjSvgRender.utils._getPointXY(nextXLabel.Value, range, xAxis.isInversed) * (xAxis.width))),
                                            nextTextWidth = sf.EjSvgRender.utils._measureText(nextXLabel.displayText, areaBoundWidth, xAxis.font).width,
                                            nextValue = nextPoint + ((xAxis.isInversed) ? nextTextWidth / 2 : -nextTextWidth / 2);
                                        if ((xAxis.isInversed) ? (value <= nextValue - this.diff) : (value >= nextValue - this.diff))
                                            labelText = label.displayText = '';
                                    }
                                    if (intersectAction == 'hide' && ((xAxis.isInversed) ? (value < pointX + width) : (value > pointX - width)))
                                        label.displayText = labelText = '';
                                }
                            }
                            else if (intersectAction == 'multiplerows' && !xAxis.enableTrim) { // to perform multipleRows on intersect

                                var currentLabelColl = [];
                                var currentLabel = label;
                                if (typeof currentLabel.Text == "string" && currentLabel.Text.indexOf('<br>') != -1)
                                    currentLabelColl = currentLabel.Text.split('<br>');
                                else
                                    currentLabelColl.push(currentLabel.Text);
                                var collectionLength = currentLabelColl.length;
                                if (labelText == '' && xAxis.edgeLabelPlacement == "hide") {
                                    for (var m = 0; m < collectionLength; m++)
                                        currentLabelColl[m] = '';
                                }
                                var largestText = sf.EjSvgRender.utils._getHighestLabel(xAxis, svgWidth, currentLabelColl),
                                    textWidth = sf.EjSvgRender.utils._measureText(largestText, chartAreaWidth, font).width,
                                    xAxisLabelLength = xAxis.visibleLabels.length - 1;
                                textWidth = textWidth / 2;

                                if (multipleRowsColl.length > 0) {
                                    var previousLabels = multipleRowsColl;
                                    for (var k = 0; k < previousLabels.length && !flag; k++) {
                                        var prevLabel = previousLabels[k];
                                        for (var l = 0; prevLabel && l < prevLabel.length; l++) {
                                            for (var c = 0; c < collectionLength; c++) {
                                                var temp = 0,
                                                    textWidth = sf.EjSvgRender.utils._measureText(currentLabelColl[c], chartAreaWidth, font).width,
                                                    preLabel = prevLabel[l],
                                                    prePoint = Math.abs(Math.floor(sf.EjSvgRender.utils._getPointXY(preLabel.Value, range, xAxis.isInversed) * (xAxis.width))),
                                                    preTextWidth = sf.EjSvgRender.utils._measureText(preLabel.Text, areaBoundWidth, xAxis.font).width;
                                                if (i != xAxisLabelLength)
                                                    textWidth = textWidth / 2;
                                                var value = prePoint + ((xAxis.isInversed) ? -preTextWidth / 2 : preTextWidth / 2);
                                                if (this.edgeLabel || previousLabels.length == 1)
                                                    value = value + this.diff;
                                                if ((xAxis.isInversed) ? (value < pointX + textWidth) : (value > pointX - textWidth)) {
                                                    if (opposedPosition) {
                                                        if (!insideLabels)
                                                            temp = options.y - textHeight;
                                                        else
                                                            temp = options.y + textHeight;
                                                        options.y = temp;
                                                        count = count + 1;
                                                        if (count < count1) {
                                                            count = count + count1;
                                                            count1 = 0;
                                                        }
                                                        if (k + 1 == previousLabels.length)
                                                            flag = true;
                                                        break;
                                                    } else {
                                                        if (!insideLabels)
                                                            temp = options.y + textHeight;
                                                        else
                                                            temp = options.y - textHeight;
                                                        options.y = temp;
                                                        count = count + 1;
                                                        if (count < count1) {
                                                            count = count + count1;
                                                            count1 = 0;
                                                        }
                                                        if (k + 1 == previousLabels.length)
                                                            flag = true;
                                                        break;

                                                    }
                                                }
                                                else {
                                                    if (l + 1 == prevLabel.length) {
                                                        if (c == collectionLength - 1)
                                                            flag = true;
                                                        else {
                                                            count1++;
                                                            flag = false;
                                                        }
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                if (temp == undefined) {
                                    if (multipleRowsColl[0] == undefined)
                                        multipleRowsColl[0] = [];
                                    if (collectionLength == 1)
                                        multipleRowsColl[0].push(currentLabel);
                                    else {
                                        for (var c = 0; c < collectionLength; c++) {
                                            if (multipleRowsColl[c] == undefined)
                                                multipleRowsColl[c] = [];
                                            multipleRowsColl[c].push({
                                                Text: currentLabelColl[c],
                                                Value: currentLabel.Value,
                                            });
                                        }
                                    }
                                }
                                else {
                                    if (multipleRowsColl[count] == undefined)
                                        multipleRowsColl[count] = [];
                                    if (collectionLength == 1)
                                        multipleRowsColl[count].push(currentLabel);
                                    else {
                                        for (var c = 0; c < collectionLength; c++) {
                                            if (multipleRowsColl[count] == undefined)
                                                multipleRowsColl[count] = [];
                                            multipleRowsColl[count].push({
                                                Text: currentLabelColl[c],
                                                Value: currentLabel.Value,
                                            });
                                            if (c != collectionLength - 1) {
                                                count = count + 1;
                                            }
                                        }
                                    }
                                }
                                if (!insideLabels)
                                    options.y = (opposedPosition) ? options.y - (textHeight * (currentLabelColl.length - 1)) : options.y;
                                else
                                    options.y = (opposedPosition) ? options.y : options.y - (textHeight * (currentLabelColl.length - 1));
                                if (labelRotation != 0 && labelRotation != -360 && labelRotation != 360) {
                                    var largestText = sf.EjSvgRender.utils._getHighestLabel(xAxis, svgWidth, currentLabelColl);
                                    textWidth = sf.EjSvgRender.utils._measureText(largestText, chartAreaWidth, font).width;
                                    options['text-anchor'] = textAnchor;
                                    options.x = options.x + textWidth / 2;
                                }
                                this.svgRenderer.drawText(options, currentLabelColl, gTickEle);

                            }


                        }
                        if ((!this.edgeLabel) && !this.zoomed && !xAxis.zoomed && !(labelRotation) && !(labelIntersectAction == "rotate90") && !(labelIntersectAction == "rotate45") && (((pointX + xAxis.x) + (textWidth / 2)) > ($(this.svgObject).width()))) {
                            $(options).attr('x', ($(this.svgObject).width() - 2));
                            $(options).attr('text-anchor', 'end');
                        }
                        xAxis.visibleLabels[i].y = options.y;

                        if (this.model.enableCanvasRendering && insideLabels && (xAxis.labelIntersectAction == "rotate45" || xAxis.labelIntersectAction == "rotate90")) {
                            options.y = options.y - textWidth;
                        }

                        if ((intersectAction == "trim" || xAxis.enableTrim) && (xAxis._valueType != "double" || typeof label.displayText == "string")) {
                            if (!insideLabels)
                                options.y = (opposedPosition) ? options.y - (textHeight * (lblCollection.length - 1)) : options.y;
                            else
                                options.y = (opposedPosition) ? options.y : options.y - (textHeight * (lblCollection.length - 1));

                            label.displayText = lblCollection.length > 0 ? lblCollection.join('') : labelText;
                            if (!(label.displayText.indexOf("...") != -1))
                                label.displayText = labelText;
                            if (labelRotation != 0 && textAnchor != "middle") {
                                options.x = options.x + textWidth / 2;
                                options['text-anchor'] = textAnchor;
                            }
                            this.svgRenderer.drawText(options, lblCollection.length > 0 ? lblCollection : labelText, isCanvas ? highestText : gTickEle);
                        }
                        else if (intersectAction != "multiplerows") {
                            if (typeof labelText == "string" && labelText.indexOf('<br>') != -1) {
                                labelTextColl = labelText.split('<br>');
                                if (!insideLabels)
                                    options.y = (opposedPosition) ? options.y - (textHeight * (labelTextColl.length - 1)) : options.y;
                                else
                                    options.y = (opposedPosition) ? options.y : options.y - (textHeight * (labelTextColl.length - 1));
                                if ((labelRotation != 0 || labelIntersectAction == "rotate45" || labelIntersectAction == "rotate90")) {
                                    options.x = options.x + textWidth / 2;
                                    options['text-anchor'] = textAnchor;
                                }
                                this.svgRenderer.drawText(options, labelTextColl, isCanvas ? highestText : gTickEle);
                            }
                            else {
                                if ((textAnchor == "start") && labelRotation != 0 && labelRotation != -360 && labelRotation != 360) {
                                    options.x = options.x + textWidth / 2;
                                    options['text-anchor'] = textAnchor;
                                }
                                this.svgRenderer.drawText(options, labelText, isCanvas ? highestText : gTickEle);
                        }
                        }
                        //create region to chart axis labels
                        if (i != labels.length - 1 && (intersectAction == "trim" || xAxis.enableTrim))
                            options.x = options.x - textWidth / 2;
                        xAxis.visibleLabels[i].region = this.calculateRegion(labelText, font, options, label, lblCollection ? lblCollection : labelTextColl, highestText, intersectAction);

                        this.model.xAxisLabelRegions.push(xAxis.visibleLabels[i].region)
                    }
                }
            }
            $(gTickEle).appendTo(this.gXaxisEle);

        },
        calculateRegion: function (labelText, font, options, label, lblCollection, highestText, intersectAction) {

            if (intersectAction == "trim" && lblCollection.length > 0) {
                var labelTxt = lblCollection.join('');
                if (!(labelTxt.indexOf("...") != -1))
                    labelTxt = label.Text;
            }
            else
                var labelTxt = highestText ? highestText : labelText;
            var count = lblCollection ? (lblCollection.length> 0 ? lblCollection.length : 1) : 1;
            var labelSize = count > 1 && highestText ? sf.EjSvgRender.utils._measureText(highestText, null, font) : sf.EjSvgRender.utils._measureText(labelTxt, null, font);
            var textHeight = labelSize.height * count;
            var bounds = { x: options.x, y: options.y, width: labelSize.width, height: textHeight };
            var xAxisLabelRegions = { bounds: bounds, trimText: labelTxt, labelText: label.Text };
            return xAxisLabelRegions;
        },
        rowscalculation: function (labelText, areaBoundWidth, xAxis, gap, options) {
            var measureText = sf.EjSvgRender.utils._measureText,
                font = xAxis.font,
                textSize = measureText(labelText, areaBoundWidth, font),
                textWidth = textSize.width,
                anchor = textWidth / 2,
                text = labelText.toString(),
                textLength = text.length,
                textcollection = [],
                i = 0, line, currentTextCollextion,
                intersectAction = xAxis.labelIntersectAction,
                labelCollection = text.split(' '),
                labelCollectionLength = labelCollection.length;

            if (this.edgeLabel) gap = (i == 0) ? gap - this.diff : gap;

            if (textWidth > gap && options) {
                line = 0;
                if (this.edgeLabel) options.x = (i == 0) ? options.x - this.diff : options.x + this.diff;
            }

            if (intersectAction == 'wrap') {
                if (textWidth > gap) {
                    for (var w = 1; w <= text.length; w++) {
                        labelText = text.substring(0, w);
                        textWidth = measureText(labelText, areaBoundWidth, font).width;
                        if (textWidth > gap) {
                            line = line + 1; // To find the no of rows splitted
                            labelText = text.substring(0, w - 1);
                            textcollection[i] = labelText;
                            text = text.slice(w - 1, textLength);
                            currentTextCollextion = text.split(' ');
                            text = labelCollection.indexOf(currentTextCollextion[0]) > -1 ? text : '-' + text;
                            var newTextWidth = measureText(labelText, areaBoundWidth, font).width;

                            i++;
                            w = 0;
                        }
                    }
                }
                if (options) options.x = (xAxis.valueType == "datetimeCategory" && xAxis.labelPlacement.toLowerCase() == "betweenticks") ? xAxis._gap : options.x;
                textcollection[i] = labelText;
            }
            else {
                var max = 0, word, currentWidth, nextWidth;

                for (var i = 0; i < labelCollectionLength; i++) {
                    word = labelCollection[i];
                    currentWidth = measureText(word, areaBoundWidth, font).width;
                    if (currentWidth < gap && textWidth > gap) {
                        while (i < labelCollectionLength) {
                            currentWidth = measureText(word, areaBoundWidth, font).width;
                            nextWidth = (labelCollection[i + 1]) ? measureText(labelCollection[i + 1], areaBoundWidth, font).width : 0;
                            if ((currentWidth + nextWidth) <= gap && nextWidth > 0) {
                                word = word.concat(' ' + labelCollection[i + 1]);
                                i++;
                            }
                            else {
                                // find the maximum width of the lines
                                max = Math.max(max, currentWidth);
                                break;
                            }
                        }
                        textcollection.push(word);
                    }
                    else {
                        if (textWidth > gap) {
                            word = sf.EjSvgRender.utils._trimText(word, gap, font);
                            newTextWidth = measureText(word, areaBoundWidth, font).width;
                            max = Math.max(max, newTextWidth)
                            textcollection.push(word);
                        } else {
                            textcollection.push(labelText);
                            break;
                        }
                    }
                }

            }

            return textcollection;
        },

        labelRotation: function (axis, x, y, options, label, degree, i) {
            var opposedPosition = axis._opposed;
            var textAnchor = axis.rotateOn.toLowerCase();
            var intersectAction = axis.labelIntersectAction.toLowerCase();
            var diffHeight = 0;
            // To rotate axis labels
            var labelText = (label.displayText) ? label.displayText : label.Text;
            var angle = (degree > 360) ? degree - 360 : (degree < -360) ? degree + 360 : degree;
            var rotate = 'rotate(' + angle + ',' + (x) + ',' + y + ')';
            $(options).attr('transform', rotate);
            $(options).attr('labelRotation', angle);
            $(options).attr('labelPosition', axis.labelPosition);
            if (intersectAction == "wrap" || intersectAction == "wrapbyword")
            {
                var gap = axis.width / axis.labels.length;
                var arrColl = this._getLabelCollection(labelText, this.model.m_AreaBounds.width, axis, gap, options);
                var labelText = sf.EjSvgRender.utils._getHighestLabel(axis, $(this.svgObject).width(), arrColl, null);
            }
            var textElement = this.svgRenderer.createText(options, labelText);
            var textElementHeight =Math.round(sf.EjSvgRender.utils._measureBounds(textElement, this).height);
            var labelTextHeight = sf.EjSvgRender.utils._measureText(labelText, null, axis.font).height;
            diffHeight = Math.ceil(sf.EjSvgRender.utils._measureBounds(textElement, this).height - sf.EjSvgRender.utils._measureText(labelText, null, axis.font).height);
            diffHeight = axis._LableMaxWidth.height - diffHeight - sf.EjSvgRender.utils._measureText(labelText, null, axis.font).height;

            if (axis.labelPosition != 'inside')
                var yLocation = (opposedPosition) ? (diffHeight / 2) : (-diffHeight / 2);
            else
                var yLocation = (opposedPosition) ? (-diffHeight / 2) : (diffHeight / 2);
            if (textAnchor == "end")
                yLocation = yLocation + ((angle < 0 && angle > -180) || angle > 180 ? -((textElementHeight) / 2) : ((textElementHeight - labelTextHeight) / 2));
            if (textAnchor == "start")
                yLocation = yLocation + ((angle < 0 && angle > -180) || angle > 180 ? ((textElementHeight) / 2) : -((textElementHeight - labelTextHeight) / 2));

            rotate = 'rotate(' + angle + ',' + (x) + ',' + (y + (this.model.enableCanvasRendering && axis.opposedPosition ? -yLocation : yLocation)) + ')';
            if (this.edgeLabel && degree == 90)
                y = (i == 0) ? options.y + this.diff : options.y - this.diff;

            $(options).attr({
                'transform': rotate,
                'y': (y + (this.model.enableCanvasRendering && axis.opposedPosition ? -yLocation : yLocation))
            });
        },

        _drawYAxisLabels: function (axisIndex, yAxis) {
            // method to draw y axis labels
            //if(yAxis.labelPosition=='inside')
            var axisName = (yAxis.name).replace(/[^a-zA-Z0-9]/g, ""),
                gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisLabels' + '_' + axisIndex, 'cursor': 'default' }),
                labelSize, textElement, diffHeight,
                yAxisLabelRegions, opposedPosition = yAxis._opposed,
                insideLabels = yAxis.labelPosition == 'inside',
                insideTicks = yAxis.tickLinesPosition == 'inside',
                bounds,
                regionX, areaBounds = this.model.m_AreaBounds,
                requireInvertedAxes = this.model.requireInvertedAxes,
                isCanvas = this.model.enableCanvasRendering,
                isScroll = yAxis._isScroll && !(yAxis.scrollbarSettings.pointsLength != null && yAxis.scrollbarSettings.pointsLength < yAxis.maxPointLength), pointY, text, position, lastLabel,
                textHeight, yLocation,
                font = yAxis.font,
                range = yAxis.visibleRange,
                lineWidth = yAxis.axisLine.width,
                labelMaxWidth = yAxis._LableMaxWidth,
                labelMaxHeight = labelMaxWidth.height,
                labelMaxRow = labelMaxWidth.rows,
                areaBounds = this.model.m_AreaBounds,
                areaBoundWidth = areaBounds.Width,
                gap = yAxis.maximumLabelWidth,  // width for 4 digits
                labelText, x, textanchor, diff, angle, rotate,
                textSize, options, scrollerSize = this.model.scrollerSize,
                textWidth, intersectAction = yAxis.labelIntersectAction.toLowerCase(),
                label, labels = yAxis.visibleLabels,
                visibleRange = range, inversed = yAxis.isInversed, axisHeight = yAxis.height,
                prevLabel, temp, prevPoint, prevTextHeight, value,
                degree = yAxis.labelRotation, maxLineWidth,
                yAxisAlignment = yAxis.alignment.toLowerCase(), pixel = 3, y;
            if (axisIndex != 1 && ((insideLabels && insideTicks) || (insideLabels && !insideTicks) && !((yAxis.x == (areaBounds.Width + areaBounds.X)) || (yAxis.x == areaBounds.X))))
                yAxis.x = (!opposedPosition) ? (yAxis.showNextToAxisLine) ? Math.floor(yAxis.x) : Math.floor(yAxis.x - labelMaxWidth.width - this.model.elementSpacing) : insideLabels && insideTicks ? Math.floor(yAxis.x) : Math.floor(yAxis.x + labelMaxWidth.width + this.model.elementSpacing);
            else if (axisIndex != 1 && (!(yAxis.x == (areaBounds.Width + areaBounds.X)) || (yAxis.x == areaBounds.X)) && (!insideLabels && insideTicks)) {
                yAxis._x = Math.floor(yAxis.x);
                yAxis.x = (!opposedPosition) ? !yAxis.showNextToAxisLine ? Math.floor(areaBounds.X) : Math.floor(yAxis.x - yAxis.majorTickLines.size) : Math.floor(yAxis.x + yAxis.majorTickLines.size);
            }
            else {
                yAxis._x = Math.floor(yAxis.x);//to store the current positons of the labels,before the property showNextToAxisLine as false.
                yAxis.x = (!yAxis.showNextToAxisLine) ? opposedPosition ? Math.floor(areaBounds.X + areaBounds.Width) : Math.floor(areaBounds.X) : Math.floor(yAxis.x);
            }

            for (var i = 0; i < labels.length; i++) {
                label = labels[i];
                if (sf.EjSvgRender.utils._inside(label.Value, visibleRange)) {
                    pointY = Math.abs(sf.EjSvgRender.utils._getPointXY(label.Value, visibleRange, inversed) * axisHeight);
                    text = sf.EjSvgRender.utils._measureText(label.Text, areaBounds.Height, font);
                    textHeight = text.height;
                    labelText = label.displayText = label.Text;
                    textSize = sf.EjSvgRender.utils._measureText(labelText, areaBoundWidth, font);
                    textWidth = textSize.width;

                    if (insideLabels && insideTicks) {
                        x = (opposedPosition) ? (yAxis.x - (yAxis.majorTickLines.size) - (lineWidth / 2) - 5)
                            : (yAxis.x + (lineWidth / 2) + 5 + yAxis.majorTickLines.size);
                        textanchor = (opposedPosition) ? 'end' : 'start';
                    }
                    else if (insideLabels && !insideTicks) {
                        x = (opposedPosition) ? (yAxis.x - (lineWidth / 2) - 5)
                            : (yAxis.x + (lineWidth / 2) + 5);
                        textanchor = (opposedPosition) ? 'end' : 'start';
                    }
                    else if (insideTicks && !insideLabels) {

                        x = (opposedPosition) ? ((lineWidth / 2) + yAxis.x + 5)
                            : (yAxis.x - (lineWidth / 2) - 5);
                        textanchor = (opposedPosition) ? 'start' : 'end';
                        x = x - ((isScroll ? (opposedPosition ? -scrollerSize : scrollerSize) : 0));
                    }
                    else {
                        x = (opposedPosition) ? ((yAxis.majorTickLines.size) + (lineWidth / 2) + yAxis.x + 5)
                            : (yAxis.x - (lineWidth / 2) - 5 - yAxis.majorTickLines.size);
                        textanchor = (opposedPosition) ? 'start' : 'end';
                        x = x - ((isScroll ? (opposedPosition ? -scrollerSize : scrollerSize) : 0));
                    }
                    if (yAxis.majorGridLines.width > yAxis.majorTickLines.width)
                        maxLineWidth = yAxis.majorGridLines.width;
                    else maxLineWidth = yAxis.majorTickLines.width;
                    if (yAxisAlignment == "far")
                        y = ((-pointY) + (yAxis.y + axisHeight)) - maxLineWidth - pixel;
                    else if (yAxisAlignment == "near")
                        y = ((-pointY) + (yAxis.y + axisHeight) + textHeight / 2) + maxLineWidth + pixel;
                    else
                        y = ((-pointY) + (yAxis.y + axisHeight) + textHeight / 4);
                    options = {
                        'id': this.svgObject.id + '_' + axisName + '_YLabel_' + i,
                        'x': x,
                        'y': y,
                        'fill': font.color,
                        'font-size': font.size,
                        'font-family': font.fontFamily,
                        'font-style': font.fontStyle,
                        'font-weight': font.fontWeight,
                        'opacity': font.opacity,
                        'text-anchor': !sf.util.isNullOrUndefined(degree) && degree != 0 ? "middle" : textanchor
                    };
                    labelText = (label.displayText) ? label.displayText : label.Text;
                    var labelCollection = [], highestText;
                    if (typeof labelText == "string" && labelText.indexOf('<br>') != -1) {
                        labelCollection = labelText.split('<br>');
                        highestText = labelText = sf.EjSvgRender.utils._getHighestLabel(yAxis, areaBounds.Height, labelCollection);
                        textWidth = sf.EjSvgRender.utils._measureText(labelText, areaBoundWidth, font).width;
                    }
                    else
                        labelCollection.push(labelText);

                    // To set position of edge labels in yAxis
                    if (yAxis.edgeLabelPlacement) {
                        position = yAxis.edgeLabelPlacement.toLowerCase();
                        lastLabel = labels.length - 1;

                        switch (position) {
                            case "none":
                                break;
                            case "shift":
                                {
                                    if (i == 0) {  // Shift first label
                                        if (options.y > yAxis.y + axisHeight) {
                                            diff = options.y - (yAxis.y + axisHeight);
                                            options.y = y = options.y - diff;
                                            this.diff = diff;
                                            this.edgeLabel = true;
                                        }
                                    } else if (i == lastLabel) // Shift last label
                                        if (options.y - textHeight / 2 < yAxis.y) {
                                            diff = yAxis.y - (options.y - textHeight / 2);
                                            options.y = y = options.y + diff;
                                            this.diff = diff;
                                            this.edgeLabel = true;
                                        }
                                    break;
                                }
                            case "hide": //to hide the edge labels
                                if ((i == 0 && options.y > yAxis.y + axisHeight) || (i == lastLabel && options.y - textHeight / 2 < areaBounds.Y)) {
                                    labelText = label.Text = "";
                                    if (labelCollection.length == 1) labelCollection[0] = labelText;
                                }
                        }
                    }

                    //To perform rotation         
                    if (!sf.util.isNullOrUndefined(degree) && degree != 0 && !this.svgRenderer.vmlNamespace) {
                        if (!insideLabels)
                            x = (opposedPosition) ? (x + textWidth / 2) : (x - textWidth / 2);
                        else
                            x = (opposedPosition) ? (x - textWidth / 2) : (x + textWidth / 2);

                        labelText = (label.displayText) ? label.displayText : label.Text;
                        labelText = highestText ? highestText : labelText;
                        angle = (degree > 360) ? degree - 360 : (degree < -360) ? degree + 360 : degree;
                        rotate = 'rotate(' + angle + ',' + (x) + ',' + y + ')';
                        $(options).attr('transform', rotate);
                        $(options).attr('labelRotation', angle);
                        textElement = this.svgRenderer.createText(options, labelText);
                        diffHeight = Math.ceil(sf.EjSvgRender.utils._measureBounds(textElement, this).width -
                            sf.EjSvgRender.utils._measureText(labelText, null, font).width);

                        if (!insideLabels)
                            yLocation = (opposedPosition) ? (diffHeight / 2) : (-diffHeight / 2);
                        else
                            yLocation = (opposedPosition) ? (-diffHeight / 2) : (diffHeight / 2);

                        rotate = 'rotate(' + angle + ',' + (x + yLocation) + ',' + (y) + ')';

                        $(options).attr({
                            'transform': rotate,
                            'x': (x + yLocation)
                        });
                    }

                    //Label intersection
                    if (yAxis.labelIntersectAction || yAxis.enableTrim) {
                        if (intersectAction == 'none' && !(yAxis.enableTrim)) {
                            this.svgRenderer.drawText(options, labelCollection.length > 0 ? labelCollection : label.Text, isCanvas && highestText ? highestText : gEle);
                            labelSize = sf.EjSvgRender.utils._measureText(labelText, null, font);
                            if (yAxis.opposedPosition)
                                regionX = options.x;
                            else
                                regionX = options.x - labelSize.width;
                            // yAxis labels region stored 
                            bounds = { x: regionX, y: options.y, width: labelSize.width, height: labelSize.height };
                            yAxisLabelRegions = { bounds: bounds, trimText: labelText, labelText: label.Text };
                            yAxis.visibleLabels[i].region = { bounds: bounds, trimText: labelText, labelText: label.Text };
                            this.model.yAxisLabelRegions.push(yAxisLabelRegions)
                            continue;
                        }
                        else if (yAxis.enableTrim) {
                            for (var l = 0; l < labelCollection.length; l++) {
                                var labelText = labelCollection[l];
                                textWidth = sf.EjSvgRender.utils._measureText(labelText, null, font).width;
                                if (textWidth > gap && labelText != "") { // check textwidth is greater than gap
                                    for (var t = 1; t < labelText.toString().length; t++) {
                                        labelText = label.displayText.toString().substring(0, t - 1) + '...';
                                        textWidth = sf.EjSvgRender.utils._measureText(labelText, areaBoundWidth, font).width;
                                        if (textWidth >= gap) {
                                            labelText = labelText.toString().substring(0, t - 1) + '...';
                                            break;
                                        }
                                    }
                                    label.displayText = labelCollection[l] = labelText;
                                }
                            }

                        }

                        for (var j = 0; j < i; j++) {
                            prevLabel = labels[j];
                            temp = 0;
                            prevPoint = Math.abs((sf.EjSvgRender.utils._getPointXY(prevLabel.Value, range, inversed) * (axisHeight)));
                            prevTextHeight = sf.EjSvgRender.utils._measureText(prevLabel.Text, areaBounds.Height, font).height;
                            value = ((prevPoint * -1) + (yAxis.y + axisHeight) + prevTextHeight / 4);
                            value = value + ((inversed) ? prevTextHeight / 2 : -prevTextHeight / 2);
                            if (this.edgeLabel)
                                value = (j == 0) ? value - prevTextHeight / 4 : value;
                            if (intersectAction == 'hide' && prevLabel.Text.toString() != "" && ((inversed) ? value > options.y - textHeight / 4 : value < options.y + textHeight / 4))
                                labelText = label.Text = '';
                            else if (intersectAction == 'multiplerows' && ((inversed) ? value > options.y - textHeight / 4 : value < options.y + textHeight / 4) && prevLabel.x == options.x) {
                                options.x = prevLabel.x + opposedPosition ? (!insideLabels ? (labelMaxWidth.maxWidth + 5) : (-labelMaxWidth.maxWidth - 5)) : (!insideLabels ? (-labelMaxWidth.maxWidth - 5) : (labelMaxWidth.maxWidth + 5));
                            }
                        }
                    }

                    labels[i].x = options.x;
                    this.svgRenderer.drawText(options, labelCollection.length > 0 ? labelCollection : labelText, gEle);
                    //create region to chart axis labels
                    labelSize = sf.EjSvgRender.utils._measureText(labelText, null, font);

                    if (opposedPosition)
                        regionX = options.x;
                    else
                        regionX = options.x - labelSize.width;

                    // yAxis labels region stored 
                    bounds = { x: regionX, y: options.y, width: labelSize.width, height: labelSize.height };
                    yAxisLabelRegions = { bounds: bounds, trimText: labelText, labelText: label.Text };
                    labels[i].region = { bounds: bounds, trimText: labelText, labelText: label.Text };
                    this.model.yAxisLabelRegions.push(yAxisLabelRegions)


                }
            }
            $(gEle).appendTo(this.gYaxisEle);
        },
        //To Trim axis title
        trimText: function (text, maxLength, ellipsis) {
            maxLength--;
            text = text.substring(0, maxLength - ellipsis.length);
            return text + ellipsis;
        },

        _drawXTitle: function (axisIndex, axis) {

            if (axis.title.text != "" && axis.title.text && axis.title.visible) {
                var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxis_Title' + '_' + axisIndex, 'cursor': 'default' }),
                    xtitleLocation = (this.model.elementSpacing) + axis._LableMaxWidth.height,
                    axisTitleSize = sf.EjSvgRender.utils._measureText(axis.title.text, (axis.width), axis.title.font),
                    titlesize = axisTitleSize.height / 2,
                    opposedPosition = axis._opposed,
                    titleText = axis.title.text,
                    _LableMaxWidth = axis._LableMaxWidth,
                    textAnchor = "middle",
                    elementSpacing = this.model.elementSpacing,
                    isEnableTrim = axis.title.enableTrim,
                    isScroll = (axis._isScroll || (this.model.zooming.enableScrollbar && axis.scrollbarSettings.visible && (axis.zoomFactor < 1 || axis.zoomPosition > 0))),
                    axisTitleWidth = axis.title.maximumTitleWidth,
                    axisTitlePosition = axis.title.position.toLowerCase(),
                    axisTitleAlignment = axis.title.alignment.toLowerCase(), y,
                    isRTL = axis.title.isReversed,
                    tickLinesPosition = axis.tickLinesPosition.toLowerCase(),
                    labelPosition = axis.labelPosition.toLowerCase(),
                    m_AreaBounds = this.model.m_AreaBounds,
                    axistitleoffset = axis.title.offset, locX, newY,
                    scrollerSize = this.model.scrollerSize;
                if (isEnableTrim && (sf.util.isNullOrUndefined(axisTitleWidth) || axisTitleWidth > 0 || isNaN(axisTitleWidth))) {
                    var maxTitleWidth = (!axisTitleWidth) ? axis.width - (elementSpacing * 2) : axisTitleWidth;
                    while (axisTitleSize.width > maxTitleWidth) {
                        titleText = this.trimText(titleText, titleText.length, "...");
                        axisTitleSize = sf.EjSvgRender.utils._measureText(titleText, (axis.width), axis.title.font);
                        if (titleText == "...") {
                            titleText = "";
                            break;
                        }
                    }
                }
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);

                var y = elementSpacing + _LableMaxWidth.height + titlesize + axis._multiLevelLabelHeight + axis.majorTickLines.size + axis.axisLine.width;

                if ((tickLinesPosition == 'inside' && labelPosition == 'inside') && (axisIndex == 0 || (axis.y == (m_AreaBounds.Height + m_AreaBounds.Y)) || (axis.y == (m_AreaBounds.Y))))
                    y = (axisTitlePosition == "inside") ? elementSpacing + _LableMaxWidth.height + titlesize + axis._multiLevelLabelHeight + axis.majorTickLines.size + axis.axisLine.width : elementSpacing + titlesize + axis.axisLine.width;
                else if ((axisIndex == 0 || (axis.y == (m_AreaBounds.Width + m_AreaBounds.X)) || (axis.y == (m_AreaBounds.X))) && (tickLinesPosition != 'inside' && labelPosition == 'inside'))
                    y = (axisTitlePosition == "inside") ? elementSpacing + _LableMaxWidth.height + titlesize + axis._multiLevelLabelHeight + axis.axisLine.width : elementSpacing + axis.majorTickLines.size + axis.axisLine.width;
                else if ((axisIndex == 0 || (axis.y == (m_AreaBounds.Width + m_AreaBounds.X)) || (axis.y == (m_AreaBounds.X))) && (tickLinesPosition == 'inside' && labelPosition != 'inside'))
                    y = (axisTitlePosition == "inside") ? elementSpacing + titlesize + axis.majorTickLines.size + axis.axisLine.width : elementSpacing + _LableMaxWidth.height + titlesize + axis._multiLevelLabelHeight + axis.axisLine.width;
                else if ((tickLinesPosition != 'inside' && labelPosition != 'inside') || (axisIndex != 1))
                    y = (axisTitlePosition == "inside") ? elementSpacing : elementSpacing + _LableMaxWidth.height + titlesize + axis.majorTickLines.size + axis.axisLine.width + axis._multiLevelLabelHeight;
                else if ((tickLinesPosition != 'inside' && labelPosition == 'inside' && !axis.showNextToAxisLine))
                    y = (axisTitlePosition == "inside") ? elementSpacing + _LableMaxWidth.height + titlesize + axis._multiLevelLabelHeight + axis.axisLine.width : elementSpacing + titlesize + axis.majorTickLines.size + axis.axisLine.width + elementSpacing + elementSpacing;
                if (axisTitleAlignment == "far") {
                    locX = isRTL ? axis.x + axistitleoffset : axis.x + axis.width + axistitleoffset;
                    textAnchor = isRTL ? "start" : "end";
                }
                else if (axisTitleAlignment == "near") {
                    locX = isRTL ? axis.x + axis.width + axistitleoffset : axis.x + axistitleoffset;
                    textAnchor = isRTL ? "end":"start";
                }
                else
                    locX = (axis.x + axis.width / 2) + axistitleoffset;

                commonEventArgs.data = { title: axis.title.text, location: { x: locX, y: y }, axes: axis };
                this._trigger("axesTitleRendering", commonEventArgs);

                if (axisTitlePosition == "inside")
                    newY = ((opposedPosition) ? (tickLinesPosition == "inside" && labelPosition == "outside" ? axis.y + commonEventArgs.data.location.y - (isScroll ? scrollerSize : 0) - axis.majorTickLines.size
                        : (axis.y + commonEventArgs.data.location.y - (isScroll ? scrollerSize : 0)))
                        : (tickLinesPosition == "outside" && labelPosition == "inside" ? (isScroll ? scrollerSize : 0) + (axis.y - commonEventArgs.data.location.y) + axis.majorTickLines.size
                            : (isScroll ? scrollerSize : 0) + (axis.y - commonEventArgs.data.location.y))) + axisTitleSize.height / 3.5;
                else
                    newY = ((opposedPosition) ? (tickLinesPosition == "inside" && labelPosition == "outside" ? axis.y - commonEventArgs.data.location.y - (isScroll ? scrollerSize : 0) - axis.majorTickLines.size
                        : (axis.y - commonEventArgs.data.location.y - (isScroll ? scrollerSize : 0)))
                        : (tickLinesPosition == "outside" && labelPosition == "inside" ? (isScroll ? scrollerSize : 0) + (commonEventArgs.data.location.y + axis.y) - axis.majorTickLines.size
                            : (isScroll ? scrollerSize : 0) + (commonEventArgs.data.location.y + axis.y))) + axisTitleSize.height / 3.5;

                var options = {
                    'id': this.svgObject.id + '_XAxisTitle' + '_' + axisIndex,
                    'x': commonEventArgs.data.location.x,
                    'y': newY,
                    'fill': axis.title.font.color,
                    'font-size': axis.title.font.size,
                    'font-family': axis.title.font.fontFamily,
                    'font-style': axis.title.font.fontStyle,
                    'font-weight': axis.title.font.fontWeight,
                    'opacity': axis.title.font.opacity,
                    'text-anchor': textAnchor
                };
                if (this.model.enableCanvasRendering) {
                    var matched = jQuery.uaMatch(navigator.userAgent);
                    var isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
                    var browser = matched.browser.toLowerCase();
                    if (browser != "msie" && !isIE11)
                        options.y = !opposedPosition ? options.y + (titlesize / 2) + (browser == "mozilla" ? 1 : -2) : options.y + (titlesize / 2) + 1; // text dominant baseline for canvas
                }
                if ($(this.svgObject).find("#" + this.svgObject.id + '_XAxisTitle' + '_' + axisIndex).length > 0)
                    $(this.svgObject).find("#" + this.svgObject.id + '_XAxisTitle' + '_' + axisIndex).attr(options);
                else if (!isEnableTrim)
                    this.svgRenderer.drawText(options, commonEventArgs.data.title, gEle);
                else if (isEnableTrim && (sf.util.isNullOrUndefined(axisTitleWidth) || axisTitleWidth > 0 || isNaN(axisTitleWidth))) {
                    var x = (textAnchor == "middle") ? options.x - (axisTitleSize.width) / 2 : (textAnchor == "end" ? options.x - axisTitleSize.width : options.x);
                    var bounds = { X: x, Y: options.y, Width: axisTitleSize.width, Height: axisTitleSize.height };
                    var xAxisTitleRegion = { Bounds: bounds, trimText: titleText, labelText: axis.title.text };
                    this.model.xAxisTitleRegion.push(xAxisTitleRegion)
                    this.svgRenderer.drawText(options, titleText, gEle);
                }

                if (!this.model.enableCanvasRendering) {
                    var borderY = (textAnchor == "start" ? 0 : (textAnchor == "end" ? axisTitleSize.width : axisTitleSize.width / 2));
                    var borderOptions = {
                        'id': this.svgObject.id + '_XAxisTitleBorder' + '_' + axisIndex,
                        'x': commonEventArgs.data.location.x - borderY - elementSpacing,
                        'y': newY - axisTitleSize.height + (axisTitleSize.height / 4),
                        'width': axisTitleSize.width + (2 * elementSpacing),
                        'height': axisTitleSize.height,
                        'fill': "transparent",
                        'class': "e-xaxistitleborder"
                    };
                    this.svgRenderer.drawRect(borderOptions, gEle);
                }
                $(gEle).appendTo(this.gXaxisEle);
            }
        },
        _drawYTitle: function (axisIndex, yAxis) {

            if (yAxis.title.text != "" && yAxis.title.text && yAxis.title.visible) {
                var opposedPosition = yAxis._opposed,
                    elementSpacing = this.model.elementSpacing,
                    textAnchor = "middle",
                    isTransposed = this.model.series.isTransposed,
                    majorTickLinesize = yAxis.majorTickLines.size,
                    axisTitlePosition = yAxis.title.position.toLowerCase(),
                    _LableMaxWidth = yAxis._LableMaxWidth,
                    m_AreaBounds = this.model.m_AreaBounds, x,
                    axisLine = yAxis.axisLine,
                    tickLinesPosition = yAxis.tickLinesPosition.toLowerCase(),
                    labelPosition = yAxis.labelPosition.toLowerCase(),
                    titleText = yAxis.title.text,
                    isEnableTrim = yAxis.title.enableTrim,
                    requireInvertedAxes = this.model.requireInvertedAxes, y,
                    isScroll = yAxis._isScroll,
                    axisTitleWidth = yAxis.title.maximumTitleWidth,
                    axistitleoffset = yAxis.title.offset,
                    axisTitleAlignment = yAxis.title.alignment.toLowerCase(),
					titleRotation = yAxis.title.titleRotation.toLowerCase(), labelRotation,
                    gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisTitleGroup' + '_' + axisIndex, 'cursor': 'default' });//Group id and text element id should not be same
                var titleSize = sf.EjSvgRender.utils._measureText(yAxis.title.text, (yAxis.height), yAxis.title.font);
                if ((tickLinesPosition == 'inside' && labelPosition == 'inside') && (axisIndex == 1 || (yAxis.x == (m_AreaBounds.Width + m_AreaBounds.X)) || (yAxis.x == (m_AreaBounds.X)))) {
                    if (axisTitlePosition == "inside")
                        x = (opposedPosition) ? (yAxis.x - ((3 * elementSpacing) + _LableMaxWidth.width + yAxis._multiLevelLabelHeight + majorTickLinesize + axisLine.width)) : yAxis.x + ((3 * elementSpacing) + _LableMaxWidth.width + yAxis._multiLevelLabelHeight + majorTickLinesize + axisLine.width);
                    else
                        x = (opposedPosition) ? yAxis.x + ((3 * elementSpacing) + axisLine.width - 5) : yAxis.x - ((3 * elementSpacing) + axisLine.width);
                } else if ((axisIndex == 1 || (yAxis.x == (m_AreaBounds.Width + m_AreaBounds.X)) || (yAxis.x == (m_AreaBounds.X))) && (tickLinesPosition != 'inside' && labelPosition == 'inside')) {
                    if (axisTitlePosition == "inside")
                        x = (opposedPosition) ? (yAxis.x - ((3 * elementSpacing) + _LableMaxWidth.width + yAxis._multiLevelLabelHeight + axisLine.width)) : yAxis.x + ((3 * elementSpacing) + _LableMaxWidth.width + yAxis._multiLevelLabelHeight + axisLine.width);
                    else
                        x = (opposedPosition) ? yAxis.x + ((3 * elementSpacing) + majorTickLinesize + axisLine.width) : yAxis.x - ((3 * elementSpacing) + majorTickLinesize + axisLine.width);
                } else if ((axisIndex == 1 || (yAxis.x == (m_AreaBounds.Width + m_AreaBounds.X)) || (yAxis.x == (m_AreaBounds.X))) && (tickLinesPosition == 'inside' && labelPosition != 'inside')) {
                    if (axisTitlePosition == "inside")
                        x = (opposedPosition) ? (yAxis.x - ((3 * elementSpacing) + majorTickLinesize + axisLine.width)) : yAxis.x + ((3 * elementSpacing) + majorTickLinesize + axisLine.width) +
                            (!yAxis.showNextToAxisLine ? -(elementSpacing) : labelPosition == "inside" ? -yAxis._multiLevelLabelHeight : yAxis._multiLevelLabelHeight);

                    else
                        x = (opposedPosition) ? yAxis.x + ((3 * elementSpacing) + yAxis._multiLevelLabelHeight + _LableMaxWidth.width + axisLine.width) : yAxis.x - ((3 * elementSpacing) + _LableMaxWidth.width + axisLine.width + yAxis._multiLevelLabelHeight);
                } else if ((yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition != 'inside') || (axisIndex != 1)) {
                    if (axisTitlePosition == "inside")
                        x = (opposedPosition) ? (yAxis.x - (elementSpacing + axisLine.width + majorTickLinesize)) : yAxis.x + (elementSpacing + (!yAxis.showNextToAxisLine ? _LableMaxWidth.width : 0) + axisLine.width + majorTickLinesize);
                    else
                        x = (opposedPosition) ? yAxis.x + ((3 * elementSpacing) + yAxis._multiLevelLabelHeight + _LableMaxWidth.width + majorTickLinesize + axisLine.width) : yAxis.x - ((3 * elementSpacing) + _LableMaxWidth.width + yAxis._multiLevelLabelHeight + majorTickLinesize + axisLine.width);
                }
                var axisTitleSize = sf.EjSvgRender.utils._measureText(titleText, (yAxis.height), yAxis.title.font);
                if (isEnableTrim && (sf.util.isNullOrUndefined(axisTitleWidth) || axisTitleWidth > 0 || isNaN(axisTitleWidth))) {
                    var maxTitleWidth = (!axisTitleWidth) ? yAxis.height - (elementSpacing * 2) : axisTitleWidth;
                    while (axisTitleSize.width > maxTitleWidth) {
                        titleText = this.trimText(titleText, titleText.length, "...");
                        axisTitleSize = sf.EjSvgRender.utils._measureText(titleText, (yAxis.height), yAxis.title.font);
                        if (titleText == "...") {
                            titleText = "";
                            break;
                        }

                    }
                }
                x = (yAxis.opposedPosition) ? x : x - (isScroll ? this.model.scrollerSize : 0)
                if (document.documentMode === 8)
                    x = (!opposedPosition) ? (x - axisTitleSize.width / 2 + elementSpacing) : (x + axisTitleSize.width / 2 - elementSpacing);
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = { title: yAxis.title.text, location: { x: titleSize.width / 2, y: 0 }, axes: yAxis };
                this._trigger("axesTitleRendering", commonEventArgs);
                y = commonEventArgs.data.location.y + (yAxis.y + yAxis.height) + (((yAxis.height) / 2) * -1);

                if (axisTitleAlignment == "near") {
                    y = (yAxis.y + yAxis.height) - axistitleoffset;
                    textAnchor = opposedPosition || isTransposed ? "end" : "start";
                }
                else if (axisTitleAlignment == "far") {
                    y = yAxis.y - axistitleoffset;
                    textAnchor = opposedPosition || isTransposed ? "start" : "end";
                }
                else if (axisTitleAlignment == "center")
                    y = yAxis.y + (yAxis.height / 2) - axistitleoffset;
                if(titleRotation == "none")  
					labelRotation = (opposedPosition) ? 90 : -90;
				else
					labelRotation = titleRotation == 'rotateminus90' ? -90 : 90;

                var options = {
                    'id': this.svgObject.id + '_YAxisTitle' + '_' + axisIndex,
                    'x': x,
                    'y': y,
                    'fill': yAxis.title.font.color,
                    'labelRotation': labelRotation,
                    'transform': 'rotate(' + labelRotation + ',' + (x) + ',' + y + ')',
                    'font-size': yAxis.title.font.size,
                    'font-family': yAxis.title.font.fontFamily,
                    'font-style': yAxis.title.font.fontStyle,
                    'font-weight': yAxis.title.font.fontWeight,
                    'opacity': yAxis.title.font.opacity,
                    'text-anchor': textAnchor,
                    'dominant-baseline': 'middle'
                };
                if (this.model.enableCanvasRendering) {
                    var matched = jQuery.uaMatch(navigator.userAgent);
                    var isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
                    var browser = matched.browser.toLowerCase();
                    if (browser != "msie" && !isIE11)
                        options.x = !opposedPosition ? options.x + (titleSize.height / 4) + (browser == "mozilla" ? 1 : -2) : options.x - (titleSize.height / 4) + 1; // text dominant baseline for canvas
                }
                if ($(this.svgObject).find("#" + this.svgObject.id + '_YAxisTitle' + '_' + axisIndex).length > 0)
                    $(this.svgObject).find("#" + this.svgObject.id + '_YAxisTitle' + '_' + axisIndex).attr(options);
                else if (!isEnableTrim)
                    this.svgRenderer.drawText(options, commonEventArgs.data.title, gEle);
                else if (isEnableTrim && (sf.util.isNullOrUndefined(axisTitleWidth) || axisTitleWidth > 0 || isNaN(axisTitleWidth))) {
                    if (!this.svgRenderer.vmlNamespace)
                        var bounds = { X: options.x - (axisTitleSize.height / 2), Y: options.y + (axisTitleSize.width / 2), Width: (axisTitleSize.height) / 2, Height: axisTitleSize.width };
                    else
                        var bounds = { X: options.x - (axisTitleSize.width) / 2, Y: options.y + (axisTitleSize.height / 2), Width: (axisTitleSize.width), Height: axisTitleSize.height };
                    var yAxisTitleRegion = { Bounds: bounds, trimText: titleText, labelText: yAxis.title.text };
                    this.model.yAxisTitleRegion.push(yAxisTitleRegion)
                    this.svgRenderer.drawText(options, titleText, gEle);
                }

                if (!this.model.enableCanvasRendering) {
                    var borderY = (textAnchor == "start" ? (axisTitleSize.width) : (textAnchor == "end" ? 0 : axisTitleSize.width / 2));
                    var borderOptions = {
                        'id': this.svgObject.id + '_YAxisTitleBorder' + '_' + axisIndex,
                        'x': options.x - axisTitleSize.height + (axisTitleSize.height / 2),
                        'y': options.y - borderY - elementSpacing,
                        'width': axisTitleSize.height,
                        'height': axisTitleSize.width + (2 * elementSpacing),
                        'fill': "transparent",
                        'class': "e-yaxistitleborder"
                    };
                    this.svgRenderer.drawRect(borderOptions, gEle);
                }
                $(gEle).appendTo(this.gYaxisEle);
            }
        },
        _drawXAxisRect: function (axisIndex, xAxis, axis) {
            if (this.model.primaryXAxis.backGround != 'transparent' && xAxis.visible && xAxis.axisLine.visible) {
            var chartBorder = this.model.border;
            axisTitleSize = sf.EjSvgRender.utils._measureText(axis.title.text, (axis.width), axis.title.font);
            titlesize = axisTitleSize.height / 2;
            opposedPosition = axis._opposed;
            _LableMaxWidth = axis._LableMaxWidth;
            elementSpacing = this.model.elementSpacing;
            isScroll = (axis._isScroll || (this.model.zooming.enableScrollbar && axis.scrollbarSettings.visible && (axis.zoomFactor < 1 || axis.zoomPosition > 0)));
            tickLinesPosition = axis.tickLinesPosition.toLowerCase();
            labelPosition = axis.labelPosition.toLowerCase();
            axistitleoffset = axis.title.offset;
            scrollerSize = this.model.scrollerSize;
            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            var y = elementSpacing + _LableMaxWidth.height + titlesize + axis._multiLevelLabelHeight + axis.majorTickLines.size + axis.axisLine.width;
            var locX = (axis.x + axis.width / 2) + axistitleoffset;
            commonEventArgs.data = { title: axis.title.text, location: { x: locX, y: y }, axes: axis };
            this._trigger("axesTitleRendering", commonEventArgs);
            var newY = ((opposedPosition) ? (tickLinesPosition == "inside" && labelPosition == "outside" ? axis.y - commonEventArgs.data.location.y - (isScroll ? scrollerSize : 0) - axis.majorTickLines.size
                : (axis.y - commonEventArgs.data.location.y - (isScroll ? scrollerSize : 0)))
                : (tickLinesPosition == "outside" && labelPosition == "inside" ? (isScroll ? scrollerSize : 0) + (commonEventArgs.data.location.y + axis.y) - axis.majorTickLines.size
                : (isScroll ? scrollerSize : 0) + (commonEventArgs.data.location.y + axis.y))) + axisTitleSize.height / 3.5;
            x1 = Math.floor(xAxis.x);
            x2 = Math.floor(xAxis.x + xAxis.width);
            y1 = Math.floor(xAxis.y);
            y2 = Math.floor(xAxis.y);
            var offset = xAxis.axisLine.offset > 0 ? xAxis.axisLine.offset : 0;
            var val = this._getSharpPath(xAxis.axisLine.width);
            var options = {
                'id': this.svgObject.id + '_XAxisRect_' + axisIndex,
                'x': ((x1 - xAxis.plotOffset) + val + offset) - 15,
                'y': y1 + val,
                'width': ((x2 + xAxis.plotOffset) - offset + val) - ((x1 - xAxis.plotOffset) + val + offset) + 30,
                'height': newY,
                'fill': this.model.primaryXAxis.backGround,
                'class': "e-XAxisarea"
            };
                this.svgRenderer.drawRect(options, this.gXaxisEle);
            }
        },
        _drawYAxisRect: function (axisIndex, yAxis) {
            if (this.model.primaryYAxis.backGround != 'transparent' && yAxis.visible && yAxis.axisLine.visible) {
            var chartBorder = this.model.border;
            var y1 = Math.floor(yAxis.y + yAxis.height);
            var y2 = Math.floor(yAxis.y);
            var opposedPosition = yAxis._opposed;
            if (axisIndex != 1  && (yAxis.labelPosition != 'inside' && yAxis.tickLinesPosition == 'inside') && (!(yAxis.x == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) || (yAxis.x == (this.model.m_AreaBounds.X))))) {
                var x1 = (!opposedPosition) ? Math.floor(yAxis.x - yAxis.majorTickLines.size) : Math.floor(yAxis.x + yAxis.majorTickLines.size);
                var x2 = (!opposedPosition) ? Math.floor(yAxis.x - yAxis.majorTickLines.size) : Math.floor(yAxis.x + yAxis.majorTickLines.size);
            }
            else {
                var x1 = Math.floor(yAxis.x);
                var x2 = Math.floor(yAxis.x);
            }
            var offset = yAxis.axisLine.offset > 0 ? yAxis.axisLine.offset : 0;
            var val = this._getSharpPath(yAxis.axisLine.width);
            var options = {
                'id': this.svgObject.id + '_YAxisRect_' + axisIndex,
                'x': 0,
                'y': ((y2 - yAxis.plotOffset) + offset + val) - 7,
                'width': (($(this.svgObject).width() - (2 * chartBorder.width)) + this.model.m_AreaBounds.X) - ($(this.svgObject).width() - (2 * chartBorder.width)),
                'height': ((y1 + yAxis.plotOffset) - offset + val) - ((y2 - yAxis.plotOffset) + offset + val) + 14,
                'fill': this.model.primaryYAxis.backGround,
                'class': "e-YAxisarea"
            };
                this.svgRenderer.drawRect(options, this.gYaxisEle);
            }
        }
    },
        sf.EjStripline.prototype = {
        _drawStripline: function (axis, stripLine, axisIndex, stripLineIndex) {
            var valueType = !sf.util.isNullOrUndefined(axis.valueType) ? axis.valueType.toLowerCase() : axis._valueType.toLowerCase();
            if (typeof stripLine.start == "string" && typeof stripLine.end == "string") {
                stripLine.start = stripLine.start.indexOf("/Date(") != -1 ? new Date(parseInt(stripLine.start.substr(6))) : stripLine.start;
                stripLine.end = stripLine.end.indexOf("/Date(") != -1 ? new Date(parseInt(stripLine.end.substr(6))) : stripLine.end;
            }
            var start, end;
            if (valueType == 'datetimecategory') {
                start = (stripLine.start != null && typeof stripLine.start !== 'number') ? axis.labels.indexOf((stripLine.start).getTime()) : stripLine.start;
                end = (stripLine.end != null && typeof stripLine.end !== 'number') ? axis.labels.indexOf((stripLine.end).getTime()) : stripLine.end;
            }
            else {
                start = (stripLine.start < axis.visibleRange.min) ? axis.visibleRange.min : stripLine.start;
                end = (stripLine.end > axis.visibleRange.max) ? axis.visibleRange.max : stripLine.end;
            }
            var x = 0, height = 0, angle = 0,
                isRepeat = stripLine.isRepeat,
                repeatEvery = stripLine.repeatEvery,
                repeatUntil = stripLine.repeatUntil,
				stripBorderWidth = stripLine.borderWidth,
                stripWidth = stripLine.width, stripValues;

            var y = 0, pointYstart = 0, yHeight = 0;
            var width = 0, widthValue = 0, textX = 0, textY = 0;
            if (stripLine.visible) {
                this.model._stripeline = true;
                var startFromAxis = stripLine.startFromAxis;
                var striplineid = (stripLine.zIndex == 'over') ? this.gStriplineOver : this.gStriplineBehind;
                striplineid = sf.util.isNullOrUndefined(striplineid) ? "" : striplineid;
                var isVisible = true;
                var count = 0;
                if (axis.orientation.toLowerCase() == "horizontal") {
                    var pointstart = 0, angle = -90;
                    if ((sf.util.isNullOrUndefined(start)) && (sf.util.isNullOrUndefined(end) || sf.util.isNullOrUndefined(stripWidth))) {
                        isVisible = false;
                    } else {
                        start = (startFromAxis ? ((sf.util.isNullOrUndefined(stripLine.offset)) ? axis.visibleRange.min : axis.visibleRange.min + stripLine.offset) : ((jQuery.type(start) == "date") ? (start).getTime() : start));
                        if (!sf.util.isNullOrUndefined(end) && (jQuery.type(end) == "date")) {
                            end = (end).getTime();
                        }
                        if (isRepeat && !sf.util.isNullOrUndefined(repeatEvery) && (stripWidth || stripBorderWidth)) {
                            var limit = (!sf.util.isNullOrUndefined(repeatUntil) ? (axis._valueType == 'datetime' ? repeatUntil.getTime() : repeatUntil) : (end ? end : axis.visibleRange.max));
                            while (start < limit) {
                                end = ((axis._valueType === 'datetime' ? this._getDatetimeValue(end, start, stripWidth, axis, (stripWidth ? null : end), stripLine, valueType) : start + stripWidth));
                                stripValues = this._getHorizontalValue(start, end, axis, stripWidth, stripLine, startFromAxis, valueType);
                                if (isVisible)
                                    this._drawAxisStriplines(stripValues.x, stripValues.y, stripValues.height, stripValues.width, stripValues.textX, stripValues.textY, angle, axisIndex, count, stripLineIndex, striplineid, stripLine, axis);
                                count++;
                                start = (axis._valueType === 'datetime' ? this._getDatetimeValue(end, start, repeatEvery, axis, null, stripLine, valueType) : start + repeatEvery);
                            }
                        }
                        else {
                            stripValues = this._getHorizontalValue(start, end, axis, stripWidth, stripLine, startFromAxis, valueType);
                            if (isVisible)
                                this._drawAxisStriplines(stripValues.x, stripValues.y, stripValues.height, stripValues.width, stripValues.textX, stripValues.textY, angle, axisIndex, count, stripLineIndex, striplineid, stripLine, axis);
                        }
                    }
                } else {
                    if (sf.util.isNullOrUndefined(start) && (sf.util.isNullOrUndefined(end) || sf.util.isNullOrUndefined(stripWidth))) {
                        isVisible = false;
                    } else {
                        start = startFromAxis ? ((sf.util.isNullOrUndefined(stripLine.offset)) ? axis.visibleRange.min : axis.visibleRange.min + stripLine.offset) : ((jQuery.type(start) == "date") ? (start).getTime() : start);
                        if (!sf.util.isNullOrUndefined(end) && (jQuery.type(end) == "date")) {
                            end = (end).getTime();
                        }
                        if (isRepeat && !sf.util.isNullOrUndefined(repeatEvery) && (stripWidth || stripBorderWidth)) {
                            var limit = (!sf.util.isNullOrUndefined(repeatUntil) ? repeatUntil : (end ? end : axis.visibleRange.max));
                            while (start < limit) {
                                end = start + stripWidth;
                                stripValues = this._getVerticalValue(start, end, axis, stripWidth, stripLine, startFromAxis);
                                if (isVisible)
                                    this._drawAxisStriplines(stripValues.x, stripValues.y, stripValues.height, stripValues.width, stripValues.textX, stripValues.textY, angle, axisIndex, count, stripLineIndex, striplineid, stripLine, axis);
                                count++;
                                start = start + repeatEvery;
                            }
                        }
                        else {
                            stripValues = this._getVerticalValue(start, end, axis, stripWidth, stripLine, startFromAxis);
                            if (isVisible)
                                this._drawAxisStriplines(stripValues.x, stripValues.y, stripValues.height, stripValues.width, stripValues.textX, stripValues.textY, angle, axisIndex, count, stripLineIndex, striplineid, stripLine, axis);
                        }
                    }
                }
            }
        },
        _getHorizontalValue: function (start, end, axis, stripWidth, stripLine, startFromAxis, valueType) {
            var pointstart = ((startFromAxis ? ((start - axis.visibleRange.min) / (axis.visibleRange.delta)) : sf.EjSvgRender.utils._getPointXY(start, axis.visibleRange, axis.isInversed)) * (axis.width)) + axis.x;
            var pointend = (sf.EjSvgRender.utils._getPointXY(end, axis.visibleRange, axis.isInversed) * (axis.width)) + axis.x;
            var widthMax = (sf.EjSvgRender.utils._getPointXY((valueType === 'datetime' ? this._getDatetimeValue(end, start, stripWidth, axis, (stripWidth ? null : end), stripLine, valueType): (start + (sf.util.isNullOrUndefined(stripLine.width) ? 0 : stripLine.width))), axis.visibleRange, axis.isInversed) * (axis.width)) + axis.x;     
            var widthValue = (axis.isInversed ? (pointend < widthMax) : (pointend > widthMax)) ? Math.abs(pointstart - pointend) : Math.abs(pointstart - widthMax);
            return this._calculateHorizontalStripline(widthValue, pointstart, axis, stripLine);;
        },
        _getVerticalValue: function (start, end, axis, stripWidth, stripLine, startFromAxis) {
            var pointYstart = (axis.y + axis.height) - ((startFromAxis ? ((start - axis.visibleRange.min) / (axis.visibleRange.delta)) : sf.EjSvgRender.utils._getPointXY(start, axis.visibleRange, axis.isInversed)) * (axis.height));
            var pointYend = (axis.y + axis.height) - (sf.EjSvgRender.utils._getPointXY((sf.util.isNullOrUndefined(end) ? 0 : end), axis.visibleRange, axis.isInversed) * (axis.height));
            var widthYValue = (axis.y + axis.height) - (sf.EjSvgRender.utils._getPointXY((start + (sf.util.isNullOrUndefined(stripWidth) ? 0 : stripWidth)), axis.visibleRange, axis.isInversed) * (axis.height));
            var yHeight = (axis.isInversed ? (pointYend > widthYValue) : (pointYend < widthYValue)) ? Math.abs(pointYstart - pointYend) : Math.abs(pointYstart - widthYValue);
            return this._calculateVerticalStripline(yHeight, pointYstart, axis, stripLine);
        },
        _calculateHorizontalStripline: function (widthValue, pointstart, axis, stripLine) {
            var borderWidth = stripLine.borderWidth,
				height = this.chart.model.m_AreaBounds.Height,
                width = widthValue ? widthValue :(borderWidth ? borderWidth : 0),
                x = (axis.isInversed) ? (pointstart - widthValue) : pointstart,
                y = this.chart.model.m_AreaBounds.Y,
                textWidth = sf.EjSvgRender.utils._measureText(stripLine.text, null, stripLine.font).height;
            if (stripLine.textAlignment == 'middletop') {
                textX = x + textWidth;
                textY = Math.abs(y + height / 2);
            } else if (stripLine.textAlignment == 'middlecenter') {
                textX = (Math.floor(x + width / 2) + (textWidth / 3));
                textY = Math.abs(y + height / 2);
            } else if (stripLine.textAlignment == 'middlebottom') {
                textX = x + width - (textWidth);
                textY = Math.abs(y + height / 2);
            }
            return { x: x, y: y, height: height, width: width, textX: textX, textY: textY };
        },
        _calculateVerticalStripline: function (yHeight, pointYstart, axis, stripLine) {
            var height = yHeight,
                x = this.chart.model.m_AreaBounds.X,
                width = this.chart.model.m_AreaBounds.Width,
                y = pointYstart + ((axis.isInversed) ? 0 : -yHeight),
                textHeight = sf.EjSvgRender.utils._measureText(stripLine.text, width, stripLine.font).height,
                textX, textY;
            if (stripLine.textAlignment == 'middletop') {
                textX = x + width / 2;
                textY = y + textHeight;
            } else if (stripLine.textAlignment == 'middlecenter') {
                textX = x + width / 2;
                textY = (Math.abs(y + (height / 2)) + (textHeight / 3));
            } else if (stripLine.textAlignment == 'middlebottom') {
                textX = x + width / 2;
                textY = (y + height) - textHeight;
            }
            return { x: x, y: y, height: height, width: width, textX: textX, textY: textY };
        },
        _getDatetimeValue: function (to, from, size, axis, end, stripline, valueType) {
            var sizeType = stripline.sizeType.toLowerCase();
            var isEnd = (end === null);
            if (valueType === 'datetime') {
                var fromValue = new Date(from);
                if (sizeType === 'auto')
                    sizeType = axis._intervalType.toLowerCase();                
                switch (sizeType) {
                    case 'years':
                        return (isEnd ? new Date(fromValue.setFullYear(fromValue.getFullYear() + size)) : to);
                    case 'months':
                        return (isEnd ? new Date(fromValue.setMonth(fromValue.getMonth() + size)) : to);
                    case 'days':
                        return (isEnd ? new Date(fromValue.setDate(fromValue.getDate() + size)) : to);
                    case 'hours':
                        return (isEnd ? new Date(fromValue.setHours(fromValue.getHours() + size)) : to);
                    case 'minutes':
                        return (isEnd ? new Date(fromValue.setMinutes(fromValue.getMinutes() + size)) : to);
                    case 'seconds':
                        return (isEnd ? new Date(fromValue.setSeconds(fromValue.getSeconds() + size)) : to);
                    default:
                        return from;
                }
            }
            else {
                return stripline.sizeType === 'pixel' ? from : (isEnd ? (from + size) : to);
            }
        },
        _drawAxisStriplines: function (x, y, height, width, textX, textY, angle, axisIndex, count, stripLineIndex, striplineid, stripLine, axis) {
            if (!sf.util.isNullOrUndefined(stripLine.imageUrl)) {
                var imgOptions = {
                    'height': height,
                    'width': width,
                    'href': stripLine.imageUrl,
                    'x': x,
                    'y': y,
                    'id': striplineid.id + '_backImage',
                    'visibility': 'visible',
                    'preserveAspectRatio': 'none'
                };

                this.svgRenderer.drawImage(imgOptions, striplineid);
            } else {
                var options = {
                    'id': striplineid.id + '_striplineRect_' + axisIndex + '_' + stripLineIndex + '_' + count,
                    'x': x,
                    'y': y,
                    'width': width,
                    'height': height,
                    'fill': stripLine.color,
                    'opacity': stripLine.opacity,
                    'stroke-width': stripLine.borderWidth,
                    'stroke': (stripLine.borderWidth == 0) ? "transparent" : stripLine.borderColor
                };
                var textOptions = {
                    'id': striplineid.id + '_striplineRectText_' + axisIndex + '_' + stripLineIndex + '_' + count,
                    'x': textX,
                    'y': textY,
                    'fill': stripLine.font.color,
                    'transform': 'rotate(' + angle + ',' + (textX) + ',' + textY + ')',
                    'labelRotation': angle,
                    'font-size': stripLine.font.size,
                    'font-family': stripLine.font.fontFamily,
                    'font-style': stripLine.font.fontStyle,
                    'font-weight': stripLine.font.fontWeight,
                    'opacity': stripLine.font.opacity,
                    'text-anchor': 'middle'
                };

                var bounds = { X: x, Y: y, Width: width, Height: height };
                var isStripline = stripLine.zIndex == "over" ? true : false;
                sf.EjSvgRender.utils.AddRegion(this.chart, bounds, isStripline)

                if (this.chart.model.enableCanvasRendering) {
                    var ctx = this.chart.svgObject.getContext("2d");
                    var clipBounds = axis.orientation.toLowerCase() == 'horizontal' ? { X: axis.x, Y: y, Width: axis.width, Height: this.chart.model.m_AreaBounds.Height }
                        : { X: x, Y: axis.y, Width: this.chart.model.m_AreaBounds.Width, Height: axis.height };
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(clipBounds.X, clipBounds.Y, clipBounds.Width, clipBounds.Height);
                    ctx.clip();
                    this.svgRenderer.drawRect(options, striplineid);
                    this.svgRenderer.drawText(textOptions, stripLine.text, striplineid);
                    ctx.closePath();
                    ctx.restore();
                }
                else {
                    this.svgRenderer.drawRect(options, striplineid);
                    this.svgRenderer.drawText(textOptions, stripLine.text, striplineid);
                }
            }
        }
        };
})(jQuery);
/* global jQuery, navigator, sf */
sf.EjLegendRender = function (chartobj) {

    this.chartObj = chartobj;
};


(function ($) {
    sf.EjLegendRender.prototype =
        {
            sumofArray: function (array) {
                var sum = 0,
                    length = array.length;
                for (var i = 0; i < length; i++)
                    sum += array[i];
                return sum;
            },

            legendRectSpace: function (svgBounds, divBounds) {
                var width = svgBounds.Width - 10;
                var height = svgBounds.Height - 10;
                var isVisible = false;
                if (Math.ceil(divBounds.Width) >= width && Math.ceil(divBounds.Height) >= height)
                    isVisible = true;
                return isVisible;
            },

            drawLegendTitle: function () {
                //draw legend title

                var chart = this.chartObj,
                    chartModel = chart.model,
                    legend = chartModel.legend,
                    isRTL = legend.isReversed,
                    legendBounds = chartModel.LegendBounds,
                    elementSpacing = chartModel.elementSpacing,
                    legendTitle = legend.title,
                    measureText = sf.EjSvgRender.utils._measureText,
                    font = legendTitle.font,
                    legendBoundsWidth = legendBounds.Width,
                    titleSize = measureText(legendTitle.text, null, font),
                    titleWidth = titleSize.width,
                    titleHeight = titleSize.height,
                    textAlignment = legendTitle.textAlignment.toLowerCase(),
                    startX = 0,
                    startY = elementSpacing + (titleHeight / 2);

                switch (textAlignment) {
                    case 'far':
                        startX = isRTL ? startX : legendBoundsWidth - titleWidth - startX;
                        break;
                    case 'center':
                        startX = legendBoundsWidth / 2 - (titleWidth) / 2;
                        break;
                }

                if (startX < 0) {
                    startX = 0;
                    legendBoundsWidth = titleWidth;
                }
                if (legendBoundsWidth < titleWidth + startX)
                    legendBoundsWidth = titleWidth + startX;

                var options = {
                    'id': chart.svgObject.id + '_LegendTitleText',
                    'x': isRTL && textAlignment == "near" ? legendBoundsWidth - titleWidth - startX : startX,
                    'y': startY,
                    'fill': font.color,
                    'font-size': font.size,
                    'font-style': font.fontStyle,
                    'font-family': font.fontFamily,
                    'font-weight': font.fontWeight,
                    'text-anchor': 'start',
                    'direction': 'ltr',
                    'lgndCtx': true
                };

                chart.svgRenderer.drawText(options, legendTitle.text, this.chartObj.gLegendEle);

            },

            drawLegendItem: function (legendItem, x, y) {
                var chart = this.chartObj,
                    chartModel = chart.model,
                    legend = chartModel.legend,
                    isRTL = legend.isReversed,
                    textOverflow = legend.textOverflow.toLowerCase(),
                    textMaxWidth = legend.textWidth,
                    legendBounds = chartModel.LegendBounds,
                    elementSpacing = chartModel.elementSpacing,
                    legendBorder = legend.border.width,
                    measureText = sf.EjSvgRender.utils._measureText,
                    svgRender = sf.EjSvgRender,
                    chartSvgRender = chart.svgRenderer,
                    legendFont = legendItem.Font,
                    symbolShape = chartModel.symbolShape,
                    isCanvas = chartModel.enableCanvasRendering,
                    shapeSize = legend.itemStyle,
                    pointIndex = legendItem.PointIndex,
                    seriesIndex = legendItem.SeriesIndex,
                    index = pointIndex ? pointIndex : seriesIndex,
                    series = chartModel.series[seriesIndex],
                    svgObject = chart.svgObject,
                    legendStyle = legendItem.LegendStyle,
                    matched = jQuery.uaMatch(navigator.userAgent),
                    isIE11 = !!navigator.userAgent.match(/Trident\/7\./),
                    color, itemInfo, data, style, startLocation, name,
                    seriesType = series.type.toLowerCase(),
                    drawType = series.drawType,
                    symbolName, symbol, textinfo, legendTextRegion, textLength, textHeight, textWidth, location;
                textHeight = measureText(legendItem.Text, legendBounds.Width, legendFont).height;
                if(typeof legendItem.Text == "object" && isRTL){
                    var w = 0, legText, legWidth, maxLegWidth, largestLabel;
                    for (var r = 0; r < legendItem.Text.length; r++) {
                        legText = legendItem.Text[r];
                        legWidth = sf.EjSvgRender.utils._measureText(legText, legendBounds.Width, legendFont).width;
                        if (w < legWidth) {
                            w = legWidth;
                            largestLabel = legText;
                        }
                    }
                    textWidth = measureText(largestLabel, null, legendFont).width;
                }
                else
                    textWidth = measureText(legendItem.Text, null, legendFont).width;
                location = {
                    startX: isRTL ? textWidth + x + elementSpacing : x + shapeSize.width / 2,
                    startY: (y + (textHeight > shapeSize.height ? textHeight : shapeSize.height) / 2)
                };

                for (name in symbolShape) {
                    if (legendItem.Shape.toLowerCase() == name.toLowerCase()) {
                        if (name.toLowerCase() == "seriestype")
                            symbolName = "SeriesType";
                        else
                            symbolName = name;
                        break;
                    }
                }

                if (symbolName == "SeriesType") {
                    if (seriesType == "radar" || seriesType == "polar") {
                        symbol = drawType.toLowerCase() == "scatter" ? series.marker.shape : symbol = drawType;
                        symbolName = (symbol.toLowerCase() == "rangecolumn") ? "RangeColumn" : symbol.capitalizeFirstString();
                    }
                    if (seriesType == "scatter") {
                        symbol = series.marker.shape;
                        symbolName = symbol.capitalizeFirstString();
                    }
                    if (legendItem.drawType)// // TrendLine drawType assigned to legend shape
                        symbolName = "SeriesType";
                    if (chart.vmlRendering && (seriesType == "pie" || seriesType == "doughnut" || seriesType == "pieofpie"))
                        symbolName = "Circle";          // VML legend shape for pie & doughnut
                }

                if (symbolName == "None") {
                    if (seriesType == "pie" || seriesType == "doughnut" || seriesType == "pieofpie")
                        symbolName = "Circle";
                    else
                        symbolName = "Rectangle";
                }

                index = (sf.util.isNullOrUndefined(pointIndex)) ? seriesIndex : pointIndex;
                chart.gLegendItemEle = chartSvgRender.createGroup({ 'id': svgObject.id + '_Legend' + index, 'cursor': 'pointer' });
                legendItem.CommonEventArgs.data.gLegendItemEle = chart.gLegendItemEle;
                data = $.extend(true, {}, legendItem.CommonEventArgs.data);
                data.model = chart.model;
                style = data.style;
                if (!legendItem.CommonEventArgs.cancel) {
                    startLocation = svgRender.chartSymbol["_draw" + symbolName](location, style, data, chart.gLegendItemEle);
                    if (legendStyle.Color && legendStyle.Color.toString().toLowerCase() !== 'gray' && isCanvas) // for canvas gradient color
                        color = legendFont.color;
                    else if (legendStyle.Color && legendStyle.Color.toLowerCase() !== 'gray') // for svg
                        color = legendFont.color;
                    else
                        color = 'gray';

                    itemInfo = legendItem;
                    textLength = itemInfo.Text.length;
                    if (legend.shape == "seriestype" || legend.shape == "seriesType")
                        x = isRTL ? x - elementSpacing / 2 : x + elementSpacing / 2;
                    var options = {
                        'id': this.chartObj.svgObject.id + '_LegendItemText' + index,
                        'x': isRTL ? x : shapeSize.width + x + elementSpacing / 2,
                        'y': location.startY,
                        'fill': color,
                        'font-size': legendFont.size,
                        'font-style': legendFont.fontStyle,
                        'font-family': legendFont.fontFamily,
                        'font-weight': legendFont.fontWeight,
                        'text-anchor': 'start',
                        'direction': 'ltr',

                    };
                    if (isCanvas)
                        options.lgndCtx = true;
                    options.y = (location.startY + (textHeight / 4));

                    if (textOverflow == "wrap" || textOverflow == "wrapandtrim") {
                        options.y = options.y - textHeight;
                        for (var k = 0; k < textLength; k++) {
                            options.y = options.y + (textHeight);
                            chartSvgRender.drawText(options, itemInfo.Text[k], chart.gLegendItemEle);
                            if (textOverflow == "wrapandtrim") {
                                textinfo = { x: options.x + legendBounds.X, y: options.y + legendBounds.Y, height: textHeight * (textLength), width: textMaxWidth };
                                legendTextRegion = { bounds: textinfo, trimText: itemInfo.Text, labelText: itemInfo.displayText };
                                chartModel.legendTextRegion.push(legendTextRegion);
                            }
                        }
                    }
                    else {
                        if (textOverflow == "trim") {
                            textinfo = { x: options.x + legendBounds.X, y: options.y + legendBounds.Y, height: textHeight + elementSpacing, width: textMaxWidth };
                            legendTextRegion = { bounds: textinfo, trimText: itemInfo.Text, labelText: itemInfo.displayText };
                            chartModel.legendTextRegion.push(legendTextRegion);
                        }
                        chartSvgRender.drawText(options, itemInfo.Text, chart.gLegendItemEle);
                    }
                    chartSvgRender.append(chart.gLegendItemEle, chart.gLegendEle);
                    var legendbound = {
                        X: legendBounds.X + legendBorder,
                        Y: legendBounds.Y + legendBorder
                    };

                    x = (startLocation) ? isRTL ? location.startX - textWidth - elementSpacing : startLocation : x;
                    var itembound = {
                        X: (x), Y: (y), _Width: legendItem.Bounds._Width, Width: legendItem.Bounds.Width, Height: legendItem.Bounds.Height
                    };
                    var bounds = { LegendBound: legendbound, ItemBound: itembound };
                    location.startX = isRTL ? Math.abs(location.startX - textWidth - (elementSpacing / 2) ): location.startX;
                    var legendRegion = {
                        LegendItem: legendItem,
                        Location: location, SymbolShape: symbolName, Style: legendItem.CommonEventArgs.data.style, Bounds: bounds
                    };
                    chartModel.legendRegion.push(legendRegion);
                }
            },

            drawLegend: function (params) {
                var chart = this.chartObj,
                    chartModel = chart.model,
                    legend = chartModel.legend,
                    isRTL = legend.isReversed,
                    legendViewerBounds = chartModel.LegendViewerBounds,
                    legendBounds = chartModel.LegendBounds,
                    actualBounds = chartModel.LegendActualBounds,
                    AreaType = chartModel.AreaType,
                    legendPosition = legend.position.toLowerCase(),
                    alignment = legend.alignment.toLowerCase(),
                    elementSpacing = chartModel.elementSpacing,
                    svgObjectWidth = chartModel.svgWidth,
                    svgObjectHeight = chartModel.svgHeight,
                    title = chartModel.title,
                    titleFontHeight = title.font.size,
                    subTitle = title.subTitle,
                    subTitleFontHeight = title.subTitle.font.size,
                    legendTitle = legend.title,
                    legendBorder = legend.border.width,
                    measureText = sf.EjSvgRender.utils._measureText,
                    margin = chartModel.margin,
                    borderSize = chartModel.border.width,
                    legendCollection = chartModel.legendCollection,
                    collectionLength = legendCollection.length,
                    svgWidth = svgObjectWidth - ((borderSize * 2)),
                    svgHeight = svgObjectHeight - ((borderSize * 2)),
                    itemPadding = legend.itemPadding > 0 ? legend.itemPadding : 0,
                    padding = 20,
                    hPadding = 10,
                    vPadding = 10,
                    modelsubTitleHeight = subTitle.text == "" || !subTitle.visible || !title.visible ? 0 : measureText(subTitle.text, svgWidth - margin.left - margin.right, subTitle.font).height + elementSpacing,
                    titleLocation = chartModel._titleLocation ? chartModel._titleLocation.Y : 0 + modelsubTitleHeight,
                    legendTitleBounds = measureText(legendTitle.text, null, legendTitle.font),
                    legendTitleHeight = legendTitleBounds.height,
                    legendTitleWidth = legendTitleBounds.width,
                    rowDefinitions = chartModel._rowDefinitions,
                    maxWidth = 0, startX, startY, currentX, currentY, vScrollSize, hScrollSize,
                    columnDefinitions = chartModel._columnDefinitions,
                    vSizeFar = this.sumofArray(rowDefinitions.farSizes),
                    vSizeNear = this.sumofArray(rowDefinitions.nearSizes),
                    hSizeFar = this.sumofArray(columnDefinitions.farSizes),
                    hSizeNear = this.sumofArray(columnDefinitions.nearSizes),
                    isScrolling = false,
                    areaBounds = chartModel.m_AreaBounds,
                    isScroll = legend.enableScrollbar,
                    legendContainer = $(chart.legendContainer),
                    leftScroll = $("#ScrollerParent_" + 'vertical' + "_" + chart._id).length > 0 ? 18 : 0,
                    bottomScroll = $("#ScrollerParent_" + 'horizontal' + "_" + chart._id).length > 0 ? 18 : 0,
                    legendSvgContainer = $(chart.legendSvgContainer);
                var textBorderConstant = 1.2,
                    titleBorderSpacing = 10,
                    subTitleBorderSpacing = 10,
                    title = chartModel.title,
                    subTitle = chartModel.title.subTitle,
                    titleTextHeight = title.visible ? parseInt(titleFontHeight) * textBorderConstant : 0,
                    subTitleTextHeight = subTitle.visible ? parseInt(subTitleFontHeight) * textBorderConstant : 0,
                    titleTextHeight = (chartModel.titleWrapTextCollection && chartModel.titleWrapTextCollection.length > 1) ? chartModel._titleLocation._height * chartModel.titleWrapTextCollection.length - 1 : titleTextHeight,
                    subTitleTextHeight = (chartModel.subTitleWrapTextCollection && chartModel.subTitleWrapTextCollection.length > 1) ? chartModel._subTitleLocation.size.height : subTitleTextHeight;
                if ((chartModel.legend.border) && (!subTitle.text)) {
                    subTitleTextHeight = 0;
                    subTitleBorderSpacing = 5;
                }

                if (legendPosition == 'right' || legendPosition == 'left') {
                    hPadding = 10;
                } else {
                    vPadding = isScroll ? svgHeight > 200 ? 10 : svgHeight > 100 ? 5 : 0 : 10;
                }
                legendViewerBounds.Height += legendTitleHeight,
                    legendBounds.Height += legendTitleHeight;
                if (legend.visible) {
                    // draw legend.
                    if (legendPosition != 'custom') {
                        if (AreaType == "cartesianaxes") {
                            switch (legendPosition) {
                                case "bottom":
                                    legendBounds.Y = areaBounds.Y + areaBounds.Height + hSizeNear - (elementSpacing / 2) + bottomScroll;
                                    break;
                                case "top":
                                    legendBounds.Y = titleLocation == 0 ? borderSize + elementSpacing : (titleTextHeight + titleBorderSpacing + subTitleTextHeight + subTitleBorderSpacing + elementSpacing);
                                    break;
                                case "right":
                                    legendBounds.X = areaBounds.X + areaBounds.Width + vSizeFar + elementSpacing * 2;
                                    break;
                                case "left":
                                    legendBounds.X = areaBounds.X - vSizeNear - actualBounds.Width - (elementSpacing / 2) - (legendBorder * 2) - leftScroll;
                                    break;
                            }
                        } else {
                            switch (legendPosition) {
                                case "bottom":
                                    legendBounds.Y = svgHeight - (actualBounds.Height + (legendBorder)) - (elementSpacing * 2);
                                    break;
                                case "top":
                                    legendBounds.Y = titleLocation == 0 ? borderSize + elementSpacing : (titleTextHeight + titleBorderSpacing + subTitleTextHeight + subTitleBorderSpacing + elementSpacing);
                                    break;
                                case "right":
                                    legendBounds.X = svgWidth - actualBounds.Width - (elementSpacing * 2);
                                    break;
                                case "left":
                                    legendBounds.X = borderSize + (elementSpacing * 2);
                                    break;
                            }
                        }
                        //Avoid axis and legend overlapping during crossing
                        if (!chartModel.enable3D && AreaType == "cartesianaxes" && params._crossAxisOverlap != null) {
                            for (var i = 0, len = chartModel._axes.length; i < len; i++) {
                                var axis = chartModel._axes[i], axisBounds = params.axes[axis.name]._bounds;
                                var hor = axis.orientation.toLowerCase() === 'horizontal';
                                if (legendPosition == "top" && hor && axis._opposed && (axis.y - axisBounds < legendBounds.Y + legendBounds.Height))
                                    legendBounds.Y -= legendBounds.Y + legendBounds.Height - axis.y + axisBounds;
                                else if (legendPosition == "bottom" && hor && !axis._opposed && (axis.y + axisBounds > legendBounds.Y))
                                    legendBounds.Y += axis.y + axisBounds - legendBounds.Y;
                                else if (legendPosition == "left" && !hor && axis._opposed && (axis.x - axisBounds < legendBounds.X + legendBounds.Width))
                                    legendBounds.X += axis.x + axisBounds - legendBounds.X;
                                else if (legendPosition == "right" && !hor && !axis._opposed && (axis.x + axisBounds > legendBounds.X))
                                    legendBounds.X -= legendBounds.X + legendBounds.Width - axis.x + axisBounds;
                            }
                        }
                        if (legendPosition == 'left' || legendPosition == 'right') {
                            if (isScroll) {
                                switch (alignment) {
                                    case "center":
                                        legendBounds.Y = areaBounds.Height / 2 - (actualBounds.Height / 2) + areaBounds.Y - legendBorder;
                                        break;
                                    case "near":
                                        legendBounds.Y = areaBounds.Y;
                                        break;
                                    case "far":
                                        legendBounds.Y = areaBounds.Y + areaBounds.Height - actualBounds.Height - (legendBorder * 2);
                                        break;
                                }
                            } else {
                                switch (alignment) {
                                    case "center":
                                        legendBounds.Y = (svgHeight / 2) - ((actualBounds.Height + legendBorder * 2) / 2) + (elementSpacing / 2);
                                        break;
                                    case "near":
                                        legendBounds.Y = borderSize + (elementSpacing * 2);
                                        break;
                                    case "far":
                                        legendBounds.Y = svgHeight - (actualBounds.Height + (legendBorder)) - (elementSpacing * 2);
                                        break;
                                }
                            }

                        } else {
                            switch (alignment) {
                                case "center":
                                    legendBounds.X = (svgWidth / 2) - ((actualBounds.Width + legendBorder * 2) / 2) + (elementSpacing / 2);
                                    break;
                                case "near":
                                    legendBounds.X = isRTL ? svgWidth - (actualBounds.Width + (legendBorder)) - (elementSpacing * 2) : borderSize + (elementSpacing * 2);
                                    break;
                                case "far":
                                    legendBounds.X = isRTL ? borderSize + (elementSpacing * 2) : svgWidth - (actualBounds.Width + (legendBorder)) - (elementSpacing * 2);
                                    break;
                            }
                        }
                    } else {
                        legendBounds.Y = (legend.location.y < svgHeight) ? legend.location.y : 0;
                        legendBounds.X = (legend.location.x < svgWidth) ? legend.location.x : 0;
                    }
                    if (isScroll) {
                        if (legendPosition == 'right' || legendPosition == 'left') {
                            if (legendBounds.Y < areaBounds.Y || actualBounds.Height + (legendBorder * 2) >= areaBounds.Height) {
                                var legendHeight = (legendBorder * 2);
                                for (var k = 0; k < collectionLength; k++) {
                                    legendHeight += legendCollection[k].Bounds.Height + itemPadding;
                                    if (legendHeight > areaBounds.Height) {
                                        actualBounds.Height = areaBounds.Height - (legendBorder * 2);
                                        legendBounds.Y = areaBounds.Y;
                                        break;
                                    }
                                }
                            }
                        }
                        else {
                            if ((legendBorder * 2 + actualBounds.Width) >= svgWidth) {
                                var legendWidth = (legendBorder * 2);
                                for (var k = 0; k < collectionLength; k++) {
                                    legendWidth += legendCollection[k].Bounds.Width + itemPadding;
                                    if (legendWidth > svgWidth) {
                                        actualBounds.Width = svgWidth - (legendBorder * 2) - actualBounds.vScrollSize - (borderSize * 2);
                                        legendBounds.X = (svgWidth / 2) - ((actualBounds.Width + legendBorder * 2) / 2) + (elementSpacing / 2);
                                        break;
                                    }

                                }
                            }
                        }
                    }

                    //Set height and width to legend Canvas element
                    chart.legendSvgContainer.setAttribute('height', legendBounds.Height);
                    chart.legendSvgContainer.setAttribute('width', Math.max(legendTitleWidth, legendBounds.Width));
                    currentX = startX = hPadding;
                    currentY = startY = vPadding;
                    if (legendTitle.text != "" && legendTitle.text) {
                        this.drawLegendTitle();
                        currentY = startY = vPadding + legendTitleHeight;
                    }
                    for (var k = 0; k < collectionLength; k++) {
                        if ((legend.rowCount < legend.columnCount || legend.rowCount == legend.columnCount) && (legendPosition == 'top' || legendPosition == 'bottom' || legendPosition == 'custom')) {
                            if ((currentX + legendCollection[k].Bounds.Width) > legendBounds.Width + startX) {
                                currentX = hPadding;
                                currentY += legendCollection[k].Bounds.Height + itemPadding;
                            }
                            this.drawLegendItem(legendCollection[k], currentX, (currentY));
                            currentX += legendCollection[k].Bounds.Width + itemPadding;
                        }
                        else {
                            if (((currentY + legendCollection[k].Bounds.Height + itemPadding) + legendTitleHeight + borderSize > legendBounds.Height + startY)) {
                                currentY = startY;
                                currentX += maxWidth + (itemPadding);
                            }
                            this.drawLegendItem(legendCollection[k], (currentX), (currentY));
                            currentY += legendCollection[k].Bounds.Height + itemPadding;
                            maxWidth = Math.max(maxWidth, legendCollection[k].Bounds.Width);
                        }
                    }
                    var legendVal = chart.legendContainer[0].offsetLeft;
                    var chartOffsetVal = $(chart.element).offset();
                    var offsetVal = (chart.vmlRendering) ? (legendVal <= 0) ? legendBounds.X : (legendVal - chartOffsetVal.left) :
                        ($(chart.svgObject).offset().left - chartOffsetVal.left);
                    var legnTx = (chart.vmlRendering) ? offsetVal : legendBounds.X + (offsetVal <= 0 ? 0 : offsetVal);
                    legendContainer.attr('style', '');
                    legendContainer.show();
                    if (!legend._ejScroller) {
                        if (isRTL)
                            legendContainer.css({ "direction": "rtl" });
                        else
                            legendContainer.css({ "direction": "ltr" });
                    }
                    legendContainer.css({ "position": "absolute", "background": legend.background, "left": legnTx, "top": legendBounds.Y, "width": actualBounds.Width, "height": actualBounds.Height, "border-width": legend.border.width, "border-color": legend.border.color, "border-style": "solid" });
                    legendContainer.addClass("e-legendborder");
                    legendSvgContainer.css({ "height": legendBounds.Height, "width": legendBounds.Width });
                    legendBounds.Height = legendBounds.Height - (padding - (vPadding * 2));
                    var isVisible = this.legendRectSpace(legendBounds, actualBounds);
                    if (isScroll) {
                        if (legend._ejScroller) {
                            if (!isVisible && (legendBounds.Width > Math.ceil(actualBounds.Width) || legendBounds.Height > Math.ceil(actualBounds.Height))) {
                                $('#' + legendContainer[0].id).ejScroller({ scrollTop: chart.scrolltop, scrollLeft: chart.scrollleft, height: actualBounds.Height, width: actualBounds.Width });
                                isScrolling = true;
                                if (legendBounds.Height > Math.ceil(actualBounds.Height)) {
                                    if (actualBounds.vScrollSize == 0) {
                                        vScrollSize = legendContainer[0].offsetWidth + (legendBorder * 5) - legendContainer[0].clientWidth;
                                        legendContainer.css({ "width": actualBounds.Width + vScrollSize });
                                    }
                                }
                            } else {
                                $('#' + legendContainer[0].id).ejScroller("instance").destroy();
                                legend._ejScroller = false;
                            }
                        }
                        else {
                            if (!isVisible && legendBounds.Width > Math.ceil(actualBounds.Width) && legendBounds.Height > Math.ceil(actualBounds.Height)) {
                                legendContainer.css({ "overflow": "scroll" });
                                isScrolling = true;
                            } else {
                                if (!isVisible && legendBounds.Height > Math.ceil(actualBounds.Height) && actualBounds.vScrollSize >= 0) {
                                    legendContainer[0].style.overflowY = "scroll";
                                    legendContainer[0].style.overflowX = "hidden";
                                    if (actualBounds.vScrollSize == 0) {
                                        vScrollSize = legendContainer[0].offsetWidth - (legendBorder * 2) - legendContainer[0].clientWidth;
                                        legendContainer.css({ "width": actualBounds.Width + vScrollSize });
                                    }
                                    isScrolling = true;
                                }
                                if (!isVisible && legendBounds.Width > Math.ceil(actualBounds.Width) && actualBounds.hScrollSize >= 0) {
                                    legendContainer[0].style.overflowX = "scroll";
                                    legendContainer[0].style.overflowY = "hidden";
                                    if (actualBounds.hScrollSize == 0) {
                                        hScrollSize = legendContainer[0].offsetHeight - (legendBorder * 2) - legendContainer[0].clientHeight;
                                        legendContainer.css({ "height": actualBounds.Height + hScrollSize });
                                    }
                                    isScrolling = true;
                                }
                            }
                        }
                    }

                    chart.svgRenderer.append(chart.gLegendEle, chart.legendSvgContainer);
                    if (!isScrolling) {
                        legendContainer.css({ "width": actualBounds.Width - actualBounds.vScrollSize, "height": actualBounds.Height - actualBounds.hScrollSize });
                    }
                    if (!legend._ejScroller) {
                        if (chart.scrolltop != undefined)
                            legendContainer.scrollTop(chart.scrolltop);
                        if (chart.scrollleft != undefined)
                            legendContainer.scrollLeft(chart.scrollleft);
                    }

                }
                else
                    legendContainer.hide();
            }
        };
})(jQuery);;
/* global jQuery, sf, document */
sf.seriesTypes = {};

sf.EjSeriesRender = function () {

};
sf.indicatorTypes = {};

sf.EjIndicatorRender = function () {

};
sf.trendlineTypes = {};

sf.EjTrendLineRenderer = function () {

};
(function ($) {
    sf.EjTrendLineRenderer.prototype = {
        draw: function (trendline, series, sender) {
            this.chartObj = sender;
            var trendIndex = $.inArray(trendline, series.trendlines);
            trendline._isTransposed = sender.model.requireInvertedAxes;
            trendline.xAxis = series.xAxis;
            trendline.yAxis = series.yAxis;
            var type = trendline.type.toLowerCase();
            if (trendline.points.length > 1) {
                if (type == "linear" || type == "movingaverage")
                    this.calculateLineDirection(trendline, series, trendIndex);
                else
                    this.calculateSplineDirection(trendline, series, trendIndex);
            }
            return false;
        },
        calculateSplineDirection: function (trendline, series, trendIndex) {
            //var series = trendline;
            var spDirection = "";
            var splinesb = sf.EjSvgRender.utils._getStringBuilder();
            var startingPoint = true;
            var yIndex = 0;
            var visiblePoints = trendline.points;
            var ySpline = sf.EjSeriesRender.prototype.naturalSpline(visiblePoints, series);
            var firstPoint = null;
            var secondPoint = null;
            var firstIndex = -1;
            var canvasX = 0;
            var canvasY = 0;
            var point, pointIndex;
            var length = visiblePoints.length;
            for (var i = 0; i < length; i++) {
                pointIndex = i;
                secondPoint = visiblePoints[i];
                if (firstPoint != null) {
                    var controlPoint1 = null;
                    var controlPoint2 = null;
                    var data = sf.EjSeriesRender.prototype.getBezierControlPoints(firstPoint, secondPoint, ySpline[firstIndex], ySpline[pointIndex], yIndex, series, this);
                    controlPoint1 = data["controlPoint1"];
                    controlPoint2 = data["controlPoint2"];
                    var pt1 = sf.EjSvgRender.utils._getPoint(firstPoint, trendline);
                    var pt2 = sf.EjSvgRender.utils._getPoint(secondPoint, trendline);
                    var bpt1 = sf.EjSvgRender.utils._getPoint(controlPoint1, trendline);
                    var bpt2 = sf.EjSvgRender.utils._getPoint(controlPoint2, trendline);
                    var chartObj = this.chartObj;
                    if (startingPoint) {
                        splinesb.append("M" + " " + (pt1.X) + " " + (pt1.Y) + " " + "C" + " " + (bpt1.X) + " " + (bpt1.Y) + " " + (bpt2.X) + " " + (bpt2.Y) + " " + (pt2.X) + " " + (pt2.Y) + " ");
                        startingPoint = false;
                    }
                    else
                        splinesb.append("C" + " " + (bpt1.X) + " " + (bpt1.Y) + " " + (bpt2.X) + " " + (bpt2.Y) + " " + (pt2.X) + " " + (pt2.Y) + " ");
                }
                firstPoint = secondPoint;
                firstIndex = pointIndex;
            }
            spDirection = splinesb.toString();
            this._drawLinePath(trendline, series, spDirection, trendIndex);

            return false;
        },
        calculateLineDirection: function (trendline, series, trendIndex) {
            var canvasX = 0;
            var canvasY = 0;
            var point;
            var lDirection;
            var sb = sf.EjSvgRender.utils._getStringBuilder();

            var firstPoint = false;
            var secondPoint;
            var length = trendline.points.length;
            for (var i = 0; i < length; i++) {
                secondPoint = trendline.points[i];
                point = sf.EjSvgRender.utils._getPoint(secondPoint, trendline);
                if (firstPoint)
                    sb.append("L" + " " + (point.X) + " " + ((point.Y)) + " ");
                else {
                    sb.append("M" + " " + (point.X) + " " + ((point.Y)) + " ");
                    sb.append("L" + " " + (point.X) + " " + ((point.Y)) + " ");
                    firstPoint = true;
                }
            }
            lDirection = sb.toString();
            this._drawLinePath(trendline, series, lDirection, trendIndex);
            return false;
        },
        _drawLinePath: function (trendline, series, lDirection, trendIndex) {
            var translate = [];
            translate[0] = trendline.xAxis.x;
            translate[1] = trendline.yAxis.y;

            if (lDirection != "") {
                var options = {
                    'id': this.chartObj.svgObject.id + "_" + trendline.seriesIndex + "_" + trendIndex + "_" + trendline.name.replace(/[^a-zA-Z ]/g, ""),
                    'fill': 'none',
                    'stroke-dasharray': trendline.dashArray,
                    'stroke-width': trendline.width,
                    'stroke': trendline.fill,
                    'opacity': trendline.opacity,
                    'd': lDirection
                };
                trendline.id = options.id;
                this.chartObj.svgRenderer.drawPath(options, series.gTrendGroupEle, translate);
            }
            this.chartObj.svgRenderer.append(series.gTrendGroupEle, this.chartObj.gTrendlinesGroupEle[trendline.seriesIndex]);

            return false;
        },

        calculateTrendLineSegment: function (series, trendline, axis, sender) {
            var chartmodel = sender.model;
            var axis, points = $.extend([], series.points);
            var trendlineType = trendline.type.toLowerCase();
            trendline.xAxis = series.xAxis ? series.xAxis : chartmodel.primaryXAxis;
            trendline.yAxis = series.yAxis ? series.yAxis : chartmodel.primaryYAxis;
            trendline.backwardForecast = trendline.backwardForecast < 0 ? 0 : trendline.backwardForecast;
            trendline.forwardForecast = trendline.forwardForecast < 0 ? 0 : trendline.forwardForecast;
            points = points.sort(function (a, b) { return (a.xValue > b.xValue) ? 1 : ((b.xValue > a.xValue) ? -1 : 0); });
            switch (trendlineType) {
                case "linear":
                    this.updateTrendSource(points, trendline);
                    this.calculateLinearTrendline(series, trendline, axis);
                    break;
                case "exponential":
                    this.updateExponentialTrendSource(points, trendline);
                    this.calculateExponentialTrendline(series, trendline, axis);
                    break;
                case "logarithmic":
                    this.updateLogarithmicTrendSource(points, trendline);
                    this.calculateLogarithmicTrendline(series, trendline, axis);
                    break;
                case "power":
                    this.updatePowerTrendSource(points, trendline);
                    this.calculatePowerTrendline(series, trendline, axis);
                    break;
                case "polynomial":
                    var length = series.points.length;
                    trendline.polynomialOrder = length <= trendline.polynomialOrder ? length : trendline.polynomialOrder;
                    trendline.polynomialOrder = trendline.polynomialOrder < 2 ? 2 : trendline.polynomialOrder;
                    trendline.polynomialOrder = trendline.polynomialOrder > 6 ? 6 : trendline.polynomialOrder;
                    if (length > 1) {
                        this.updateTrendSource(points, trendline);
                        this.calculatePolynomialTrendline(series, trendline, axis);
                    }
                    break;
                case "movingaverage":
                    this.updateMovingAverageTrendSource(points, trendline);
                    this.calculateMovingAverageTrendline(series, trendline, axis);
                    break;
            }
            if (series.points.length > 1 && trendline.points)
                this.calculateTrendLineRange(trendline, axis);
            return false;
        },
        updateTrendSource: function (points, trendline) {
            var len = points.length, point, xValue;

            trendline.xPoints = [];
            trendline.xValues = [];
            trendline.yValues = [];
            for (var i = 0; i < len; i++) {
                point = points[i];
                if (!point.isEmpty && !sf.isNullOrUndefined(point.y)) {
                    trendline.xPoints.push(point.xValue);
                    xValue = typeof (point.xValue) === 'number' ? point.xValue : Date.parse(point.xValue);
                    trendline.xValues.push(xValue);
                    trendline.yValues.push(point.y);
                }
            }
            this.calculateSumXAndYValue(trendline);
            return false;
        },
        calculateLinearTrendline: function (series, trendline, axis) {

            var count = trendline.xValues.length;
            var x1, x2;
            trendline.points = [];

            if (count > 1) {
                if (axis._valueType.toLowerCase() == "datetime") {
                    x1 = this._increaseDateTimeInterval(trendline.xPoints[0], -trendline.backwardForecast, axis._intervalType);
                    x2 = this._increaseDateTimeInterval(trendline.xPoints[count - 1], trendline.forwardForecast, axis._intervalType);
                } else {
                    x1 = (trendline.xPoints[0] - trendline.backwardForecast);
                    x2 = (trendline.xPoints[count - 1] + trendline.forwardForecast);
                }

                //trendline linear segment  y = ax + b;
                var y1 = trendline.slope * x1 + trendline._intercept;
                var y2 = trendline.slope * x2 + trendline._intercept;
                trendline.points.push({ x: x1, xValue: x1, y: y1, YValues: [], visible: true });
                trendline.points.push({ x: x2, xValue: x2, y: y2, YValues: [], visible: true });

                trendline.points[0].YValues[0] = trendline.points[0].y;
                trendline.points[1].YValues[0] = trendline.points[1].y;
            }
            return false;
        },

        //// Calculate Trendline range
        calculateTrendLineRange: function (trendline, axis) {

            var length = trendline.points.length;
            var y;
            trendline.minY = trendline.points[0].y;
            trendline.maxY = trendline.points[length - 1].y;
            if (!axis.setRange) {
                if (trendline.backwardForecast > 0 && axis._valueType != "category" && length > 1) {
                    axis.range.min = axis.range.min > trendline.points[0].x ? trendline.points[0].x : axis.range.min;
                    axis.visibleRange.min = axis.range.min;
                }
                if (trendline.forwardForecast > 0 && length > 1) {
                    axis.range.max = axis.range.max < trendline.points[length - 1].x ? trendline.points[length - 1].x : axis.range.max;
                    axis.visibleRange.max = axis.range.max;
                }
            }
            for (var i = 0; i < length; i++) {
                y = trendline.points[i].y;
                trendline.minY = Math.min(trendline.minY, y);
                trendline.maxY = Math.max(trendline.maxY, y);
            }
            return false;
        },

        /// Calculate Sum of x and y values
        calculateSumXAndYValue: function (trendline) {
            var points = trendline.points,
                N = trendline.xPoints.length,
                type = trendline.type.toLowerCase(),
                Slope, Intercept, SX = 0, SY = 0,
                SXX = 0, SXY = 0, SYY = 0, i,
                SumProduct = 0, X = trendline.xValues, Y = trendline.yValues;

            for (i = 0; i < N; i++) {
                SX = SX + X[i];
                SY = SY + Y[i];
                SumProduct = SumProduct + (X[i] * Y[i]);
                SXY = SXY + X[i] * Y[i];
                SXX = SXX + X[i] * X[i];
                SYY = SYY + Y[i] * Y[i];
            }
            if (!sf.util.isNullOrUndefined(trendline.intercept) && (type == "linear" || type == "exponential" || type == "polynomial")) { //Set intercept value externally
                switch (type) {
                    case "polynomial":
                        Slope = (((SumProduct) - (Math.log(trendline.intercept) * SX)) / SXX) * 3;
                        break;
                    case "linear":
                        Slope = ((SumProduct) - (trendline.intercept * SX)) / SXX;
                        break;
                    case "exponential":
                        Slope = ((SumProduct) - (Math.log(trendline.intercept) * SX)) / SXX;
                        break;

                }
                trendline._intercept = trendline.intercept;
            }
            else {
                Slope = ((N * SXY) - (SX * SY)) / ((N * SXX) - (SX * SX));
                if (type == "exponential" || type == "power")
                    Intercept = Math.exp((SY - (Slope * SX)) / N);
                else
                    Intercept = (SY - (Slope * SX)) / N;

                trendline._intercept = Intercept;
            }
            trendline.slope = Slope;
            return false;
        },

        ////Calculate forward backward Forecast points for dateTime axis
        _increaseDateTimeInterval: function (date, interval, intervalType) {
            var result = new Date(date);
            date = typeof (date) === "object" ? date : result;
            if (intervalType.toLowerCase() == "days") {
                result.setDate(date.getDate() + interval);
            } else if (intervalType.toLowerCase() == "hours") {
                result.setHours(date.getHours() + interval);
            } else if (intervalType.toLowerCase() == "milliseconds") {
                result.setMilliseconds(date.getMilliseconds() + interval);
            } else if (intervalType.toLowerCase() == "seconds") {
                result.setSeconds(date.getSeconds() + interval);
            } else if (intervalType.toLowerCase() == "minutes") {
                result.setMinutes(date.getMinutes() + interval);
            } else if (intervalType.toLowerCase() == "months") {
                result.setMonth(date.getMonth() + interval);
            } else if (intervalType.toLowerCase() == "years") {
                result.setYear(date.getFullYear() + interval);
            }
            return result;
        }

    },

        sf.ejLinear = ejExtendClass(sf.EjTrendLineRenderer);
    sf.trendlineTypes.linear = sf.ejLinear;

    sf.Exponential = ejExtendClass(sf.EjTrendLineRenderer, {

        updateExponentialTrendSource: function (points, trendline) {
            var len = points.length, point, xValue;
            trendline.xPoints = [];
            trendline.xValues = [];
            trendline.yValues = [];
            for (var i = 0; i < len; i++) {
                point = points[i];
                if (!point.isEmpty && !sf.isNullOrUndefined(point.y)) {
                    trendline.xPoints.push(point.xValue);
                    xValue = typeof (point.xValue) === 'number' ? point.xValue : Date.parse(point.xValue);
                    trendline.xValues.push(xValue);
                    trendline.yValues.push(Math.log(point.y));
                }
            }
            this.calculateSumXAndYValue(trendline);
            return false;
        },
        calculateExponentialTrendline: function (series, trendline, axis) {
            var count = trendline.xValues.length;
            var x1, x2, x3;
            var X1, X2, X3;

            var midPoint = Math.round((count / 2));
            trendline.points = [];

            if (count > 1) {
                if (axis._valueType.toLowerCase() == "datetime") {
                    x1 = this._increaseDateTimeInterval(trendline.xPoints[0], -trendline.backwardForecast, axis._intervalType);
                    X1 = x1.getTime();
                    x2 = (trendline.xPoints[midPoint - 1]);
                    X2 = new Date(x2).getTime();
                    x3 = this._increaseDateTimeInterval(trendline.xPoints[count - 1], trendline.forwardForecast, axis._intervalType);
                    X3 = x3.getTime();
                } else {
                    x1 = X1 = (trendline.xPoints[0] - trendline.backwardForecast);
                    x2 = X2 = (trendline.xPoints[midPoint - 1]);
                    x3 = X3 = (trendline.xPoints[count - 1] + trendline.forwardForecast);
                }

                //trendline exponential segment  (Intercept * Math.Exp(Slope * xValue));
                var y1 = (trendline._intercept * Math.exp(trendline.slope * x1));
                var y2 = (trendline._intercept * Math.exp(trendline.slope * x2));
                var y3 = (trendline._intercept * Math.exp(trendline.slope * x3));
                trendline.points.push({ x: x1, xValue: X1, y: y1, YValues: [], visible: true });
                trendline.points.push({ x: x2, xValue: X2, y: y2, YValues: [], visible: true });
                trendline.points.push({ x: x3, xValue: X3, y: y3, YValues: [], visible: true });

                trendline.points[0].YValues[0] = trendline.points[0].y;
                trendline.points[1].YValues[0] = trendline.points[1].y;
                trendline.points[2].YValues[0] = trendline.points[2].y;
            }
            return false;
        }
    });
    sf.trendlineTypes.exponential = sf.Exponential;

    sf.Logarithmic = ejExtendClass(sf.EjTrendLineRenderer, {

        updateLogarithmicTrendSource: function (points, trendline) {
            var len = points.length, point, xValue;
            trendline.xPoints = [];
            trendline.xValues = [];
            trendline.yValues = [];
            for (var i = 0; i < len; i++) {
                point = points[i];
                if (!point.isEmpty && !sf.isNullOrUndefined(point.y)) {
                    trendline.xPoints.push(point.xValue);
                    xValue = typeof (point.xValue) === 'number' ? point.xValue : Date.parse(point.xValue);
					var xVal = isFinite(Math.log(xValue)) ? Math.log(xValue) : xValue;
					trendline.xValues.push(xVal);
                    trendline.yValues.push(point.y);
                }
            }
            this.calculateSumXAndYValue(trendline);
            return false;
        },
        calculateLogarithmicTrendline: function (series, trendline, axis) {
            var count = trendline.xValues.length;
            var x1, x2, x3;
            var X1, X2, X3;
            var midPoint = Math.round((count / 2));
            trendline.points = [];

            if (count > 1) {
                if (axis._valueType.toLowerCase() == "datetime") {
                    x1 = this._increaseDateTimeInterval(trendline.xPoints[0], -trendline.backwardForecast, axis._intervalType);
                    X1 = x1.getTime();
                    x2 = (trendline.xPoints[midPoint - 1]);
                    X2 = new Date(x2).getTime();
                    x3 = this._increaseDateTimeInterval(trendline.xPoints[count - 1], trendline.forwardForecast, axis._intervalType);
                    X3 = x3.getTime();
                } else {
                    x1 = X1 = (trendline.xPoints[0] - trendline.backwardForecast);
                    x2 = X2 = (trendline.xPoints[midPoint - 1]);
                    x3 = X3 = (trendline.xPoints[count - 1] + trendline.forwardForecast);
                }

                //trendline logarithmic segment  Intercept + Slope * Math.Log(xValue);
                var y1 = trendline._intercept + (trendline.slope * (isFinite(Math.log(x1)) ? Math.log(x1) : x1));
                var y2 = trendline._intercept + (trendline.slope * (isFinite(Math.log(x2))? Math.log(x2) : x2));
                var y3 = trendline._intercept + (trendline.slope * (isFinite(Math.log(x3))? Math.log(x3) : x3));
                trendline.points.push({ x: x1, xValue: X1, y: y1, YValues: [], visible: true });
                trendline.points.push({ x: x2, xValue: X2, y: y2, YValues: [], visible: true });
                trendline.points.push({ x: x3, xValue: X3, y: y3, YValues: [], visible: true });

                trendline.points[0].YValues[0] = trendline.points[0].y;
                trendline.points[1].YValues[0] = trendline.points[1].y;
                trendline.points[2].YValues[0] = trendline.points[2].y;
            }
            return false;
        }
    });
    sf.trendlineTypes.logarithmic = sf.Logarithmic;

    sf.Power = ejExtendClass(sf.EjTrendLineRenderer, {

        updatePowerTrendSource: function (points, trendline) {
            var len = points.length, point, xValue;
            trendline.xPoints = [];
            trendline.xValues = [];
            trendline.yValues = [];
            for (var i = 0; i < len; i++) {
                point = points[i];
                if (!point.isEmpty) {
                    trendline.xPoints.push(point.xValue);
                    xValue = typeof (point.xValue) === 'number' ? point.xValue : Date.parse(point.xValue);
                    trendline.xValues.push(Math.log(xValue));
                    trendline.yValues.push(Math.log(point.y));
                }
            }
            this.calculateSumXAndYValue(trendline);
            return false;
        },
        calculatePowerTrendline: function (series, trendline, axis) {
            var count = trendline.xValues.length;
            var x1, x2, x3;
            var X1, X2, X3;
            var midPoint = Math.round((count / 2));
            trendline.points = [];

            if (count > 1) {
                if (axis._valueType.toLowerCase() == "datetime") {
                    x1 = this._increaseDateTimeInterval(trendline.xPoints[0], -trendline.backwardForecast, axis._intervalType);
                    X1 = x1.getTime();
                    x2 = (trendline.xPoints[midPoint - 1]);
                    X2 = new Date(x2).getTime();
                    x3 = this._increaseDateTimeInterval(trendline.xPoints[count - 1], trendline.forwardForecast, axis._intervalType);
                    X3 = x3.getTime();
                } else {
                    var p1 = (trendline.xPoints[0] - trendline.backwardForecast);
                    x1 = X1 = p1 > -1 ? p1 : 0;
                    x2 = X2 = (trendline.xPoints[midPoint - 1]);
                    x3 = X3 = (trendline.xPoints[count - 1] + trendline.forwardForecast);
                }

                //trendline power segment  (Intercept * Math.Pow(xValue, Slope))
                var y1 = trendline._intercept * Math.pow(x1, trendline.slope);
                var y2 = trendline._intercept * Math.pow(x2, trendline.slope);
                var y3 = trendline._intercept * Math.pow(x3, trendline.slope);
                trendline.points.push({ x: x1, xValue: X1, y: y1, YValues: [], visible: true });
                trendline.points.push({ x: x2, xValue: X2, y: y2, YValues: [], visible: true });
                trendline.points.push({ x: x3, xValue: X3, y: y3, YValues: [], visible: true });

                trendline.points[0].YValues[0] = trendline.points[0].y;
                trendline.points[1].YValues[0] = trendline.points[1].y;
                trendline.points[2].YValues[0] = trendline.points[2].y;
            }
            return false;
        }
    });
    sf.trendlineTypes.power = sf.Power;

    sf.Polynomial = ejExtendClass(sf.EjTrendLineRenderer, {

        //// Calculate Polynomial Trendline with order
        calculatePolynomialTrendline: function (series, trendline, axis) {
            var power = trendline.polynomialOrder;

            // Calculate sum of y datapoints 1 X power matrix
            trendline.polynomialSlopes = new Array(power + 1);
            var xLength = trendline.xValues.length;
            for (var index1 = 0; index1 < xLength; index1++) {
                var num2 = trendline.xValues[index1];
                var yval = trendline.yValues[index1];

                for (var index2 = 0; index2 <= power; ++index2) {
                    if (!trendline.polynomialSlopes[index2]) trendline.polynomialSlopes[index2] = 0;
                    trendline.polynomialSlopes[index2] += Math.pow(num2, index2) * yval;
                }
            }

            // Calculate sum matrix of x datapoints
            var numArray = new Array(1 + 2 * power);
            var matrixOfA = new Array(power + 1);
            for (var i = 0; i < (power + 1); i++)
                matrixOfA[i] = new Array(3);
            var num1 = 0;
            for (var index1 = 0; index1 < xLength; ++index1) {
                var num2 = 1.0;
                var d = trendline.xValues[index1];
                for (var index2 = 0; index2 < numArray.length; ++index2) {
                    if (!numArray[index2]) numArray[index2] = 0;
                    numArray[index2] += num2;
                    num2 *= d;
                    ++num1;
                }
            }

            for (var index1 = 0; index1 <= power; ++index1) {
                for (var index2 = 0; index2 <= power; ++index2)
                    matrixOfA[index1][index2] = numArray[index1 + index2];
            }

            //Calculation Gauss jordan eliminiation value of a and b matrix
            if (!this.gaussJordanEliminiation(matrixOfA, trendline.polynomialSlopes))
                trendline.polynomialSlopes = null;

            //Create segments methods
            this.createPolynomialSegments(series, axis, trendline);
            return false;
        },
        createPolynomialSegments: function (series, axis, trendline) {
            var polynomialSlopes = trendline.polynomialSlopes;
            if (polynomialSlopes != null) {
                var count = trendline.xValues.length, midPoint = Math.round((count / 2)), x1 = 1, X, length = polynomialSlopes.length;
                var valueType = axis._valueType.toLowerCase();

                trendline.points = [];
                for (var i = 1; i <= length; i++) {
                    var x, y;
                    if (i == 1) {
                        if (valueType == "datetime") {
                            x = this._increaseDateTimeInterval(trendline.xPoints[0], -trendline.backwardForecast, axis._intervalType);
                            X = x.getTime();
                        }
                        else
                            x = X = (trendline.xPoints[0] - trendline.backwardForecast);
                        var y = this.getPolynomialYValue(polynomialSlopes, X);
                    }
                    else if (i == polynomialSlopes.length) {
                        if (valueType == "datetime") {
                            x = this._increaseDateTimeInterval(trendline.xPoints[count - 1], trendline.forwardForecast, axis._intervalType);
                            X = x.getTime();
                        }
                        else
                            x = X = (trendline.xPoints[count - 1] + trendline.forwardForecast);

                        var y = this.getPolynomialYValue(polynomialSlopes, X);
                    } else {
                        x1 += (count + trendline.forwardForecast) / polynomialSlopes.length;
                        if (valueType == "category") {
                            x = X = trendline.xPoints[0] + (x1 - 1);

                        }
                        else {
                            x = X = trendline.xPoints[parseInt(x1) - 1];
                            if (valueType == "datetime" && count > x1)
                                X = new Date(x).getTime();
                        }
                        var y = this.getPolynomialYValue(polynomialSlopes, X);
                    }
                    if (i == 1 || i == polynomialSlopes.length || valueType == "category" || count > x1) {
                        trendline.points.push({ x: x, xValue: X, y: y, YValues: [], visible: true });
                        trendline.points[trendline.points.length - 1].YValues[0] = trendline.points[trendline.points.length - 1].y;
                    }
                }
            }
            return false;
        },

        getPolynomialYValue: function (slopes, x) {
            var sum = 0;
            for (var i = 0; i < slopes.length; i++) {
                sum += slopes[i] * Math.pow(x, i);
            }
            return sum;
        },

        gaussJordanEliminiation: function (matrixOfA, polynomialSlopes) {
            var length = matrixOfA.length;
            var numArray1 = new Array(length);
            var numArray2 = new Array(length);
            var numArray3 = new Array(length);
            for (var index = 0; index < length; ++index)
                numArray3[index] = 0;
            for (var index1 = 0; index1 < length; ++index1) {
                var num1 = 0.0;
                var index2 = 0;
                var index3 = 0;
                for (var index4 = 0; index4 < length; ++index4) {
                    if (numArray3[index4] != 1) {
                        for (var index5 = 0; index5 < length; ++index5) {
                            if (numArray3[index5] == 0 && Math.abs(matrixOfA[index4][index5]) >= num1) {
                                num1 = Math.abs(matrixOfA[index4][index5]);
                                index2 = index4;
                                index3 = index5;
                            }
                        }
                    }
                }
                ++numArray3[index3];
                if (index2 != index3) {
                    for (var index4 = 0; index4 < length; ++index4) {
                        var num2 = matrixOfA[index2, index4];
                        matrixOfA[index2][index4] = matrixOfA[index3][index4];
                        matrixOfA[index3][index4] = num2;
                    }
                    var num3 = polynomialSlopes[index2];
                    polynomialSlopes[index2] = polynomialSlopes[index3];
                    polynomialSlopes[index3] = num3;
                }
                numArray2[index1] = index2;
                numArray1[index1] = index3;
                if (matrixOfA[index3][index3] == 0.0)
                    return false;
                var num4 = 1.0 / matrixOfA[index3][index3];
                matrixOfA[index3][index3] = 1.0;

                for (var index4 = 0; index4 < length; ++index4)
                    matrixOfA[index3][index4] *= num4;

                polynomialSlopes[index3] *= num4;

                for (var index4 = 0; index4 < length; ++index4) {
                    if (index4 != index3) {
                        var num2 = matrixOfA[index4][index3];
                        matrixOfA[index4][index3] = 0.0;
                        for (var index5 = 0; index5 < length; ++index5)
                            matrixOfA[index4][index5] -= matrixOfA[index3][index5] * num2;
                        polynomialSlopes[index4] -= polynomialSlopes[index3] * num2;
                    }
                }
            }
            for (var index1 = length - 1; index1 >= 0; --index1) {
                if (numArray2[index1] != numArray1[index1]) {
                    for (var index2 = 0; index2 < length; ++index2) {
                        var num = matrixOfA[index2, numArray2[index1]];
                        matrixOfA[index2][numArray2[index1]] = matrixOfA[index2][numArray1[index1]];
                        matrixOfA[index2][numArray1[index1]] = num;
                    }
                }
            }
            return true;
        }
    });
    sf.trendlineTypes.polynomial = sf.Polynomial;

    sf.MovingAverage = ejExtendClass(sf.EjTrendLineRenderer, {

        updateMovingAverageTrendSource: function (points, trendline) {
            var len = points.length, i, yVal;
            trendline.xPoints = [];
            trendline.xValues = [];
            trendline.yValues = [];
            for (i = 0; i < len; i++) {
                trendline.xPoints.push(points[i].xValue);
                trendline.xValues.push(i + 1);
                yVal = !points[i].isEmpty ? points[i].y : null;
                trendline.yValues.push(yVal);
            }
            return false;
        },
        calculateMovingAverageTrendline: function (series, trendline, axis) {
            var pointsLength = trendline.xPoints.length,
                period = trendline.period >= pointsLength ? pointsLength - 1 : trendline.period,
                x1, i, j, yVal, count, nullCount, xVal, length;
            period = period < 2 ? 2 : period;
            trendline.points = [];

            for (i = 0; i < pointsLength - 1; i++) {
                yVal = count = nullCount = 0;
                for (j = i; count < period; j++) {
                    count++;
                    if (sf.util.isNullOrUndefined(trendline.yValues[j])) nullCount++;
                    yVal += trendline.yValues[j];
                }
                yVal = period - nullCount <= 0 ? null : yVal / (period - nullCount);
                if (!sf.util.isNullOrUndefined(yVal) && !isNaN(yVal)) {
                    xVal = trendline.xPoints[period - 1 + i];
                    trendline.points.push({
                        x: xVal, xValue: xVal,
                        y: yVal, YValues: [], visible: true
                    });
                    length = trendline.points.length;
                    trendline.points[length - 1].YValues[0] = trendline.points[length - 1].y;
                }
            }
        }
    });
    sf.trendlineTypes.movingaverage = sf.MovingAverage;

    sf.EjIndicatorRender.prototype = {

        draw: function (indicator, sender) {

            this.chartObj = sender;
            var translate = null;

            if (this.chartObj.model.AreaType == "cartesianaxes") {
                var transX = indicator.xAxis.x;
                var transY = indicator.yAxis.y;
                translate = 'translate(' + transX + ',' + transY + ')';
            }

            var indicatorIndex = $.inArray(indicator, this.chartObj.model.indicators);
            var indicatorOptions = { 'id': this.chartObj.svgObject.id + '_indicatorGroup' + '_' + indicatorIndex, 'transform': translate };
            this.gIndicatorGroupEle = this.chartObj.svgRenderer.createGroup(indicatorOptions);


            if (indicator._points.length > 0) {
                for (var i = 0; i < indicator.segment.length; i++) {
                    var segment = indicator.segment[i];
                    var style = { fill: segment.fill, width: segment.width, opacity: indicator.opacity };
                    segment.isIndicator = true;
                    segment.xAxis = indicator.xAxis;
                    segment.yAxis = indicator.yAxis;
                    if (segment.type == "line")
                        this.calculateDirection(segment, style, indicatorIndex);
                    else
                        this.drawColumn(segment, style, indicator);
                }
            }

        },

        _drawLinePath: function (indicator, style, lDirection, indicatorIndex) {




            if (lDirection != "") {
                var options = {
                    'name': 'line',
                    'id': this.chartObj.svgObject.id + "_" + indicatorIndex + "_" + indicator.name,
                    'fill': 'none',
                    'stroke-dasharray': indicator.dashArray,
                    'stroke-width': style.width,
                    'stroke': style.fill,
                    'stroke-linecap': indicator.lineCap,
                    'stroke-linejoin': indicator.lineJoin,
                    'opacity': style.opacity,
                    'd': lDirection
                };

                this.chartObj.svgRenderer.drawPath(options, this.gIndicatorGroupEle);
            }

            this.chartObj.svgRenderer.append(this.gIndicatorGroupEle, this.chartObj.gIndicatorEle);
        },

        calculateDirection: function (currentseries, style, indicatorIndex) {
            var canvasX = 0;
            var canvasY = 0;
            var point;
            if (this.chartObj.model.enableCanvasRendering) {
                canvasX = currentseries.xAxis.x;
                canvasY = currentseries.yAxis.y;
            }
            currentseries.points = sf.DataManager(currentseries.points, sf.Query().sortBy("xValue")).executeLocal();

            var visiblePoints = sf.EjSeriesRender.prototype._isVisiblePoints(currentseries);
            var lDirection;
            var sb = sf.EjSvgRender.utils._getStringBuilder();

            // Dashed Line issue in Indicator is fixed.
            var firstPoint = false;
            var secondPoint;

            for (var i = 0; i < visiblePoints.length; i++) {
                secondPoint = visiblePoints[i];
                if (secondPoint.visible) {
                    point = sf.EjSvgRender.utils._getPoint(secondPoint, currentseries);
                    if (firstPoint) {
                        sb.append("L" + " " + (point.X + canvasX) + " " + ((point.Y + canvasY)) + " ");
                    }
                    else {
                        sb.append("M" + " " + (point.X + canvasX) + " " + ((point.Y + canvasY)) + " ");
                        firstPoint = true;
                    }

                }
                else {
                    firstPoint = false;
                }

            }

            lDirection = sb.toString();

            this._drawLinePath(currentseries, style, lDirection, indicatorIndex);
        },

        drawColumn: function (option, style, indicator) {
            var series = option;
            var seriesIndex = $.inArray(indicator, this.chartObj.model.indicators);
            series.index = seriesIndex;
            var origin = Math.max(option.yAxis.visibleRange.min, 0);

            var sidebysideinfo = { Start: -0.35, End: 0.35 };
            var visiblePoints = sf.EjSeriesRender.prototype._isVisiblePoints(series);

            var cSer = this;
            var chart = cSer.chartObj;
            for (var i = 0; i < visiblePoints.length; i++) {
                var pointIndex = i;
                var point = visiblePoints[i];

                var y1 = point.YValues[0];
                var y2 = origin;
                if (point.visible) {
                    //calculate sides
                    var data = sf.EjSeriesRender.prototype.calculateSides(point, sidebysideinfo);
                    var x1 = data.x1;
                    var x2 = data.x2;
                    var rect = sf.EjSeriesRender.prototype.getRectangle(x1, y1, x2, y2, series, chart);

                    //drawing part
                    var xr = Math.min(0, rect.Width);
                    var yr = Math.min(0, rect.Height);
                    if (rect.Width < 0.0001)// condition checked for IE width issue
                        rect.Width = 0.0001;
                    var bounds;
                    if ((xr == 0 || yr == 0) && rect.Width > 0) {
                        var options = {
                            'id': this.chartObj.svgObject.id + "_" + seriesIndex + "_" + series.name,
                            'x': rect.X + cSer.chartObj.canvasX,
                            'y': rect.Y + cSer.chartObj.canvasY,
                            'width': rect.Width,
                            'height': rect.Height,
                            'fill': (!visiblePoints[i].fill) ? style.fill : visiblePoints[i].fill,
                            'stroke-width': series.border.width,
                            'plot': y1 < 0 ? "negative" : "positive",
                            'opacity': series.histogram.opacity,
                            'stroke': (!visiblePoints[i].fill) ? series.border.color : visiblePoints[i].fill
                        };

                        this.chartObj.svgRenderer.drawRect(options, this.gIndicatorGroupEle);

                        var svgXy = sf.EjSvgRender.utils._getSvgXY(rect.X, (rect.Y), series, cSer.chartObj);
                        bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };

                        this._addRegion(cSer.chartObj, bounds, series, point, pointIndex);
                    }
                }
            }

            this.chartObj.svgRenderer.append(this.gIndicatorGroupEle, this.chartObj.gIndicatorEle);
        },
        _addRegion: function (chart, bounds, series, point, pointIndex) {
            var type = series.type;
            if (series.index >= 0) {
                var regionItem = { SeriesIndex: series.index, Region: { PointIndex: pointIndex, Bounds: bounds }, type: type, isIndicator: true };
                chart.model.chartRegions.push(regionItem);
            }
        },

        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};
            indicator.period = parseInt(indicator.period);   // to convert float value to integer
            if (indicator.period < indicator._points.length && indicator.period > 0) {
                //Upperband 
                var upperSeries = $.extend(true, {}, indicator);
                upperSeries.name = "upperseries";
                upperSeries.fill = indicator.upperLine.fill;
                upperSeries.width = indicator.upperLine.width;
                upperSeries.type = "line";

                for (var k = 0; k < indicator._points.length; k++) {
                    indicator._points[k].YValues.length = 1;
                    indicator._points[k].YValues[0] = indicator._points[k].y = 70;
                }

                upperSeries.points = $.extend(true, [], indicator._points);
                var xValues = sender._getXValues(upperSeries.points);
                var yValues = sender._getYValues(upperSeries.points);

                indicator.xRange.min = Math.min.apply(Math, xValues);
                indicator.xRange.max = Math.max.apply(Math, xValues);
                indicator.yRange.min = Math.min.apply(Math, yValues);
                indicator.yRange.max = Math.max.apply(Math, yValues);

                indicator.segment.push(upperSeries);

                //Lowerband
                var lowerSeries = $.extend(true, {}, indicator);
                lowerSeries.name = "lowerSeries";
                lowerSeries.width = indicator.lowerLine.width;
                lowerSeries.fill = indicator.lowerLine.fill;
                lowerSeries.type = "line";


                for (var n = 0; n < indicator._points.length; n++) {
                    indicator._points[n].YValues[0] = indicator._points[n].y = 30;
                }

                lowerSeries.points = $.extend(true, [], indicator._points);

                yValues = sender._getYValues(lowerSeries.points);

                indicator.yRange.min = Math.min(Math.min.apply(Math, yValues), indicator.yRange.min);
                indicator.yRange.max = Math.max(Math.max.apply(Math, yValues), indicator.yRange.max);

                indicator.segment.push(lowerSeries);

                // signalLine
                var trendSeries = $.extend(true, {}, indicator);
                trendSeries.name = "signalSeries";
                trendSeries.width = indicator.width;
                trendSeries.fill = indicator.fill;
                trendSeries.type = "line";

                var c = 0, c1 = 0;
                var pmf = 0;
                var nmf = 0;
                var len = indicator.period;
                c1 = indicator._points[0].close;

                for (var i = 1; i <= len; ++i) {
                    c = indicator._points[i].close;
                    if (c > c1)
                        pmf += c - c1;
                    else if (c < c1)
                        nmf += c1 - c;
                    c1 = c;
                    indicator._points[i - 1].YValues[0] = indicator._points[i - 1].y = null;
                }
                pmf = pmf / len;
                nmf = nmf / len;

                indicator._points[len].YValues[0] = indicator._points[len].y = 100 - 100 / (1 + pmf / nmf);

                for (var j = len + 1; j < indicator._points.length; j++) {
                    c = indicator._points[j].close;
                    if (c > c1) {
                        pmf = (pmf * (len - 1) + (c - c1)) / len;
                        nmf = (nmf * (len - 1)) / len;
                    }
                    else if (c < c1) {
                        nmf = (nmf * (len - 1) + (c1 - c)) / len;
                        pmf = (pmf * (len - 1)) / len;
                    }
                    c1 = c;
                    indicator._points[j].YValues[0] = indicator._points[j].y = 100 - (100 / (1 + pmf / nmf));
                }
                trendSeries.points = $.extend(true, [], indicator._points);
                var trendPoints = [];
                for (var i = len, j = 0; i < trendSeries.points.length; i++ , j++) {
                    trendPoints[j] = trendSeries.points[i].y;
                }

                indicator.yRange.min = Math.min(Math.min.apply(Math, trendPoints), indicator.yRange.min);
                indicator.yRange.max = Math.max(Math.max.apply(Math, trendPoints), indicator.yRange.max);

                indicator.segment.push(trendSeries);
                this.calculateIndicatorRange(sender, indicator);
            }
        },

        calculateIndicatorRange: function (sender, indicator) {
            //Indicator X-Axis Calculation
            if (sender.model.indicatorRange[indicator.xAxisName] == undefined) {
                sender.model.indicatorRange[indicator.xAxisName] = {};
                sender.model.indicatorRange[indicator.xAxisName] = { min: indicator.xRange.min, max: indicator.xRange.max };
            } else {
                if (sender.model.indicatorRange[indicator.xAxisName].min > indicator.xRange.min)
                    sender.model.indicatorRange[indicator.xAxisName].min = indicator.xRange.min;
                if (sender.model.indicatorRange[indicator.xAxisName].max < indicator.xRange.max)
                    sender.model.indicatorRange[indicator.xAxisName].max = indicator.xRange.max;
            }
            //Indicator Y-Axis Calculation
            if (sender.model.indicatorRange[indicator.yAxisName] === undefined) {
                sender.model.indicatorRange[indicator.yAxisName] = {};
                sender.model.indicatorRange[indicator.yAxisName] = { min: indicator.yRange.min, max: indicator.yRange.max };
            } else {
                if (sender.model.indicatorRange[indicator.yAxisName].min > indicator.yRange.min)
                    sender.model.indicatorRange[indicator.yAxisName].min = indicator.yRange.min;
                if (sender.model.indicatorRange[indicator.yAxisName].max < indicator.yRange.max)
                    sender.model.indicatorRange[indicator.yAxisName].max = indicator.yRange.max;
            }
        }
    },
        sf.ejRSI = ejExtendClass(sf.EjIndicatorRender);

    sf.indicatorTypes.rsi = sf.ejRSI;
    sf.ejMACD = ejExtendClass(sf.EjIndicatorRender, {


        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};

            var pointsLength = indicator._points.length;
            var longPeriod = indicator.longPeriod;
            var shortPeriod = indicator.shortPeriod;
            var trigger = indicator.trigger;
            var diff = longPeriod - shortPeriod;
            var shortEMA = [];
            var longEMA = [];
            var macdPoints = [];
            var signalEMA = [];
            var histogramPoints = [];
            var length = longPeriod + trigger;
            if (length <= indicator._points.length && ((length - 2) >= 0) && (shortPeriod <= longPeriod) && (shortPeriod > 0)) {
                shortEMA = this.calculateEMA(indicator._points, shortPeriod, true);
                longEMA = this.calculateEMA(indicator._points, longPeriod, true);

                //Calculte MACD Line points: MACD Line: (shortPeriod EMA - longPeriod EMA)  
                for (i = 0; i < longEMA.length; i++)
                    macdPoints.push((shortEMA[i + diff] - longEMA[i]));

                //MACD Line 
                var macdSeries = $.extend(true, {}, indicator);
                macdSeries.name = "macdSeries";
                macdSeries.fill = indicator.macdLine.fill;
                macdSeries.width = indicator.macdLine.width;
                macdSeries.type = "line";
                macdSeries.xAxis = indicator.xAxis;
                macdSeries.yAxis = indicator.yAxis;

                var l = longPeriod - 1;
                for (var t = 0, i = 0; t < pointsLength; t++) {
                    if (t < l)
                        indicator._points[t].YValues[0] = indicator._points[t].y = null;
                    else {
                        indicator._points[t].YValues[0] = indicator._points[t].y = macdPoints[i];
                        i += 1;
                    }
                }
                macdSeries.points = $.extend(true, [], indicator._points);
                //////////////////////////////////////////////

                //Signal Line: Trigger value(9-day default) EMA of MACD Line 
                signalEMA = this.calculateEMA(macdPoints, trigger, false);
                var trendSeries = $.extend(true, {}, indicator);
                trendSeries.name = "signalSeries";
                trendSeries.fill = indicator.fill;
                trendSeries.width = indicator.width;
                trendSeries.type = "line";
                trendSeries.xAxis = indicator.xAxis;
                trendSeries.yAxis = indicator.yAxis;

                var l = longPeriod + trigger - 2;
                for (var t = 0, i = 0; t < pointsLength; t++) {
                    if (t < l)
                        indicator._points[t].YValues[0] = indicator._points[t].y = null;
                    else {
                        indicator._points[t].YValues[0] = indicator._points[t].y = signalEMA[i];
                        i += 1;
                    }
                }
                trendSeries.points = $.extend(true, [], indicator._points);
                /////////////////////////////////////////

                //MACD Histogram: MACD Line - Signal Line
                var histogramSeries = $.extend(true, {}, indicator);
                histogramSeries.border = {};
                histogramSeries.name = "histogramSeries";
                histogramSeries.fill = indicator.histogram.fill;
                histogramSeries.opacity = indicator.histogram.opacity;
                histogramSeries.fill = indicator.histogram.fill;
                histogramSeries.border = indicator.histogram.border;
                histogramSeries.type = "column";
                histogramSeries.xAxis = indicator.xAxis;
                histogramSeries.yAxis = indicator.yAxis;

                for (var j = 0, k = l; k < pointsLength; j++ , k++)
                    histogramPoints.push((macdPoints[j + (trigger - 1)]) - (signalEMA[j]));
                for (var j = 0, k = l; k < pointsLength; j++ , k++) {
                    indicator._points[k].YValues[0] = indicator._points[k].y = histogramPoints[j];
                }
                histogramSeries.points = $.extend(true, [], indicator._points);
                var xValues = sender._getXValues(macdSeries.points);
                indicator.xRange.min = Math.min.apply(Math, xValues);
                indicator.xRange.max = Math.max.apply(Math, xValues);

                switch (indicator.macdType) {
                    case "line":
                        {
                            //Push MACD Line
                            indicator.yRange.min = Math.min.apply(Math, macdPoints);
                            indicator.yRange.max = Math.max.apply(Math, macdPoints);
                            indicator.segment.push(macdSeries);

                            //Push Signal Line
                            var min = Math.min.apply(Math, signalEMA), max = Math.max.apply(Math, signalEMA);
                            indicator.yRange.min = indicator.yRange.min < min ? indicator.yRange.min : min;
                            indicator.yRange.max = indicator.yRange.max > max ? indicator.yRange.max : max;
                            indicator.segment.push(trendSeries);
                        }
                        break;
                    case "histogram":
                        {
                            //Push histogram Series
                            var min1 = Math.min.apply(Math, histogramPoints), max1 = Math.max.apply(Math, histogramPoints);
                            indicator.yRange.min = indicator.yRange.min < min1 ? indicator.yRange.min : min1;
                            indicator.yRange.max = indicator.yRange.max > max1 ? indicator.yRange.max : max1;
                            indicator.segment.push(histogramSeries);
                        }
                        break;
                    case "both":
                        {
                            //Push histogram Series
                            var min1 = Math.min.apply(Math, histogramPoints), max1 = Math.max.apply(Math, histogramPoints);
                            indicator.yRange.min = indicator.yRange.min < min1 ? indicator.yRange.min : min1;
                            indicator.yRange.max = indicator.yRange.max > max1 ? indicator.yRange.max : max1;
                            indicator.segment.push(histogramSeries);

                            //Push MACD Line 
                            indicator.yRange.min = Math.min.apply(Math, macdPoints);
                            indicator.yRange.max = Math.max.apply(Math, macdPoints);
                            indicator.segment.push(macdSeries);

                            //Push Signal Line
                            var min = Math.min.apply(Math, signalEMA), max = Math.max.apply(Math, signalEMA);
                            indicator.yRange.min = indicator.yRange.min < min ? indicator.yRange.min : min;
                            indicator.yRange.max = indicator.yRange.max > max ? indicator.yRange.max : max;
                            indicator.segment.push(trendSeries);
                        }
                        break;
                }
                this.calculateIndicatorRange(sender, indicator);
            }
        },
        calculateEMA: function (points, period, flag) {
            var sma = 0;
            var initialEMA = 0;
            var pointsLength = points.length;
            var getPoints = [];
            var getEma = [];
            var emaPercent = (2 / (period + 1));
            if (flag) { // calculating EMA for Indicators Points
                for (var i = 0; i < period; i++) {
                    getPoints.push(points[i].close);
                    sma = sma + getPoints[i];
                }

                initialEMA = (sma / period);
                getEma.push(initialEMA);
                var emaAvg = initialEMA;
                for (var j = period; j < pointsLength; j++) {
                    emaAvg = (points[j].close - emaAvg) * emaPercent + emaAvg;
                    getEma.push(emaAvg);
                }
            } else { //Calculating EMA for Signal Points
                for (var i = 0; i < period; i++) {
                    getPoints.push(points[i]);
                    sma = sma + getPoints[i];
                }

                initialEMA = (sma / period);
                getEma.push(initialEMA);
                var emaAvg = initialEMA;
                for (var j = period; j < pointsLength; j++) {
                    emaAvg = (points[j] - emaAvg) * emaPercent + emaAvg;
                    getEma.push(emaAvg);
                }
            }
            return getEma;
        }

    });

    sf.indicatorTypes.macd = sf.ejMACD;
    sf.ejSMA = ejExtendClass(sf.EjIndicatorRender, {


        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};



            // signalLine
            var trendSeries = $.extend(true, {}, indicator);
            trendSeries.name = "trendSeries";
            trendSeries.width = indicator.width;
            trendSeries.fill = indicator.fill;
            trendSeries.type = "line";

            //variable declaration
            var closevalues = [];
            var smavalues = [];
            var trendPoints = [];
            var sum, xValues;
            var length = indicator._points.length;
            var period = indicator.period;

            if (period <= 0 || length < period) return;

            //Push the Close values
            for (var i = 0; i < length; i++) {

                closevalues.push(indicator._points[i].close);

            }

            var close_length = closevalues.length;
            //calculation for SMA values


            while (close_length >= period) {
                sum = 0;
                for (var j = 0; j < period; j++) {
                    sum = sum + closevalues[j];

                }
                sum = sum / period;
                smavalues.push(sum);
                closevalues.splice(0, 1);
                close_length = closevalues.length;
            }


            //set the SMA values to Y-Axis
            for (var k = 0; k < length; k++) {
                if (k < period - 1) {
                    indicator._points[k].YValues[0] = indicator._points[k].y = null;

                }
                else {
                    indicator._points[k].YValues[0] = indicator._points[k].y = smavalues[k - (period - 1)];
                }

            }


            trendSeries.points = $.extend(true, [], indicator._points);
            var xValues = sender._getXValues(trendSeries.points);

            //Assign the Y-Axis values into trendPoints
            for (var i = period - 1, j = 0; i < trendSeries.points.length; i++ , j++) {
                trendPoints[j] = trendSeries.points[i].y;
            }

            //X-Axis and Y-Axis range calculation
            indicator.xRange.min = Math.min.apply(Math, xValues);
            indicator.xRange.max = Math.max.apply(Math, xValues);
            indicator.yRange.min = Math.min.apply(Math, trendPoints);
            indicator.yRange.max = Math.max.apply(Math, trendPoints);

            //push trendSeries
            indicator.segment.push(trendSeries);
            this.calculateIndicatorRange(sender, indicator);


        }

    });

    sf.indicatorTypes.sma = sf.ejSMA;

    sf.ejEMA = ejExtendClass(sf.EjIndicatorRender, {


        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};



            // signalLine

            var trendSeries = $.extend(true, {}, indicator);
            trendSeries.name = "trendSeries";
            trendSeries.type = "line";
            trendSeries.xAxis = indicator.xAxis;
            trendSeries.yAxis = indicator.yAxis;


            var getCloseValues = [];
            var ema = [];
            var pointsLength = indicator._points.length;
            var period = indicator.period;
            var sma = 0, xValues;
            if (pointsLength < period || period <= 0) return;
            // K=Smoothing Factor
            var k = (2 / (period + 1));

            //Get a close Values and push the previous Ema 
            for (var i = 0; i < period; i++) {
                getCloseValues.push(indicator._points[i].close);
                sma = sma + getCloseValues[i];
            }
            ema.push(sma / period);

            //Find Remaining EMA by Adding smoothing factor K to the close values
            for (j = period; j < pointsLength; j++) {
                ema.push((indicator._points[j].close - ema[j - period]) * k + ema[j - period]);
            }

            // Set Ema to the Indicator Points

            for (var t = 0; t < pointsLength; t++) {
                if (t < (period - 1)) {
                    indicator._points[t].YValues[0] = indicator._points[t].y = null;
                }
                else if (t >= (period - 1)) {
                    indicator._points[t].YValues[0] = indicator._points[t].y = ema[t - (period - 1)];
                }
            }

            // Send the indicator Points for draw series.
            trendSeries.points = $.extend(true, [], indicator._points);
            xValues = sender._getXValues(trendSeries.points);
            var trendPoints = [];
            for (var i = period, j = 0; i < trendSeries.points.length; i++ , j++)
                trendPoints[j] = trendSeries.points[i].y;

            indicator.xRange.min = Math.min.apply(Math, xValues);
            indicator.xRange.max = Math.max.apply(Math, xValues);
            indicator.yRange.min = Math.min.apply(Math, trendPoints);
            indicator.yRange.max = Math.max.apply(Math, trendPoints);

            indicator.segment.push(trendSeries);
            this.calculateIndicatorRange(sender, indicator);


        }

    });

    sf.indicatorTypes.ema = sf.ejEMA;


    sf.ejSTOCHASTIC = ejExtendClass(sf.EjIndicatorRender, {

        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};
            var KPeriod = indicator.kPeriod;
            var DPeriod = indicator.dPeriod;
            var Period = indicator.period;
            if (Period < 1 || DPeriod < 1 || KPeriod < 1) return;
            if (Period > indicator._points.length || DPeriod > indicator._points.length || KPeriod > indicator._points.length) return;
            // Upper Line Calculation
            var upperSeries = $.extend(true, {}, indicator);
            upperSeries.name = "upperseries";
            upperSeries.type = "line";
            upperSeries.fill = indicator.upperLine.fill;
            upperSeries.width = indicator.upperLine.width;

            for (var k = 0; k < indicator._points.length; k++) {
                indicator._points[k].YValues.length = 1;
                indicator._points[k].YValues[0] = indicator._points[k].y = 80;
            }

            upperSeries.points = $.extend(true, [], indicator._points);
            var xValues = sender._getXValues(upperSeries.points);
            var yValues = sender._getYValues(upperSeries.points);

            indicator.xRange.min = Math.min.apply(Math, xValues);
            indicator.xRange.max = Math.max.apply(Math, xValues);
            indicator.yRange.min = Math.min.apply(Math, yValues);
            indicator.yRange.max = Math.max.apply(Math, yValues);

            indicator.segment.push(upperSeries);
            // End for Upper Line Calculation

            // Lower Line Calculation
            var lowerSeries = $.extend(true, {}, indicator);
            lowerSeries.name = "lowerSeries";
            lowerSeries.width = indicator.lowerLine.width;
            lowerSeries.fill = indicator.lowerLine.fill;
            lowerSeries.type = "line";


            for (var n = 0; n < indicator._points.length; n++) {
                indicator._points[n].YValues[0] = indicator._points[n].y = 20;
            }

            lowerSeries.points = $.extend(true, [], indicator._points);

            xValues = sender._getXValues(lowerSeries.points);
            yValues = sender._getYValues(lowerSeries.points);

            indicator.xRange.min = Math.min(Math.min.apply(Math, xValues), indicator.xRange.min);
            indicator.xRange.max = Math.max(Math.max.apply(Math, xValues), indicator.xRange.max);
            indicator.yRange.min = Math.min(Math.min.apply(Math, yValues), indicator.yRange.min);
            indicator.yRange.max = Math.max(Math.max.apply(Math, yValues), indicator.yRange.max);

            indicator.segment.push(lowerSeries);
            // End for Lower Line Calculation

            // Signal and Period Line Calculation

            var periodSeries = $.extend(true, {}, indicator);
            periodSeries.name = "periodSeries";
            periodSeries.width = indicator.periodLine.width;
            periodSeries.fill = indicator.periodLine.fill;
            periodSeries.type = "line";

            var HighValues = [];
            var LowValues = [];
            var CloseValues = [];
            var check = [];
            for (var i = 0; i < indicator._points.length; i++) {
                LowValues[i] = indicator._points[i].low;
                HighValues[i] = indicator._points[i].high;
                CloseValues[i] = indicator._points[i].close;
            }


            AddPoints(Period, KPeriod, indicator._points);
            check = indicator._points;
            SMA(Period, KPeriod, indicator._points);
            check = indicator._points;
            periodSeries.points = $.extend(true, [], indicator._points);

            xValues = sender._getXValues(periodSeries.points);
            yValues = sender._getYValues(periodSeries.points);

            indicator.xRange.min = Math.min(Math.min.apply(Math, xValues), indicator.xRange.min);
            indicator.xRange.max = Math.max(Math.max.apply(Math, xValues), indicator.xRange.max);
            indicator.yRange.min = Math.min(Math.min.apply(Math, yValues), indicator.yRange.min);
            indicator.yRange.max = Math.max(Math.max.apply(Math, yValues), indicator.yRange.max);

            indicator.segment.push(periodSeries);


            var trendSeries = $.extend(true, {}, indicator);
            trendSeries.name = "trendSeries";
            trendSeries.width = indicator.width;
            trendSeries.fill = indicator.fill;
            trendSeries.type = "line";

            SMA((Period + KPeriod - 1), DPeriod, indicator._points);
            trendSeries.points = $.extend(true, [], indicator._points);

            indicator.segment.push(trendSeries);

            ///SMA Calculation(Signal Line and Period Line)

            function SMA(Period1, Period2, series) {
                if (indicator._points.length >= Period1 + Period2) {
                    SMACal(Period1, Period2, series);
                }
            }

            function SMACal(period1, period2, series) {
                var count = period1 + (period2 - 1);
                var temp = [];
                var values = [];
                var sum;
                for (var i = 0; i < indicator._points.length; i++) {
                    var val = check[i].y;
                    temp.push(val);
                }
                var length = temp.length;

                while (length >= count) {
                    sum = 0;
                    for (var j = period1 - 1; j < (period1 + period2 - 1); j++) {
                        sum = sum + temp[j];

                    }
                    sum = sum / period2;
                    values.push(sum.toFixed(2));
                    temp.splice(0, 1);
                    length = temp.length;
                }
                var len = count - 1;
                for (var k = 0; k < indicator._points.length; k++) {
                    if (k < len) {
                        series[k].YValues[0] = series[k].y = null;

                    }
                    else {
                        series[k].YValues[0] = series[k].y = Number((values[k - len]));
                    }

                }

            }

            // End for SMA Calculation

            // Period Line Calculation

            function AddPoints(Period1, Period2, series) {
                if (indicator._points.length > Period1) {
                    ComputeStochastics(Period1, Period2, series);
                }
            }
            function ComputeStochastics(len1, len2, series) {
                var len = len1 + len2;
                var mins = [];
                var maxs = [];
                var max;
                var min;
                var top = 0;
                var bottom = 0;
                for (var i = 0; i < len1 - 1; ++i) {
                    maxs.push(0);
                    mins.push(0);
                }

                for (var i = len1 - 1; i < indicator._points.length; ++i) {
                    min = Number.MAX_VALUE;
                    max = Number.MIN_VALUE;
                    for (var j = 0; j < len1; ++j) {
                        min = Math.min(min, LowValues[i - j]);
                        max = Math.max(max, HighValues[i - j]);
                    }
                    maxs.push(max);
                    mins.push(min);
                }

                for (var i = 0; i < len - 1; ++i) {
                    series[i].YValues.length = 1;
                    series[i].YValues[0] = series[i].y = null;
                }

                for (var i = len1 - 1; i < indicator._points.length; ++i) {
                    top = 0;
                    bottom = 0;
                    top += CloseValues[i] - mins[i];
                    bottom += maxs[i] - mins[i];
                    series[i].YValues.length = 1;
                    series[i].YValues[0] = series[i].y = (((top / bottom) * 100));
                }
            }

            // End for Period Line Calculation

            // Indicator Axis Range Calculation
            this.calculateIndicatorRange(sender, indicator);
        }


    });
    sf.indicatorTypes.stochastic = sf.ejSTOCHASTIC;
    sf.ejbollingerBand = ejExtendClass(sf.EjIndicatorRender, {
        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};
            var sum = 0.0;
            var deviationSum = 0.0;
            var limit = indicator._points.length;
            var multiplier = indicator.standardDeviations;
            var movingavg = indicator.period;
            var length = Math.round(movingavg);
            var smaPoints = [];
            var deviations = [];
            var bbiPoints = [];
            //Calculating simple moving average
            if ((length < limit) && (length > 0)) {
                for (var i = 0; i < length; i++) {
                    sum += indicator._points[i].close;

                }
                var sma = sum / movingavg;
                //Calculating smapoints using iteration
                for (var i = 0; i < limit; ++i) {
                    if (i >= length - 1 && i < limit) {
                        if (i - movingavg >= 0) {
                            var diff = indicator._points[i].close - indicator._points[i - length].close;

                            sum = sum + diff;
                            sma = sum / (movingavg);
                            smaPoints[i] = sma;
                            deviations[i] = Math.pow(indicator._points[i].close - sma, 2);
                            deviationSum += deviations[i] - deviations[i - length];


                        }
                        else {

                            smaPoints[i] = sma;
                            deviations[i] = Math.pow(indicator._points[i].close - sma, 2);
                            deviationSum += deviations[i];
                        }


                        //calculation for standarddeviation for each period

                        var range = Math.sqrt(deviationSum / (movingavg));

                        //lower Band points for bollinger band
                        var lb = smaPoints[i] - (multiplier * range);
                        //upper Band points for bollinger band
                        var ub = smaPoints[i] + (multiplier * range);
                        //Binding the lowerband,upperband and middleband values to bollingerband array if the i value equal to period
                        if (i + 1 == length) {
                            for (var j = 0; j < length - 1; j++)
                                bbiPoints[j] = { "X": indicator._points[j].X, "mb": smaPoints[i], "lb": lb, "ub": ub, visible: true };



                        }
                        //binding the lb,ub,mb values to bollinger band array if i greather than period value.
                        bbiPoints[i] = { "X": indicator._points[i].X, "mb": smaPoints[i], "lb": lb, "ub": ub, visible: true };


                    }


                    else {
                        if (i < movingavg - 1) {

                            smaPoints[i] = sma;
                            deviations[i] = Math.pow(indicator._points[i].close - sma, 2);
                            deviationSum += deviations[i];
                        }


                    }

                }


                var upperSeries = $.extend(true, {}, indicator);
                upperSeries.name = "upperseries";
                upperSeries.fill = indicator.upperLine.fill;
                upperSeries.width = indicator.upperLine.width;
                upperSeries.type = "line";

                //binding bollingerband array values to upper series and assigning null values 
                for (var k = 0; k < indicator._points.length; k++) {
                    if (k >= (length - 1)) {
                        indicator._points[k].YValues.length = 1;
                        indicator._points[k].YValues[0] = indicator._points[k].y = bbiPoints[k].ub;
                    }
                    else {
                        indicator._points[k].YValues[0] = indicator._points[k].y = null;
                    }
                }

                upperSeries.points = $.extend(true, [], indicator._points);
                var xValues = sender._getXValues(upperSeries.points);
                var values = [];
                //storing the y values from the period value
                for (var i = length; i < upperSeries.points.length; i++)
                    values.push(upperSeries.points[i].y);
                var yValues = values;
                indicator.xRange.min = Math.min.apply(Math, xValues);
                indicator.xRange.max = Math.max.apply(Math, xValues);
                indicator.yRange.min = Math.min.apply(Math, yValues);
                indicator.yRange.max = Math.max.apply(Math, yValues);

                indicator.segment.push(upperSeries);


                var lowerSeries = $.extend(true, {}, indicator);
                lowerSeries.name = "lowerSeries";
                lowerSeries.width = indicator.lowerLine.width;
                lowerSeries.fill = indicator.lowerLine.fill;
                lowerSeries.type = "line";


                for (var n = 0; n < indicator._points.length; n++) {
                    if (n >= (length - 1)) {
                        indicator._points[n].YValues.length = 1;
                        indicator._points[n].YValues[0] = indicator._points[n].y = bbiPoints[n].lb;
                    }
                    else {
                        indicator._points[n].YValues[0] = indicator._points[n].y = null;
                    }
                }


                lowerSeries.points = $.extend(true, [], indicator._points);

                xValues = sender._getXValues(lowerSeries.points);

                var lowvalues = [];
                for (var i = length; i < lowerSeries.points.length; i++)
                    lowvalues.push(lowerSeries.points[i].y);
                var yValues = lowvalues;

                indicator.xRange.min = Math.min(Math.min.apply(Math, xValues), indicator.xRange.min);
                indicator.xRange.max = Math.max(Math.max.apply(Math, xValues), indicator.xRange.max);
                indicator.yRange.min = Math.min(Math.min.apply(Math, yValues), indicator.yRange.min);
                indicator.yRange.max = Math.max(Math.max.apply(Math, yValues), indicator.yRange.max);

                indicator.segment.push(lowerSeries);



                var trendSeries = $.extend(true, {}, indicator);
                trendSeries.name = "trendSeries";
                trendSeries.width = indicator.width;
                trendSeries.fill = indicator.fill;
                trendSeries.type = "line";

                for (var m = 0; m < indicator._points.length; m++) {
                    if (m >= (length - 1)) {
                        indicator._points[m].YValues.length = 1;
                        indicator._points[m].YValues[0] = indicator._points[m].y = bbiPoints[m].mb;
                    }
                    else {
                        indicator._points[m].YValues[0] = indicator._points[m].y = null;
                    }
                }
                trendSeries.points = $.extend(true, [], indicator._points);
                xValues = sender._getXValues(trendSeries.points);
                var trendvalues = [];
                for (var i = length; i < trendSeries.points.length; i++)
                    trendvalues.push(trendSeries.points[i].y);
                var yValues = trendvalues;

                indicator.xRange.min = Math.min(Math.min.apply(Math, xValues), indicator.xRange.min);
                indicator.xRange.max = Math.max(Math.max.apply(Math, xValues), indicator.xRange.max);
                indicator.yRange.min = Math.min(Math.min.apply(Math, yValues), indicator.yRange.min);
                indicator.yRange.max = Math.max(Math.max.apply(Math, yValues), indicator.yRange.max);
                indicator.segment.push(trendSeries);
                //calculating indicator range
                this.calculateIndicatorRange(sender, indicator);
            }
        }

    });
    sf.indicatorTypes.bollingerband = sf.ejbollingerBand;
    sf.ejATR = ejExtendClass(sf.EjIndicatorRender, {
        calculateSegment: function (indicator, sender) {
            //calculation for atr
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};
            var atrPoints = [];
            var high_Low, high_ClosePrevious, low_ClosePrevious;
            high_Low = high_ClosePrevious = low_ClosePrevious = 0.0;
            var trueRange;
            var sumTruRange = 0.0;
            var firstFlag = false;
            var atr;
            var period = indicator.period;
            if ((period <= 0) || (period > indicator._points.length))
                return;
            for (var i = 0; i < period; i++) {

                high_Low = indicator._points[i].high - indicator._points[i].low;
                if (i > 0) {
                    high_ClosePrevious = Math.abs(indicator._points[i].high - indicator._points[i - 1].close);
                    low_ClosePrevious = Math.abs(indicator._points[i].low - indicator._points[i - 1].close);
                }

                trueRange = Math.max(high_Low, high_ClosePrevious, low_ClosePrevious);

                sumTruRange += trueRange;
                atr = (sumTruRange / period);

                atrPoints[i] = { "X": indicator._points[i].X, "YValues": atr };

            }

            for (var i = period; i < indicator._points.length; ++i) {
                high_Low = indicator._points[i].high - indicator._points[i].low;
                high_ClosePrevious = Math.abs(indicator._points[i].high - indicator._points[i - 1].close);
                low_ClosePrevious = Math.abs(indicator._points[i].low - indicator._points[i - 1].close);
                trueRange = Math.max(high_Low, high_ClosePrevious, low_ClosePrevious);

                atr = (atrPoints[i - 1].YValues * (period - 1) + trueRange) / period;

                atrPoints[i] = {
                    "X": indicator._points[i].X, "YValues": atr
                };

            }



            var trendSeries = $.extend(true, {}, indicator);


            trendSeries.name = "trendSeries";
            trendSeries.width = indicator.width;
            trendSeries.fill = indicator.fill;
            trendSeries.type = "line";



            for (var k = 0; k < indicator._points.length; k++) {
                if (k >= (period - 1)) {
                    indicator._points[k].YValues.length = 1;
                    indicator._points[k].YValues[0] = indicator._points[k].y = atrPoints[k].YValues;
                }
                else {
                    indicator._points[k].YValues[0] = indicator._points[k].y = null;
                }
            }



            trendSeries.points = $.extend(true, [], indicator._points);

            var xValues = sender._getXValues(trendSeries.points);

            var values = [];
            for (var i = period; i < trendSeries.points.length; i++)
                values.push(trendSeries.points[i].y);

            indicator.xRange.min = Math.min.apply(Math, xValues);
            indicator.xRange.max = Math.max.apply(Math, xValues);
            indicator.yRange.min = Math.min.apply(Math, values);
            indicator.yRange.max = Math.max.apply(Math, values);

            indicator.segment.push(trendSeries);


            this.calculateIndicatorRange(sender, indicator);



        }

    });
    sf.indicatorTypes.atr = sf.ejATR;

    sf.ejaccumulationDistribution = ejExtendClass(sf.EjIndicatorRender, {
        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};
            var adlPoints = [];
            var sum = 0;
            //calculating accumulation distribution line points 
            for (var i = 0; i < indicator._points.length; i++) {
                var close = indicator._points[i].close;

                var value = (((close - indicator._points[i].low) - (indicator._points[i].high - close)) / (indicator._points[i].high - indicator._points[i].low));
                sum += (isNaN(value) ? 0 : value) * indicator._points[i].volume;
                adlPoints[i] = sum;

            }
            var trendSeries = $.extend(true, {}, indicator);
            trendSeries.name = "trendseries";
            trendSeries.fill = indicator.fill;
            trendSeries.width = indicator.width;
            trendSeries.type = "line";

            //Binding the accumulation distribution array values to indicator y values
            for (var k = 0; k < indicator._points.length; k++) {

                indicator._points[k].YValues[0] = indicator._points[k].y = adlPoints[k];
            }

            trendSeries.points = $.extend(true, [], indicator._points);
            var xValues = sender._getXValues(trendSeries.points);
            var yValues = sender._getYValues(trendSeries.points);

            indicator.xRange.min = Math.min.apply(Math, xValues);
            indicator.xRange.max = Math.max.apply(Math, xValues);
            indicator.yRange.min = Math.min.apply(Math, yValues);
            indicator.yRange.max = Math.max.apply(Math, yValues);

            indicator.segment.push(trendSeries);
            //calculating indicator range
            this.calculateIndicatorRange(sender, indicator);


        }

    });
    sf.indicatorTypes.accumulationdistribution = sf.ejaccumulationDistribution;
    sf.ejTMA = ejExtendClass(sf.EjIndicatorRender, {
        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};

            // signalLine
            var trendSeries = $.extend(true, {}, indicator);
            trendSeries.name = "trendSeries";
            trendSeries.width = indicator.width;
            trendSeries.fill = indicator.fill;
            trendSeries.type = "line";

            //variable declaration
            var closevalues = [];
            var close_values = [];
            var smavalues = [];
            var tmavalues = [];
            var smaPoints = [];
            var trendPoints = [];
            var sum = 0;
            var sum1;
            var length = indicator._points.length;
            var period = indicator.period;
            if (period < 1) return;

            if (period < length) {
                //Push the values to closevalues array
                for (var i = 0; i < length; i++) {
                    closevalues.push(indicator._points[i].close);
                }
                //find the closevalues length
                var close_length = closevalues.length;

                //calculation for SMA values

                while (close_length >= period) {
                    sum = 0;
                    for (var j = 0; j < period; j++) {
                        sum = sum + closevalues[j];

                    }
                    sum = sum / period;
                    smavalues.push(parseFloat(sum.toFixed(2)));
                    closevalues.splice(0, 1);
                    close_length = closevalues.length;
                }
                //calculating sma values depend on period
                for (var k = 0; k < length; k++) {
                    if (k < period - 1) {
                        sum = 0;
                        for (var j = 0; j < k + 1; j++) {
                            sum = sum + indicator._points[j].close;

                        }
                        sum = sum / (k + 1);
                        smaPoints[k] = parseFloat(sum.toFixed(2));
                    }
                    else {
                        smaPoints[k] = smavalues[k - (period - 1)];
                    }

                }
                //find the smavalues count
                var sma_count = smaPoints.length;
                //calculating TMA values
                while (sma_count >= period) {
                    sum1 = 0;
                    for (var j = 0; j < period; j++) {
                        sum1 = sum1 + smaPoints[j];

                    }
                    sum1 = sum1 / period;
                    tmavalues.push(sum1);
                    smaPoints.splice(0, 1);
                    sma_count = smaPoints.length;
                }
                //set the TMA values to Y-Axis
                for (var k = 0; k < length; k++) {
                    if (k < period - 1) {
                        indicator._points[k].YValues[0] = indicator._points[k].y = null;

                    }
                    else {
                        indicator._points[k].YValues[0] = indicator._points[k].y = tmavalues[k - (period - 1)];

                    }

                }
                trendSeries.points = $.extend(true, [], indicator._points);
                var xValues = sender._getXValues(trendSeries.points);

                //Assign the Y-Axis values into trendPoints
                for (var i = period - 1, j = 0; i < trendSeries.points.length; i++ , j++) {
                    trendPoints[j] = trendSeries.points[i].y;
                }

                //X-Axis and Y-Axis range calculation
                indicator.xRange.min = Math.min.apply(Math, xValues);
                indicator.xRange.max = Math.max.apply(Math, xValues);
                indicator.yRange.min = Math.min.apply(Math, trendPoints);
                indicator.yRange.max = Math.max.apply(Math, trendPoints);

                //push trendSeries
                indicator.segment.push(trendSeries);
                this.calculateIndicatorRange(sender, indicator);


            }
        }
    });
    sf.indicatorTypes.tma = sf.ejTMA;

    sf.ejMomentum = ejExtendClass(sf.EjIndicatorRender, {
        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};

            //Upperband 
            var upperSeries = $.extend(true, {}, indicator);
            upperSeries.name = "upperseries";
            upperSeries.fill = indicator.upperLine.fill;
            upperSeries.width = indicator.upperLine.width;
            upperSeries.type = "line";

            var period = indicator.period;
            var pointsLength = indicator._points.length;

            if (period > 0 && period < pointsLength - 1) {  // to check period value is greater than 0 and it is less than pointslength
                for (var k = 0; k < pointsLength; k++) {
                    indicator._points[k].YValues.length = 1;
                    indicator._points[k].YValues[0] = indicator._points[k].y = 100;
                }

                upperSeries.points = $.extend(true, [], indicator._points);
                var xValues = sender._getXValues(upperSeries.points);
                var yValues = sender._getYValues(upperSeries.points);

                indicator.xRange.min = Math.min.apply(Math, xValues);
                indicator.xRange.max = Math.max.apply(Math, xValues);
                indicator.yRange.min = Math.min.apply(Math, yValues);
                indicator.yRange.max = Math.max.apply(Math, yValues);

                indicator.segment.push(upperSeries);

                // signalLine
                var trendSeries = $.extend(true, {}, indicator);
                trendSeries.name = "trendSeries";
                trendSeries.width = indicator.width;
                trendSeries.fill = indicator.fill;
                trendSeries.type = "line";

                var c = [];
                var len = indicator.period;      // period value

                for (var i = 0; i < indicator._points.length; ++i) {
                    var points = indicator._points;
                    if (!(i < len))                                       // calculate signal line points
                        indicator._points[i].YValues[0] = indicator._points[i].y = (points[i].close / (points[i - len].close) * 100);
                }

                for (var k = 0; k < len && k < indicator._points.length; k++) {
                    indicator._points[k].YValues[0] = indicator._points[k].y = null;
                }

                trendSeries.points = $.extend(true, [], indicator._points);
                xValues = sender._getXValues(trendSeries.points);
                var trendPoints = [];
                for (var i = len, j = 0; i < trendSeries.points.length; i++ , j++) {
                    trendPoints[j] = trendSeries.points[i].y;
                }

                indicator.xRange.min = Math.min(Math.min.apply(Math, xValues), indicator.xRange.min);
                indicator.xRange.max = Math.max(Math.max.apply(Math, xValues), indicator.xRange.max);
                indicator.yRange.min = Math.min(Math.min.apply(Math, trendPoints), indicator.yRange.min);
                indicator.yRange.max = Math.max(Math.max.apply(Math, trendPoints), indicator.yRange.max);

                indicator.segment.push(trendSeries);
                this.calculateIndicatorRange(sender, indicator);
            }
        }
    });

    sf.indicatorTypes.momentum = sf.ejMomentum;

    sf.EjSeriesRender.prototype = {

        getOrigin: function (chart, options, params) {
            if (params.axes[options.xAxis.name]._validCross) {
                var crossAxis = chart.chartObj._getCrossAxis(chart.chartObj.model._axes, true, options.xAxis.crossesInAxis);
                if ((chart.chartObj.model.requireInvertedAxes ? options.xAxis.name : options.yAxis.name === crossAxis.name))
                    return options.xAxis._crossValue;
            }
            if (options.type.toLowerCase() == "splinerangearea")
                return Math.max(options.points[0].YValues[1], 0)
            else
            return Math.max(options.yAxis.visibleRange.min, 0);
        },

        setLineSeriesStyle: function (currentSeries) {

            var seriesIndex = $.inArray(currentSeries, this.chartObj.model._visibleSeries);
            var serColor = this.chartObj.model.seriesColors[seriesIndex], seriesInterior;

            if (!currentSeries.isTransposed)
                seriesInterior = this.chartObj.svgRenderer.createGradientElement(this.getSeriesName(currentSeries) + seriesIndex, serColor, 0, 0, 0, 100, this.chartObj.gSeriesEle);
            else
                seriesInterior = this.chartObj.svgRenderer.createGradientElement(this.getSeriesName(currentSeries) + seriesIndex, serColor, 100, 0, 0, 0, this.chartObj.gSeriesEle);
            var seriesBorder = this.chartObj.model.seriesBorderColors[seriesIndex];
            return { SeriesInterior: seriesInterior, SeriesBorder: seriesBorder };

        },
        getSeriesName: function (series) {
            var serName;
            if (series.name)
                serName = series.name.replace(/\s/g, '');
            else
                serName = "series";

            return serName;
        },

        drawAreaPath: function (series, style, direction, canvasTranslate) {
            var requireInvertedAxes = this.chartObj.model.requireInvertedAxes,
                seriesIndex = $.inArray(series, this.chartObj.model._visibleSeries),
                translate = null, areaType = this.chartObj.model.AreaType, seriesBorder = series.border;
            if (areaType == "cartesianaxes") {
                var trans = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);
                translate = 'translate(' + trans.x + ',' + trans.y + ')'
            }
            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': translate };

            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
            if (direction != "") {
                var options = {
                    'id': this.chartObj.svgObject.id + "_Series" + seriesIndex,
                    'fill': style.SeriesInterior,
                    'fill-opacity': series.opacity,
                    'stroke-width': seriesBorder.width,
                    'stroke': seriesBorder.color,
                    'stroke-dasharray': seriesBorder.dashArray,
                    'stroke-linecap': series.lineCap,
                    'stroke-linejoin': series.lineJoin,
                    'd': direction
                };
                if (this.chartObj.dragPoint) {
                    options.id = this.chartObj.svgObject.id + "_PreviewSeries" + seriesIndex;
                    options['fill-opacity'] = 0.6;
                    if (this.chartObj.model.enableCanvasRendering) this.chartObj.svgRenderer.drawPath(options, this.chartObj.canvasElement, canvasTranslate);
                    else this.chartObj.svgRenderer.drawPath(options, this.chartObj.gPreviewSeriesGroupEle, canvasTranslate);
                }
                else
                    this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle, canvasTranslate);
            }
        },

        setAreaSeriesStyle: function (series) {

            var seriesIndex = $.inArray(series, this.chartObj.model._visibleSeries);
            var serColor = this.chartObj.model.seriesColors[seriesIndex], seriesInterior;

            if (!series.isTransposed)
                seriesInterior = this.chartObj.svgRenderer.createGradientElement(this.getSeriesName(series) + seriesIndex, serColor, 0, 0, 0, 100, this.chartObj.gSeriesEle);
            else
                seriesInterior = this.chartObj.svgRenderer.createGradientElement(this.getSeriesName(series) + seriesIndex, serColor, 100, 0, 0, 0, this.chartObj.gSeriesEle);
            return { SeriesInterior: seriesInterior };

        },





        naturalSpline: function (points, series, yIndex, axis) {
            var count = points.length, dx = [], dy = [], slope = [];
            var ySpline = [], ySplineDuplicate = [];
            var cardinalSplineTension = sf.util.isNullOrUndefined(series.cardinalSplineTension) ? 0.5 : series.cardinalSplineTension < 0 ? 0 : series.cardinalSplineTension > 1 ? 1 : series.cardinalSplineTension;
            var index = series.type.toLowerCase() == "splinerangearea" ? yIndex : 0;
			if(axis && axis._valueType == 'datetime'){
				var seriesPoints = points;
				for(var p = 0; p< seriesPoints.length; p++){
					var yPoint = seriesPoints[p].YValues[0];
					if(typeof yPoint == "object")
						seriesPoints[p].YValues[0] = Date.parse(yPoint);
				}
			}
            if (series.splineType == "monotonic") {
                for (var i = 0; i < count - 1; i++) {
                    //slope calculation                
                    dx[i] = points[i + 1].xValue - points[i].xValue;
                    dy[i] = points[i + 1].YValues[index] - points[i].YValues[index];
                    slope[i] = dy[i] / dx[i];
                }
                //interpolant points
                var slopeLength = slope.length, interPoint;
                // to find the first and last co-efficient value
                ySpline[0] = slope[0];
                ySpline[count - 1] = slope[slopeLength - 1];

                //to find the other co-efficient values
                for (var j = 0; j < dx.length; j++) {
                    if (slopeLength > j + 1) {
                        if (slope[j] * slope[j + 1] <= 0)
                            ySpline[j + 1] = 0;
                        else {
                            interPoint = dx[j] + dx[j + 1];
                            ySpline[j + 1] = 3 * interPoint / ((interPoint + dx[j + 1]) / slope[j] + (interPoint + dx[j]) / slope[j + 1]);
                        }

                    }
                }
            }
            else if (series.splineType == "cardinal") {
                for (var i = 0; i < count; i++) {
                    if (i == 0)
                        ySpline[i] = (count > 2) ? (cardinalSplineTension * (points[i + 2].xValue - points[i].xValue)) : 0;
                    else if (i == (count - 1))
                        ySpline[i] = (count > 2) ? (cardinalSplineTension * (points[count - 1].xValue - points[count - 3].xValue)) : 0;
                    else
                        ySpline[i] = (cardinalSplineTension * (points[i + 1].xValue - points[i - 1].xValue));
                }


            }
            else {
                var a = 6;
                if (series.splineType == "clamped") {
                    // calculating the first and last index value for clamped spline series type					
                    var firstIndex = (points[1].xValue - points[0].xValue) / (points[1].YValues[index] - points[0].YValues[index]);
                    var lastIndex = (points[count - 1].xValue - points[count - 2].xValue) / (points[count - 1].YValues[index] - points[count - 2].YValues[index]);
                    ySpline[0] = (3 * (points[1].YValues[index] - points[0].YValues[index])) / (points[1].xValue - points[0].xValue) - 3 * firstIndex;
                    ySplineDuplicate[0] = 0.5;
                    ySpline[points.length - 1] = 3 * lastIndex - (3 * (points[points.length - 1].YValues[index] - points[points.length - 2].YValues[index])) / (points[points.length - 1].xValue - points[points.length - 2].xValue);
                    ySpline[0] = Math.abs(ySpline[0]) == "Infinity" ? 0 : ySpline[0];
                    ySpline[points.length - 1] = Math.abs(ySpline[points.length - 1]) == "Infinity" ? 0 : ySpline[points.length - 1];
                }
                else {
                    // assigning the first and last value as zero
                    ySpline[0] = ySplineDuplicate[0] = 0;
                    ySpline[points.length - 1] = 0;
                }

                for (var i = 1; i < count - 1; i++) {
                    var d1 = points[i].xValue - points[i - 1].xValue;
                    var d2 = points[i + 1].xValue - points[i - 1].xValue;
                    var d3 = points[i + 1].xValue - points[i].xValue;
                    var dy1 = points[i + 1].YValues[index] - points[i].YValues[index] || null;
                    var dy2 = points[i].YValues[index] - points[i - 1].YValues[index] || null;

                    if (d1 == 0 || d2 == 0 || d3 == 0) {
                        ySpline[i] = 0;
                        ySplineDuplicate[i] = 0;
                    }
                    else {
                        var p = 1 / (d1 * ySpline[i - 1] + 2 * d2);

                        ySpline[i] = -p * d3;
                        ySplineDuplicate[i] = p * (a * (dy1 / d3 - dy2 / d1) - d1 * ySplineDuplicate[i - 1]);
                    }
                }

                for (var k = count - 2; k >= 0; k--)
                    ySpline[k] = ySpline[k] * ySpline[k + 1] + ySplineDuplicate[k];

            }
            return ySpline;

        },

        getDaysInMonth: function (month, year) {
            return new Date(year, month + 1, 0).getDate();
        },

        getBezierControlPoints: function (point1, point2, ySpline1, ySpline2, yIndex, series, chart) {
            var controlPoint1;
            var controlPoint2;
            var yDuplicate1, yDuplicate2;
            var oneDay = 24 * 60 * 60 * 1000;
            var xPoint = new Date(point1.xValue);
            var haxesCount = chart.chartObj.model.hAxes.length;
            var seriesIndex = $.inArray(series, chart.chartObj.model._visibleSeries);
            var j = (seriesIndex != haxesCount && seriesIndex < haxesCount) ? seriesIndex : 0;
            if (series.splineType == "cardinal") {
                if (sf.util.isNullOrUndefined(chart.chartObj.model.hAxes[j].intervalType) || chart.chartObj.model.hAxes[j].intervalType.toLowerCase() == "years" || chart.chartObj.model.hAxes[j].intervalType.toLowerCase() == "auto") {

                    var year = new Date(xPoint.getFullYear());
                    var yearValue = (year % 4 == 0 && (year % 100 == 0 || year % 400 != 0)) ? 366 : 365;
                    yDuplicate1 = (ySpline1 / (oneDay * yearValue));
                    yDuplicate2 = (ySpline2 / (oneDay * yearValue));

                }
                else if (chart.chartObj.model.hAxes[j].intervalType.toLowerCase() == "months") {
                    var dateObj = new Date(xPoint);
                    var year = dateObj.getFullYear();
                    var month = dateObj.getMonth();
                    var CountDays = sf.EjSeriesRender.prototype.getDaysInMonth(month, year);
                    yDuplicate1 = (ySpline1 / (oneDay * CountDays));
                    yDuplicate2 = (ySpline2 / (oneDay * CountDays));
                }
                else {
                    yDuplicate1 = ySpline1;
                    yDuplicate2 = ySpline2;
                }

                controlPoint1 = { xValue: (point1.xValue + ySpline1 / 3), YValues: [point1.YValues[yIndex] + yDuplicate1 / 3] };
                controlPoint2 = { xValue: (point2.xValue - ySpline2 / 3), YValues: [point2.YValues[yIndex] - yDuplicate2 / 3] };
            }
            else if (series.splineType == "monotonic") {
                var value = (point2.xValue - point1.xValue) / 3;
                controlPoint1 = { xValue: point1.xValue + value, YValues: [point1.YValues[yIndex] + ySpline1 * value] };
                controlPoint2 = { xValue: point2.xValue - value, YValues: [point2.YValues[yIndex] - ySpline2 * value] };
            }
            else {
                var one3 = 1 / 3.0;
                var deltaX2 = (point2.xValue - point1.xValue);

                deltaX2 = deltaX2 * deltaX2;

                var dx1 = 2 * parseFloat(point1.xValue) + parseFloat(point2.xValue);
                var dx2 = parseFloat(point1.xValue) + 2 * parseFloat(point2.xValue);

                var dy1 = 2 * point1.YValues[yIndex] + point2.YValues[yIndex];
                var dy2 = point1.YValues[yIndex] + 2 * point2.YValues[yIndex];

                var y1 = one3 * (dy1 - one3 * deltaX2 * (ySpline1 + 0.5 * ySpline2));
                var y2 = one3 * (dy2 - one3 * deltaX2 * (0.5 * ySpline1 + ySpline2));

                controlPoint1 = { xValue: dx1 * one3, YValues: [y1] };
                controlPoint2 = { xValue: dx2 * one3, YValues: [y2] };
            }
            return { controlPoint1: controlPoint1, controlPoint2: controlPoint2 };


        },

        improveChartPerformance: function (chartSeries) {
            var tempPoints = [],
                seriesPoints = chartSeries.pointCollection && chartSeries.dragPoint ? chartSeries.pointCollection : chartSeries.points,
                AreaBounds = this.chartObj.model.m_AreaBounds,
                emptyPoints,
                emptyPointsCount = 0,
                xTolerance = chartSeries.xAxis.visibleRange.delta / AreaBounds.Width,
                yTolerance = chartSeries.yAxis.visibleRange.delta / AreaBounds.Height,
                prevXValue = (seriesPoints[0] && seriesPoints[0].xValue > xTolerance) ? 0 : xTolerance,
                prevYValue = (seriesPoints[0] && seriesPoints[0].y > yTolerance) ? 0 : yTolerance,
                xVal = 0, yVal = 0, isEmpty, point, xDiff, yDiff,
                currentPointsLenght = seriesPoints.length,
                markerCount = 0, dataLabelCount = 0, sorted = true,
                count = 0, minPoint = currentPointsLenght > 0 && seriesPoints[0].xValue;

            for (var k = 0; k < currentPointsLenght; k++) {
                point = seriesPoints[k];
                xVal = point.xValue;
                yVal = point.YValues[0];
                (point.fill) && (chartSeries.pointFill = true);
                if (sorted && xVal != minPoint) {
                    sorted = minPoint < xVal;
                    minPoint = xVal;
                }
                (point.isEmpty || xVal == null || yVal == null || xVal !== xVal || yVal !== yVal || isNaN(xVal) || isNaN(yVal)) && (point.isEmpty = true);
                (xVal == null) && (point.xValue = chartSeries.xAxis.visibleRange.min);
                (yVal == null) && (point.YValues[0] = chartSeries.yAxis.visibleRange.min);
                (point.marker && point.marker.visible) && (markerCount++);
                (point.marker && point.marker.dataLabel && point.marker.dataLabel.visible) && (dataLabelCount++);
                point.isEmpty && emptyPointsCount++;
                xDiff = xVal - prevXValue;
                yDiff = yVal - prevYValue;
                if ((xDiff >= xTolerance || -xDiff >= xTolerance) || yDiff >= yTolerance || -yDiff >= yTolerance) {
                    point.visible = !point.isEmpty ? true : (point.visible || false);
                    tempPoints[count++] = point;
                    (xVal === xVal) && (prevXValue = xVal);
                    (yVal === yVal) && (prevYValue = yVal);
                }
            }
            sorted && (chartSeries._sorted = sorted);
            chartSeries._pointMarker = markerCount;
            chartSeries._dataLabels = dataLabelCount;
            return ((emptyPointsCount == 0 && (chartSeries.marker && !chartSeries.marker.dataLabel.visible)) ? tempPoints : this._calculateEmptyPoints(chartSeries, tempPoints));
        },
        _isVisiblePoints: function (chartSeries) {
            var points = chartSeries.pointCollection && chartSeries.dragPoint ? chartSeries.pointCollection : chartSeries.points,
                emptyPoints,
                isEmpty,
                checkNull = sf.util.isNullOrUndefined,
                length = points.length;
            for (var k = 0; k < length; k++) {
                isEmpty = (checkNull(points[k].isEmpty)) ? false : points[k].isEmpty;
                points[k].visible = (checkNull(points[k].visible)) ? true : points[k].visible;
                if (checkNull(points[k].xValue)) {
                    points[k].isEmpty = true;
                    points[k].visible = false;
                    points[k].xValue = chartSeries.xAxis ? chartSeries.xAxis.visibleRange.min : null;
                } else
                    points[k].isEmpty = isEmpty;

                if ((typeof points[k].YValues[0] != "object" && isNaN(points[k].YValues[0]) || points[k].YValues[0] == null || points[k].YValues[0] == 'undefined') ||
                    (!chartSeries.isIndicator && (chartSeries._hiloTypes && (isNaN(points[k].YValues[1]) || points[k].YValues[1] == undefined || points[k].YValues[1] == null)))) {
                    points[k].isEmpty = true;
                    points[k].visible = false;
                } else {
                    points[k].isEmpty = points[k].isEmpty;
                    points[k].visible = (points[k].isEmpty) ? !points[k].isEmpty : points[k].visible;
                }
                if (!checkNull(points[k].x)) {
                    if (jQuery.type(points[k].xValue) == "date")
                        points[k].xValue = (points[k].xValue).getTime();
                }
            }
            if (chartSeries.emptyPointSettings)
                emptyPoints = this._calculateEmptyPoints(chartSeries, points);
            else
                emptyPoints = points;

            if (chartSeries.type.toLowerCase() == "waterfall")
                this.chartObj.calculateWaterfallSeriesPoints(emptyPoints);

            chartSeries._visiblePoints = emptyPoints;

            return emptyPoints;

        },

        _calculateEmptyPoints: function (series, points, chartObj) {
            var currentPoints;
            var emptyPoints = series.emptyPointSettings,
                style = emptyPoints.style,
                fill = style.color,
                checkNull = sf.util.isNullOrUndefined,
                borderColor = style.border.color,
                borderWidth = style.border.width,
                mode = emptyPoints.displayMode.toLowerCase(),
                emptyPointsVisible = emptyPoints.visible,
                length = points.length,
                point, value, 
                xPoints = [],
                visiblePoints = [];
            currentPoints = $.extend(true, {}, points, currentPoints);
            var seriesType = series.type.toLowerCase();
            currentPoints.length = points.length;
            mode = (seriesType == "boxandwhisker") ? "gap" : mode;
            if (emptyPointsVisible) {
                if (mode != 'gap') {
                    for (var i = 0; i < length; i++) {
                        currentPoints[i].actualIndex = checkNull(chartObj) ? i : (chartObj.model._isPieOfPie ? currentPoints[i].actualIndex : i);
                        point = currentPoints[i];
                        if ((point.isEmpty) && (!checkNull(point.x) || series._xAxisValueType == "string")) {
                            if (fill != '')
                                point.fill = fill;
                            if (borderColor != '') {
                                point.border = point.border ? point.border : {};
                                point.border.color = borderColor;
                                point.border.width = borderWidth;
                            }
                            switch (mode) {
                                case 'average':
                                    if (series._hiloTypes) {
                                        if (seriesType == "splinerangearea")
                                            this._setsraPoint(currentPoints[i])
                                        $.each(point.YValues, function (index, value) {
                                            value = ((currentPoints[i - 1] ? currentPoints[i - 1].YValues[index] : 0) + (currentPoints[i + 1] ? (currentPoints[i + 1].isEmpty ? 0 : currentPoints[i + 1].YValues[index]) : 0)) / 2
                                            point.YValues[index] = value;
                                            sf.EjSeriesRender.prototype._sethlocPoint(index, point, value);
                                        })
                                    } else {
                                        value = ((currentPoints[i - 1] ? currentPoints[i - 1].y : 0) + (currentPoints[i + 1] ? (currentPoints[i + 1].isEmpty ? 0 : currentPoints[i + 1].y) : 0)) / 2;
                                        point.YValues[0] = value;
                                        point.y = value;
                                    }
                                    break;
                                case 'zero':
                                    if (series._hiloTypes) {
                                        if (seriesType == "splinerangearea")
                                            this._setsraPoint(currentPoints[i]);
                                        $.each(point.YValues, function (index, value) {
                                            point.y = 0;
                                            point.YValues[index] = 0;
                                            sf.EjSeriesRender.prototype._sethlocPoint(index, point, 0);
                                        })
                                    } else {
                                        var yvalue = seriesType.indexOf("stackingspline") != -1 ? currentPoints[i].YValues[0] : 0;
                                        point.YValues[0] = yvalue;
                                        point.y = yvalue;
                                    }
                                    break;
                            }
                            point.isEmpty = false;
                            point.visible = true;
                            visiblePoints.push(point);
                        } else {
                            if (!checkNull(currentPoints[i].x) || series._xAxisValueType == "string")
                                visiblePoints.push(point);
                        }
                    }
                } else {
                    for (var i = 0; i < length; i++) {
                        currentPoints[i].actualIndex = checkNull(chartObj) ? i : (chartObj.model._isPieOfPie ? currentPoints[i].actualIndex : i);
                        if (seriesType == "splinerangearea")
                            this._setsraPoint(currentPoints[i]);
                        visiblePoints[i] = (currentPoints[i]);
                    }
                }
            } else {
                for (var i = 0; i < length; i++) {
                    currentPoints[i].actualIndex = i;
                    if (currentPoints[i].visible)
                        visiblePoints.push(currentPoints[i]);
                }
            }

            return visiblePoints;

        },
        _setsraPoint: function (currentPoint) {
            var checkNull = sf.util.isNullOrUndefined;
            if (checkNull(currentPoint.YValues[0]))
                currentPoint.YValues[0] = 0;
            if (checkNull(currentPoint.YValues[1]))
                currentPoint.YValues[1] = 0;
        },
        _sethlocPoint: function (index, point, value) {
            switch (index) {
                case 0:
                    point.high = value;
                    break;
                case 1:
                    point.low = value;
                    break;
                case 2:
                    point.open = value;
                    break;
                case 3:
                    point.close = value;
                    break;
            }
        },

        _calculatePolarAxesSegment: function (currentseries) {

            var points = currentseries._visiblePoints;
            var segment = sf.EjSvgRender.utils._getStringBuilder();
            var SeriesIndex = $.inArray(currentseries, this.chartObj.model._visibleSeries)
            var size;
            var interval;
            var centerX = this.chartObj.model.centerX;
            var centerY = this.chartObj.model.centerY;
            // calculating side by side info.
            var sideInfo = this._getSeriesPosition(currentseries);
            var drawType = currentseries.drawType.toLowerCase();
            var spDirection = "",
                splinesb = sf.EjSvgRender.utils._getStringBuilder(),
                style = this.setLineSeriesStyle(currentseries),
                yIndex = 0,
                firstPoint = null,
                secondPoint = null,
                firstIndex = -1, controlPointsCount = 0,
                controlPoint1 = null,
                controlPoint2 = null,
                data = null,
                bpt1 = null,
                bpt2 = null, ySpline, pointIndex, firstIndex, firstPoint, secondPoint, data, point3, point4, text, 
                chartObj = this.chartObj;
            size = $.extend(true, {}, currentseries.marker.size, size);
            if (size.width <= 10) {
                size.width = size.height = (1.5 * this.chartObj.model.elementSpacing);
            }
            if (currentseries.drawType.toLowerCase() == 'column' || currentseries.drawType.toLowerCase() == 'rangecolumn') {

                var innerRadius = 0;
                var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + SeriesIndex };
                this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
                var interval = currentseries.xAxis.visibleRange.interval;
                currentseries.xAxis.labelPlacement = !(currentseries.xAxis.labelPlacement) ? "betweenticks" : currentseries.xAxis.labelPlacement;
                var ticks = 0, temp, point;
                if (currentseries.xAxis._valueType != "category" || (currentseries.xAxis._valueType == "category" && currentseries.xAxis.labelPlacement == "onticks"))
                    ticks = interval / 2;
                var inversed = (currentseries.xAxis.isInversed) ? 0 : 1;
                interval = interval / sideInfo.all;
                var nextPoint = interval;
                var visiblePoints = currentseries._visiblePoints;
                var length = visiblePoints.length;
                // calculation for start and end angle for each positions.
                for (var l = 0; l < length; l++) {
                    var itemCurrentXPos = temp = (visiblePoints[l].xValue - currentseries.xAxis.visibleRange.min) + ((interval) * sideInfo.pos - ticks);
                    itemCurrentXPos = (itemCurrentXPos) / this.chartObj.model.sumofYValues;
                    point = visiblePoints[l];

                    var nextPoint = (currentseries.xAxis.visibleRange.interval) / sideInfo.all;
                    point.startAngle = 2 * Math.PI * itemCurrentXPos;
                    point.endAngle = 2 * Math.PI * (itemCurrentXPos + ((nextPoint) / this.chartObj.model.sumofYValues));
                }
                if (!visiblePoints[visiblePoints.length - 1].startAngle) {
                    visiblePoints[visiblePoints.length - 1].startAngle = visiblePoints[0].startAngle;
                    visiblePoints[visiblePoints.length - 1].endAngle = visiblePoints[0].endAngle;
                }
            }
            var gap = false;
            for (var i = 0; i < points.length; i++) {
                var point1;
                var point2;

                // drawType 'Scatter' calculation
                if (drawType == 'scatter') {
                    point1 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[i].xValue, points[i].y, this.chartObj);
                    this.drawSymbol(SeriesIndex, currentseries, i, point1.X, point1.Y);
                }

                // drawType 'Line' calculation
                else if (currentseries.drawType.toLowerCase() == 'line') {
                    point1 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[i].xValue, points[i].y, this.chartObj);

                    if (i < points.length - 1 && points[i + 1].visible) {
                        point2 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[i + 1].xValue, points[i + 1].y, this.chartObj);
                        segment.append("M" + " " + (point1.X) + " " + (point1.Y) + " " + "L" + " " + (point2.X) + " " + (point2.Y) + " ");
                    }
                    // when isClosed is true
                    else if (i == points.length - 1) {
                        if (currentseries.isClosed) {
                            point2 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[0].xValue, points[0].y, this.chartObj);
                            segment.append("M" + " " + (point1.X) + " " + (point1.Y) + " " + "L" + " " + (point2.X) + " " + (point2.Y) + " ");
                        }
                    }
                }

                else if (currentseries.drawType.toLowerCase() == 'column') {
                    var interval = currentseries.xAxis.visibleRange.interval;
                    var inversed = (currentseries.xAxis.isInversed) ? 0 : 1;
                    var interval = interval / sideInfo.all;
                    // radius for each point based on the y values.
                    var radius = this.chartObj.model.Radius * sf.EjSvgRender.utils._valueToCoefficient(currentseries.yAxis, points[i].y);

                    var chartStartAngle = -.5 * Math.PI;
                    var startAngle = points[i].startAngle + chartStartAngle;
                    var endAngle = points[i].endAngle + chartStartAngle - 0.000001;

                    var x1, y1, x2, y2, direction;

                    // calculating arc when the Stacking mode is enabled

                    if (currentseries.isStacking) {
                        var startValue = currentseries.stackedValue.StartValues[i];
                        var endValue = currentseries.stackedValue.EndValues[i];
                        radius = ((startValue == endValue) ? 0 : (this.chartObj.model.Radius * sf.EjSvgRender.utils._valueToCoefficient(currentseries.yAxis, endValue)));

                        x1 = centerX + radius * Math.cos(startAngle);
                        y1 = centerY + radius * Math.sin(startAngle);

                        x2 = centerX + radius * Math.cos(endAngle);
                        y2 = centerY + radius * Math.sin(endAngle);

                        innerRadius = this.chartObj.model.Radius * sf.EjSvgRender.utils._valueToCoefficient(currentseries.yAxis, (startValue == 0 && currentseries.yAxis.visibleRange.min != 0) ? currentseries.yAxis.visibleRange.min : startValue);

                        var dStartX = centerX + innerRadius * Math.cos(startAngle);
                        var dStartY = centerY + innerRadius * Math.sin(startAngle);

                        var dEndX = centerX + innerRadius * Math.cos(endAngle);
                        var dEndY = centerY + innerRadius * Math.sin(endAngle);
                        if (this.chartObj.model.isPolar)
                            direction = "M" + " " + x1 + " " + y1 + " " + "A" + " " + radius + " " + radius + " " + "0" + " " + "0" + " " + inversed + " " + x2 + " " + y2 + " " + "L" + " " + dEndX + " " + dEndY + " " + "A" + " " + innerRadius + " " + innerRadius + " " + "1" + " " + "0" + " " + "0" + " " + dStartX + " " + dStartY + " " + "z";
                        else
                            direction = "M" + " " + x1 + " " + y1 + " " + "L" + " " + x2 + " " + y2 + " " + "L" + " " + dEndX + " " + dEndY + " " + "L" + " " + dStartX + " " + dStartY + " " + "z";
                    }
                    // calculating arc for normal mode.
                    else {

                        x1 = centerX + radius * Math.cos(startAngle);
                        y1 = centerY + radius * Math.sin(startAngle);

                        x2 = centerX + radius * Math.cos(endAngle);
                        y2 = centerY + radius * Math.sin(endAngle);
                        if (this.chartObj.model.isPolar)
                            direction = "M" + " " + x1 + " " + y1 + " " + "A" + " " + radius + " " + radius + " " + "0" + " " + "0" + " " + inversed + " " + x2 + " " + y2 + " " + "L" + " " + centerX + " " + centerY + " " + "z";
                        else
                            direction = "M" + " " + x1 + " " + y1 + " " + "L" + " " + x2 + " " + y2 + " " + "L" + " " + centerX + " " + centerY + " " + "z";
                    }

                    // gradient creation
                    var seriesInterior = this.chartObj.svgRenderer.createGradientElement(this.getSeriesName(currentseries) + "_" + SeriesIndex + i, this.chartObj.model.seriesColors[SeriesIndex], 0, 0, 0, 100, this.chartObj.gSeriesEle),
                        seriesBorder = currentseries.border;
                    var options = {
                        'id': this.chartObj.svgObject.id + "_Series" + SeriesIndex + "_Point" + i,
                        'fill': seriesInterior,
                        'stroke': seriesBorder.color,
                        'stroke-dasharray': seriesBorder.dashArray,
                        'stroke-width': seriesBorder.width,

                        'opacity': currentseries.opacity,
                        'pointIndex': i,
                        'd': direction,
                        'start': points[i].startAngle - 1.57,
                        'end': points[i].endAngle - 1.57,
                        'radius': radius,
                        'innerR': innerRadius
                    };
                    if (this.chartObj.model.isPolar) {
                        options.x = centerX;
                        options.y = centerY;
                        bounds = { PointIndex: i, StartAngle: points[i].startAngle, EndAngle: points[i].endAngle, CenterX: centerX, CenterY: centerY, Radius: radius, DRadius: innerRadius };
                    }
                    if (currentseries.type == "radar") {
                        var line1 = { x: centerX, y: centerY };
                        var line2 = { x: x1, y: y1 };
                        var line3 = { x: x2, y: y2 };
                        bounds = { PointIndex: i, Line1: line1, Line2: line2, Line3: line3 };
                        var hasStackingInnerRadius = innerRadius ? true : false;
                        options.hasStackingInnerRadius = hasStackingInnerRadius;
                    }
                    point = currentseries._visiblePoints[i];
                    if ((!sf.util.isNullOrUndefined(currentseries.marker) && currentseries.marker.visible) || (!sf.util.isNullOrUndefined(currentseries.marker) && currentseries.marker.dataLabel.visible))
                        point.symbolLocation = { X: ((x1 + x2) / 2), Y: ((y1 + y2) / 2) };

                    this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle);

                }
                else if (drawType == 'spline') {
                    visiblePoints = this.chartObj.dragPoint ? currentseries.pointCollection : this._isVisiblePoints(currentseries),
                        point1 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[i].xValue, points[i].y, this.chartObj);
                    if (i < points.length - 1 && points[i + 1].visible) {
                        point2 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[i + 1].xValue, points[i + 1].y, this.chartObj);
                        ySpline = this.naturalSpline(points, currentseries),
                            pointIndex = firstIndex = i;
                        firstPoint = visiblePoints[i];
                        secondPoint = visiblePoints[i + 1];
                        data = this.getBezierControlPoints(firstPoint, secondPoint, ySpline[firstIndex], ySpline[pointIndex], yIndex, currentseries, this);
                        controlPoint1 = (data["controlPoint1"]);
                        controlPoint2 = (data["controlPoint2"]);
                        bpt1 = sf.EjSvgRender.utils.TransformToVisible(currentseries, controlPoint1.xValue, controlPoint1.YValues, chartObj);
                        bpt2 = sf.EjSvgRender.utils.TransformToVisible(currentseries, controlPoint2.xValue, controlPoint2.YValues, chartObj);
                        segment.append("M" + " " + (point1.X) + " " + (point1.Y) + " " + "C" + " " + (bpt1.X) + " " + (bpt1.Y) + " " + (bpt2.X) + " " + (bpt2.Y) + " " + (point2.X) + " " + (point2.Y) + " ")
                        if (currentseries.isClosed) {
                            if (i == points.length - 1) {
                                if (point1 != null) {
                                    point3 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[0].xValue, points[0].y, chartObj);
                                    firstPoint = visiblePoints[visiblePoints.length - 1];
                                    secondPoint = visiblePoints[0];
                                    pointIndex = firstIndex = 0;
                                    data = this.getBezierControlPoints(firstPoint, secondPoint, ySpline[firstIndex], ySpline[pointIndex], yIndex, currentseries, this);
                                    controlPoint1 = (data["controlPoint1"]);
                                    controlPoint2 = (data["controlPoint2"]);
                                    bpt1 = sf.EjSvgRender.utils.TransformToVisible(currentseries, controlPoint1.xValue, controlPoint1.YValues, chartObj);
                                    bpt2 = sf.EjSvgRender.utils.TransformToVisible(currentseries, controlPoint2.xValue, controlPoint2.YValues, chartObj);
                                    segment.append("M" + " " + (point2.X) + " " + (point2.Y) + " " + "C" + " " + (bpt1.X + chartObj.canvasX) + " " + (bpt1.Y + chartObj.canvasY) + " " + (bpt2.X + chartObj.canvasX) + " " + (bpt2.Y + chartObj.canvasY) + " " + (point3.X) + " " + (point3.Y) + " ");
                                }
                            }
                        }
                    }
                }

                else if (currentseries.drawType.toLowerCase() == 'rangecolumn') {
                    var interval = currentseries.xAxis.visibleRange.interval;
                    var inversed = (currentseries.xAxis.isInversed) ? 0 : 1;
                    var interval = interval / sideInfo.all;
                    var chartStartAngle = -.5 * Math.PI;
                    var startAngle = points[i].startAngle + chartStartAngle;
                    var endAngle = points[i].endAngle + chartStartAngle - 0.000001;
                    var x1, y1, x2, y2, direction;
                    var startValue = points[i].YValues[1];
                    var endValue = points[i].YValues[0];
                    radius = ((startValue == endValue) ? 0 : (this.chartObj.model.Radius * sf.EjSvgRender.utils._valueToCoefficient(currentseries.yAxis, endValue)));
                    x1 = centerX + radius * Math.cos(startAngle);
                    y1 = centerY + radius * Math.sin(startAngle);
                    x2 = centerX + radius * Math.cos(endAngle);
                    y2 = centerY + radius * Math.sin(endAngle);
                    innerRadius = this.chartObj.model.Radius * sf.EjSvgRender.utils._valueToCoefficient(currentseries.yAxis, (startValue == 0 && currentseries.yAxis.visibleRange.min != 0) ? currentseries.yAxis.visibleRange.min : startValue);
                    var dStartX = centerX + innerRadius * Math.cos(startAngle);
                    var dStartY = centerY + innerRadius * Math.sin(startAngle);
                    var dEndX = centerX + innerRadius * Math.cos(endAngle);
                    var dEndY = centerY + innerRadius * Math.sin(endAngle);
                    if (this.chartObj.model.isPolar)
                        direction = "M" + " " + x1 + " " + y1 + " " + "A" + " " + radius + " " + radius + " " + "0" + " " + "0" + " " + inversed + " " + x2 + " " + y2 + " " + "L" + " " + dEndX + " " + dEndY + " " + "A" + " " + innerRadius + " " + innerRadius + " " + "1" + " " + "0" + " " + "0" + " " + dStartX + " " + dStartY + " " + "z";
                    else
                        direction = "M" + " " + x1 + " " + y1 + " " + "L" + " " + x2 + " " + y2 + " " + "L" + " " + dEndX + " " + dEndY + " " + "L" + " " + dStartX + " " + dStartY + " " + "z";
                    var seriesInterior = this.chartObj.svgRenderer.createGradientElement(this.getSeriesName(currentseries) + "_" + SeriesIndex + i, this.chartObj.model.seriesColors[SeriesIndex], 0, 0, 0, 100, this.chartObj.gSeriesEle),
                        seriesBorder = currentseries.border;
                    var options = {
                        'id': this.chartObj.svgObject.id + "_Series" + SeriesIndex + "_Point" + i,
                        'fill': seriesInterior,
                        'stroke': seriesBorder.color,
                        'stroke-dasharray': seriesBorder.dashArray,
                        'stroke-width': seriesBorder.width,
                        'opacity': currentseries.opacity,
                        'pointIndex': i,
                        'd': direction,
                        'start': points[i].startAngle - 1.57,
                        'end': points[i].endAngle - 1.57,
                        'radius': radius,
                        'innerR': innerRadius
                    };
                    if (this.chartObj.model.isPolar) {
                        options.x = centerX;
                        options.y = centerY;
                        bounds = { PointIndex: i, StartAngle: points[i].startAngle, EndAngle: points[i].endAngle, CenterX: centerX, CenterY: centerY, Radius: radius, DRadius: innerRadius };
                    }

                    if (currentseries.type == "radar") {
                        var line1 = { x: dEndX, y: dEndY };
                        var line2 = { x: x1, y: y1 };
                        var line3 = { x: x2, y: y2 };
                        var line4 = { x: dStartX, y: dStartY };
                        bounds = { PointIndex: i, Line1: line1, Line2: line2, Line3: line3, Line4: line4 };
                        var hasStackingInnerRadius = innerRadius ? true : false;
                        options.hasStackingInnerRadius = hasStackingInnerRadius;
                    }
                    point = currentseries._visiblePoints[i];
                    if ((!sf.util.isNullOrUndefined(currentseries.marker) && currentseries.marker.visible) || (!sf.util.isNullOrUndefined(currentseries.marker) || currentseries.marker.dataLabel.visible)) {
                        point.symbolLocation = { X: ((x1 + x2) / 2), Y: ((y1 + y2) / 2) };
                        this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle);
                    }
                }

                // drawType 'Area' calculation
                else {
                    if (currentseries.isStacking) {
                        startValue = currentseries.stackedValue.StartValues[i];
                        endValue = currentseries.stackedValue.EndValues[i];
                        if (i == 0) {
                            point1 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[i].xValue, endValue, this.chartObj);
                            for (var j = points.length - 1; j >= 0; j--) {
                                startValue = currentseries.stackedValue.StartValues[j];
                                points[j].y = Math.max(currentseries.yAxis.actualRange.min, startValue);
                                //points[j].y=startValue;
                                point1 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[j].xValue, points[j].y, this.chartObj);
                                text = (j == points.length - 1) ? "M" : "L"
                                segment.append("" + text + "" + " " + (point1.X) + " " + (point1.Y) + " ");
                            }
                        }
                        if (i <= points.length - 1) {
                            points[i].y = endValue;
                            point1 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[i].xValue, points[i].y, this.chartObj);
                            segment.append("L" + " " + (point1.X) + " " + (point1.Y) + " ");
                            if (i == points.length - 1) {
                                if (currentseries.isClosed) {
                                    point2 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[0].xValue, currentseries.stackedValue.EndValues[0], this.chartObj);
                                    point3 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[0].xValue, currentseries.stackedValue.StartValues[0], this.chartObj);
                                    point4 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[i].xValue, currentseries.stackedValue.StartValues[i], this.chartObj);
                                    segment.append("L" + " " + (point2.X) + " " + (point2.Y) + " " + " L" + " " + (point3.X) + " " + (point3.Y) + " " + " L" + " " + (point4.X) + " " + (point4.Y) + " " + " L" + " " + (point3.X) + " " + (point3.Y) + " " + "z ");
                                }
                                else
                                    segment.append("L" + " " + (centerX) + " " + (centerY) + " ");
                            }
                        }
                    }
                    else {
                        point1 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[i].xValue, points[i].y, this.chartObj);
                        if (i == 0 || gap) {
                            segment.append("M" + " " + (point1.X) + " " + (point1.Y) + " ");
                        }
                        // when isClosed is enabled
                        else if (i == points.length - 1) {
                            if (!currentseries.isClosed) {
                                segment.append("L" + " " + (point1.X) + " " + (point1.Y) + " " + "L" + " " + (centerX) + " " + (centerY));
                            }
                            else {
                                point2 = sf.EjSvgRender.utils.TransformToVisible(currentseries, points[0].xValue, points[0].y, this.chartObj);
                                segment.append("L" + " " + (point1.X) + " " + (point1.Y) + " " + "z");
                            }
                        }

                        else {
                            if (points[i + 1].visible)
                                segment.append("L" + " " + (point1.X) + " " + (point1.Y) + " ");
                            else
                                segment.append("L" + " " + (point1.X) + " " + (point1.Y) + " " + "L" + " " + (centerX) + " " + (centerY) + " " + "z");
                        }
                        if (points[i + 1] && points[i + 1].visible)
                            gap = false;
                        else
                            gap = true;
                    }
                }
                if (!currentseries.regionAdded && currentseries.drawType.toLowerCase() != 'column' && (currentseries.drawType.toLowerCase() != 'rangecolumn')) {
                    var bounds = { X: point1.X - size.width / 2, Y: point1.Y - size.height / 2, Width: size.width, Height: size.height };
                    sf.EjSvgRender.utils._addRegion(this.chartObj, bounds, currentseries, points[i], i);
                }
                if (!currentseries.regionAdded && currentseries.drawType.toLowerCase() == 'column' && this.chartObj.model.enableCanvasRendering || (currentseries.drawType.toLowerCase() == 'rangecolumn' && this.chartObj.model.enableCanvasRendering))
                    sf.EjSvgRender.utils._addRegion(this.chartObj, bounds, currentseries, null, null);

            }

            if (!currentseries.regionAdded && currentseries.drawType.toLowerCase() == 'column' && !this.chartObj.model.enableCanvasRendering || (currentseries.drawType.toLowerCase() == 'rangecolumn' && !this.chartObj.model.enableCanvasRendering))
                sf.EjSvgRender.utils._addRegion(this.chartObj, bounds, currentseries, null, null);
            return segment.toString();
        },
        _calculateVisiblePoints: function (currentseries, chartObj) {
            var visiblePoints = [],
                legendPoints = [],
                emptyPointsLength,
                checkNull = sf.util.isNullOrUndefined,
                points = checkNull(chartObj) ? currentseries.points : (chartObj.model._isPieOfPie ? currentseries.pieCollections[currentseries.collectionIndex] : currentseries.points), currentPoints,
                length = points.length, emptyPoints,
                point;

            // calculate visible points
            for (var i = 0; i < length; i++) {
                // for legend visibility
                point = points[i];
                if (checkNull(point._visibility))
                    point._visibility = 'visible';
                point.actualIndex = checkNull(chartObj) ? i : (chartObj.model._isPieOfPie ? point.actualIndex : i);
                point.visible = (point.isEmpty) ? false : point.visible;
                if (checkNull(point.visible))
                    point.visible = true;
                if (point.y < 0) {
                    point.YValues[0] = Math.abs(point.YValues[0])
                }
                if (checkNull(point.x) && currentseries._xAxisValueType != "string") {
                    point.visible = false;
                    point.isEmpty = true;
                }
                if (checkNull(point.y)) {
                    point.visible = false;
                    point.isEmpty = true;
                }
            }
            currentPoints = $.extend(true, {}, points, currentPoints);
            currentPoints.length = length;
            if (currentseries.emptyPointSettings.visible) {
                emptyPoints = this._calculateEmptyPoints(currentseries, currentPoints, chartObj);
                emptyPointsLength = emptyPoints.length;
                for (var j = 0; j < emptyPointsLength; j++) {
                    if (emptyPoints[j].visible) {
                        emptyPoints[j].visible = emptyPoints[j]._visibility == 'hidden' ? false : true;
                        legendPoints.push(emptyPoints[j]);
                        if (emptyPoints[j].visible)
                            visiblePoints.push(emptyPoints[j]);
                    } else {
                        //calculating gap mode values
                        emptyPoints[j].y = ((emptyPoints[j - 1] ? emptyPoints[j - 1].y : 0) + (emptyPoints[j + 1] ? emptyPoints[j + 1].y : 0)) / 2;
                        if (isNaN(emptyPoints[j].y))
                            emptyPoints[j].y = ((emptyPoints[j - 2] ? emptyPoints[j - 2].y : 0) + (emptyPoints[j + 2] ? emptyPoints[j + 2].y : 0)) / 2;

                        emptyPoints[j].YValues[0] = emptyPoints[j].y;
                        if (!checkNull(emptyPoints[j].x) || currentseries._xAxisValueType == "string") {
                            emptyPoints[j].gapMode = true;
                            visiblePoints.push(emptyPoints[j]);
                        }
                    }
                }
            }
            else {
                for (var j = 0; j < length; j++) {
                    legendPoints.push(currentPoints[j]);
                    if (currentPoints[j].visible) {
                        currentPoints[j].visible = currentPoints[j]._visibility == 'hidden' ? false : true;
                        if (currentPoints[j].visible)
                            visiblePoints.push(currentPoints[j]);
                    }
                }
            }
            if (currentseries.visibility == "hidden") {
                for (var i = 0; i < legendPoints.length; i++) {
                    legendPoints[i].visible = false;
                }
            }
            currentseries._visiblePoints = visiblePoints;
            currentseries.visiblePoints = legendPoints;

            return {
                'visiblePoints': visiblePoints,
                'legendPoints': legendPoints
            };
        },
        getMinMaxValue: function (point1, point2, degree) {
            var minX = Math.min(point1.x, point2.x);
            var minY = Math.min(point1.y, point2.y);
            var maxX = Math.max(point1.x, point2.x);
            var maxY = Math.max(point1.y, point2.y);
            var pointValue;
            switch (degree) {
                case 0:
                case 360:
                    pointValue = maxY;
                    break;
                case 90:
                    pointValue = minX;
                    break;
                case 180:
                    pointValue = minY;
                    break;
                case 270:
                    pointValue = maxX;
                    break;
            }
            return pointValue;
        },
        pieDoughnutCenter: function (currentseries) {
            var startAngle = currentseries.startAngle;
            var endAngle = currentseries.endAngle;
            this.chartObj.model.centerCount++;
            var seriesIndex = $.inArray(currentseries, this.chartObj.model._visibleSeries);
            var regions = [-630, -540, -450, -360, -270, -180, -90, 0, 90, 180, 270, 360, 450, 540, 630];
            var region = [];
            var oldCenterX = this.chartObj.model.circleCenterX[seriesIndex];
            var oldCenterY = this.chartObj.model.circleCenterY[seriesIndex];

            if (currentseries.startAngle < currentseries.endAngle) {
                for (i = 0; i < regions.length; i++) {
                    if (regions[i] > startAngle && regions[i] < endAngle)
                        region[region.length] = (regions[i] % 360) < 0 ? (regions[i] % 360) + 360 : (regions[i] % 360);
                }
            }
            else {
                for (i = 0; i < regions.length; i++) {
                    if (regions[i] < startAngle && regions[i] > endAngle)
                        region[region.length] = (regions[i] % 360) < 0 ? (regions[i] % 360) + 360 : (regions[i] % 360);
                }
            }
            if (this.chartObj.model.centerCount == 1) {

                var radius = this.chartObj.model.circularRadius[seriesIndex];
                var startRadian = 2 * Math.PI * (startAngle - 90) / 360;
                var endRadian = 2 * Math.PI * (endAngle - 90) / 360;
                var centerPoint = { x: this.chartObj.model.circleCenterX[seriesIndex], y: this.chartObj.model.circleCenterY[seriesIndex] };
                var startPoint = { x: this.chartObj.model.circleCenterX[seriesIndex] + radius * Math.cos(startRadian), y: this.chartObj.model.circleCenterY[seriesIndex] + radius * Math.sin(startRadian) }
                var endPoint = { x: this.chartObj.model.circleCenterX[seriesIndex] + radius * Math.cos(endRadian), y: this.chartObj.model.circleCenterY[seriesIndex] + radius * Math.sin(endRadian) }
                switch (region.length) {
                    case 0:
                        var longX = Math.abs(centerPoint.x - startPoint.x) > Math.abs(centerPoint.x - endPoint.x) ? startPoint.x : endPoint.x;
                        var longY = Math.abs(centerPoint.y - startPoint.y) > Math.abs(centerPoint.y - endPoint.y) ? startPoint.y : endPoint.y;
                        var midPoint = { x: (centerPoint.x + longX) / 2, y: (centerPoint.y + longY) / 2 }
                        this.chartObj.model.circleCenterX[seriesIndex] = this.chartObj.model.circleCenterX[seriesIndex] + (this.chartObj.model.circleCenterX[seriesIndex] - midPoint.x);
                        this.chartObj.model.circleCenterY[seriesIndex] = this.chartObj.model.circleCenterY[seriesIndex] + (this.chartObj.model.circleCenterY[seriesIndex] - midPoint.y);
                        break;
                    case 1:
                        var maxRadian = 2 * Math.PI * (region[0] - 90) / 360;
                        var maxPoint = { x: this.chartObj.model.circleCenterX[seriesIndex] + radius * Math.cos(maxRadian), y: this.chartObj.model.circleCenterY[seriesIndex] + radius * Math.sin(maxRadian) }
                        switch (region[0]) {
                            case 0:
                            case 360:
                                point1 = { x: startPoint.x, y: maxPoint.y };
                                point2 = { x: endPoint.x, y: centerPoint.y };
                                break;
                            case 90:
                                point1 = { x: centerPoint.x, y: endPoint.y };
                                point2 = { x: maxPoint.x, y: startPoint.y };
                                break;
                            case 180:
                                point1 = { x: endPoint.x, y: centerPoint.y };
                                point2 = { x: startPoint.x, y: maxPoint.y };
                                break;
                            case 270:
                                point1 = { x: maxPoint.x, y: startPoint.y };
                                point2 = { x: centerPoint.x, y: endPoint.y };
                                break;
                        }
                        var midPoint = { x: (point1.x + point2.x) / 2, y: (point1.y + point2.y) / 2 }
                        this.chartObj.model.circleCenterX[seriesIndex] = this.chartObj.model.circleCenterX[seriesIndex] + ((this.chartObj.model.circleCenterX[seriesIndex] - midPoint.x) >= radius ? 0 : (this.chartObj.model.circleCenterX[seriesIndex] - midPoint.x));
                        this.chartObj.model.circleCenterY[seriesIndex] = this.chartObj.model.circleCenterY[seriesIndex] + ((this.chartObj.model.circleCenterY[seriesIndex] - midPoint.y) >= radius ? 0 : (this.chartObj.model.circleCenterY[seriesIndex] - midPoint.y));
                        break;
                    case 2:
                        var minRadian = 2 * Math.PI * (region[0] - 90) / 360;
                        var maxRadian = 2 * Math.PI * (region[1] - 90) / 360;
                        var maxPoint = { x: this.chartObj.model.circleCenterX[seriesIndex] + radius * Math.cos(maxRadian), y: this.chartObj.model.circleCenterY[seriesIndex] + radius * Math.sin(maxRadian) }
                        var minPoint = { x: this.chartObj.model.circleCenterX[seriesIndex] + radius * Math.cos(minRadian), y: this.chartObj.model.circleCenterY[seriesIndex] + radius * Math.sin(minRadian) }
                        var point1;
                        var point2
                        if (region[0] == 90 && region[1] == 180 || region[0] == 270 && region[1] == 0)
                            point1 = { x: minPoint.x, y: maxPoint.y }
                        else
                            point1 = { x: maxPoint.x, y: minPoint.y }
                        if (region[0] == 90 || region[0] == 270)
                            point2 = { x: this.getMinMaxValue(startPoint, endPoint, region[0]), y: this.getMinMaxValue(startPoint, endPoint, region[1]) }
                        else
                            point2 = { x: this.getMinMaxValue(startPoint, endPoint, region[1]), y: this.getMinMaxValue(startPoint, endPoint, region[0]) }
                        var midPoint = { x: Math.abs(point1.x - point2.x) / 2 >= radius ? 0 : (point1.x + point2.x) / 2, y: Math.abs(point1.y - point2.y) / 2 >= radius ? 0 : (point1.y + point2.y) / 2 }
                        this.chartObj.model.circleCenterX[seriesIndex] = this.chartObj.model.circleCenterX[seriesIndex] + (midPoint.x == 0 ? 0 : (this.chartObj.model.circleCenterX[seriesIndex] - midPoint.x) >= radius ? 0 : (this.chartObj.model.circleCenterX[seriesIndex] - midPoint.x));
                        this.chartObj.model.circleCenterY[seriesIndex] = this.chartObj.model.circleCenterY[seriesIndex] + (midPoint.y == 0 ? 0 : (this.chartObj.model.circleCenterY[seriesIndex] - midPoint.y) >= radius ? 0 : (this.chartObj.model.circleCenterY[seriesIndex] - midPoint.y));
                        break;
                }
            }
            for (var i = 0; i < currentseries.points.length; i++) {
                if (seriesIndex < this.chartObj.model._visibleSeries.length && this.chartObj.model.centerCount > 1) {
                    if (this.chartObj.model._visibleSeries[seriesIndex + 1].startAngle == startAngle && this.chartObj.model._visibleSeries[seriesIndex + 1].endAngle == endAngle) {
                        this.chartObj.model.circleCenterX[seriesIndex] = this.chartObj.model.circleCenterX[seriesIndex + 1];
                        this.chartObj.model.circleCenterY[seriesIndex] = this.chartObj.model.circleCenterY[seriesIndex + 1];
                    }
                }
                this.chartObj.model.startX[i] = this.chartObj.model.startX[i] - (oldCenterX - this.chartObj.model.circleCenterX[seriesIndex]);
                this.chartObj.model.startY[i] = this.chartObj.model.startY[i] - (oldCenterY - this.chartObj.model.circleCenterY[seriesIndex]);


            }

        },
        _drawEmptyPieOfPie: function (chartObj) {
            var startAngle = -.5 * Math.PI,
                endAngle = 360 * (Math.PI / 180) + (-.5 * Math.PI) - 0.000001,
                startX = chartObj.model.circleCenterX[1],
                startY = chartObj.model.circleCenterY[1],
                radius = chartObj.model.circularRadius[1];
            var direction = "M" + " " + (startX + radius * Math.cos(startAngle)) + " " + (startY + radius * Math.sin(startAngle)) + " " + "A" + " " + radius + " " + radius + " " + "0" + " " +
                1 + " " + 1 + " " + (startX + radius * Math.cos(endAngle)) + " " + (startY + radius * Math.sin(endAngle)) + " " + "z";
            var theme = chartObj.model.theme.toLowerCase();
            var pathOptions = {
                'id': chartObj.svgObject.id + '_Series' + 0 + "_EmptyCircle",
                'fill': 'none',
                'stroke-width': 1.5,
                'stroke': theme.indexOf("dark") >= 0 || theme.indexOf("contrast") >= 0 ? " #FFFFFF" : "#000000",
                'stroke-dasharray': '',
                'd': direction,
                'opacity': 1,
                'radius': radius,
                'start': 0 - 1.57,
                'end': (360 * (Math.PI / 180)) - 1.57,
                'cx': startX,
                'cy': startY
            };
            return pathOptions;
        },
        calculatingSliceAngle: function (currentseries, chartObj) {
            var chart = this.chartObj ? this.chartObj : chartObj,
                chartModel = chart.model,
                legend = chartModel.legend,
                seriesIndex = $.inArray(currentseries, chartModel._visibleSeries),
                legendPosition = legend.position.toLowerCase(),
                legendActualBounds = chartModel.LegendActualBounds,
                visiblePoints = currentseries._visiblePoints,
                visiblePointslength = visiblePoints.length,
                legXSpace = 0, totalDegree,
                legYSpace = 0,
                legendBorder = legend.border.width,
                border = chartModel.border.width,
                point, margin = chartModel.margin,
                elementSpacing = chartModel.elementSpacing,
                itemCurrentXPos = 0,
                subTitle = chartModel.title.subTitle.text ? chartModel.title.subTitle : '';
            chartModel.arcData = [];
            currentseries.rightsidePoints = [];
            currentseries.leftsidePoints = [];
            currentseries.labels = [];
            chartModel.sumofYValues = 0;
            chartModel.midPoint = 0;
            var type = currentseries.type.toLowerCase(),
                gapWidthValue = currentseries.gapWidth;


            for (j = 0; j < visiblePoints.length; j++) {
                chartModel.sumofYValues += visiblePoints[j].YValues[0];
            }
            if (currentseries.endAngle != null && type != "pieofpie")
                totalDegree = (currentseries.endAngle - currentseries.startAngle);
            else
                totalDegree = 360;
            totalDegree = (totalDegree != 360 && totalDegree != -360) ? totalDegree % 360 : totalDegree;
            if (currentseries.startAngle && type != "pieofpie") {
                currentseries.startAngle = currentseries.startAngle % 360;
                currentseries.endAngle = currentseries.startAngle + totalDegree;
                itemCurrentXPos = (currentseries.startAngle) ? ((chartModel.sumofYValues / 360) * currentseries.startAngle) : 0;
                itemCurrentXPos = itemCurrentXPos / chartModel.sumofYValues;
				itemCurrentXPos = isFinite(itemCurrentXPos) ? itemCurrentXPos : 0;
                chartModel.itemCurrentXPos = itemCurrentXPos;
            }
            else
                currentseries.endAngle = totalDegree;
            if (legend.visible && legendPosition != "custom") {
                if (legendPosition == "right" || legendPosition == "left")
                    legXSpace += legendActualBounds.Width + (legendBorder * 2) + elementSpacing;
                else
                    legYSpace += legendActualBounds.Height + (legendBorder * 2) + elementSpacing;

            }

            var yOffset = ((chartModel.title.text && chartModel.title.visible) ? chartModel._titleLocation.size.height + chartModel.elementSpacing + (subTitle == '' ? 0 : (subTitle.text && subTitle.visible && subTitle.enableTrim && (subTitle.textOverflow == 'wrap' || subTitle.textOverflow == 'wrapandtrim') ? chartModel._subTitleLocation.size.height : 0)) : 0);

            var constantWidth = 0.1 * Math.min($(chart.svgObject).width(), $(chart.svgObject).height());
            var actualWidth = $(chart.svgObject).width() - (legXSpace + margin.left + margin.right + border * 2) - (type == "pieofpie" ? gapWidthValue : 0);
            var actualHeight = $(chart.svgObject).height() - (legYSpace + yOffset + margin.top + margin.bottom + border * 2);
            seriesIndex = chart.model._isPieOfPie ? currentseries.collectionIndex : seriesIndex;

            if (type == "pieofpie") {
                if (actualWidth < constantWidth) {
                    var widthDifference = constantWidth - actualWidth;
                    actualWidth = constantWidth;
                }
                gapWidthValue = widthDifference ? gapWidthValue - widthDifference : $(chart.svgObject).width() >= gapWidthValue ? gapWidthValue : 0;
            }
            var value = type == "pieofpie" ? (seriesIndex == 0 ? 0.25 : 0.25 * 3) : 0.5;
            chartModel.circleCenterX[seriesIndex] = (actualWidth * value) + (seriesIndex == 1 && type == "pieofpie" ? gapWidthValue : 0) + margin.left + ((legend.visible && legendPosition === "left") ? legXSpace : 0);
            chartModel.circleCenterY[seriesIndex] = (actualHeight * 0.5) + margin.top + yOffset + ((legend.visible && legendPosition === "top") ? legYSpace : 0);

            if (!sf.util.isNullOrUndefined(chart.model.pieGapWidth) && chart.model.pieGapWidth != 0) {
                if (seriesIndex == 0)
                    chartModel.circleCenterX[seriesIndex] = chartModel.circleCenterX[seriesIndex] + chart.model.pieGapWidth / 2;
                else
                    chartModel.circleCenterX[seriesIndex] = chartModel.circleCenterX[seriesIndex] - chart.model.pieGapWidth / 2;
            }
            var endAngle;
            currentseries.startAngle = (type == "pieofpie") ? 0 : currentseries.startAngle;
            totalDegree = currentseries.endAngle - currentseries.startAngle;
            var pieFactor = totalDegree / 180;
            var circleMidAngle = (totalDegree / 4) * (Math.PI / 180);
            for (var l = 0; l < visiblePointslength; l++) {
                point = currentseries._visiblePoints[l];
                if (point.visible || point.gapMode) {
                    var pointIndex = type == "pieofpie" ? point.actualIndex : l;
					var mean = point.YValues[0] / chartModel.sumofYValues;
						mean = isFinite(mean) ? mean : 0;
                    if (l == 0 && seriesIndex == 0 && type == "pieofpie") {
                        var startAngle = 2 * Math.PI * itemCurrentXPos;
                        var endAngle = (pieFactor * Math.PI * mean) + startAngle;
                        endAngle = (isNaN(endAngle)) ? startAngle : endAngle;
                        midAngle = (endAngle + startAngle) / 2;
                        point.start = point.startAngle = circleMidAngle - midAngle;
                        point.end = point.endAngle = circleMidAngle + midAngle;
                        point.midAngle = circleMidAngle;
                    }
                    else {
                        if (l == 0)
                            point.startAngle = 2 * Math.PI * itemCurrentXPos;
                        else
                            point.startAngle = (type == "pieofpie") ? currentseries.pieCollections[seriesIndex][l - 1].endAngle : endAngle;
                        endAngle = point.endAngle = (pieFactor * Math.PI * mean) + point.startAngle;
                        endAngle = point.endAngle = (isNaN(endAngle)) ? point.startAngle : endAngle;
                        point.start = point.startAngle;
                        point.end = point.endAngle;
                        point.midAngle = (point.endAngle + point.startAngle) / 2;
                    }
                    point.pointIndex = pointIndex;
                    var chartStartingAngle = -.5 * Math.PI;

                    point.radian = (point.midAngle) % (2 * Math.PI)

                    if (currentseries.labelPosition.toLowerCase() == "outsideextended" && type != "pieofpie") {

                        if (point.radian < Math.PI)
                            currentseries.rightsidePoints.push(point);
                        else
                            currentseries.leftsidePoints.push(point);
                    }
                    itemCurrentXPos += point.YValues[0] / chartModel.sumofYValues;

                    var midAngle = point.midAngle + chartStartingAngle;

                    if ((point.actualIndex == currentseries.explodeIndex || currentseries.explodeAll) && !chart.vmlRendering) {

                        chartModel.startX[pointIndex] = chartModel.circleCenterX[seriesIndex] + Math.cos(midAngle) * currentseries.explodeOffset;
                        chartModel.startY[pointIndex] = chartModel.circleCenterY[seriesIndex] + Math.sin(midAngle) * currentseries.explodeOffset;
                    }
                    else {
                        chartModel.startX[pointIndex] = chartModel.circleCenterX[seriesIndex];
                        chartModel.startY[pointIndex] = chartModel.circleCenterY[seriesIndex];
                    }
                }

            }

            if (currentseries.labelPosition.toLowerCase() == "outsideextended") {
                currentseries.rightsidePoints = sf.DataManager(currentseries.rightsidePoints, sf.Query().sortBy("radian")).executeLocal();
                currentseries.leftsidePoints = sf.DataManager(currentseries.leftsidePoints, sf.Query().sortBy("radian")).executeLocal();
            }
            if (currentseries.marker.dataLabel.template) {
                if (currentseries.labelPosition.toLowerCase() == "outsideextended") {
                    for (var i = 0; i < currentseries.rightsidePoints.length; i++) {
                        sf.EjSvgRender.utils._getSeriesTemplateSize(currentseries.rightsidePoints[i], currentseries.rightsidePoints[i].actualIndex, currentseries, false, chart);
                    }
                    for (var k = 0; k < currentseries.leftsidePoints.length; k++) {
                        sf.EjSvgRender.utils._getSeriesTemplateSize(currentseries.leftsidePoints[k], currentseries.leftsidePoints[k].actualIndex, currentseries, true, chart);
                    }

                }
                else {
                    for (var j = 0; j < currentseries._visiblePoints.length; j++) {
                        sf.EjSvgRender.utils._getSeriesTemplateSize(currentseries._visiblePoints[j], currentseries._visiblePoints[j].actualIndex, currentseries, true, chart);
                    }
                }

            }
            else {
                sf.EjSvgRender.utils._getSeriesMaxLabel(currentseries);
            }


            currentseries.finalSize = { width: actualWidth, height: actualHeight };
            return currentseries.finalSize;
        },
        _drawHiloPath: function (series, style, interior, direction, i, pointbounds) {

            var seriesIndex = $.inArray(series, this.chartObj.model._visibleSeries);

            var options = {
                'name': series.type,
                'id': this.chartObj.svgObject.id + "_Series" + seriesIndex + "_Point" + i,
                'fill': "none",
                'stroke-dasharray': series.dashArray,
                'stroke-width': style.borderWidth,
                'stroke': interior,
                'stroke-linecap': series.lineCap,
                'stroke-linejoin': series.lineJoin,
                'opacity': series.opacity,
                'd': direction
            };
            this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle);
            var valWidth, valHeight, x, y;
            var trans = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, this.chartObj.model.requireInvertedAxes);
            x = (Math.min(pointbounds.point2.X, pointbounds.point1.X) + trans.x) - (style.borderWidth);
            y = (Math.min(pointbounds.point2.Y, pointbounds.point1.Y) + trans.y);
            if (pointbounds.point1.Y != pointbounds.point2.Y) {
                valWidth = style.borderWidth + (style.borderWidth / 2);
                valHeight = Math.abs(pointbounds.point1.Y - pointbounds.point2.Y);
            }
            else {
                valWidth = Math.abs(pointbounds.point2.X - pointbounds.point1.X);
                valHeight = style.borderWidth + (style.borderWidth / 2);
            }
            var bounds = { X: x, Y: y, Width: valWidth, Height: valHeight };
            sf.EjSvgRender.utils._addRegion(this.chartObj, bounds, series, null, i);

        },
        isIntersec: function (other, currBounds) {
            if (currBounds.Bottom < other.Top || currBounds.Right < other.Left
                || currBounds.Top > other.Bottom || currBounds.Left > other.Right) {
                return false;
            }
            return true;
        },
        IntersectWith: function (sender, point, currBounds, labelPosition, seriesIndex, size) {
            var chartObj = this, intersect = false,
                smartIndex, bounds;
            if (sf.util.isNullOrUndefined(sender.model.rightsidebounds[seriesIndex]) || sf.util.isNullOrUndefined(sender.model.leftsidebounds[seriesIndex])) {
                sender.model.leftsidebounds[seriesIndex] = [];
                sender.model.rightsidebounds[seriesIndex] = [];
                sender.model.leftsidebounds[seriesIndex].points = [];
                sender.model.rightsidebounds[seriesIndex].points = [];
            }
            if (labelPosition == "outsideExtended") {
                for (var i = seriesIndex; i < sender.model.bounds.length; i++) {
                    if (sender.model._visibleSeries[i].labelPosition.toLowerCase() == "outsideextended") {
                        if ((!sf.util.isNullOrUndefined(sender.model.bounds[i].points["left"])) && (sender.model.bounds[i].points["left"].length > 0)) {
                            var pointsLength = sender.model.bounds[i].points["left"].length;
                            for (var j = pointsLength - 1; j >= 0 && !(sf.util.isNullOrUndefined(sender.model.bounds[i].points["left"][j])); j--) {
                                sender.model.leftsidebounds[i].points[j] = sender.model.bounds[i].points["left"][j];

                            }
                        }
                        if ((!sf.util.isNullOrUndefined(sender.model.bounds[i].points["right"])) && (sender.model.bounds[i].points["right"].length > 0)) {
                            var pointsLength = sender.model.bounds[i].points["right"].length;
                            for (var k = 0; k < pointsLength && !(sf.util.isNullOrUndefined(sender.model.bounds[i].points["right"][k])); k++) {
                                sender.model.rightsidebounds[i].points[k] = sender.model.bounds[i].points["right"][k];
                            }
                        }

                    }
                }
            }
            else {

                if (sender.model.bounds[seriesIndex].points.length > 0 || seriesIndex >= 0) {
                    for (var i = seriesIndex; i < sender.model.bounds.length && (!sf.util.isNullOrUndefined(sender.model.bounds[i])); i++) {
                        if (sender.model._visibleSeries[i].labelPosition.toLowerCase() != "outsideextended") {
                            var pointsLength = sender.model.bounds[i].points.length;
                            for (var j = 0; j < pointsLength && !(sf.util.isNullOrUndefined(sender.model.bounds[i].points[j])); j++) {
                                if (sender.model.bounds[i].points[j].X < sender.model.circleCenterX[seriesIndex]) {
                                    if (($.inArray(sender.model.bounds[i].points[j], sender.model.leftsidebounds[i].points)) == -1)
                                        sender.model.leftsidebounds[i].points[j] = sender.model.bounds[i].points[j];
                                }
                                else if (($.inArray(sender.model.bounds[i].points[j], sender.model.rightsidebounds[i].points)) == -1)
                                    sender.model.rightsidebounds[i].points[j] = (sender.model.bounds[i].points[j]);

                            }
                        }
                    }
                }

            }
            for (i = seriesIndex; i < sender.model.bounds.length && (!sf.util.isNullOrUndefined(sender.model.bounds[i])); i++) {
                if (sender.model.leftsidebounds[i].points.length > 0) {
                    bounds = sender.model.leftsidebounds[i].points;
                    if (bounds.length > 0) {
                        for (var j = bounds.length - 1; j >= 0; j--) {
                            var other = bounds[j];

                            if (!(sf.util.isNullOrUndefined(other) && other != currBounds)) {
                                if (other.SeriesIndex == currBounds.SeriesIndex && other.PointIndex == currBounds.PointIndex) {
                                    if (point.smartLabelPosition == "outside")
                                        continue;
                                    else
                                        break;
                                }
                                else if (this.isIntersec(other, currBounds))
                                    return true;
                                else if (currBounds.X < sender.model.circleCenterX[seriesIndex] && other.X < sender.model.circleCenterX[seriesIndex] && sender.model.series[seriesIndex].marker.dataLabel.shape != "none") {                                  
                                    var yDiff = Math.abs(other.Y - currBounds.Y);
                                    if (size && yDiff <= size.height && other.Bottom > currBounds.Top && other.Left < currBounds.X)
                                        currBounds.overlap = true;
                                }
                            }
                        }
                    }

                }
            }
            for (i = seriesIndex; i < sender.model.bounds.length && (!sf.util.isNullOrUndefined(sender.model.bounds[i])); i++) {
                bounds = sender.model.rightsidebounds[i].points;
                if (bounds.length > 0) {
                    for (var j = bounds.length - 1; j >= 0; j--) {
                        var other = bounds[j];
                        if (!(sf.util.isNullOrUndefined(other) && other != currBounds)) {
                            if (other.SeriesIndex == currBounds.SeriesIndex && other.PointIndex == currBounds.PointIndex) {
                                if (point.smartLabelPosition == "outside")
                                    continue;
                                else
                                    break;
                            }
                            else if (this.isIntersec(other, currBounds))
                                return true;
                            else if (currBounds.X > sender.model.circleCenterX[seriesIndex] && other.X > sender.model.circleCenterX[seriesIndex]  && sender.model.series[seriesIndex].marker.dataLabel.shape != "none") {
                                var yDiff = Math.abs(other.Y - currBounds.Y);
                                if (size && yDiff <= size.height && other.Bottom > currBounds.Top && (other.X + (other.Right - other.Left)) > currBounds.X)
                                    currBounds.overlap = true;
                            }
                        }
                    }

                }
            }
            return intersect;

        },


        _calculateArcData: function (sender, pointIndex, point, series, seriesIndex, pieSeriesIndex) {
            var seriesIndex = sender.model._isPieOfPie ? pieSeriesIndex : seriesIndex;
            var visiblePoints = series._visiblePoints;
            var index = point.actualIndex;
            var chartObj = sender;
            var chartStartAngle = -.5 * Math.PI;
            var currBounds, startAngle, endAngle;
            // fix for doughnut width is inconsistent when series having single point-EJMVC-6272
            if (series.type.toLowerCase() == "doughnut" && series._visiblePoints.length == 1 && Math.abs(series.endAngle - series.startAngle) == 360
                && series.startAngle % 90 != 0) {
                startAngle = parseFloat((point.startAngle + chartStartAngle).toFixed(3));
                endAngle = parseFloat((point.endAngle + chartStartAngle).toFixed(3)) - 0.000001;
            }
            else {
                startAngle = point.startAngle + chartStartAngle;
                endAngle = point.endAngle + chartStartAngle - 0.000001;
            }
            var totalDegree = series.endAngle - series.startAngle;
            var longArc = endAngle - startAngle < Math.PI ? 0 : 1;
            var midAngle = (startAngle + endAngle) / 2;
            if (sf.util.isNullOrUndefined(point.currentMidAngle)) {
                point.currentMidAngle = (startAngle + endAngle) / 2;
            }
            var direction;
            var startX;
            var startY
            var clockWise = totalDegree > 0 ? 1 : 0;
            var longArc = clockWise ? endAngle - startAngle < Math.PI ? 0 : 1 : endAngle - startAngle > -1 * Math.PI ? 0 : 1;
            var radius = chartObj.model.circularRadius[seriesIndex];
            var innerRadius = chartObj.model.innerRadius[seriesIndex];
            if ((index == series.explodeIndex || series.explodeAll) && !chartObj.vmlRendering) {

                startX = chartObj.model.circleCenterX[seriesIndex] + Math.cos(midAngle) * series.explodeOffset;
                startY = chartObj.model.circleCenterY[seriesIndex] + Math.sin(midAngle) * series.explodeOffset;
            }
            else {
                startX = chartObj.model.circleCenterX[seriesIndex];
                startY = chartObj.model.circleCenterY[seriesIndex];
            }


            var x1 = startX + radius * Math.cos(startAngle);
            var y1 = startY + radius * Math.sin(startAngle);

            var x2 = startX + radius * Math.cos(endAngle);
            var y2 = startY + radius * Math.sin(endAngle);

            if (series.type.toLowerCase() == "doughnut") {
                var dStartX = startX + innerRadius * Math.cos(startAngle);
                var dStartY = startY + innerRadius * Math.sin(startAngle);

                var dEndX = startX + innerRadius * Math.cos(endAngle);
                var dEndY = startY + innerRadius * Math.sin(endAngle);
                var dClockWise = clockWise ? 0 : 1;
                if ((startAngle < 0) && Math.round(point.endAngle - point.startAngle) == 6) {
                    dEndX = dEndX - 0.01;
                    x2 = x2 - 0.01;
                }
                direction = "M" + " " + x1 + " " + y1 + " " + "A" + " " + radius + " " + radius + " " + "0" + " " + longArc + " " + clockWise + " " + x2 + " " + y2 + " " + "L" + " " + dEndX + " " + dEndY + " " + "A" + " " + innerRadius + " " + innerRadius + " " + "1" + " " + longArc + " " + dClockWise + " " + dStartX + " " + dStartY + " " + "z";
            }

            else {
                if ((point.endAngle - point.startAngle).toFixed(4) == (2 * Math.PI).toFixed(4)) {
                    var centerx = startX;
                    var centery = startY;
                    direction = "M" + " " + x1 + " " + y1 + " " + "A" + " " + radius + " " + radius + " " + "0" + " " + longArc + " " + clockWise + " " + x2 + " " + y2;
                }
                else
                    direction = "M" + " " + x1 + " " + y1 + " " + "A" + " " + radius + " " + radius + " " + "0" + " " + longArc + " " + clockWise + " " + x2 + " " + y2 + " " + "L" + " " + startX + " " + startY + " " + "z";
            }

            // display label for pie and doughnut chart


            return { Direction: direction, centerX: centerx, centerY: centery };

        },

        getXCordinate: function (x, radius, angle) {
            var x1 = x + radius * (Math.cos(angle));
            return x1;
        },

        getYCordinate: function (y, radius, angle) {
            var y1 = y + radius * (Math.sin(angle));
            return y1;
        },
        getDoubleRange: function (start, end) {
            var mstart;
            var mend;
            if (start > end) {
                mstart = end;
                mend = start;
            }
            else {
                mstart = start;
                mend = end;
            }

            var mdelta = mend - mstart;
            var mmedian = (mstart + mend) / 2;
            var misEmpty = isNaN(mstart) || isNaN(mend);

            return { Start: mstart, End: mend, Delta: mdelta, Median: mmedian, IsEmpty: misEmpty };

        },
        isDependentSeries: function (series) {
            var type = series.type.toLowerCase();
            var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
            if ((!requireInvertedAxes) || (requireInvertedAxes && series.isTransposed))
                return ((type.indexOf("bar") != -1 && !series._isTransposed) || (type.indexOf("column") != -1) || (type.indexOf("waterfall") != -1) || (type.indexOf("hilo") != -1) || (type.indexOf("candle") != -1) || (type.indexOf("boxandwhisker") != -1)) ? true : false;
            else
                return (type.indexOf("bar") != -1) ? true : false;
        },

        getPointXYOrgin: function (x, y, series, sender) {
            var requireInvertedAxes = sender.model.requireInvertedAxes;
            var xvalue;
            var yvalue;
            if ((series.isTransposed && requireInvertedAxes) || series._isTransposed) {
                xvalue = (1 - sf.EjSvgRender.utils._valueToCoefficient(series.xAxis, x)) * (series.xAxis.height);
                yvalue = (sf.EjSvgRender.utils._valueToCoefficient(series.yAxis, y)) * (series.yAxis.width);
                return { X: yvalue, Y: xvalue };
            }
            else {
                xvalue = sf.EjSvgRender.utils._valueToCoefficient(series.xAxis, x) * (series.xAxis.width);
                yvalue = (1 - sf.EjSvgRender.utils._valueToCoefficient(series.yAxis, y)) * (series.yAxis.height);
                return { X: xvalue, Y: yvalue };
            }
        },
        getRectangle: function (x1, y1, x2, y2, series, sender) {
            var pt1 = this.getPointXYOrgin(x1, y1, series, sender);
            var pt2 = this.getPointXYOrgin(x2, y2, series, sender);
            return sf.EjSvgRender.utils._correctRect(pt1.X, pt1.Y, pt2.X, pt2.Y);
        },

        calculateMean: function (values, series, pointIndex) {

            var q1Arr, q3Arr, q1Arrodd, q1Arreven, q2Arr, q3Arrodd, q3Arreven, q1half, q3half, midhalf, lowerquartile, upperquartile;
            var wholenumlower, remainderlower, intpartlower, decimalpartlower, wholenumupper, remainderupper, intpartupper, decimalpartupper,
                intpartlowerposition, intpartupperposition, averageValue = 0, boxAverageValue = 0, boxWhiskerValues = [], boxWhiskerCount = 0, boxes = [], boxArrCount = 0;
            if (values.length > 1)
                values.sort(function (a, b) { return a - b; });

            //showMean calculation
            for (var q = 0; q < values.length; q++) {
                averageValue = averageValue + values[q];
            }
            boxAverageValue = averageValue / values.length;
            boxAverageValue = parseInt(boxAverageValue.toFixed(2));
            boxes[boxArrCount] = boxAverageValue;
            boxArrCount++;

            if (series.boxPlotMode.toLowerCase() == "normal") {
                //Lower quartile calculation for normal mode
                q1Arr = (values.length % 2 == 0) ? values.slice(0, (values.length / 2)) : values.slice(0, Math.floor(values.length / 2));
                q1half = Math.floor(q1Arr.length / 2);
                lowerquartile = q1Arr.length % 2 == 0 ? (q1Arr[q1half - 1] + q1Arr[q1half]) / 2 : q1Arr[q1half];
                lowerquartile = (values.length <= 3) ? values[0] : lowerquartile;
                boxes[boxArrCount] = lowerquartile;
                boxArrCount++;
                //Upper quartile calculation for normal mode 	 
                q3Arr = (values.length % 2 == 0) ? values.slice((values.length / 2), values.length) : values.slice(Math.ceil(values.length / 2), values.length);
                q3half = Math.floor(q3Arr.length / 2);
                upperquartile = q3Arr.length % 2 == 0 ? (q3Arr[q3half - 1] + q3Arr[q3half]) / 2 : q3Arr[q3half];
                upperquartile = (values.length <= 3) ? values[values.length - 1] : upperquartile;
                boxes[boxArrCount] = upperquartile;
                boxArrCount++;
            }
            else if (series.boxPlotMode.toLowerCase() == "exclusive" || series.boxPlotMode.toLowerCase() == "inclusive") {

                //Lower quartile calculation for exclusive meadian and inclusive median 
                wholenumlower = series.boxPlotMode.toLowerCase() == "exclusive" ? (values.length + 1) / 4 : (values.length - 1) / 4;
                intpartlower = Math.floor(wholenumlower);
                decimalpartlower = wholenumlower - intpartlower;
                intpartlowerposition = series.boxPlotMode.toLowerCase() == "exclusive" ? intpartlower - 1 : intpartlower;
                q1Arr = (1 - decimalpartlower) * values[intpartlowerposition] + decimalpartlower * values[intpartlowerposition + 1];
                q1Arr = (values.length <= 3) ? values[0] : q1Arr;
                lowerquartile = q1Arr;
                boxes[boxArrCount] = lowerquartile;
                boxArrCount++;

                //Upper quartile calculation for exclusive meadian and inclusive median 
                wholenumupper = series.boxPlotMode.toLowerCase() == "exclusive" ? (3 * (values.length + 1)) / 4 : (3 * (values.length - 1)) / 4;
                intpartupper = Math.floor(wholenumupper);
                decimalpartupper = wholenumupper - intpartupper;
                intpartupperposition = series.boxPlotMode.toLowerCase() == "exclusive" ? intpartupper - 1 : intpartupper;
                q3Arr = (1 - decimalpartupper) * values[intpartupperposition] + decimalpartupper * values[intpartupperposition + 1];
                q3Arr = (values.length <= 3) ? values[values.length - 1] : q3Arr;
                upperquartile = q3Arr;
                boxes[boxArrCount] = upperquartile;
                boxArrCount++;
            }


            //calculate median
            midhalf = Math.floor(values.length / 2);
            q2Arr = values.length % 2 == 0 ? (values[midhalf - 1] + values[midhalf]) / 2 : values[midhalf];
            boxes[boxArrCount] = q2Arr;
            boxArrCount++;

            //calculate interquartile range
            var iqr = upperquartile - lowerquartile;
            var upperrange = upperquartile + 1.5 * (iqr);
            var lowerrange = lowerquartile - 1.5 * (iqr);
            var maximum = values[values.length - 1];
            var minimum = values[0];
            var outliers = [], maxNumCount = 0, index = 0;


            for (var i = 0; i < values.length; i++) {
                if (upperrange < values[i]) {
                    maxNumCount++;
                    outliers[index] = values[i];
                    index++;
                    maximum = values[i - maxNumCount];

                }
                if (lowerrange > values[i]) {
                    outliers[index] = values[i];
                    index++;
                    minimum = values[i + 1];
                }
            }
            boxes[boxArrCount] = minimum;
            boxArrCount++;
            boxes[boxArrCount] = maximum;
            boxArrCount++;

            var boxPlotValues = { Minimum: minimum, LowerQuartile: lowerquartile, midvalue: q2Arr, UpperQuartile: upperquartile, Maximum: maximum, boxAverage: boxAverageValue, outliers: outliers };
            series._visiblePoints[pointIndex].boxPlotValues = boxPlotValues;
            series._visiblePoints[pointIndex].boxPlotValues.quartileValues = boxes;




            return { Minimum: minimum, LowerQuartile: lowerquartile, midvalue: q2Arr, UpperQuartile: upperquartile, Maximum: maximum, boxAverage: boxAverageValue, outliers: outliers };
        },
        calculateBoxAndWhiskerPath: function (options, rect, options1, list2, series, point, pointIndex) {

            series._visiblePoints[pointIndex].boxPlotLocation = [];
            series._visiblePoints[pointIndex].dataLabelLocation = [];
            var boxCount = 0;
            var cSer = this, offset = 5;
            var isTransposed = series._isTransposed;
            var outlierShape = series.outlierSettings.shape.toLowerCase();
            var invertedAxis = this.chartObj.model.requireInvertedAxes, whiskerpath, boxAvg, boxAvgValue, fenceValue, outlierpoint;


            for (var p = 0; p < series._visiblePoints[pointIndex].boxPlotValues.quartileValues.length; p++) {
                boxAvg = { "xValue": point.xValue, "YValues": series._visiblePoints[pointIndex].boxPlotValues.quartileValues[p] };
                boxAvgValue = sf.EjSvgRender.utils._getPoint(boxAvg, series);
                series._visiblePoints[pointIndex].boxPlotLocation[boxCount] = boxAvgValue;
                series._visiblePoints[pointIndex].boxPlotLocation[boxCount].xValue = boxAvg.xValue;
                series._visiblePoints[pointIndex].boxPlotLocation[boxCount].YValues = boxAvg.YValues;
                if (isTransposed)
                    series._visiblePoints[pointIndex].dataLabelLocation[boxCount] = { X: boxAvgValue.X, Y: rect.Y + rect.Height / 2 + offset }
                else
                    series._visiblePoints[pointIndex].dataLabelLocation[boxCount] = { X: rect.X + rect.Width / 2, Y: boxAvgValue.Y };
                boxCount++;

            }

            for (var k = 0; k < list2.outliers.length && outlierShape != "none"; k++) {
                fenceValue = { "xValue": point.xValue, "YValues": list2.outliers[k] };
                outlierpoint = sf.EjSvgRender.utils._getPoint(fenceValue, series);
                series._visiblePoints[pointIndex].boxPlotLocation[boxCount] = outlierpoint;//to store x and y positions of upper outlier
                series._visiblePoints[pointIndex].boxPlotLocation[boxCount].xValue = fenceValue.xValue;
                series._visiblePoints[pointIndex].boxPlotLocation[boxCount].YValues = fenceValue.YValues;
                series._visiblePoints[pointIndex].boxPlotLocation[boxCount].outlier = true;
                if (isTransposed)
                    outlierpoint.Y = rect.Y + rect.Height / 2;
                else
                    outlierpoint.X = rect.X + rect.Width / 2;
                if (isTransposed)
                    series._visiblePoints[pointIndex].dataLabelLocation[boxCount] = { X: outlierpoint.X - series.outlierSettings.size.height, Y: rect.Y + rect.Height / 2 + series.outlierSettings.size.width, outlier: true }
                else
                    series._visiblePoints[pointIndex].dataLabelLocation[boxCount] = { X: rect.X + rect.Width / 2, Y: outlierpoint.Y, outlier: true };
                boxCount++;
            }
            whiskerpath = series._visiblePoints[pointIndex].boxPlotLocation;

            if (series._isTransposed) {
                var plotlowerwhisker = "M" + " " + (cSer.chartObj.canvasX + whiskerpath[4].X) + " " + (cSer.chartObj.canvasY + rect.Y) + " L " + (whiskerpath[4].X + cSer.chartObj.canvasX) + " " + (rect.Height + rect.Y + cSer.chartObj.canvasY) + " M " + (cSer.chartObj.canvasX + whiskerpath[4].X) + " " + (cSer.chartObj.canvasY + rect.Y + (rect.Height / 2)) + " L " + (cSer.chartObj.canvasX + whiskerpath[1].X) + " " + (cSer.chartObj.canvasY + rect.Y + (rect.Height / 2)) + " " + " z";
                var plotupperwhisker = "M" + " " + (cSer.chartObj.canvasX + whiskerpath[5].X) + " " + (cSer.chartObj.canvasY + rect.Y) + " L " + (cSer.chartObj.canvasX + whiskerpath[5].X) + " " + (rect.Height + rect.Y + cSer.chartObj.canvasY) + " M " + (cSer.chartObj.canvasX + whiskerpath[5].X) + " " + (cSer.chartObj.canvasY + rect.Y + (rect.Height / 2)) + " L " + (cSer.chartObj.canvasX + whiskerpath[2].X) + " " + (cSer.chartObj.canvasY + rect.Y + (rect.Height / 2)) + " " + " z";

            }
            else {
                var plotlowerwhisker = "M" + " " + (cSer.chartObj.canvasX + rect.X) + " " + (cSer.chartObj.canvasY + whiskerpath[4].Y) + " L " + (cSer.chartObj.canvasX + rect.X + rect.Width) + " " + (cSer.chartObj.canvasY + whiskerpath[4].Y) + " M " + (cSer.chartObj.canvasX + rect.X + (rect.Width / 2)) + " " + (cSer.chartObj.canvasY + whiskerpath[4].Y) + " L " + (cSer.chartObj.canvasX + rect.X + (rect.Width / 2)) + " " + (cSer.chartObj.canvasY + whiskerpath[1].Y) + " " + " z";
                var plotupperwhisker = "M" + " " + (cSer.chartObj.canvasX + rect.X) + " " + (cSer.chartObj.canvasY + whiskerpath[5].Y) + " L " + (cSer.chartObj.canvasX + rect.X + rect.Width) + " " + (cSer.chartObj.canvasY + whiskerpath[5].Y) + " M " + (cSer.chartObj.canvasX + rect.X + (rect.Width / 2)) + " " + (cSer.chartObj.canvasY + whiskerpath[5].Y) + " L " + (cSer.chartObj.canvasX + rect.X + (rect.Width / 2)) + " " + (cSer.chartObj.canvasY + whiskerpath[2].Y) + " " + " z";
            }

            var meanPath = !series._isTransposed ? "M" + " " + (cSer.chartObj.canvasX + rect.X + (rect.Width / 2) - 5) + " " + (cSer.chartObj.canvasY + whiskerpath[0].Y - 5) + " L " + (cSer.chartObj.canvasX + rect.X + (rect.Width / 2) + 5) + " " + (cSer.chartObj.canvasY + whiskerpath[0].Y + 5) + " M " + (cSer.chartObj.canvasX + rect.X + (rect.Width / 2) - 5) + " " + (cSer.chartObj.canvasY + whiskerpath[0].Y + 5) + " L " + (cSer.chartObj.canvasX + rect.X + (rect.Width / 2) + 5) + " " + (cSer.chartObj.canvasY + whiskerpath[0].Y - 5) + " " + "z" :
                "M" + " " + (cSer.chartObj.canvasX + whiskerpath[0].X - 5) + " " + (cSer.chartObj.canvasY + rect.Y + (rect.Height / 2) - 5) + " L " + (cSer.chartObj.canvasX + whiskerpath[0].X + 5) + " " + (cSer.chartObj.canvasY + rect.Y + (rect.Height / 2) + 5) + " M " + (cSer.chartObj.canvasX + whiskerpath[0].X + 5) + " " + (cSer.chartObj.canvasY + rect.Y + (rect.Height / 2) - 5) + " L " + (cSer.chartObj.canvasX + whiskerpath[0].X - 5) + " " + (cSer.chartObj.canvasY + rect.Y + (rect.Height / 2) + 5) + " " + "z";


            return { upperWhisker: plotupperwhisker, lowerWhisker: plotlowerwhisker, mean: meanPath };
        },
        calculateSides: function (point, sidebysideinfo) {
            var x1 = point.xValue + sidebysideinfo.Start;
            var x2 = point.xValue + sidebysideinfo.End;
            return { x1: x1, x2: x2 };
        },
        _getSeriesPosition: function (currentSeries) {
            // calculation for position of series in radar and polar.
            if (sf.util.isNullOrUndefined(currentSeries.position) || this.chartObj.model.legendCollapsed) {
                var stacked;
                var stackingposition
                var all = 0;
                var seriesCollection = [];
                for (var i = 0; i < this.chartObj.model._visibleSeries.length; i++) {
                    var series = this.chartObj.model._visibleSeries[i];
                    if (series.visibility.toLowerCase() === 'visible' && series.drawType.toLowerCase() == 'column' || (series.drawType.toLowerCase() == 'rangecolumn')) {
                        seriesCollection.push(series);
                    }
                }
                for (var j = 0; j < seriesCollection.length; j++) {
                    var series = seriesCollection[j];
                    if (series._xAxisName == this.chartObj.model._axes[0].name && series._yAxisName == this.chartObj.model._axes[1].name) {
                        if (series.isStacking) {
                            if (!stacked) {
                                stackingposition = all;
                                all++;
                                stacked = true;
                            }
                            series.position = stackingposition;
                        }
                        else {
                            series.position = all;
                            all++;
                        }
                    }
                }
                for (var k = 0; k < seriesCollection.length; k++)
                    seriesCollection[k].all = all;

            }
            return { all: currentSeries.all, pos: currentSeries.position };
        },
        getSideBySidePositions: function (currentSeries, params) {

            var chart = this,
                stackingGroup = [],
                model = chart.chartObj.model,
                vAxeseries, i, j, k, visibleSeriesLength;
            i = j = k = 0;
            visibleSeriesLength = model._visibleSeries.length;
            //Spacing not calculated during resize event because position value in series is not null or undefined		 
            if (sf.util.isNullOrUndefined(currentSeries.position) || model.legendCollapsed || !params.spacingCalculated) {
                var hAxes = (model.requireInvertedAxes) ? model.vAxes : model.hAxes;
                var vAxes = (model.requireInvertedAxes) ? model.hAxes : model.vAxes;

                $.each(hAxes, function (index, hAxis) {
                    var all = 0, seriesCollection = [];
                    vAxeseries = [];
                    for (j = 0; j < visibleSeriesLength; j++) {
                        var series = model._visibleSeries[j];
                        if (series.visibility.toLowerCase() === 'visible') {
                            if (chart.isDependentSeries(series)) {
                                    seriesCollection.push(series);
                            }
                        }
                    }
                    var seriesCollectionLength = seriesCollection.length;
                    for (j = 0; j < seriesCollectionLength; j++) {
                        var index = (model.requireInvertedAxes) ? seriesCollection[j].yAxis.columnIndex : seriesCollection[j].yAxis.rowIndex;
                        if (!vAxeseries[index]) {
                            vAxeseries[index] = [];
                            seriesCollection[j].yAxis.position = null;
                        }
                        vAxeseries[index].push(seriesCollection[j]);
                    }

                    for (i = 0; i < vAxeseries.length; i++) {
                        if (!sf.util.isNullOrUndefined(vAxeseries[i])) {
                            vAxeseries[i].all = 0;
                            for (j = 0; j < vAxeseries[i].length; j++) {
                                series = vAxeseries[i][j];
                                if (series.type.toLowerCase().indexOf("stacking") != -1) {
                                    if (series.stackingGroup) {
                                        if (sf.util.isNullOrUndefined(stackingGroup[series.stackingGroup])) {
                                            vAxeseries[i].all++;
                                            series.position = vAxeseries[i].all;
                                            stackingGroup[series.stackingGroup] = vAxeseries[i].all;
                                        }
                                        else
                                            series.position = stackingGroup[series.stackingGroup];
                                    }
                                    else {
                                        if (sf.util.isNullOrUndefined(series.yAxis.position) || model.legendCollapsed) {
                                            vAxeseries[i].all++;
                                            series.position = vAxeseries[i].all;
                                            series.yAxis.position = vAxeseries[i].all;
                                            model.legendCollapsed = false;
                                        }
                                        else
                                            series.position = series.yAxis.position;
                                    }
                                }
                                else {
                                    vAxeseries[i].all++;
                                    series.position = vAxeseries[i].all;
                                }
                            }
                        }
                    }
                    var columnWidth = seriesCollectionLength > 0 && seriesCollection[0].columnWidth;
                    for (k = 0; k < seriesCollectionLength; k++) {
                        var index = (model.requireInvertedAxes) ? seriesCollection[k].yAxis.columnIndex : seriesCollection[k].yAxis.rowIndex;
                        seriesCollection[k].all = vAxeseries[index].all;
                        params.needSpace = params.needSpace || columnWidth != seriesCollection[k].columnWidth
                    }

                });
                if (params.needSpace && this.chartObj.model._sideBySideSeriesPlacement)
                    this._getColumnSpacing(vAxeseries, params);
                params.spacingCalculated = true;
            }
            return { all: currentSeries.all, pos: currentSeries.position };
        },

        getSideBySideInfo: function (series, params) {
            if (sf.util.isNullOrUndefined(series.xAxis.m_minPointsDelta)) {
                this.chartObj.currentSeries = series;
                series.xAxis.m_minPointsDelta = sf.EjSvgRender.utils.getMinPointsDelta(series.xAxis, this.chartObj);
            }
            var spacing = series.columnSpacing,
                columnWidth = series.columnWidth,
                data = this.getSideBySidePositions(series, params),
                pos = data.pos,
                all = data.all,
                needSpace = params.needSpace && this.chartObj.model._sideBySideSeriesPlacement,
                width = series.xAxis.m_minPointsDelta * (needSpace ? 1 : columnWidth),
                loc = needSpace ? params[series.name || series._name].loc : (pos - 1) / all - 0.5,
                range = this.getDoubleRange(loc, loc + (needSpace ? columnWidth : 1) / all);
            if (!this.chartObj.model._sideBySideSeriesPlacement)
                return this.getDoubleRange(-width / 2, width / 2);


            // multiplying with width  and scaling
            if (!range.IsEmpty) {
                range = this.getDoubleRange(range.Start * width, range.End * width);
                var radius = spacing * range.Delta;
                range = this.getDoubleRange(range.Start + radius / 2, range.End - radius / 2);
            }
            return range;
        },

        _getColumnSpacing: function (axesSeries, params) {
            var i = 0, j = 0, length, len, series, name;
            for (len = axesSeries.length; i < len; i++) {
                var width = 0, stackingSeries = [], group = {};
                for (length = axesSeries[i].length; j < length; j++)
                    if ((series = axesSeries[i][j]).type.toLowerCase().indexOf("stacking") == -1)
                        width += series.columnWidth / series.all;
                    else
                        group[name = series.stackingGroup] = { width: Math.max(series.columnWidth, group[name] ? group[name].width : 0), all: series.all }
                for (var key in group)
                    width += group[key].width / group[key].all;

                var start = (1 - width) / 2 - .5;
                for (j = 0, length = axesSeries[i].length; j < length; j++) {
                    if ((series = axesSeries[i][j]).type.toLowerCase().indexOf("stacking") == -1) {
                        params[series.name || (series._name = "series" + i + j)] = { loc: start };
                        start += series.columnWidth / series.all;
                    }
                    else {
                        if (group[name = series.stackingGroup].loc == null) {
                            params[series.name || (series._name = "series" + i + j)] = { loc: start + (group[name].width - series.columnWidth) / 2 / series.all };
                            group[name].loc = params[series.name || series._name].loc + series.columnWidth / 2 / series.all;
                            start += group[name].width / series.all;
                        }
                        else
                            params[series.name || series._name] = { loc: group[name].loc - series.columnWidth / 2 / series.all };
                    }
                }
            }
        },

        _getPoint: function (point, xLength, yLength, xRange, xInversed, yRange, yInversed) {

            var x = point.xValue,
                y = point.YValues[0];

            x = (x - xRange.min) / (xRange.delta);
            y = (y - yRange.min) / (yRange.delta);

            return { X: (!xInversed ? x : 1 - x) * xLength, Y: (1 - (!yInversed ? y : 1 - y)) * yLength };
        },

        _getLogPoint: function (point, xLength, yLength, xRange, xInversed, yRange, yInversed, series) {

            var x = point.xValue,
                y = point.YValues[0];
            if (series.xAxis._valueType.toLowerCase() == "logarithmic")
                x = (sf.EjSvgRender.utils._logBase((x == 0 ? 1 : x), series.xAxis.logBase) - xRange.min) / (xRange.delta);
            else
                x = (x - xRange.min) / (xRange.delta);

            if (series.yAxis._valueType.toLowerCase() == "logarithmic")
                y = (sf.EjSvgRender.utils._logBase((y == 0 ? 1 : y), series.yAxis.logBase) - yRange.min) / (yRange.delta);
            else
                y = (y - yRange.min) / (yRange.delta);

            return { X: (!xInversed ? x : 1 - x) * xLength, Y: (1 - (!yInversed ? y : 1 - y)) * yLength };
        },

        _getTransposedPoint: function (point, xLength, yLength, xRange, xInversed, yRange, yInversed) {

            var x = point.xValue,
                y = point.YValues[0];

            x = (x - xRange.min) / xRange.delta;
            y = (y - yRange.min) / yRange.delta;

            return { X: (!yInversed ? y : 1 - y) * yLength, Y: (1 - (!xInversed ? x : 1 - x)) * xLength };
        },

        _getTransposedLogPoint: function (point, xLength, yLength, xRange, xInversed, yRange, yInversed, series) {

            var x = point.xValue,
                y = point.YValues[0];

            if (series.xAxis._valueType.toLowerCase() == "logarithmic")
                x = (sf.EjSvgRender.utils._logBase((x == 0 ? 1 : x), series.xAxis.logBase) - xRange.min) / (xRange.delta);
            else
                x = (x - xRange.min) / (xRange.delta);

            if (series.yAxis._valueType.toLowerCase() == "logarithmic")
                y = (sf.EjSvgRender.utils._logBase((y == 0 ? 1 : y), series.yAxis.logBase) - yRange.min) / (yRange.delta);
            else
                y = (y - yRange.min) / (yRange.delta);

            return { X: (!yInversed ? y : 1 - y) * yLength, Y: (1 - (!xInversed ? x : 1 - x)) * xLength };
        },

        draw: function (chart, options, excludeDataUpdate) {

            //DrawLineGraph
            var lDirection, sb = sf.EjSvgRender.utils._getStringBuilder(),
                visiblePoints, limit, i, pathOptions,
                firstPoint, secondPoint, firstIndex,
                point1, point2, canvasX = chart.canvasX, canvasY = chart.canvasY,
                seriesIndex, nextpoint, context, length, serOptions,
                previousStyle, styleOptions, point,
                requireInvertedAxes = chart.model.requireInvertedAxes,
                count = 0, isCanvas = chart.model.enableCanvasRendering,
                chartObj = chart, trans,
                isLog = options.xAxis._valueType.toLowerCase() == "logarithmic" || options.yAxis._valueType.toLowerCase() == "logarithmic",
                isTransposed = options._isTransposed,
                xLength = isTransposed ? options.xAxis.height : options.xAxis.width,
                yLength = isTransposed ? options.yAxis.width : options.yAxis.height,
                xRange = options.xAxis.visibleRange, yRange = options.yAxis.visibleRange,
                xInversed = options.xAxis.isInversed, yInversed = options.yAxis.isInversed,
                style, getPoint = this["_get" + (isTransposed ? "Transposed" : "") + (isLog ? "Log" : "") + "Point"];

            this.chartObj = chart;
            style = this.setLineSeriesStyle(options);
            options._animationType = "path";
            if (options.sorting)
                options.points = sf.DataManager(options.points, sf.Query().sortBy("xValue")).executeLocal();
            options._visiblePoints = undefined;
            visiblePoints = this.improveChartPerformance(options);

            limit = { min: 0, max: visiblePoints.length };
            if (!options.pointFill) {
                if (isCanvas) {
                    context = chart.svgRenderer.ctx;
                    context.save();
                    context.beginPath();
                    if (chart.model.AreaType == "cartesianaxes") {
                        trans = sf.EjSvgRender.utils._getTransform(options.xAxis, options.yAxis, requireInvertedAxes);
                        trans = 'translate(' + trans.x + ',' + trans.y + ')'
                    }
                    styleOptions = {
                        'stroke-dasharray': options.dashArray,
                        'stroke-width': options.width,
                        'stroke': style.SeriesInterior,
                        'stroke-linecap': options.lineCap,
                        'stroke-linejoin': options.lineJoin,
                        'opacity': options.opacity
                    };
                    chart.svgRenderer._setLinePathStyle(styleOptions, trans);
                }
                firstPoint = null;
                secondPoint;
                firstIndex = -1;
                var startDirection = "M ";
				var prevPoint;
                for (i = limit.min; i < limit.max; i++) {
                    secondPoint = visiblePoints[i];
                    if (secondPoint.visible !== false) {
                        if (firstPoint != null && visiblePoints.length > firstIndex + 1) {
                            nextpoint = visiblePoints[firstIndex + 1];
                            point1 = getPoint(firstPoint, xLength, yLength, xRange, xInversed, yRange, yInversed, options);
                            point2 = getPoint(nextpoint, xLength, yLength, xRange, xInversed, yRange, yInversed, options);
                            if (isCanvas) {
								if(prevPoint){
									context.lineTo(point2.X + canvasX, point2.Y + canvasY);
									prevPoint = null;
								}
                                context.moveTo(point1.X + canvasX, point1.Y + canvasY);
                                context.lineTo(point2.X + canvasX, point2.Y + canvasY);
								prevPoint = point2;
                            }
                            else {
                                sb.append(startDirection + (point1.X + canvasX) + " " + (point1.Y + canvasY) + " L " + (point2.X + canvasX) + " " + (point2.Y + canvasY) + " ");
                                startDirection = "L ";
                            }
                        }
                        firstPoint = secondPoint;
                        firstIndex = i;
                    }
                    else {
                        firstPoint = prevPoint = null;
                        startDirection = "M ";
                    }
                }
                if (isCanvas) {
                    context.stroke();
                    context.restore();
                }
                else
                    this._drawLinePath(options, style, sb.toString());
            }

            else {
                seriesIndex = $.inArray(options, this.chartObj.model._visibleSeries),
                    length = visiblePoints.length - 1;

                trans = sf.EjSvgRender.utils._getTransform(options.xAxis, options.yAxis, requireInvertedAxes);

                canvasX = chartObj.canvasX, canvasY = chartObj.canvasY,

                    serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };

                this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);

                for (i = 0; i < length; i++) {
                    point = visiblePoints[i];
                    nextpoint = visiblePoints[i + 1];

                    if (!previousStyle)
                        previousStyle = this.chartObj.setStyle(this, options, seriesIndex, i, undefined, visiblePoints);

                    if (nextpoint.visible && point.visible) {
                        point1 = sf.EjSvgRender.utils._getPoint(point, options);

                        point2 = sf.EjSvgRender.utils._getPoint(nextpoint, options);

                        sb.append("M" + " " + (point1.X + canvasX) + " " + ((point1.Y + canvasY)) + " " + "L" + " " + (point2.X + canvasX) + " " + ((point2.Y + canvasY)) + " ");
                    }

                    styleOptions = this.chartObj.setStyle(this, options, seriesIndex, i + 1, undefined, visiblePoints);

                    if (styleOptions.interior == previousStyle.interior && (i != length - 1) && nextpoint.visible)
                        continue;

                    pathOptions = {
                        'name': options.type,
                        'id': this.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + (count++),
                        'stroke-dasharray': previousStyle.dashArray,
                        'fill': "none",
                        'stroke-width': previousStyle.width,
                        'stroke-linecap': options.lineCap,
                        'stroke-linejoin': options.lineJoin,
                        'stroke': previousStyle.interior,
                        'opacity': previousStyle.opacity,
                        'd': sb.toString()
                    };

                    this.chartObj.svgRenderer.drawPath(pathOptions, this.gSeriesGroupEle);
                    sb = sf.EjSvgRender.utils._getStringBuilder();
                    previousStyle = styleOptions;
                }
            }
            if (this.chartObj.dragPoint)
                this.chartObj.svgRenderer.append(this.chartObj.gPreviewSeriesGroupEle, this.chartObj.gSeriesEle);
            else
                this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

            //Calculate visible points for points with data label
            if (options._dataLabels > 0 || options.marker && options.marker.dataLabel.visible == true && options.enableSmartLabels)
                options._visiblePoints = this._isVisiblePoints(options);
            else //Use sampled data points if data labels are not visible 
                options._visiblePoints = visiblePoints;
        },

        doCircularAnimation: function (chartObj, series, seriesType, seriesIndex, duration) {
            var type = series.type.toLowerCase();
            if (type == "pie" || type == "doughnut" || type == "pieofpie") {
                var seriesRender = this, startAngle, endAngle,
                    angle = (series.points[0]) ? series.points[0].startAngle : 0;
                var collectionIndex = chartObj.model._isPieOfPie ? series.collectionIndex : 0,
                    visiblePoints = series.emptyPointSettings.visible ? series.visiblePoints : series._visiblePoints;
                duration = !sf.util.isNullOrUndefined(duration) ? duration : 1200;
                $.each(visiblePoints, function (pointIndex, point) {
                    startAngle = point.startAngle;
                    endAngle = point.endAngle;
                    chartObj.model._radius = chartObj.model._isPieOfPie ? chartObj.model.circularRadius[collectionIndex] : chartObj.model.circularRadius[seriesIndex];
                    point.startAngle = 0;
                    point.endAngle = point.startAngle;
                    chartObj.model.Radius = 0;
                    var piePath = $(chartObj.gSeriesEle).find("#" + chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex)[collectionIndex].childNodes[pointIndex];
                    if (type == "pie" || type == "pieofpie") {
                        $(piePath).each(function () { this.StartAngle = angle, this.EndAngle = angle; }).animate(
                            { StartAngle: startAngle, EndAngle: endAngle, pieRadius: chartObj.model._radius },
                            {
                                duration: duration, queue: false, step: function (now, fx) {
                                    if (fx.prop.toString() === "StartAngle") {
                                        point.startAngle = now;
                                        point.endAngle = point.startAngle;
                                    }
                                    else if (fx.prop.toString() == "pieRadius" && chartObj.model)
                                        chartObj.model.Radius = now;
                                    else
                                        point.endAngle = now;
                                    if (chartObj.model) {
                                        var result = seriesRender._calculateArcData(chartObj, pointIndex, point, series, seriesIndex, collectionIndex);
                                        chartObj.svgRenderer._setAttr($(piePath), { "d": result.Direction });
                                        chartObj.model.Radius = chartObj.model._radius;
                                    }
                                },
                                complete: function () {
                                    seriesRender.circularAnimationComplete(pointIndex, chartObj, series);
                                }
                            });
                    }
                    else {
                        $(piePath).each(function () { this.StartAngle = angle, this.EndAngle = angle; }).animate(
                            { StartAngle: startAngle, EndAngle: endAngle },
                            {
                                duration: duration, queue: false, step: function (now, fx) {
                                    if (fx.prop.toString() === "StartAngle") {
                                        point.startAngle = now;
                                        point.endAngle = point.startAngle;
                                    }
                                    else
                                        point.endAngle = now;
                                    if (chartObj.model) {
                                        var result = seriesRender._calculateArcData(chartObj, pointIndex, point, series, seriesIndex);
                                        chartObj.svgRenderer._setAttr($(piePath), { "d": result.Direction });
                                        chartObj.model.Radius = chartObj.model._radius;
                                    }
                                },
                                complete: function () {
                                    seriesRender.circularAnimationComplete(pointIndex, chartObj, series);
                                }
                            });
                    }
                });
            }
        },
        circularAnimationComplete: function (pointIndex, chartObj, series) {
            if (!sf.util.isNullOrUndefined(chartObj.model)) {
                var commonEventArgs, i, seriesIndex = $.inArray(series, chartObj.model._visibleSeries), elements;
                if (chartObj.gSeriesTextEle[seriesIndex])
                    chartObj.svgRenderer._setAttr($(chartObj.gSeriesEle).find("#" + chartObj.gSeriesTextEle[seriesIndex].id), { "visibility": "visible" });
                if (chartObj.gSymbolGroupEle[seriesIndex])
                    chartObj.svgRenderer._setAttr($(chartObj.gSeriesEle).find("#" + chartObj.gSymbolGroupEle[seriesIndex].id), { "visibility": "visible" });
                if (chartObj.gDataLabelEle[seriesIndex])
                    chartObj.svgRenderer._setAttr($(chartObj.gSeriesEle).find("#" + chartObj.gDataLabelEle[seriesIndex].id), { "visibility": "visible" });
                if (series.marker.dataLabel.template) {
                    elements = $(chartObj.element[0].childNodes[0].childNodes);
                    for (i = 0; i < elements.length; i++)
                        $(elements[i]).css('display', 'block');
                }
                if (chartObj.gConnectorEle[seriesIndex])
                    chartObj.svgRenderer._setAttr($(chartObj.gSeriesEle).find("#" + chartObj.gConnectorEle[seriesIndex].id), { "visibility": "visible" });
                if (chartObj.gConnectorLinesGroup)
                    chartObj.svgRenderer._setAttr($(chartObj.gSeriesEle).find("#" + chartObj.gConnectorLinesGroup.id), { "visibility": "visible" });
                chartObj.model.AnimationComplete = true;
                series.AnimationComplete = true;
                commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = { series: series };
                chartObj._trigger("animationComplete", commonEventArgs);
            }
        },

        _doLineSymbol: function (element, sec, val, series, invertedAxes, chartobj, duration) {
            if (element.tagName != "defs") {
                var beginTime = parseInt(val * sec),
                    chartObj = (this.chartObj == undefined) ? chartobj : this.chartObj,
                    box = sf.EjSvgRender.utils._getBoundingClientRect(element, chartObj, series, invertedAxes),
                    centerX = box.x + (box.width / 2),
                    centerY = box.y + (box.height / 2),
                    scaleVal, $ele = $(element),
                    rotate = chartObj.svgRenderer._getAttrVal($ele, "transform");
                rotate = !sf.util.isNullOrUndefined(rotate) ? rotate : " ";
                chartObj.svgRenderer._setAttr($ele, { "transform": "scale(0)" });
                $ele.delay(beginTime).animate(
                    {
                        scales: 1
                    },
                    {
                        duration: duration,
                        step: function (now) {
                            scaleVal = now;
                            chartObj.svgRenderer._setAttr($ele, { "transform": "translate(" + centerX + " " + centerY + ") scale(" + scaleVal + ") translate(" + (-centerX) + " " + (-centerY) + ")" + rotate });

                        }
                    }
                );
            }
        },
        animateSymbol: function (element, delayInterval, series, invertedAxes, chartobj, duration) {
            if (element.tagName != "defs") {
                var chartObj = (this.chartObj == undefined) ? chartobj : this.chartObj,
                    box = sf.EjSvgRender.utils._getBoundingClientRect(element, chartObj, series, invertedAxes),
                    centerX = box.x + (box.width / 2),
                    centerY = box.y + (box.height / 2),
                    scaleVal, $ele = $(element),
                    rotate = chartObj.svgRenderer._getAttrVal($ele, "transform");
                rotate = !sf.util.isNullOrUndefined(rotate) ? rotate : " ";
                $ele.delay(delayInterval).each(function () { this.scale = 0.5; }).animate(
                    {
                        scales: 1
                    },
                    {
                        duration: duration,
                        step: function (now) {
                            scaleVal = now;
                            chartObj.svgRenderer._setAttr($ele, { "transform": "translate(" + centerX + " " + centerY + ") scale(" + scaleVal + ") translate(" + (-centerX) + " " + (-centerY) + ")" + (rotate) });
                        }
                    }
                );
            }
        },
        animateCylinder: function (chartObj, series, invertedAxes, clipRect, duration) {
            if (series.isTransposed && invertedAxes) {
                var width = clipRect[0].width.animVal.value
                if (chartObj.model.series[0].type.indexOf("bar") > -1) {
                    chartObj.svgRenderer._setAttr($(clipRect), { "x": width });
                    $(clipRect).animate({
                        x: 0,
                    }, duration, function () {
                    });
                }
                else {
                    var height = clipRect[0].height.animVal.value;
                    chartObj.svgRenderer._setAttr($(clipRect), { "y": 0 });
                    $(clipRect).animate(
                        {
                            y: parseFloat(chartObj.svgRenderer._getAttrVal(clipRect, "y")),
                            height: parseFloat(chartObj.svgRenderer._getAttrVal(clipRect, "height"))
                        },
                        {
                            duration: duration,
                            step: function (now) {
                                chartObj.svgRenderer._setAttr($(clipRect), { "y": height - now });
                                chartObj.svgRenderer._setAttr($(clipRect), { "height": now });
                            }
                        });
                }
            }
            else {
                if (chartObj.model.series[0].type.indexOf("bar") > -1) {
                    $(clipRect).animate(
                        {
                            width: parseFloat(chartObj.svgRenderer._getAttrVal(clipRect, "width"))
                        },
                        {
                            duration: duration,
                            step: function (now) {
                                chartObj.svgRenderer._setAttr($(clipRect), { "width": now });
                            }
                        });
                }
                else {
                    var height = clipRect[0].height.animVal.value;
                    chartObj.svgRenderer._setAttr($(clipRect), { "y": height });
                    $(clipRect).animate({

                        y: 0,
                    }, duration, function () {
                    });
                }
            }
        },
        animateRect: function (element, series, invertedAxes, chartObj, duration) {
            var animationType = series.animationType.toLowerCase();
            var box = sf.EjSvgRender.utils._getBoundingClientRect(
                animationType == "smooth" ? element[0] : element, chartObj, series, invertedAxes
            ), centerX, centerY, scale1, scale2, scaleVal, $element = $(element), size, isBar;
            if ((series.isTransposed && invertedAxes) || invertedAxes) {
                size = animationType == "smooth" ? parseFloat(chartObj.svgRenderer._getAttrVal(element, "width")) : 0;
                isBar = true;
                if (chartObj.svgRenderer._getAttrVal($element, "plot") === "negative") {
                    centerX = box.x + box.width;
                    centerY = box.y + box.height;
                } else {
                    centerX = box.x;
                    centerY = box.y;
                }
                scale1 = ") scale(";
                scale2 = ",1) translate(";
            }
            else {
                size = animationType == "smooth" ? parseFloat(chartObj.svgRenderer._getAttrVal(element, "height")) : 0;
                isBar = false;
                if (chartObj.svgRenderer._getAttrVal($element, "plot") === "negative") {
                    centerX = box.x;
                    centerY = box.y;
                }
                else {
                    centerX = (box.x + box.width);
                    centerY = (box.y + box.height);
                }
                scale1 = ") scale(1,";
                scale2 = ") translate(";
            }
            var diff = Math.abs(
                sf.EjSvgRender.utils._getPointXY(
                    series.yAxis.visibleRange.min < 0 ? 0 : series.yAxis.visibleRange.min, series.yAxis.visibleRange, series.yAxis.isInversed
                ) * (isBar ? series.yAxis.width : series.yAxis.height)
            );

            $element.animate(
                {
                    scales: animationType == "smooth" ? size : 1
                },
                {
                    duration: duration,
                    complete: function () {
                        if (series.type.toLowerCase() == "waterfall")
                            $("#" + chartObj.svgObject.id + '_SeriesGroup' + '_waterfallLine_' + series.index).attr("visibility", "visible");
                    },
                    step: function (now) {
                        scaleVal = now;
                        if (animationType == "smooth") {
                            if (now) {
                                isBar ? chartObj.svgRenderer._setAttr($element, {
                                    'width': (diff + now) >= size ? size : now
                                }) : chartObj.svgRenderer._setAttr($element, {
                                    'height': now
                                });
                            }
                            isBar ? chartObj.svgRenderer._setAttr($element, { 'x': (diff + now) >= size ? (size  - now) : diff }) :
                                chartObj.svgRenderer._setAttr($element, { 'y': (size - diff - now) >= 0 ? (size - diff - now) : 0 });
                        } else {
                            chartObj.svgRenderer._setAttr($element, { "transform": "translate(" + centerX + " " + centerY + scale1 + scaleVal + scale2 + (-centerX) + " " + (-centerY) + ")" });
                        }
                    }
                });
        },
        animateStackingRect: function (element, series, invertedAxes, chartObj, duration) {
            var centerX, centerY, scale1, scale2, $element = $(element), boxX, boxY, scaleVal,
                box = sf.EjSvgRender.utils._getBoundingClientRect(element, chartObj, series, invertedAxes);
            if ((series.isTransposed && invertedAxes) || invertedAxes) {
                boxX = (sf.EjSvgRender.utils._valueToCoefficient(series.yAxis, 0)) * (series.yAxis.width);
                centerX = boxX;
                centerY = box.y;
                scale1 = ") scale(";
                scale2 = ",1) translate(";
            }
            else {
                boxY = (1 - sf.EjSvgRender.utils._valueToCoefficient(series.yAxis, 0)) * (series.yAxis.height);
                centerX = box.x;
                centerY = boxY;
                scale1 = ") scale(1,";
                scale2 = ") translate(";
            }
            $element.animate(
                {
                    scales: 1
                },
                {
                    duration: duration,

                    step: function (now) {
                        scaleVal = now;
                        chartObj.svgRenderer._setAttr($element, { "transform": "translate(" + centerX + " " + centerY + scale1 + scaleVal + scale2 + (-centerX) + " " + (-centerY) + ")" });
                    }
                });
        },
        _doLineAnimation: function (chartObj, clipRect, duration) {
            var duration = !sf.util.isNullOrUndefined(duration) ? duration : 2000;
            var animationReversed = chartObj.model.primaryXAxis.isInversed;
            var width = parseFloat(chartObj.svgRenderer._getAttrVal(clipRect, "width"));
            if (chartObj.model.requireInvertedAxes) {
                var height = parseFloat(chartObj.svgRenderer._getAttrVal(clipRect, "height"));
                //Animation for transposed series is working from top to bottom instead of bottom to top
                //In some scenario, series is not appearing because clip rect location gets changed
                //chartObj.svgRenderer._setAttr($(clipRect), { "y": height });
                $(clipRect).animate(
                    {
                        //y: parseFloat(chartObj.svgRenderer._getAttrVal(clipRect, "y")),
                        clipRectHeight: parseFloat(chartObj.svgRenderer._getAttrVal(clipRect, "height"))
                    },
                    {
                        duration: duration,
                        step: function (now) {
                            chartObj.svgRenderer._setAttr($(clipRect), { "y": height - now });
                            chartObj.svgRenderer._setAttr($(clipRect), { "height": now });
                        }
                    });
            }
            else {
                $(clipRect).animate(
                    {
                        clipRectWidth: parseFloat(chartObj.svgRenderer._getAttrVal(clipRect, "width"))
                    },
                    {
                        duration: duration,
                        step: function (now) {
                            if (animationReversed)
                                chartObj.svgRenderer._setAttr($(clipRect), { "x": width - now });
                            chartObj.svgRenderer._setAttr($(clipRect), { "width": now });
                        }
                    });
            }
        },

        _drawLinePath: function (series, style, direction) {
            var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
            var trans;
            var seriesIndex = $.inArray(series, this.chartObj.model._visibleSeries);
            var translate = null;
            if (this.chartObj.model.AreaType == "cartesianaxes") {
                trans = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);
                translate = 'translate(' + trans.x + ',' + trans.y + ')'
            }

            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': translate };
            this.chartObj.gSeriesGroupEle = this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
            if (direction != "" && direction.indexOf("NaN") == -1) {
                var options = {

                    'id': this.chartObj.svgObject.id + "_Series" + seriesIndex,
                    'fill': 'none',
                    'stroke-dasharray': series.dashArray,
                    'stroke-width': series.width,
                    'stroke': style.SeriesInterior,
                    'stroke-linecap': series.lineCap,
                    'stroke-linejoin': series.lineJoin,
                    'opacity': series.opacity,
                    'd': direction
                };
                if (this.chartObj.dragPoint) {
                    options.id = this.chartObj.svgObject.id + "_PreviewSeries" + seriesIndex;
                    options.opacity = 0.6;
                    if (this.chartObj.model.enableCanvasRendering) this.chartObj.svgRenderer.drawPath(options, this.chartObj.canvasElement, translate);
                    else this.chartObj.svgRenderer.drawPath(options, this.chartObj.gPreviewSeriesGroupEle);
                }
                else
                    this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle);
            }


        },

        _applySaturation: function (chartObj, pointColor) {
            var format, color, rgbValue, contrast, rgbColorValue;
            format = sf.EjSvgRender.prototype.checkColorFormat(pointColor);
            if (!format)
                pointColor = chartObj.colorNameToHex(pointColor);
            rgbColorValue = sf.EjSvgRender.prototype.hexToRGB(pointColor);
            contrast = Math.round(((parseInt(rgbColorValue.R) * 299) + (parseInt(rgbColorValue.G) * 587) + (parseInt(rgbColorValue.B) * 114)) / 1000);
            color = (contrast >= 128) ? "black" : "white";
            return color;
        },



        drawDataLabel: function (series, index, point, x, y, chartRegionIndex, params, outlier) {
            // method for data label symbols - cartesianaxes
            point.marker = point.marker ? point.marker : {};
            var labelFormat = series.yAxis.labelFormat, labelPrecision, labelPrecisionDefault = 6, labelPrecisionHighest = 20,
                valueType = series.yAxis.valueType, pointText, xPos, yPos, textWidth, textHeight, diff, pointColor, collide,
                boxPlotLabels = series._visiblePoints[index].boxPlotValues,
                value = (series.type.toLowerCase() == "waterfall" && (point.showIntermediateSum || point.showTotalSum)) ? point.waterfallSum : point.y;
            if (point.text)
                pointText = point.text;
            else if (labelFormat) {
                if (labelFormat.indexOf("{value}") > -1)
                    pointText = labelFormat.replace("{value}", value);
                else if (labelFormat.indexOf('e') == 0 || labelFormat.indexOf('E') == 0) {
                    labelPrecision = labelFormat.match(/(\d+)/g);
                    labelPrecision = labelPrecision == null ? labelPrecisionDefault : labelPrecision > labelPrecisionHighest ? labelPrecisionHighest : labelPrecision;
                    pointText = value.toExponential(labelPrecision);
                }
                else pointText = sf.format(value, labelFormat, this.chartObj.model.locale);
            }
            else pointText = value;
            var chart = this.chartObj,
                chartModel = chart.model,
                seriesIndex = $.inArray(series, chartModel._visibleSeries),
                textAlign, element, fontBackgroundColor,
                textBaseline, symbolName,
                marker = $.extend(true, {}, series.marker, point.marker),
                dataLabel = marker.dataLabel, areaBounds = chartModel.m_AreaBounds,
                dataLabelFont = dataLabel.font,
                textPosition = dataLabel.textPosition.toLowerCase(),
				textAnchor = dataLabel.textAnchor.toLowerCase(),
                type = series.type.toLowerCase(), isCanvas = chartModel.enableCanvasRendering,
                regiontype = sf.seriesTypes[type].prototype.isRegion,
                size = sf.util.isNullOrUndefined(dataLabelFont.size) ? "11px" : dataLabelFont.size,
                fontStyle = sf.util.isNullOrUndefined(dataLabelFont.fontStyle) ? "Normal" : dataLabelFont.fontStyle,
                fontFamily = sf.util.isNullOrUndefined(dataLabelFont.fontFamily) ? "Segoe UI" : dataLabelFont.fontFamily,
                labelfont = { size: size, fontStyle: fontStyle, fontFamily: fontFamily },
                textOffset = sf.EjSvgRender.utils._measureText(pointText, null, labelfont);
				degree = dataLabel.angle, 
				padding = 10,
                angle = (degree > 360) ? degree - 360 : (degree < -360) ? degree + 360 : degree;
				if(textPosition == 'middle' && (angle == -90 || angle == 90)){
					var rect = chart.model.chartRegions[chartRegionIndex].Region.Bounds;
					if(textOffset.width > rect.Height)
						textPosition = 'bottom';
					else 
						textPosition == 'middle';
				}
            var position = this.textPosition(series, seriesIndex, point, textOffset, type, x, y, chartRegionIndex, index, params, textPosition),
                commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs), contrastColor = dataLabel.enableContrastColor,
                chartAreaBackground = chartModel.chartArea.background.toLowerCase(), chartBackground = chartModel.background.toLowerCase();
            commonEventArgs.data = { text: pointText, location: { x: position.x + chart.canvasX, y: position.y + chart.canvasY }, seriesIndex: seriesIndex, pointIndex: index };
            if (series.isStacking && series.drawType == "area" && ((series.type == "polar") || (series.type == "radar"))) {
                commonEventArgs.data.text = series.stackedValue.EndValues[index] - series.stackedValue.StartValues[index];
            }
            chart._trigger("displayTextRendering", commonEventArgs);
            var dataLabelOffset = (marker.dataLabel.offset.y == undefined) ? marker.dataLabel.offset : marker.dataLabel.offset.y;
            var xval = marker.dataLabel.offset.x;
            var textOffset = sf.EjSvgRender.utils._measureText(commonEventArgs.data.text, null, labelfont);
            if (textPosition == 'bottom')
                commonEventArgs.data.location.y = commonEventArgs.data.location.y + dataLabelOffset;
            else
                commonEventArgs.data.location.y = commonEventArgs.data.location.y - dataLabelOffset;
            if (xval)
                commonEventArgs.data.location.x = commonEventArgs.data.location.x + xval;
			
			if(angle == 90 || angle == -90){
				if(textPosition == 'bottom'){
					textAnchor = angle == -90 ? 'start': 'end';
					commonEventArgs.data.location.y = commonEventArgs.data.location.y + (padding/2);
				}
				else if(textPosition == 'top'){
					if(textAnchor == 'middle' || textAnchor == 'start'){
						textAnchor = angle == -90 ? 'start': 'end';
						commonEventArgs.data.location.y = commonEventArgs.data.location.y + (padding);
					}
					else{
						textAnchor = 'end';
						commonEventArgs.data.location.y = commonEventArgs.data.location.y + (padding * 2);
					}
				}			
			}
            if (!commonEventArgs.cancel) {
                var options = {
                    'id': chart.svgObject.id + '_SeriesText' + index + seriesIndex,
                    'x': commonEventArgs.data.location.x,
                    'y': commonEventArgs.data.location.y,
                    'fill': dataLabelFont.color,
                    'font-size': dataLabelFont.size,
                    'font-family': dataLabelFont.fontFamily,
                    'font-style': dataLabelFont.fontStyle,
                    'font-weight': dataLabelFont.fontWeight,
                    'opacity': dataLabelFont.opacity,

                    'text-anchor': textAnchor
                };
                var margin = dataLabel.margin,
                    width = textOffset.width + margin.left + margin.right,
                    height = textOffset.height + margin.top + margin.bottom,
                    location = { X: commonEventArgs.data.location.x, Y: commonEventArgs.data.location.y };

                if (sf.util.isNullOrUndefined(dataLabel.template)) {
                    if (dataLabel.shape)
                        element = dataLabel.shape;
                    else
                        element = "None";
                    $.each(chartModel.symbolShape, function (name) {
                        if (element.toLowerCase() == name.toLowerCase())
                            symbolName = name;
                    });

                    var xXalue = commonEventArgs.data.location.x - (margin.left) / 2 + (margin.right) / 2,
                        yValue = commonEventArgs.data.location.y - (margin.top) / 2 - (height / margin.top) + (margin.bottom) / 2;
                        

                    //For accurate placement of rotated data labels in canvas
                    if (chartModel.enableCanvasRendering && (degree % 360 != 0)) {
                        options.y -= textOffset.height / 4;
                        options.baseline = 'middle';
                    }

                    if (dataLabel.showEdgeLabels) {
                        xPos = isCanvas ? options.x - chart.canvasX : options.x;
                        yPos = isCanvas ? options.y - chart.canvasY : options.y;
						if (angle == 90 || angle == -90) 
                            textOffset.width = [textOffset.height, textOffset.height = textOffset.width][0];
                        textWidth = textOffset.width;
                        textHeight = textOffset.height;
                        var isLastLabelOut = (series._visiblePoints[series._visiblePoints.length-1] == point) && xPos + textWidth / 2 >= chart.model.m_AreaBounds.Width;
                        if ((xPos - textWidth / 2 < 0 || xPos < -textWidth / 2) && isLastLabelOut) {
                            diff = xPos - textWidth / 2;
                            options.x = xXalue = Math.abs(diff) + (!isLastLabelOut ? xPos + 10 : - 10);
                        }
                        else if (xPos + textWidth / 2 > areaBounds.textWidth || xPos + textWidth / 2 > areaBounds.textWidth + textWidth / 2) {
                            diff = xPos - textWidth / 2;
                            options.x = xXalue = areaBounds.textWidth - textWidth / 2 - 10;
                        }
                        if (yPos + textHeight / 2 > areaBounds.textHeight || yPos + textHeight / 2 > areaBounds.textHeight + textHeight / 2) {
                            diff = yPos + textHeight / 2 - areaBounds.textHeight;
                            yValue = yPos - diff - 10;
                            options.y = yValue + 5;
                        }
                        else if (yPos - textHeight / 2 < 0 || yPos < -textHeight / 2) {
                            diff = yPos - textHeight / 2;
                            yValue += Math.abs(diff) + 10;
                            options.y = yValue + 5;
                        }
                    }
                    if (series._enableSmartLabels) {
                        point.dataLabel = { textX: options.x, textY: options.y, x: xXalue, y: yValue, width: width, height: height }
                        point.margin = { top: margin.top, bottom: margin.bottom }
                    }
                    // to get the point color for saturation
                    pointColor = jQuery.type(chartModel.seriesColors[seriesIndex]) == "array" ?
                        chartModel.seriesColors[seriesIndex][0].color : chartModel.seriesColors[seriesIndex];
                    pointColor = point.fill ? jQuery.type(point.fill) == "array" ? point.fill[0].color : point.fill : pointColor;
                    if (contrastColor) {
                        fontBackgroundColor = !regiontype || textPosition == "top" ?
                            (chartAreaBackground === "transparent" && chartBackground === "transparent") ? "white" : (chartAreaBackground != "transparent") ?
                                chartAreaBackground : chartBackground : pointColor;
                        options.fill = this._applySaturation(chart, fontBackgroundColor);
                    }

                    if (point.y == point.low && !(point.y === undefined && point.low === undefined)) //undefined condition checked for waterfall series sum value display
                    {
                        point.xPosLow = xXalue;
                        point.yPosLow = yValue;
                        point.widthLow = (symbolName == "None") ? textOffset.width : width;
                        point.heightLow = (symbolName == "None") ? textOffset.height : height;
                        point.textOptionsLow = options;
                        point.textOptionsLow.angle = angle;
                        point.drawTextLow = commonEventArgs.data.text;
                    }
                    else if (type.toLowerCase() == "boxandwhisker" && (boxPlotLabels.midvalue != point.y)) {
                        var textOptionsBox = {
                            'id': chart.svgObject.id + '_SeriesText' + index + seriesIndex,
                            'x': sf.util.isNullOrUndefined(outlier) ? commonEventArgs.data.location.x : xXalue,
                            'y': sf.util.isNullOrUndefined(outlier) ? commonEventArgs.data.location.y : yValue,
                            'fill': dataLabelFont.color,
                            'font-size': dataLabelFont.size,
                            'font-family': dataLabelFont.fontFamily,
                            'font-style': dataLabelFont.fontStyle,
                            'font-weight': dataLabelFont.fontWeight,
                            'opacity': dataLabelFont.opacity,

                            'text-anchor': textAnchor
                        };
                        var boxLabelCount = point.textOptionsBoxValues.length;

                        point.textOptionsBoxValues[boxLabelCount] = textOptionsBox;
                        if (angle != 0)
                            point.textOptionsBoxValues[boxLabelCount].angle = angle;
                        point.textOptionsBoxValues[boxLabelCount].drawText = commonEventArgs.data.text;
                        point.textOptionsBoxValues[boxLabelCount].index = index;
                        point.textOptionsBoxValues[boxLabelCount].xPos = sf.util.isNullOrUndefined(outlier) ? xXalue : xXalue - (margin.left) / 2 + (margin.right) / 2;
                        point.textOptionsBoxValues[boxLabelCount].yPos = sf.util.isNullOrUndefined(outlier) ? yValue : yValue - (margin.top) / 2 - (height / margin.top) + (margin.bottom) / 2;
                        point.textOptionsBoxValues[boxLabelCount].seriesIndex = seriesIndex;
                        point.textOptionsBoxValues[boxLabelCount].width = (symbolName == "None") ? textOffset.width : width;
                        point.textOptionsBoxValues[boxLabelCount].height = (symbolName == "None") ? textOffset.height : height;
                        point.textOptionsBoxValues[boxLabelCount].symbolName = symbolName;

                    }

                    else {
                        // storing the values in point
                        point.textOptions = options;

                        if (angle != 0)
                            point.textOptions.angle = angle;
                        point.drawText = commonEventArgs.data.text;
                        point.index = index;
                        point.xPos = xXalue;
                        point.yPos = yValue;
                        point.seriesIndex = seriesIndex;
                        point.width = (symbolName == "None") ? textOffset.width : width;
                        point.height = (symbolName == "None") ? textOffset.height : height;
                        if (angle == 90 || angle == -90) //Swapping datalabel text height and width value
                            point.width = [point.height, point.height = point.width][0];

                        point.symbolName = symbolName;
                    }
                }
                else {
                    location.X -= chart.canvasX;
                    location.Y -= chart.canvasY;
                    this.drawLabelTemplate(series, point, index, location, chart);
                }
                // to test the datalabel whether it is placed inside / outside the region in column and bar series 
                if ((type.indexOf("column") > -1 || type.indexOf("bar") > -1) && contrastColor) {
                    var region = chart.model.chartRegions[chartRegionIndex];
                    var group = params.stackingGroup;
                    if (textPosition == "top" && type.indexOf("stacking") > -1) {// to apply the saturation color for the datalabel in stacking column top position 
                        if (sf.util.isNullOrUndefined(series.stackingGroup) || series.stackingGroup == "") {
                            if (seriesIndex < chartModel._visibleSeries.length - 1) {
                                pointColor = jQuery.type(chartModel.seriesColors[seriesIndex + 1]) == "array" ?
                                    chartModel.seriesColors[seriesIndex + 1][0].color : chartModel.seriesColors[seriesIndex + 1];
                                pointColor = point.fill ? jQuery.type(point.fill) == "array" ? point.fill[0].color : point.fill : pointColor;
                                fontBackgroundColor = pointColor;
                            }
                            else
                                fontBackgroundColor = (chartAreaBackground === "transparent" && chartBackground === "transparent") ?
                                    "white" : (chartAreaBackground != "transparent") ? chartAreaBackground : chartBackground;
                        }
                        else { // stacking along with grouping 
                            for (var key in group) {
                                if (key == series.stackingGroup && seriesIndex < group[key].length - 1) {
                                    pointColor = jQuery.type(chartModel.seriesColors[seriesIndex + 1]) == "array" ?
                                        chartModel.seriesColors[seriesIndex + 1][0].color : chartModel.seriesColors[seriesIndex + 1];
                                    pointColor = point.fill ? jQuery.type(point.fill) == "array" ? point.fill[0].color : point.fill : pointColor;
                                    fontBackgroundColor = pointColor;
                                    break;
                                }
                                else {
                                    fontBackgroundColor = (chartAreaBackground === "transparent" && chartBackground === "transparent") ?
                                        "white" : (chartAreaBackground != "transparent") ? chartAreaBackground : chartBackground;
                                    break;
                                }
                            }
                        }
                        options.fill = this._applySaturation(chart, fontBackgroundColor);
                    }
                    else { // when the textposition is middle/bottom to check whether the datalabel lies within the region
                        collide = sf.ejChart.isCollide(region, point, 0, contrastColor, chart);
                        if ((textPosition == "bottom" || textPosition == "middle") && !collide.state) {
                            fontBackgroundColor = (chartAreaBackground === "transparent" && chartBackground === "transparent") ?
                                "white" : (chartAreaBackground != "transparent") ? chartAreaBackground : chartBackground;
                            options.fill = this._applySaturation(chart, fontBackgroundColor);
                        }
                    }
                }
            }
        },

        //smart labels for pie and doughnut

        updateSmartLabelPosition: function (currentseries, point, pointIndex, bounds, midAngle, startPoint, textOffset, size, sender, seriesIndex) {
            var renderingPoints = [],
                chartObj = sender,
                chartModel = chartObj.model,
                legend = chartModel.legend,
                legendActualBounds = chartModel.LegendActualBounds,
                legendPosition = legend.position.toLowerCase(),
                seriesType = new sf.seriesTypes[currentseries.type.toLowerCase()](),
                connectorDirection = "",
                bezierPoints = "",
                connectorX = bounds.connector.connectorX,
                connectorY = bounds.connector.connectorY,
                midX = bounds.midPoint.midX,
                midY = bounds.midPoint.midY,
                dMidX = bounds.doughnutMidPoint.dMidX,
                dMidY = bounds.doughnutMidPoint.dMidY,
                startX = startPoint.startX,
                startY = startPoint.startY,
                marker = $.extend(true, {}, currentseries.marker, point.marker),
                textGap = (marker.dataLabel.template) ? 0 : 4,
                outerX, positionX, positionY,
                radius,
                isIntersectedLabel,
                angle = midAngle,
                smartAngle = (currentseries.startAngle > currentseries.endAngle) ? -0.01 : 0.01,
                connectorType = marker.dataLabel.connectorLine.type.toLowerCase(),
                previousLeft, type = currentseries.type.toLowerCase(),
                radius = chartModel._isPieOfPie ? chartModel.circularRadius[currentseries.collectionIndex] : chartModel.circularRadius[seriesIndex],
                labelPosition = type == "pieofpie" ? "inside" : currentseries.labelPosition.toLowerCase();
            if (sf.util.isNullOrUndefined(chartModel.bounds[seriesIndex])) {
                chartModel.bounds[seriesIndex] = [];
                chartModel.bounds[seriesIndex].points = [];
                if (labelPosition == 'outsideextended') {
                    chartModel.bounds[seriesIndex].points["left"] = [];
                    chartModel.bounds[seriesIndex].points["right"] = [];
                }
            }

            //calculation for inside labels
            if (labelPosition == 'inside' && sf.util.isNullOrUndefined(point.smartLabelPosition)) {
                positionX = (midX + startX) / 2;
                positionY = (midY + startY) / 2;

                positionX = (midX + positionX) / 2;
                positionY = (midY + positionY) / 2;

                if (point.isIntersected && chartModel.bounds[seriesIndex].points[point.index]) {
                    currBounds = chartModel.bounds[seriesIndex].points[point.index];
                }
                else {
                    if (midX > startX)
                        currBounds = { X: positionX, Y: positionY, Left: positionX, Top: positionY, Right: positionX + size.width, Bottom: positionY + size.height, SeriesIndex: seriesIndex, PointIndex: pointIndex };
                    else
                        currBounds = { X: positionX, Y: positionY, Left: positionX - size.width, Top: positionY, Right: positionX, Bottom: positionY + size.height, SeriesIndex: seriesIndex, PointIndex: pointIndex };
                }

                do {
                    isIntersectedLabel = false;
                    if (!this.IntersectWith(chartObj, point, currBounds, "inside", seriesIndex)) continue;
                    previousLeft = currBounds.Left;
                    var initialAngle = midAngle * 180 / Math.PI;

                    //convert radian to degree and break the loop after complete the 360 degree 
                    var degree = angle * 180 / Math.PI;
                    // chart start the angle from -90. So it will be skip in 270 degree
                    if (((degree - initialAngle) >= 270)) continue;

                    angle += smartAngle;
                    point.isIntersected = true;
                    currBounds.Angle = angle;
                    if (midX > startX) {
                        currBounds.X = currBounds.Left = seriesType.getXCordinate(startX, (radius) + textOffset, angle);
                        currBounds.Right = currBounds.X + size.width;
                    }
                    else {
                        currBounds.X = currBounds.Right = seriesType.getXCordinate(startX, (radius) + textOffset, angle);
                        currBounds.Left = currBounds.Right - size.width;
                    }
                    currBounds.Y = currBounds.Top = seriesType.getYCordinate(startY, (radius) + textOffset, angle);
                    currBounds.Bottom = currBounds.Y + size.height;
                    isIntersectedLabel = true;
                } while (isIntersectedLabel)
                if (midX > startX && currBounds.X < startX) {
                    currBounds.Right = previousLeft;
                    currBounds.Left = previousLeft - size.width;
                }
                chartModel.bounds[seriesIndex].points[pointIndex] = currBounds;


                if (point.isIntersected && chartModel.bounds[seriesIndex].points[pointIndex].Angle) {

                    positionX = seriesType.getXCordinate(startX, (radius) + textOffset, chartModel.bounds[seriesIndex].points[pointIndex].Angle);
                    positionY = seriesType.getYCordinate(startY, (radius) + textOffset, chartModel.bounds[seriesIndex].points[pointIndex].Angle);

                    var connectorMidX = seriesType.getXCordinate(startX, (radius) + textOffset / 3, midAngle);
                    var connectorMidY = seriesType.getYCordinate(startY, (radius) + textOffset / 3, midAngle);
                    renderingPoints.push({ X: midX, Y: midY });
                    renderingPoints.push({ X: connectorMidX, Y: connectorMidY });
                    renderingPoints.push({ X: positionX, Y: positionY });
                    if (point.isIntersected && connectorType == 'bezier' && !chartObj.vmlRendering) {
                        bezierPoints = seriesType.drawBezierSegment(renderingPoints, currentseries, pointIndex, chartObj, seriesIndex);
                    }
                    connectorDirection = "M" + " " + midX + " " + midY + " " + "L" + " " + connectorMidX + " " + connectorMidY + " " + "M" + " " + connectorMidX + " " + connectorMidY + " " + "L" + " " + positionX + " " + positionY;

                }
            }

            //calculation for outside labels
            else if (labelPosition == 'outside' || point.smartLabelPosition == "outside") {

                if (midX >= startX)
                    currBounds = { X: connectorX, Y: connectorY, Left: connectorX, Top: connectorY, Right: connectorX + size.width, Bottom: connectorY + size.height, SeriesIndex: seriesIndex, PointIndex: pointIndex };
                else
                    currBounds = { X: connectorX, Y: connectorY, Left: connectorX - size.width, Top: connectorY, Right: connectorX, Bottom: connectorY + size.height, SeriesIndex: seriesIndex, PointIndex: pointIndex };

                do {
                    isIntersectedLabel = false;
                    if (!this.IntersectWith(chartObj, point, currBounds, "outside", seriesIndex, size)) continue;
                    previousLeft = currBounds.Left;
                    angle += smartAngle;
                    point.isIntersected = true;
                    if (midX > startX) {
                        currBounds.X = currBounds.Left = seriesType.getXCordinate(startX, (radius) + textOffset, angle);
                        currBounds.Right = currBounds.X + size.width;
                    }
                    else {
                        currBounds.X = currBounds.Right = seriesType.getXCordinate(startX, (radius) + textOffset, angle);
                        currBounds.Left = currBounds.Right - size.width;
                    }

                    currBounds.Y = currBounds.Top = seriesType.getYCordinate(startY, (radius) + textOffset, angle);
                    currBounds.Bottom = currBounds.Y + size.height;
                    isIntersectedLabel = true;
                } while (isIntersectedLabel)
                if (midX > startX && currBounds.X < startX) {
                    currBounds.Right = previousLeft;
                    currBounds.Left = previousLeft - size.width;
                }
                chartModel.bounds[seriesIndex].points[pointIndex] = currBounds;
                var connectorMidX = seriesType.getXCordinate(startX, (radius) + textOffset / 3, midAngle);
                var connectorMidY = seriesType.getYCordinate(startY, (radius) + textOffset / 3, midAngle);

                renderingPoints.push({ X: midX, Y: midY });
                renderingPoints.push({ X: connectorMidX, Y: connectorMidY });
                renderingPoints.push({ X: currBounds.X, Y: currBounds.Y });
                positionX = currBounds.X;
                positionY = currBounds.Y;
                if (textOffset > 0) {
                    if (midX < startX) {
                        outerX = currBounds.X - chartModel.elementSpacing;
                        positionX = outerX - textGap;
                    }
                    else {
                        outerX = currBounds.X + chartModel.elementSpacing;
                        positionX = outerX + textGap;
                    }
                    renderingPoints.push({ X: outerX, Y: currBounds.Y });
                }
                if (connectorType == 'bezier' && !chartObj.vmlRendering) {
                    bezierPoints = seriesType.drawBezierSegment(renderingPoints, currentseries, pointIndex, chartObj, seriesIndex);
                }
                else {
                    connectorDirection = "M" + " " + midX + " " + midY + " " + "L" + " " + connectorMidX + " " + connectorMidY + " " + "M" + " " + connectorMidX + " " + connectorMidY + " " + "L" + " " + currBounds.X + " " + currBounds.Y + " " + "M" + " " + currBounds.X + " " + currBounds.Y + " " + "L" + " " + outerX + " " + currBounds.Y;
                }

            }


            //calculation for outsideExtended labels
            else {
                var labelX = midX;
                var labelY = midY;

                midX = midX + (Math.cos((midAngle)) * (-(radius / 10)));
                midY = midY + (Math.sin((midAngle)) * (-(radius / 10)));

                var connectorHeight = radius / 4;

                renderingPoints.push({ X: midX, Y: midY });
                midX = midX + (Math.cos((midAngle)) * connectorHeight);
                midY = midY + (Math.sin((midAngle)) * connectorHeight);

                renderingPoints.push({ X: midX, Y: midY });

                var legendWidth = (legend.visible && legendPosition == "left") ? (chartModel.margin.left + legendActualBounds.Width) : 0;
                var centerX = chartModel.circleCenterX[seriesIndex];
                var labelEdge, connectorLineEdge;

                if (midX < startX) {

                    midX = ((centerX - radius - (connectorHeight * 2) - currentseries.LeftLabelMaxWidth > 0)
                        ? centerX - radius - (connectorHeight * 2) + legendWidth
                        : (currentseries.LeftLabelMaxWidth > labelX) ? labelX : currentseries.LeftLabelMaxWidth + legendWidth) - size.width / 2;

                    labelEdge = renderingPoints[1].X - currentseries.LeftLabelMaxWidth;

                    var height = (centerX - radius - (connectorHeight * 2) - currentseries.LeftLabelMaxWidth > 0) ? connectorHeight
                        : (currentseries.LeftLabelMaxWidth > labelX) ? 0
                            : (labelEdge > 3 * (connectorHeight / 2)) ? connectorHeight : labelEdge / 2;

                    connectorLineEdge = +size.width / 2;

                }
                else {
                    var legendRight = (legend.visible && legendPosition == "right") ? (chartModel.margin.right + legendActualBounds.Width) : 0;
                    midX = ((centerX + radius + (connectorHeight * 2) + currentseries.RightLabelMaxWidth < $(chartObj.svgObject).width() - legendRight)
                        ? centerX + radius + (connectorHeight * 2) - legendWidth
                        : ((centerX + radius + currentseries.RightLabelMaxWidth) > $(chartObj.svgObject).width()) ? labelX : $(chartObj.svgObject).width() - currentseries.RightLabelMaxWidth - legendRight) + size.width / 2;


                    labelEdge = ($(chartObj.svgObject).width() - currentseries.RightLabelMaxWidth) - renderingPoints[1].X;

                    var height = (centerX + radius + (connectorHeight * 2) + currentseries.RightLabelMaxWidth < $(chartObj.svgObject).width()) ? connectorHeight
                        : ((centerX + radius + currentseries.RightLabelMaxWidth) > $(chartObj.svgObject).width()) ? 0
                            : (labelEdge > 3 * (connectorHeight / 2)) ? connectorHeight : labelEdge / 2;
                    connectorLineEdge = -size.width / 2;
                }

                var distanceFromOrigin = (Math.sqrt(Math.pow(labelX - midX, 2) + Math.pow(labelY - midY, 2))) / 10;

                var isLeft = (midX < startX) ? true : false;
                midX = isLeft ? midX + distanceFromOrigin : midX - distanceFromOrigin;
                var index = isLeft ? 1 : -1;

                var bounds = isLeft ? chartModel.bounds[seriesIndex].points["left"] : chartModel.bounds[seriesIndex].points["right"];
                var currBounds = { X: midX, Y: midY, Left: midX, Top: midY, Right: midX + size.width, Bottom: midY + size.height, index: pointIndex, SeriesIndex: seriesIndex, PointIndex: pointIndex };
                var clockwise = currentseries.endAngle > currentseries.startAngle ? true : false;
                if (this.IntersectWith(chartObj, point, currBounds, "outsideExtended", seriesIndex)) {
                    renderingPoints.push(midX < startX
                        ? { X: midX + height + connectorLineEdge, Y: midY }
                        : { X: midX - height + connectorLineEdge, Y: midY });
                    if (!clockwise && currentseries.startAngle != null) {
                        if (!isLeft)
                            midY = bounds[bounds.length - 1].Y + size.height + 2;
                        else
                            midY = bounds[bounds.length - 1].Y - size.height - 2;
                    }
                    else {
                        midY = bounds[bounds.length - 1].Y + size.height + 2;
                    }
                    currBounds.Y = midY;
                    currBounds.Top = midY;
                    currBounds.Bottom = midY + size.height;
                }
                renderingPoints.push({ X: midX + connectorLineEdge, Y: midY });
                if (centerX < renderingPoints[0].X && (renderingPoints[1].X > renderingPoints[2].X))
                    renderingPoints[2].X = renderingPoints[1].X;
                if (centerX > renderingPoints[0].X && (renderingPoints[1].X < renderingPoints[2].X))
                    renderingPoints[2].X = renderingPoints[1].X;
                if (!isLeft) {
                    if (!chartModel.bounds[seriesIndex].points["right"])
                        chartModel.bounds[seriesIndex].points.right = [];
                    chartModel.bounds[seriesIndex].points["right"].push(currBounds);
                    if (renderingPoints[renderingPoints.length - 1].X < renderingPoints[renderingPoints.length - 2].X)
                        renderingPoints[renderingPoints.length - 2].X = renderingPoints[renderingPoints.length - 1].X;

                }
                else {
                    if (!chartModel.bounds[seriesIndex].points["left"])
                        chartModel.bounds[seriesIndex].points.left = [];
                    chartModel.bounds[seriesIndex].points["left"].push(currBounds);
                    if (renderingPoints[renderingPoints.length - 1].X > renderingPoints[renderingPoints.length - 2].X)
                        renderingPoints[renderingPoints.length - 2].X = renderingPoints[renderingPoints.length - 1].X;
                }


                connectorDirection = sf.EjSvgRender.utils._getStringBuilder();
                if (connectorType == 'bezier' && !chartObj.vmlRendering) {
                    bezierPoints = seriesType.drawBezierSegment(renderingPoints, currentseries, pointIndex, chartObj, seriesIndex);
                }
                else {
                    for (var k = 0; k < renderingPoints.length; k++) {
                        if (k == renderingPoints.length - 1)
                            connectorDirection.append(" ");
                        else
                            connectorDirection.append("M" + " " + (renderingPoints[k].X) + " " + (renderingPoints[k].Y) + " " + "L" + " " + (renderingPoints[k + 1].X) + " " + (renderingPoints[k + 1].Y) + " ");
                    }
                    connectorDirection = connectorDirection.toString();
                }
                positionX = renderingPoints[renderingPoints.length - 1].X + ((midX < startX) ? -textGap : textGap);
                positionY = renderingPoints[renderingPoints.length - 1].Y;
            }
            return { positionX: positionX, positionY: positionY, connectorDirection: connectorDirection, isInterSected: point.isIntersected, bezierPath: bezierPoints };
        },

        updateLabelPosition: function (currentseries, point, pointIndex, bounds, midAngle, startPoint, textOffset, size, sender, seriesIndex) {

            var renderingPoints = [];
            var chartObj = sender;
            var seriesType = new sf.seriesTypes[currentseries.type.toLowerCase()]();
            var connectorDirection = "";

            var connectorX = bounds.connector.connectorX;
            var connectorY = bounds.connector.connectorY;
            var midX = bounds.midPoint.midX;
            var midY = bounds.midPoint.midY;
            var dMidX = bounds.doughnutMidPoint.dMidX;
            var dMidY = bounds.doughnutMidPoint.dMidY;
            var startX = startPoint.startX;
            var startY = startPoint.startY;
            var marker = $.extend(true, {}, currentseries.marker, point.marker);
            var textGap = (marker.dataLabel.template) ? 0 : 4;

            var outerX, positionX, positionY, labelX, labelY;
            var type = currentseries.type.toLowerCase();
            var radius = chartObj.model.circularRadius[seriesIndex];
            var labelPosition = type == "pieofpie" ? "inside" : currentseries.labelPosition.toLowerCase();

            //calculation for outside labels

            renderingPoints.push({ X: midX, Y: midY });
            renderingPoints.push({ X: connectorX, Y: connectorY });
            positionX = connectorX;
            positionY = connectorY;

            if (labelPosition == 'outside') {
                if (textOffset > 0) {
                    if (connectorX < startX) {
                        outerX = connectorX - chartObj.model.elementSpacing;
                        positionX = outerX - textGap;
                    }
                    else {
                        outerX = connectorX + chartObj.model.elementSpacing;
                        positionX = outerX + textGap;
                    }
                    renderingPoints.push({ X: outerX, Y: connectorY });
                }

                if (marker.dataLabel.connectorLine.type.toLowerCase() == 'bezier' && !chartObj.vmlRendering) {
                    seriesType.drawBezierSegment(renderingPoints, currentseries, pointIndex, chartObj, seriesIndex);
                }
                else {
                    connectorDirection = "M" + " " + midX + " " + midY + " " + "L" + " " + connectorX + " " + connectorY + " " + "M" + " " + connectorX + " " + connectorY + " " + "L" + " " + outerX + " " + connectorY;
                }

            }


            //calculation for outsideextended labels
            else if (labelPosition == 'outsideextended') {

                labelX = midX;
                labelY = midY;

                midX = midX + (Math.cos((midAngle)) * (-(radius / 10)));
                midY = midY + (Math.sin((midAngle)) * (-(radius / 10)));


                var renderingPoints = [];

                var connectorHeight = radius / 4;

                renderingPoints.push({ X: midX, Y: midY });
                connectorX = midX + (Math.cos((midAngle)) * connectorHeight);
                connectorY = midY + (Math.sin((midAngle)) * connectorHeight);

                renderingPoints.push({ X: connectorX, Y: connectorY });

                var legendWidth = (chartObj.model.legend.visible && (chartObj.model.legend.position.toLowerCase() == "left" || chartObj.model.legend.position.toLowerCase() == "right")) ? (chartObj.model.elementSpacing) : 0;

                if (midX < startX) {
                    connectorX = (chartObj.model.centerX - radius - (connectorHeight * 2) - currentseries.LeftLabelMaxWidth > 0)
                        ? chartObj.model.centerX - radius - (connectorHeight * 2) + legendWidth
                        : (currentseries.LeftLabelMaxWidth > labelX) ? labelX : currentseries.LeftLabelMaxWidth;
                }
                else {
                    connectorX = (chartObj.model.centerX + radius + (connectorHeight * 2) + currentseries.RightLabelMaxWidth < $(chartObj.svgObject).width())
                        ? chartObj.model.centerX + radius + (connectorHeight * 2) - legendWidth
                        : ((chartObj.model.centerX + radius + currentseries.RightLabelMaxWidth) > $(chartObj.svgObject).width()) ? labelX : $(chartObj.svgObject).width() - currentseries.RightLabelMaxWidth;

                }

                renderingPoints.push({ X: connectorX, Y: connectorY });

                connectorDirection = sf.EjSvgRender.utils._getStringBuilder();
                if (marker.dataLabel.connectorLine.type.toLowerCase() == 'bezier' && !chartObj.vmlRendering) {
                    seriesType.drawBezierSegment(renderingPoints, currentseries, pointIndex, chartObj, seriesIndex);
                }
                else {
                    for (var k = 0; k < renderingPoints.length; k++) {
                        if (k == renderingPoints.length - 1)
                            connectorDirection.append(" ");
                        else
                            connectorDirection.append("M" + " " + (renderingPoints[k].X) + " " + (renderingPoints[k].Y) + " " + "L" + " " + (renderingPoints[k + 1].X) + " " + (renderingPoints[k + 1].Y) + " ");
                    }
                    connectorDirection = connectorDirection.toString();
                }
                positionX = renderingPoints[renderingPoints.length - 1].X + ((midX < startX) ? -textGap : textGap);;
                positionY = renderingPoints[renderingPoints.length - 1].Y;
            }

            //calculation for inside labels

            else {
                if (currentseries.type.toLowerCase() == "doughnut") {
                    positionX = (midX + dMidX) / 2;
                    positionY = (midY + dMidY) / 2;
                }
                else {
                    positionX = (midX + startX) / 2;
                    positionY = (midY + startY) / 2;

                    positionX = (midX + positionX) / 2;
                    positionY = (midY + positionY) / 2;
                }
            }

            return { positionX: positionX, positionY: positionY, connectorDirection: connectorDirection, points: renderingPoints[renderingPoints.length - 1] };
        },
        // method to update the position of the data labels in pyramid chart
        updateSmartLabel: function (chartObj, currentseries, pointIndex, point) {
            // declaration
            var datalabelTemplateVisiblity = true,
                connectorDirection = "",
                labelPosition = currentseries.labelPosition.toLowerCase(),
                marker = $.extend(true, {}, currentseries.marker, point.marker),
                dataLabel = marker.dataLabel,
                areaBounds = chartObj.model.m_AreaBounds,
                svgHeight = chartObj.model.svgHeight,
                type = currentseries.type.toLowerCase(),
                pyrX, pyrY, ele, xPos, yPos;
            point._labelPlacement = "";
            if (labelPosition == "inside" || labelPosition == "outsideextended")
                this.calculateInsideConnectorLines(pointIndex, point, currentseries, chartObj);
            else
                this.compareDataLabels(point, pointIndex, chartObj.model.outsideDataRegionPoints, currentseries, chartObj);

            pyrX = (chartObj.model.enableCanvasRendering && !dataLabel.template) ? chartObj.pyrX : 0;
            pyrY = (chartObj.model.enableCanvasRendering && !dataLabel.template) ? chartObj.pyrY : 0;
            if (type == "pyramid") {
                if ((chartObj.model.actualHeight < point.yPos - pyrY) || (point.xPos - pyrX > areaBounds.Width && point._labelPlacement == "insideoverlap") || (chartObj.model.legend.position == "right" && dataLabel.template && (point.xPos + point.width) > areaBounds.Width + chartObj.model.LegendActualBounds.Width)) {
                    datalabelTemplateVisiblity = false;
                    point.drawTextacc = "";
                }
            }
            else {
                if ((point.yPos - pyrY < 0) || (point.xPos - pyrX > areaBounds.Width && point._labelPlacement == "insideoverlap") || (chartObj.model.legend.position == "right" && dataLabel.template && (point.xPos + point.width) > areaBounds.Width + chartObj.model.LegendActualBounds.Width)) {
                    datalabelTemplateVisiblity = false;
                    point.drawTextacc = "";

                }
            }
            if ((labelPosition == "outside" || point._labelPlacement == "insideoverlap") && datalabelTemplateVisiblity)
                connectorDirection = this.drawConnectorLines(pointIndex, point, currentseries, chartObj);

            if (dataLabel.template) {
                ele = $("#" + point.id);
                if (!datalabelTemplateVisiblity) {
                    ele.css("display", "none");
                }
                else {
                    xPos = (point._labelPlacement == "insidenooverlap") ? point.textOptionsacc.x + chartObj.pyrX - point.width / 2 : point.textOptionsacc.x + chartObj.pyrX;
                    yPos = (point._labelPlacement == "insidenooverlap") ? point.textOptionsacc.y + chartObj.pyrY : point.textOptionsacc.y + chartObj.pyrY - chartObj.model.elementSpacing;
                    ele.css("left", xPos).css("top", yPos);
                    ele.css("height", point.height).css("overflow", "hidden");
                }
            }


            return { xPos: point.xPos, yPos: point.yPos, textOptionsacc: point.textOptionsacc, connectorDirection: connectorDirection.connectorDirection, bezierPath: connectorDirection.bezierdir, drawTextacc: point.drawTextacc };
        },
        // method to compare the data labels in chart for intersection
        compareDataLabels: function (point, pointIndex, outsideDataRegionPoints, currentseries, chartObj) {

            var marker = $.extend(true, {}, currentseries.marker, point.marker),
                dataLabel = marker.dataLabel,
                prevLabel, collide, regionPoint, degree, angle, rotate, positionPoint,
                elementSpacing = chartObj.model.elementSpacing,
                margin = marker.dataLabel.margin,
                visiblePointslength = currentseries._visiblePoints.length,
                labelPosition = currentseries.labelPosition.toLowerCase(),
                pyrX = (chartObj.model.enableCanvasRendering) ? chartObj.pyrX : 0,
                pyrY = (chartObj.model.enableCanvasRendering) ? chartObj.pyrY : 0;
            for (var j = 0, length = outsideDataRegionPoints.length; j < length; j++) {
                prevLabel = outsideDataRegionPoints[j];
                collide = this.isCollide(prevLabel, point, currentseries);
                if (collide.state) {
                    if (labelPosition == "inside" || labelPosition == "outsideextended") {
                        point.textOptionsacc.y = point.yPos = point.textOptionsacc.y + collide.height;
                        positionPoint = (dataLabel.template) ? { x: point.xPos, y: point.yPos } : { x: point.xPos - pyrX, y: point.yPos - pyrY };
                        for (var k = 0, visibleLength = visiblePointslength; k < visibleLength; k++) {
                            regionPoint = (chartObj.isPointInPolygon(chartObj.model.chartRegions[0].Region[k].Polygon, positionPoint));
                            if (regionPoint) {
                                point.textOptionsacc.x = point.xPos = point.textOptionsacc.x + point.width;
                                positionPoint = (dataLabel.template) ? { x: point.xPos, y: point.yPos } : { x: point.xPos - pyrX, y: point.yPos - pyrY };
                            }
                        }
                    }
                    else {
                        point._labelPlacement = "outside";
                        point.textOptionsacc.y = point.yPos = (currentseries.type.toLowerCase() == "pyramid") ? point.yPos + collide.height + elementSpacing / 2 : point.yPos + collide.height - elementSpacing / 2;
                        point.textOptionsacc.y = point.textOptionsacc.y + point.height / 4 - elementSpacing / 2 + margin.top / 2 - margin.bottom / 2;
                    }
                }
            }
            degree = dataLabel.angle;
            angle = (degree > 360) ? degree - 360 : (degree < -360) ? degree + 360 : degree;
            rotate = 'rotate(' + angle + ',' + (point.textOptionsacc.x) + ',' + (point.textOptionsacc.y) + ')';
            $(point.textOptionsacc).attr('transform', rotate);

            $(point.textOptionsacc).attr({
                'transform': rotate
            });
            if (labelPosition == "inside" || labelPosition == "outsideextended") {
                point.yPos = point.yPos + elementSpacing / 4;
                point.textOptionsacc.y = point.textOptionsacc.y + point.height / 4 + margin.top / 2 - margin.bottom / 2;
            }
            outsideDataRegionPoints[outsideDataRegionPoints.length] = point;
        },

        //Inside region checking and smartlabels
        calculateInsideConnectorLines: function (pointIndex, point, currentseries, chartObj) {

            var polygon = point.Polygon,
                marker = $.extend(true, {}, currentseries.marker, point.marker),
                dataLabel = marker.dataLabel,
                font = dataLabel.font, connectorHeight,
                pyrX = (chartObj.model.enableCanvasRendering) ? chartObj.pyrX : 0,
                pyrY = (chartObj.model.enableCanvasRendering) ? chartObj.pyrY : 0,
                //inside connector line height
                connectorLength = 70,
                datalabelWidth = sf.EjSvgRender.utils._measureText(point.drawTextacc, null, font),
                positionPoint = (dataLabel.template) ? { x: point.xPos, y: point.yPos } : { x: point.xPos + (datalabelWidth.width / 2) - pyrX, y: point.yPos - (point.height / 2) - pyrY },
                regionPoint = chartObj.isPointInPolygon(polygon, positionPoint);
            if (!regionPoint) {
                point._labelPlacement = "insideoverlap";
                point.textOptionsacc['text-anchor'] = 'start';
                if (point.startX + connectorLength < chartObj.model.m_AreaBounds.Width)
                    connectorHeight = connectorLength;
                else
                    connectorHeight = chartObj.model.m_AreaBounds.Width - (point.startX);

                point.textOptionsacc.x = point.xPos = point.startX + connectorHeight;
                point.textOptionsacc.y = point.yPos = point.yLocation;
                if (chartObj.model.enableCanvasRendering && !dataLabel.template) {
                    point.textOptionsacc.x += chartObj.pyrX;
                    point.textOptionsacc.y += chartObj.pyrY;
                    point.xPos += chartObj.pyrX;
                    point.yPos += chartObj.pyrY;
                }
                this.compareDataLabels(point, pointIndex, chartObj.model.outsideDataRegionPoints, currentseries, chartObj);

            }

            else {
                point._labelPlacement = "insidenooverlap";
            }
        },
        //smartLabels connector Lines
        drawConnectorLines: function (index, currentPoint, currentseries, chartObj) {
            var bezierdir = "";
            var seriesType = new sf.seriesTypes[currentseries.type.toLowerCase()](),
                startx = currentseries._visiblePoints[index].startX,
                starty = currentseries._visiblePoints[index].startY,
                connectorDirection = "",
                seriesIndex = $.inArray(currentseries, chartObj.model._visibleSeries),
                marker = $.extend(true, {}, currentseries.marker, currentPoint.marker),
                dataLabel = marker.dataLabel,
                endy = currentPoint.textOptionsacc.y - chartObj.model.elementSpacing / 2,
                pyrX = (chartObj.model.enableCanvasRendering) ? chartObj.pyrX : 0,
                pyrY = (chartObj.model.enableCanvasRendering) ? chartObj.pyrY : 0,
                renderingPoints = [{ X: startx + pyrX, Y: starty + pyrY },//bezier curve control points
                { X: currentPoint.textOptionsacc.x, Y: endy }];
            if (dataLabel.connectorLine.type.toLowerCase() == 'bezier' && !chartObj.vmlRendering)
                bezierdir = seriesType.drawBezierSegment(renderingPoints, currentseries, index, chartObj, seriesIndex);
            else {
                connectorDirection = "M" + " " + (startx) + " " + (starty) + " " + "L" + " " + (currentPoint.textOptionsacc.x) + " " + (endy);
                if (chartObj.model.enableCanvasRendering && !dataLabel.template)
                    connectorDirection = "M" + " " + (startx) + " " + (starty) + " " + "L" + " " + (currentPoint.textOptionsacc.x - pyrX) + " " + (endy - pyrY);
            }
            return { connectorDirection: connectorDirection, bezierdir: bezierdir };
        },

        //method to detect collision between data labels
        isCollide: function (prevlabel, currentlabel, currentseries) {
            var width = 0,
                height = 0,
                type = currentseries.type.toLowerCase(),
                state;
            state = !(
                ((prevlabel.yPos + prevlabel.height) < (currentlabel.yPos)) ||
                (prevlabel.yPos > (currentlabel.yPos + currentlabel.height)) ||
                ((prevlabel.xPos + prevlabel.width / 2) < currentlabel.xPos - currentlabel.width / 2) ||
                ((prevlabel.xPos - prevlabel.width) > (currentlabel.xPos + currentlabel.width)));

            if (state && type == "pyramid") {
                height = ((prevlabel.yPos + prevlabel.height) - (currentlabel.yPos));
                width = (prevlabel.xPos + prevlabel.width) - currentlabel.xPos;
            }
            else if (state && type == "funnel") {
                height = ((prevlabel.yPos) - (currentlabel.yPos + currentlabel.height));
                width = (prevlabel.xPos + prevlabel.width) - currentlabel.xPos;
            }
            return { state: state, height: height, width: width };
        },
        // trimming the text when it exceeds chart area
        trimText: function (text, maxLength, ellipsis) {
            maxLength--;
            var length = maxLength - ellipsis.length,
                trimmedText = text.substr(0, length);
            return trimmedText + ellipsis;
        },

        //calculate a length of a text for datalabel trimming
        trimfunction: function (datalabelText, remainingWidth, datalabelLength, elipsis, axisWidth, font) {
            while (remainingWidth < datalabelLength) {
				datalabelText = datalabelText.toString();
                datalabelText = this.trimText(datalabelText, datalabelText.length, elipsis);
                datalabelLength = sf.EjSvgRender.utils._measureText(datalabelText, axisWidth, font).width;
                if (datalabelText == elipsis) {
                    datalabelText = "";
                    break;
                }
            }
            return datalabelText;
        },

        //To calculate start and end point of a text inside a pie and doughnut region
        calculatePosition: function (chartObj, textOptions, datalabelLength, startX, startY) {
            var rightEndX, rightEndY, leftEndX, leftEndY;
            rightEndX = (textOptions.x + (datalabelLength / 2)) - startX;
            rightEndY = (textOptions.y) - (startY);
            leftEndX = (textOptions.x - (datalabelLength / 2)) - startX;
            leftEndY = textOptions.y - startY;
            return { rightEndX: rightEndX, rightEndY: rightEndY, leftEndX: leftEndX, leftEndY: leftEndY };

        },

        //To caluculate textoptions
        textOption: function (currentseries, chartObj, textsize, pyrX, pyrY, pointIndex, textAnchor, positionX, positionY, seriesIndex, visiblePoint) {
            if (chartObj.model._isPieOfPie)
                var marker = $.extend(true, {}, currentseries.marker, visiblePoint.marker);
            else
                var marker = $.extend(true, {}, currentseries.marker, currentseries._visiblePoints[pointIndex].marker);
            if (!marker.dataLabel.template) {
                $("#" + chartObj.svgObject.id + 'series' + seriesIndex + '_PointText' + pointIndex).remove();
                var textOptions = {
                    'id': chartObj.svgObject.id + 'series' + seriesIndex + '_PointText' + pointIndex,
                    'x': positionX + pyrX,
                    'y': positionY + textsize.height / 4 + pyrY,
                    'fill': marker.dataLabel.font.color,
                    'font-size': marker.dataLabel.font.size,
                    'font-family': marker.dataLabel.font.fontFamily,
                    'font-style': marker.dataLabel.font.fontStyle,
                    'font-weight': marker.dataLabel.font.fontWeight,
                    'opacity': marker.dataLabel.font.opacity,
                    'text-anchor': textAnchor,
                    'cursor': 'default',
                    'degree': marker.dataLabel.angle
                };
                //To rotate datalabels
                var degree = marker.dataLabel.angle;
                var angle = (degree > 360) ? degree - 360 : (degree < -360) ? degree + 360 : degree;
                var rotate = 'rotate(' + angle + ',' + (positionX) + ',' + (positionY) + ')';
                $(textOptions).attr('transform', rotate);
                if (chartObj.model.enableCanvasRendering) {
                    $(textOptions).attr('labelRotation', degree);
                }
                $(textOptions).attr({
                    'transform': rotate
                });
            }
            return textOptions;
        },

        //To trim  datalabel when it exceed a particular pie and doughnut region
        labelTrim: function (chartObj, textOptions, datalabelLength, datalabelText, startX, startY, point, font, seriesIndex, pieSeriesIndex) {
            var chartStartAngle = -.5 * Math.PI;
            var chartEndAngle = .5 * Math.PI;
            var position = this.calculatePosition(chartObj, textOptions, datalabelLength, startX, startY);
            var startAngle = chartObj.model.series[seriesIndex].startAngle;
            var endAngle = chartObj.model.series[seriesIndex].endAngle;
            var regionData = (chartObj.model.chartRegions.length < chartObj.model._visibleSeries.length) ? chartObj.model.chartRegions[0].Region : chartObj.model.chartRegions[seriesIndex].Region;
            var pointStartAngle, pointEndAngle;
            var distanceFromCenter;
            var textinRegion;
            var trimPosition, datalabelWidth;
            var ellipsis = "...";
            var firstStartAngle = [];
            var totalDegree = endAngle - startAngle;
            var seriesIndex = chartObj.model._isPieOfPie ? pieSeriesIndex : seriesIndex;
            if (totalDegree < 0) {
                endAngle = endAngle / 360;
                var arcAngle = (endAngle) ? 2 * Math.PI * (endAngle < 0 ? 1 + endAngle : endAngle) : 0;
            }
            else
                var arcAngle = startAngle ? 2 * Math.PI * (chartObj.model.itemCurrentXPos < 0 ? 1 + chartObj.model.itemCurrentXPos : chartObj.model.itemCurrentXPos) : 0;
            startAngle = (Math.atan2(position.rightEndY, position.rightEndX) - chartStartAngle - arcAngle) % (2 * Math.PI);
            if (startAngle < 0) startAngle = 2 * Math.PI + startAngle;
            endAngle = (Math.atan2(position.leftEndY, position.leftEndX) - chartStartAngle - arcAngle) % (2 * Math.PI);
            if (endAngle < 0) endAngle = 2 * Math.PI + endAngle;
            pointStartAngle = parseFloat(point.start.toFixed(14));
            pointEndAngle = parseFloat(point.end.toFixed(14));
            if (totalDegree > 0) {
                if (sf.util.isNullOrUndefined(chartObj.firstStartAngle[0])) {
                    chartObj.firstStartAngle.push(pointStartAngle);
                }
                pointStartAngle = (chartObj.firstStartAngle[0] < 0) ? (chartObj.model._isPieOfPie ? pointStartAngle : 2 * Math.PI + pointStartAngle) : pointStartAngle;
                pointEndAngle = (chartObj.firstStartAngle[0] < 0) ? (chartObj.model._isPieOfPie ? pointEndAngle : 2 * Math.PI + pointEndAngle) : pointEndAngle;
            }
            else {
                pointStartAngle = pointStartAngle < 0 ? (chartObj.model._isPieOfPie ? pointStartAngle : 2 * Math.PI + pointStartAngle) : pointStartAngle;
                pointEndAngle = pointEndAngle < 0 ? (chartObj.model._isPieOfPie ? pointEndAngle : 2 * Math.PI + pointEndAngle) : pointEndAngle;
            }
            pointStartAngle -= arcAngle;
            pointEndAngle -= arcAngle;
            // to check start and end angle when greater than 360 in pieofpie
            if (pointStartAngle > 2 * Math.PI && pointEndAngle > 2 * Math.PI) {
                startAngle = startAngle + 2 * Math.PI;
                endAngle = endAngle + 2 * Math.PI;
            }
            else if (pointStartAngle < 2 * Math.PI && pointEndAngle > 2 * Math.PI) {
                if (startAngle < Math.PI / 2)
                    startAngle = startAngle + 2 * Math.PI;
                if (endAngle < Math.PI / 2)
                    endAngle = endAngle + 2 * Math.PI;
            }
            if (startAngle < 0 && (endAngle > 0 || endAngle == null)) {
                pointStartAngle = pointStartAngle < 0 ? 2 * Math.PI + pointStartAngle : pointStartAngle;
                pointEndAngle = pointEndAngle <= 0 ? 2 * Math.PI + pointEndAngle : pointEndAngle;
            }
            if (chartObj.model.circleCenterX[seriesIndex] < textOptions.x) {
                distanceFromCenter = Math.sqrt(Math.pow(Math.abs(position.rightEndX), 2) + Math.pow(Math.abs(position.rightEndY), 2));
            }
            else
                distanceFromCenter = Math.sqrt(Math.pow(Math.abs(position.leftEndX), 2) + Math.pow(Math.abs(position.leftEndY), 2));
            if (totalDegree < 0) {
                pointEndAngle = [pointStartAngle, pointStartAngle = pointEndAngle][0];
            }
            if ((endAngle >= pointStartAngle && endAngle <= pointEndAngle) && (startAngle >= pointStartAngle && startAngle <= pointEndAngle) && (distanceFromCenter <= chartObj.model.circularRadius[seriesIndex] && distanceFromCenter > 0)) {
                textinRegion = true;
            }
            else {
                textinRegion = false;
                while (!textinRegion) {
                    datalabelText = this.trimText(datalabelText, datalabelText.length, ellipsis);
                    if (datalabelText == ellipsis) {
                        datalabelText = "";
                        break;
                    }
                    datalabelWidth = sf.EjSvgRender.utils._measureText(datalabelText, null, font);
                    trimPosition = this.calculatePosition(chartObj, textOptions, datalabelWidth.width, startX, startY);
                    var startangle = (Math.atan2(trimPosition.rightEndY, trimPosition.rightEndX) - chartStartAngle - arcAngle) % (2 * Math.PI);
                    if (startangle < 0) startangle = 2 * Math.PI + startangle;
                    var endAngle = (Math.atan2(trimPosition.leftEndY, trimPosition.leftEndX) - chartStartAngle - arcAngle) % (2 * Math.PI);
                    if (endAngle < 0) endAngle = 2 * Math.PI + endAngle;
                    if (chartObj.model.circleCenterX[seriesIndex] < textOptions.x) {
                        distanceFromCenter = Math.sqrt(Math.pow(Math.abs(trimPosition.rightEndX), 2) + Math.pow(Math.abs(trimPosition.rightEndY), 2));
                    }
                    else
                        distanceFromCenter = Math.sqrt(Math.pow(Math.abs(trimPosition.leftEndX), 2) + Math.pow(Math.abs(trimPosition.leftEndY), 2));
                    // to check when startangle and endangle is greater than 360 degree for pieofpie
                    if ((pointStartAngle > 2 * Math.PI && pointEndAngle > 2 * Math.PI) && chartObj.model._isPieOfPie) {
                        var stAngle = pointStartAngle - 2 * Math.PI;
                        pointStartAngle = stAngle;
                        var enAngle = pointEndAngle - 2 * Math.PI;
                        pointEndAngle = enAngle;
                    }
                    else if ((pointStartAngle != 0 && pointStartAngle < 2 * Math.PI && pointEndAngle >= 2 * Math.PI) && chartObj.model._isPieOfPie) {
                        var stAngle = pointStartAngle - 2 * Math.PI;
                        pointStartAngle = stAngle;
                    }
                    if ((endAngle >= pointStartAngle && endAngle <= pointEndAngle) &&
                        (startangle >= pointStartAngle && startangle <= pointEndAngle) &&
                        (distanceFromCenter <= chartObj.model.circularRadius[seriesIndex] && distanceFromCenter > 0)) {
                        textinRegion = true;
                    }

                }
            }

            return datalabelText;
        },


        drawDataLabelAcc: function (sender, currentseries, pointIndex, point, seriesIndex, pieSeriesIndex) {
            // method for data label symbols - accumulation series	
            var pointMarker = point.marker;
            if (point.visible && ((pointMarker && pointMarker.dataLabel && pointMarker.dataLabel.visible) || (!pointMarker || !pointMarker.dataLabel) && currentseries.marker.dataLabel.visible)) {
                var chartObj = sender,
                    type = currentseries.type.toLowerCase(),
                    seriesType = new sf.seriesTypes[type](),
                    isNull = sf.util.isNullOrUndefined,
                    _labelPosition = type == "pieofpie" ? "inside" : currentseries.labelPosition.toLowerCase(),
                    chartModel = chartObj.model,
                    chartTitle = chartModel.title,
                    measureText = sf.EjSvgRender.utils._measureText,
                    elementSpacing = chartModel.elementSpacing,
                    seriesMarker = currentseries.marker,
                    dataLabel = seriesMarker.dataLabel,
                    margin = dataLabel.margin,
                    dataLabelFont = dataLabel.font,
                    connectorLine = dataLabel.connectorLine,
                    connectorType = connectorLine.type.toLowerCase(),
                    legend = chartModel.legend,
                    legendPosition = legend.position.toLowerCase(),
                    legendActualBounds = chartModel.LegendActualBounds,
                    text = isNull(point.text) ? point.y : point.text,
                    enableWrap = dataLabel.enableWrap,
                    wrapConnectorpoints, shape, size,
                    labelText = text,
                    srIndex = chartModel._isPieOfPie ? pieSeriesIndex : seriesIndex;

                var connectorDirection, labelfont,
                    commonEventArgs, textsize, position, symbolPos, accDataLabelRegion,
                    positionX = 0, textWidth, textHeight,
                    positionY = 0, symbolName,
                    pointColor, chartBackground = chartModel.background.toLowerCase(), fontBackgroundColor, contrastColor = dataLabel.enableContrastColor;

                if ((type == "pyramid" || type == "funnel") && _labelPosition == 'outsideextended')
                    _labelPosition = 'inside';

                commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = { text: text, series: currentseries, pointIndex: pointIndex };
                chartObj._trigger("displayTextRendering", commonEventArgs);

                labelfont = { size: dataLabelFont.size, fontStyle: dataLabelFont.fontStyle, fontFamily: dataLabelFont.fontFamily };
                textsize = measureText(commonEventArgs.data.text, null, labelfont);
                textWidth = textsize.width + margin.left + margin.right;
                textHeight = textsize.height + margin.top + margin.bottom;

                if (type == "pyramid" || type == "funnel") {
                    var measureTitle = (chartModel.title.text) ? measureText(chartModel.title.text, $(this.svgObject).width() - chartModel.margin.left - chartModel.margin.right, chartModel.title.font) : 0;
                    var mesureSubTitle = (chartObj.model.title.subTitle.text) ? sf.EjSvgRender.utils._measureText(chartObj.model.title.subTitle.text, $(this.svgObject).width() - chartObj.model.margin.left - chartObj.model.margin.right, chartObj.model.title.subTitle.font) : 0;
                    var subtitleHeight = (chartObj.model.title.subTitle.text === '') ? 0 : mesureSubTitle.height;
                    var pyrX = elementSpacing + chartModel.margin.left + (legendPosition === "left") ? (legendActualBounds.Width) : 0;
                    var pyrY = ((legendPosition === "top") ? (legendActualBounds.Height) : 0) + ((chartModel.title.text && chartModel.title.visible) ? (chartModel._titleLocation.Y + measureTitle.height + subtitleHeight) : (chartModel.margin.top + elementSpacing));
                    textWidth = textWidth + 10;
                    var Location = { X: point.xLocation + chartObj.pyrX, Y: point.yLocation + chartObj.pyrY };
                    positionX = point.xLocation;
                    positionY = point.yLocation;
                    var marker = point.marker ? point.marker : seriesMarker;
                    marker = $.extend(true, {}, seriesMarker, marker);
                    connectorDirection = point.connectorLine;
                    symbolPos = { positionX: positionX, positionY: positionY };
                }

                if (type != "pyramid" && type != "funnel") {
                    var chartStartingAngle = -.5 * Math.PI,
                        midAngle = point.midAngle + chartStartingAngle,
                        midPoint, doughnutMidPoint, connector, bounds,
                        startPoint,
                        measureTitle = (chartModel.title.text) ? measureText(chartModel.title.text, $(this.svgObject).width() - chartModel.margin.left - chartModel.margin.right, chartModel.title.font) : 0,
                        mesureSubTitle = (chartObj.model.title.subTitle.text) ? sf.EjSvgRender.utils._measureText(chartObj.model.title.subTitle.text, $(this.svgObject).width() - chartObj.model.margin.left - chartObj.model.margin.right, chartObj.model.title.subTitle.font) : 0,
                        subtitleHeight = (chartObj.model.title.subTitle.text === '') ? 0 : mesureSubTitle.height,
                        textOffset, startX, startY, midX, midY, dMidX, dMidY, connectorX, connectorY,
                        renderingPoints = [],
                        radius = chartModel.circularRadius[srIndex];
                    if (isNull(connectorLine.height))
                        textOffset = measureText(commonEventArgs.data.text, null, dataLabelFont).height;
                    else
                        textOffset = connectorLine.height;
                    var actualIndex = chartObj.model._isPieOfPie ? point.actualIndex : currentseries._visiblePoints[pointIndex].actualIndex;
                    if ((actualIndex == currentseries.explodeIndex || currentseries.explodeAll) && !chartObj.vmlRendering) {
                        startX = chartModel.circleCenterX[srIndex] + Math.cos(midAngle) * currentseries.explodeOffset;
                        startY = chartModel.circleCenterY[srIndex] + Math.sin(midAngle) * currentseries.explodeOffset;
                    }
                    else {
                        startX = chartModel.circleCenterX[srIndex];
                        startY = chartModel.circleCenterY[srIndex];
                    }
                    midX = seriesType.getXCordinate(startX, (radius), midAngle);
                    midX = point.y != 0 ? midX : parseFloat(midX.toFixed(12));
                    midY = seriesType.getYCordinate(startY, (radius), midAngle);

                    dMidX = seriesType.getXCordinate(startX, (chartModel.innerRadius[seriesIndex]), midAngle);
                    dMidY = seriesType.getYCordinate(startY, (chartModel.innerRadius[seriesIndex]), midAngle);

                    connectorX = this.getXCordinate(startX, (radius) + textOffset, midAngle);
                    connectorX = point.y != 0 ? connectorX : parseFloat(connectorX.toFixed(12));
                    connectorY = this.getYCordinate(startY, (radius) + textOffset, midAngle);

                    if (dataLabel.template)
                        size = point.size;
                    else {
                        var marker = point.marker ? point.marker : seriesMarker,
                            marker = $.extend(true, {}, seriesMarker, marker);
                        shape = marker.dataLabel.shape;
                        size = measureText(commonEventArgs.data.text, $(chartObj.svgObject).width(), dataLabelFont);
                        if (shape.toLowerCase() != "none") {
                            size.height = size.height + margin.top + margin.bottom;
                            size.width = size.width + margin.left + margin.right;
                        }
                    }

                    midPoint = { midX: midX, midY: midY };
                    doughnutMidPoint = { dMidX: dMidX, dMidY: dMidY };
                    connector = { connectorX: connectorX, connectorY: connectorY };
                    bounds = { midPoint: midPoint, doughnutMidPoint: doughnutMidPoint, connector: connector };
                    startPoint = { startX: startX, startY: startY };

                    if (!currentseries._enableSmartLabels) {
                        position = seriesType.updateLabelPosition(currentseries, point, pointIndex, bounds, midAngle, startPoint, textOffset, size, sender, seriesIndex);
                        positionX = position.positionX;
                        positionY = position.positionY;
                        connectorDirection = position.connectorDirection;
                    }
                    // smart labels

                    else {
                        position = seriesType.updateSmartLabelPosition(currentseries, point, pointIndex, bounds, midAngle, startPoint, textOffset, size, sender, seriesIndex);
                        if (chartObj.model.bounds[seriesIndex].points[pointIndex])
                            var isOverlapped = chartObj.model.bounds[seriesIndex].points[pointIndex].overlap;
                   		positionX = position.positionX;
						positionY = position.positionY;
                        symbolPos = { positionX: positionX, positionY: positionY, isInterSected: position.isInterSected };
                        connectorDirection = chartObj.model._isPieOfPie || isOverlapped ? "" : position.connectorDirection;
                    }
                }

                var textAnchor = ((_labelPosition != 'inside' && _labelPosition != 'insidenooverlap') || ((type == "pyramid" || type == "funnel") && _labelPosition == 'outside')) ? (positionX < chartModel.circleCenterX[srIndex] ? 'end' : 'start') : 'middle',
                    width = (_labelPosition == 'inside' || _labelPosition == 'insidenooverlap') ? 0 : (positionX < chartModel.circleCenterX[srIndex]) ? -textsize.width : textsize.width,
                    pyrX = 0, pyrY = 0, textOptions;

                if ((type == "pie" || type == "doughnut" || type == "pieofpie") && _labelPosition == "inside")
                    textAnchor = (connectorDirection != "") ? (positionX < chartModel.circleCenterX[srIndex] ? 'end' : 'start') : 'middle';
                if ((type == "pyramid" || type == "funnel") && _labelPosition == "outside")
                    textAnchor = 'start';

                var subtitleHeight = (chartObj.model.title.subTitle.text === '') ? 0 : mesureSubTitle.height;
                if ((this.chartObj && chartModel.enableCanvasRendering) && (type == "pyramid" || type == "funnel")) {
                    pyrX = ((legendPosition === "left") ? (legendActualBounds.Width) : 0) + elementSpacing + chartModel.margin.left;
                    pyrY = ((legendPosition === "top") ? (legendActualBounds.Height) : 0) + ((chartTitle.text) ? (chartModel._titleLocation.Y + measureTitle.height + subtitleHeight) : (chartModel.margin.top + elementSpacing));
                }

                pointIndex = chartObj.model._isPieOfPie ? point.actualIndex : pointIndex;
                textOptions = this.textOption(currentseries, chartObj, textsize, pyrX, pyrY, pointIndex, textAnchor, positionX, positionY, seriesIndex, point);
                // to obtain the background color
                pointColor = jQuery.type(chartModel.pointColors[point.actualIndex]) == "array" ?
                    chartModel.pointColors[point.actualIndex][0].color : chartModel.pointColors[point.actualIndex];
                // To set the point color when set the color in empty point
                pointColor = point.fill ? jQuery.type(point.fill) == "array" ? point.fill[0].color : point.fill : pointColor;
                if (dataLabel.template) {
                    Location = isNull(Location) ? { X: positionX, Y: positionY } : Location;
                    var pointindex = point.actualIndex;
                    seriesType.drawLabelTemplate(currentseries, point, pointindex, Location, sender);
                    if (connectorType == "bezier" && (position.bezierPath) != "")
                        sender.svgRenderer.drawPolyline(position.bezierPath, sender.gConnectorEle[seriesIndex]);
                }
                else {
                    $.each(chartModel.symbolShape, function (name) {
                        marker = point.marker ? point.marker : seriesMarker;
                        marker = $.extend(true, {}, seriesMarker, marker);
                        shape = marker.dataLabel.shape;
                        if (shape.toLowerCase() == name.toLowerCase())
                            symbolName = name;
                    });

                    positionX = pyrX + positionX - (margin.left) / 2 + (margin.right) / 2 + width / 2;
                    positionY = pyrY + positionY - (margin.top) / 2 + (margin.bottom) / 2;
                    //SmartLabels value storing for pyramid and funnel
                    if (type == "pyramid" || type == "funnel") {
                        point.xPos = symbolPos.positionX + pyrX;
                        point.yPos = symbolPos.positionY + pyrY;
                        point.width = (symbolName == "None") ? textsize.width : textWidth;
                        point.height = (symbolName == "None") ? textsize.height : textHeight;
                        point.symbolName = (dataLabel.template) ? "none" : symbolName;
                        point.textOptionsacc = textOptions;
                        point.drawTextacc = commonEventArgs.data.text;
                    }
                    //For accurate placement of rotated data labels in canvas
                    if (chartModel.enableCanvasRendering && (textOptions.degree % 360 != 0)) {
                        textOptions.y -= (textsize.height / 4);
                        textOptions.baseline = 'middle';
                    }
                    if (contrastColor && !currentseries._enableSmartLabels) {
                        fontBackgroundColor = _labelPosition != "inside" ? (chartBackground === "transparent") ? "white" :
                            chartBackground : pointColor;
                        textOptions.fill = this._applySaturation(chartObj, fontBackgroundColor);
                    }
                    if (currentseries._enableSmartLabels) {
                        var axisWidth = chartModel.m_AreaBounds.Width + chartModel.m_AreaBounds.X + chartModel.margin.left,
                            labelPosition = _labelPosition,
                            enableCanvasRendering = chartModel.enableCanvasRendering,
                            datalabelText = (typeof commonEventArgs.data.text == "string") ? commonEventArgs.data.text : commonEventArgs.data.text.toString(),
                            datalabelLength = measureText(datalabelText, datalabelText.length, dataLabelFont).width,
                            legendBounds,
                            remainingWidth,
                            legendWidth = 0, legendHeight = 0;
                        if (legend.visible) {
                            if (legendPosition == "left" || legendPosition == "right")
                                legendBounds = legendActualBounds;
                        }
                        else
                            legendBounds = { Width: 0 };

                        if (type == "pie" || type == "doughnut" || type == "pieofpie") {

                            if (labelPosition == "outside" || labelPosition == "outsideextended" || connectorDirection != "") {
                                if (chartModel.circleCenterX[srIndex] < textOptions.x)
                                    remainingWidth = (axisWidth - textOptions.x);
                                else
                                    remainingWidth = legendPosition == "left" ? (textOptions.x - chartModel.margin.left - (chartModel.elementSpacing * 2) - legendBounds.Width) : (textOptions.x - chartModel.margin.left);
                                datalabelText = this.trimfunction(datalabelText, remainingWidth, datalabelLength, "...", axisWidth, dataLabelFont);

                                if (legend.visible && (legendPosition == 'top' || legendPosition == 'bottom')) {
                                    datalabelText = this._overlapLegend(textOptions, datalabelText, sender, seriesIndex);
                                }
                            }
                            if (labelPosition == "inside" && (connectorDirection == "")) {
                                datalabelText = this.labelTrim(chartObj, textOptions, datalabelLength, datalabelText, startX, startY, point, dataLabelFont, seriesIndex, pieSeriesIndex);

                                if (datalabelText == "" && !chartObj.model._isPieOfPie) {
                                    point.smartLabelPosition = "outside";
                                    position = seriesType.updateSmartLabelPosition(currentseries, point, pointIndex, bounds, midAngle, startPoint, textOffset, size, sender, seriesIndex);
                                    symbolPos = { positionX: position.positionX, positionY: position.positionY, isInterSected: position.isInterSected };
                                    datalabelText = commonEventArgs.data.text;
                                    connectorDirection = position.connectorDirection;
                                    textAnchor = (chartModel.circleCenterX[srIndex] < position.positionX) ? "start" : "end";
                                    textOptions = this.textOption(currentseries, chartObj, textsize, pyrX, pyrY, pointIndex, textAnchor, position.positionX, position.positionY, seriesIndex, point);
                                    if (chartModel.circleCenterX[srIndex] < position.positionX)
                                        remainingWidth = legendPosition == "right" ? (axisWidth - textOptions.x - legendBounds) : (axisWidth - textOptions.x);
                                    else
                                        remainingWidth = legendPosition == "left" ? (textOptions.x - legendBounds) : (textOptions.x);
                                    datalabelText = this.trimfunction(datalabelText, remainingWidth, datalabelLength, "...", axisWidth, dataLabelFont);
                                    delete point.smartLabelPosition;
                                }
                            }
                        }
                        else if ((type == "pyramid" || type == "funnel")) {
                            position = seriesType.updateSmartLabel(sender, currentseries, pointIndex, point);
                            positionX = position.xPos;
                            positionY = position.yPos;
                            connectorDirection = position.connectorDirection;
                            textOptions = position.textOptionsacc;
                            datalabelText = point.drawTextacc;

                            if ((connectorDirection != "" || connectorType == "bezier") && datalabelText != "") {
                                datalabelText = datalabelText.toString();
                                if (legendPosition == "right")
                                    remainingWidth = (enableCanvasRendering) ? (axisWidth - textOptions.x) : (axisWidth - textOptions.x - chartObj.pyrX);
                                else if (legendPosition == "left")
                                    remainingWidth = enableCanvasRendering ? (axisWidth - textOptions.x) : (axisWidth - textOptions.x - chartObj.pyrX);
                                else if (legendPosition == "top")
                                    remainingWidth = (enableCanvasRendering) ? (axisWidth - textOptions.x) : axisWidth - textOptions.x - chartObj.pyrX;
                                else
                                    remainingWidth = (enableCanvasRendering) ? (axisWidth - textOptions.x) : axisWidth - textOptions.x - chartObj.pyrX;
                                if (remainingWidth < datalabelLength)
                                    datalabelText = this.trimfunction(datalabelText, remainingWidth, datalabelLength, "...", axisWidth, dataLabelFont);
                            }
                        }

                        var datalabelShape = measureText(datalabelText, null, dataLabelFont);
                        if (type == "pie" || type == "doughnut" || type == "pieofpie")
                            var width = ((_labelPosition == 'inside' || _labelPosition == 'insidenooverlap') && !symbolPos.isInterSected && connectorDirection == "") ? 0 : (positionX < chartModel.circleCenterX[srIndex]) ? -datalabelShape.width : datalabelShape.width;
                        else if (type == "pyramid" || type == "funnel")
                            var width = (point._labelPlacement == "insidenooverlap") ? 0 : datalabelShape.width;
                        if (type == "pie" || type == "doughnut" || type == "pieofpie") {
                            positionX = pyrX + symbolPos.positionX - (margin.left) / 2 + (margin.right) / 2 + (width / 2);
                            positionY = pyrY + symbolPos.positionY - (margin.top) / 2 + (margin.bottom) / 2;
                        }
                        else {
                            positionX = positionX - (margin.left) / 2 + (margin.right) / 2 + (width / 2);
                            positionY = positionY - (margin.top) / 2 + (margin.bottom) / 2;
                        }

                        var dataLabelEle = $('#' + chartObj.svgObject.id + '_dataLabel_series' + seriesIndex + "_point_" + pointIndex);
                        var conEle = $('#' + chartObj.svgObject.id + "_connectorLine_series" + seriesIndex + "_point_" + pointIndex);
                        if (datalabelText !== "") {
                            dataLabelEle.show();
                            conEle.show();
                            if (contrastColor) {
                                fontBackgroundColor = labelPosition != "inside" ? (chartBackground === "transparent") ? "white" : chartBackground :
                                    (position.connectorDirection != "" && !sf.util.isNullOrUndefined(position.connectorDirection)
                                        || position.bezierPath != "" && !sf.util.isNullOrUndefined(position.bezierPath)) ?
                                        (chartBackground === "transparent") ? "white" : chartBackground : pointColor;
                                textOptions.fill = this._applySaturation(chartObj, fontBackgroundColor);
                            }
                            if (!enableWrap && !isOverlapped) {
                                seriesType.dataLabelSymbol(seriesIndex, currentseries, pointIndex, positionX, positionY, textWidth, textHeight, symbolName, chartObj);
                            }
                            if (connectorType == "bezier" && (position.bezierPath) != "" && !(sf.util.isNullOrUndefined(position.bezierPath)))
                                sender.svgRenderer.drawPolyline(position.bezierPath, sender.gConnectorEle[seriesIndex]);
                        }
                        else {
                            dataLabelEle.hide();
                            conEle.hide();
                            connectorDirection = "";
                        }
                        if (!enableWrap && !isOverlapped)
                            chartObj.svgRenderer.drawText(textOptions, datalabelText, chartObj.gSeriesTextEle[seriesIndex]);
                        var datalabelSize = measureText(datalabelText, datalabelText.length, dataLabelFont);
                        var untrimmedSize = measureText(commonEventArgs.data.text, null, dataLabelFont);
                        var bounds;
                        var minX, minY, maxX, maxY;
                        if (type == "pie" || type == "doughnut" || type == "pieofpie") {
                            if (labelPosition == "inside" && position.connectorDirection == "") {
                                minX = textOptions.x - datalabelShape.width / 2;
                                maxX = textOptions.x + datalabelShape.width / 2;
                                minY = textOptions.y - datalabelShape.height / 2;
                                maxY = textOptions.y + datalabelShape.height / 2;
                            }
                            else {
                                if (chartModel.circleCenterX[srIndex] < textOptions.x) {
                                    minX = textOptions.x;
                                    maxX = textOptions.x + datalabelShape.width;
                                }
                                else {
                                    minX = textOptions.x - datalabelShape.width;
                                    maxX = textOptions.x;
                                }
                                minY = textOptions.y - datalabelShape.height / 2;
                                maxY = textOptions.y + datalabelShape.height / 3;
                            }
                            bounds = { centerX: chartModel.circleCenterX[srIndex], minX: minX, minY: minY, maxX: maxX, maxY: maxY, width: datalabelSize.width, height: datalabelSize.height, labelPosition: labelPosition };
                        }

                        if ((type == "funnel" || type == "pyramid")) {
                            legendWidth = legendPosition == "left" ? legendWidth : 0;
                            var legendHeight = 0;
                            if (connectorDirection != "" || connectorType == "bezier") {
                                minX = textOptions.x - legendWidth;
                                maxX = textOptions.x + datalabelShape.width - legendWidth;
                                minY = textOptions.y - datalabelShape.height;
                                maxY = textOptions.y;
                            }
                            if (!enableCanvasRendering)
                                bounds = { minX: minX + chartObj.pyrX + legendWidth, maxX: maxX + chartObj.pyrX + legendWidth, minY: minY + chartObj.pyrY + legendHeight, maxY: maxY + chartObj.pyrY + legendHeight, width: datalabelSize.width, height: datalabelSize.height, labelPosition: labelPosition };
                            else
                                bounds = { minX: minX + legendWidth, maxX: maxX + legendWidth, minY: minY + legendHeight, maxY: maxY + legendHeight, width: datalabelSize.width, height: datalabelSize.height, labelPosition: labelPosition };
                        }
                        accDataLabelRegion = { bounds: bounds, trimmedText: datalabelText, text: commonEventArgs.data.text, type: type, font: dataLabelFont };
                        chartObj.accDataLabelRegion.type = type;
                        chartObj.accDataLabelRegion.connectorDirection = connectorDirection;
                        if (sf.util.isNullOrUndefined(chartObj.accDataLabelRegion[srIndex])) {
                            chartObj.accDataLabelRegion[srIndex] = [];
                        }

                        if (chartObj.accDataLabelRegion[srIndex].length < currentseries._visiblePoints.length)
                            chartObj.accDataLabelRegion[srIndex].push(accDataLabelRegion);
                        if (((!isNull(point.index) && currentseries.explode) && (!enableCanvasRendering)))
                            chartObj.accDataLabelRegion[srIndex].splice(point.index, 1, accDataLabelRegion);
                        if (pieSeriesIndex == 1 && chartObj.accDataLabelRegion[srIndex].length == currentseries._visiblePoints.length) {
                            chartObj.accDataLabelRegion[seriesIndex] = $.merge($.merge([], chartObj.accDataLabelRegion[0]), chartObj.accDataLabelRegion[1]);
                        }
                    }

                    else if (!enableWrap && !isOverlapped) {
                        seriesType.dataLabelSymbol(seriesIndex, currentseries, point.index, positionX, positionY, textWidth, textHeight, symbolName, chartObj);
                        chartObj.svgRenderer.drawText(textOptions, commonEventArgs.data.text, chartObj.gSeriesTextEle[seriesIndex]);
                    }

                    if (enableWrap) {
                        var labelTextSize = measureText(labelText, null, labelfont), maxWidth, collection, padding = 5;
                        collection = this.updateWrappedText(textOptions, labelText, labelTextSize, point, type, startX, startY, radius, chartModel.innerRadius[seriesIndex], _labelPosition, dataLabel, (connectorType == "bezier") ? (currentseries._enableSmartLabels ? (!isNull(position.bezierPath) ? position.bezierPath.points : "") : position.points) : connectorDirection);
                        datalabelText = collection.text;
                        textOptions.x = parseFloat(collection.x); textOptions.y = parseFloat(collection.y);
                        if (datalabelText != "" && !isOverlapped) {
                            var x = (textOptions['text-anchor'] == 'start') ? parseFloat(textOptions.x + collection.width / 2) : (isNull(connectorDirection) || connectorDirection == "") ? parseFloat(textOptions.x) : parseFloat(textOptions.x - collection.width / 2);
                            seriesType.dataLabelSymbol(seriesIndex, currentseries, pointIndex, x, textOptions.y + collection.height / 2 - labelTextSize.height / 2 - padding, collection.width, collection.height, symbolName, chartObj);
                        }
                        if (!isNull(connectorDirection) && connectorDirection != "") {
                            var pyrX, pyrY;
                            if (type == "funnel" || type == "pyramid") {
                                pyrX = ((chartModel.enableCanvasRendering) ? this.chartObj.pyrX : 0);
                                pyrY = ((chartModel.enableCanvasRendering) ? this.chartObj.pyrY : 0);
                            }
                            var connectorSegments = connectorDirection.split(" "), connectorLength = (_labelPosition == "outsideextended" && (type == "pie" || type == "doughnut")) ? connectorSegments.length - 2 : connectorSegments.length;
                            connectorSegments[connectorLength - 1] = textOptions.y - pyrY + (collection.height / 2 - labelTextSize.height);//canvas connector line issue fix
                            connectorSegments[connectorLength - 2] = textOptions.x - pyrX;//canvas connector line issue fix
                            connectorDirection = connectorSegments.toString().replace(/,/g, " ");
                        }
                        connectorDirection = (collection.exceed == false) ? "" : connectorDirection;

                        if ((chartModel.enableCanvasRendering || this.chartObj.vmlRendering) && (typeof datalabelText == "object") && !isOverlapped) {
                            for (var txt = 0, tempY = textOptions.y, tempX = textOptions.x; txt < datalabelText.length; txt++) {
                                textOptions.y = parseFloat(tempY) + ((txt) * textsize.height);
                                textOptions.x = tempX;
                                chartObj.svgRenderer.drawText(textOptions, datalabelText[txt], chartObj.gSeriesTextEle[seriesIndex]);
                            }
                        }
                        else if(!isOverlapped){
                            chartObj.svgRenderer.drawText(textOptions, datalabelText, chartObj.gSeriesTextEle[seriesIndex]);
                        }
                    }
                }
                if ((type == "pyramid" || type == "funnel") && dataLabel.template && currentseries._enableSmartLabels) {
                    position = seriesType.updateSmartLabel(sender, currentseries, pointIndex, point);
                    positionX = position.xPos;
                    positionY = position.yPos;
                    connectorDirection = position.connectorDirection;

                }
                var translate = [];
                translate[0] = pyrX;
                translate[1] = pyrY;
                if ((connectorType != 'bezier' || chartObj.vmlRendering || (type == "pyramid" || type == "funnel")) && (connectorDirection != '')) {
                    if (connectorDirection) {
                        var connectorOptions = {
                            'id': chartObj.svgObject.id + "_connectorLine_series" + seriesIndex + "_point_" + pointIndex,
                            'stroke': (connectorLine.color) ? connectorLine.color : pointColor,
                            'stroke-width': connectorLine.width,
                            'd': connectorDirection
                        };
                        chartObj.svgRenderer.drawPath(connectorOptions, chartObj.gConnectorEle[seriesIndex], translate);
                    }
                }
            }
        },

        _overlapLegend: function (textOptions, datalabelText, chart, seriesIndex) {

            var svgHeight = $(chart.svgObject).height(),
                svgWidth = $(chart.svgObject).width(),
                legendBounds = chart.model.LegendActualBounds,
                elementSpacing = chart.model.elementSpacing,
                margin = chart.model.series[seriesIndex].marker.dataLabel.margin,
                shape = chart.model.series[seriesIndex].marker.dataLabel.shape,
                top = shape != 'none' ? margin.top : 0,
                bottom = shape != 'none' ? margin.bottom : 0,
                textHeight = sf.EjSvgRender.utils._measureText((datalabelText, null, textOptions)).height,
                dataLabelEndPos = textOptions.y + textHeight + bottom,
                dataLabelTopPos = textOptions.y - top,
                legendPosition = chart.model.legend.position.toLowerCase(),
                title = chart.model.title,
                subTitle = title.subTitle,
                margin = chart.model.margin,
                borderSize = chart.model.border.width,
                modelsubTitleHeight = subTitle.text == "" ? 0 : sf.EjSvgRender.utils._measureText(subTitle.text, svgWidth - margin.left - margin.right, subTitle.font).height + elementSpacing,
                titleLocation = chart.model._titleLocation ? chart.model._titleLocation.Y : 0 + modelsubTitleHeight,
                text = datalabelText, legendPosY;


            if (legendPosition == 'bottom') {
                legendPosY = svgHeight - chart.model.LegendActualBounds.Height - elementSpacing;
                text = dataLabelEndPos > legendPosY ? '' : text;
            } else {
                legendPosY = titleLocation == 0 ? borderSize + elementSpacing : titleLocation + elementSpacing;
                text = dataLabelTopPos < (legendPosY + legendBounds.Height) ? '' : text;
            }
            if (dataLabelEndPos > svgHeight)
                text = '';
            return text;

        },

        updateWrappedText: function (textOptions, labelText, textSize, currentPoint, seriesType, centerX, centerY, radius, innerRadius, labelPlacement, dataLabel, connector) {
            var chartObj = this.chartObj,
                point = currentPoint,
                previousBoundary = {},
                textWidth = textSize.width,
                textHeight = textSize.height,
                wrapTrim, maxWidth, wrapText, firstSegment,
                text, arrayText,
                textPosX = textOptions.x,
                textPosY = textOptions.y,
                segmentHeight,
                segmentWidth,
                midX = textPosX,
                exceed = true,
                areaSpace = chartObj.model.m_AreaBounds.X,
                midY = textPosY,
                connectorPoints,
                txtLength,
                textX, textY;
            if (!sf.util.isNullOrUndefined(connector) && connector != "") {
                if (typeof connector == "object") {
                    textX = connector.X;
                    textY = connector.Y;
                }
                else {
                    connectorPoints = connector.split(" "),
                        txtLength = (labelPlacement == "outsideextended") ? (connectorPoints.length - 2) : (dataLabel.connectorLine.type.toLowerCase() == "bezier") ? connectorPoints.length - 2 : connectorPoints.length;
                    if (connectorPoints[txtLength - 1].indexOf(",") > -1) {
                        var tempXY = connectorPoints[txtLength].split(",");
                        textX = tempXY[0];
                        textY = tempXY[1];
                    }
                    else {
                        textX = connectorPoints[txtLength - 2];
                        textY = connectorPoints[txtLength - 1];
                    }
                }
            }
            if (seriesType == 'pie' || seriesType == 'doughnut') {
                if (labelPlacement == "inside") {
                    var innerRadius = (sf.util.isNullOrUndefined(innerRadius)) ? 0 : innerRadius,
                        chartStartingAngle = -.5 * Math.PI,
                        startAngle = point.startAngle + chartStartingAngle,
                        endAngle = point.endAngle + chartStartingAngle,
                        midAngleRadian = point.midAngle + chartStartingAngle,
                        midAngle = ((180 / Math.PI) * midAngleRadian) % 360,
                        startANG = ((180 / Math.PI) * startAngle) % 360,
                        endANG = ((180 / Math.PI) * endAngle) % 360,
                        radiusTextPosPercentage = (seriesType == "doughnut") ? 0.75 : 0.5;
                    midX = this.getXCordinate(centerX, (radius * radiusTextPosPercentage), midAngleRadian);
                    midY = this.getYCordinate(centerY, (radius * radiusTextPosPercentage), midAngleRadian);
                    var startPointX = this.getXCordinate(centerX, (radius), startAngle),
                        startPointY = this.getYCordinate(centerY, (radius), startAngle),
                        endPointX = this.getXCordinate(centerX, (radius), endAngle),
                        endPointY = this.getYCordinate(centerY, (radius), endAngle),
                        midPointX = this.getXCordinate(centerX, (radius), midAngleRadian),
                        midPointY = this.getYCordinate(centerY, (radius), midAngleRadian),
                        innerCenterX = this.getXCordinate(centerX, innerRadius, midAngleRadian),
                        innerCenterY = this.getYCordinate(centerY, innerRadius, midAngleRadian),
                        segmentBounds = this.getSegementMinMax([startPointX, endPointX, (seriesType == "doughnut") ? innerCenterX : centerX, midPointX], [startPointY, endPointY, (seriesType == "doughnut") ? innerCenterY : centerY, midPointY]);
                    segmentBounds.width = (segmentBounds.height > radius) ? segmentBounds.height : segmentBounds.width;
                    segmentWidth = segmentBounds.width * 0.75;
                }
                else if (((labelPlacement == "outside" || labelPlacement == "outsideextended") && (seriesType == 'pie' || seriesType == 'doughnut')) && connector != "") {
                    var areabounds = chartObj.model.m_AreaBounds,
                        areaStartX = areaSpace,
                        areaEndX = chartObj.svgWidth - areaSpace;
                    segmentWidth = (textX <= centerX) ? (textX - areaStartX) : (areaEndX - textX);
                    midX = textX;
                    midY = textY;
                }
            }
            else {
                var svgWidth = chartObj.svgWidth;
                if (labelPlacement == "outside") {
                    segmentWidth = svgWidth - (textX);
                }
                else {
                    segmentWidth = point.width;
                    var insidenooverap = chartObj.isPointInPolygon(point.Polygon, { x: midX + textWidth, y: midY });
                    if (!insidenooverap) {
                        segmentWidth = ((seriesType == "funnel") ? (point.Polygon[3].x - point.Polygon[4].x) : (point.Polygon[1].x - point.Polygon[0].x));
                        segmentHeight = point.Polygon[3].y - point.Polygon[0].y;
                        var changedHeight = Math.round(textWidth / segmentWidth) * textHeight, padding = 5,
                            exceed = ((changedHeight >= (segmentHeight - (2 * padding))) || (segmentWidth <= 50)) ? true : false;
                        if (!exceed) {
                            textOptions["text-anchor"] = "middle";
                            midX = ((seriesType == "funnel") ? point.Polygon[4].x : point.Polygon[0].x) + (segmentWidth / 2) + ((chartObj.model.enableCanvasRendering) ? chartObj.pyrX : 0);
                            midY = ((point.Polygon[0].y + point.Polygon[3].y) / 2) - (changedHeight / 2) + ((chartObj.model.enableCanvasRendering) ? chartObj.pyrY : 0);
                            point._labelPlacement = "insidenooverlap";
                        }
                        else {
                            segmentWidth = svgWidth - midX - areaSpace;
                        }
                    }
                }
            }
            if (labelPlacement == "inside" || (connector != "" || !sf.util.isNullOrUndefined(connector))) {
                maxWidth = (dataLabel.maximumLabelWidth != null) ? dataLabel.maximumLabelWidth : parseFloat(segmentWidth);
                text = labelText;
                wrapText = chartObj._rowsCalculation({ text: text.toString(), font: dataLabel.font }, maxWidth, wrapTrim);
                text = wrapText.textCollection;
                arrayText = $.extend([], text);
                for (var i = 0, temp; i < arrayText.length - 1; i++) {
                    arrayText[i + 1] = arrayText[i].concat("<br/>", arrayText[i + 1]);
                }
                arrayText = arrayText[arrayText.length - 1];
            }
            else {
                text = "";
            }
            var changedText = sf.EjSvgRender.utils._measureText(arrayText, segmentWidth, dataLabel.font);
            changedText.height += (textHeight / 2);// size differing canvas and svg space between new line text more 
            if ((seriesType == "pie" || seriesType == "doughnut") && (labelPlacement == "inside")) {
                midY = midY - (changedText.height / 2) + (textHeight / 2);
                text = (changedText.height > (segmentBounds.height)) ? "" : text;
                text = (changedText.width > (segmentBounds.width)) ? "" : text;
                if (text == "") {
                    changedText.width = 0; changedText.height = 0;
                }
            }
            previousBoundary = (this.currentBoundary == 'undefined') ? "undefined" : this.currentBoundary;
            this.currentBoundary = ({ X: midX - (changedText.width / 2), Y: parseFloat(midY), Height: changedText.height, Width: changedText.width });
            if (!!previousBoundary && (point._labelPlacement != "insidenooverlap")) {
                var overlap = this.checkOverlapping(chartObj, this.currentBoundary, previousBoundary, seriesType, text, firstSegment, midAngle, labelPlacement, { startAngle: startAngle, endAngle: endAngle, radius: radius, centerX: centerX, centerY: centerY });

                if (overlap[1] && (overlap[2] != "")) {
                    previousBoundary = overlap[0];
                    midX = previousBoundary.X + (previousBoundary.Width / 2);
                    midY = previousBoundary.Y;
                    text = overlap[2];
                    changedText.height = overlap[0].Height;
                    changedText.width = overlap[0].Width;
                }
                else {
                    text = overlap[2];
                }
            }
            else {
                firstSegment = this.currentBoundary;

            }
            exceed = (text == "") ? false : exceed;
            this.currentBoundary = (text == "") ? previousBoundary : this.currentBoundary;
            return { text: text, x: midX, y: midY, exceed: exceed, height: changedText.height, width: changedText.width };
        },
        checkOverlapping: function (chartObj, current, previous, seriesType, text, firstSegment, midAngle, labelPlacement, segmentBounds) {
            var gap = 10, overlap = false, textOverlap, xOverlap, yOverlap;
            textOverlap = this.getOverlapArea(current, previous);
            overlap = textOverlap.overlap;
            xOverlap = textOverlap.xOverlap;
            yOverlap = textOverlap.yOverlap;
            if (overlap) {
                if (seriesType == "pie" || seriesType == "doughnut") {
                    if (labelPlacement.toLowerCase() == "inside") {
                        var minDiff = (xOverlap >= yOverlap) ? "Y" : "X",
                            flag;
                        if (minDiff == "X") {
                            flag = (midAngle > 0 && midAngle < 180) ? -1 : 1;
                            current.X += flag * (xOverlap + gap);
                        }
                        else {
                            flag = (midAngle > 90 && midAngle < 270) ? -1 : 1
                            current.Y += (flag) * (yOverlap + gap);
                        }

                    }
                    else {
                        current.Y -= (yOverlap + gap);
                    }
                }
                else if (seriesType == "funnel") {
                    current.Y = (previous.Y - current.Height - gap);
                }
                else {
                    current.Y = (previous.Y + previous.Height + gap);
                }
            }
            if ((seriesType == "pie" || seriesType == "doughnut" || seriesType == "pieofpie") && labelPlacement.toLowerCase() == "inside") {
                textOverlap = this.getOverlapArea(current, firstSegment);
                text = (textOverlap.overlap == true) ? "" : text;
                overlap = (textOverlap.overlap == true) ? true : overlap;
                var labelexceeding = this.checkSegmentExceeding(current, segmentBounds);
                text = (!labelexceeding) ? "" : text;
            }
            else if (seriesType == "funnel") {
                if ((current.Y + current.Height) >= previous.Y) {
                    text = "";
                }
            }
            else if (seriesType == "pyramid") {
                if ((current.Y + current.Height) <= (previous.Y + previous.Height)) {
                    text = "";
                }
            }
            var areaBounds = chartObj.model.m_AreaBounds;
            return [{ X: current.X, Y: current.Y, Height: current.Height, Width: current.Width }, overlap, text];
        },
        getOverlapArea: function (firstTextSegment, lastTextSegment) {
            var xOverlap = Math.max(0, Math.min((firstTextSegment.X + firstTextSegment.Width), (lastTextSegment.X + lastTextSegment.Width)) - Math.max(firstTextSegment.X, lastTextSegment.X)),
                yOverlap = Math.max(0, Math.min((firstTextSegment.Y + firstTextSegment.Height), (lastTextSegment.Y + lastTextSegment.Height)) - Math.max(firstTextSegment.Y, lastTextSegment.Y)),
                overlapArea = xOverlap * yOverlap,
            overlap = (overlapArea > 0) ? true : false;
            return { overlap: overlap, xOverlap: xOverlap, yOverlap: yOverlap };
        },
        getSegementMinMax: function (xArray, yArray) {
            var minX, maxX, minY, maxY, width, height;
            xArray.sort(function (a, b) { return a - b; });
            yArray.sort(function (a, b) { return a - b; });
            minX = xArray[0]; maxX = xArray[3]; minY = yArray[0]; maxY = yArray[3];
            width = maxX - minX;
            height = maxY - minY;
            return { minX: minX, maxX: maxX, minY: minY, maxY: maxY, width: width, height: height };
        },
        checkSegmentExceeding: function (textBounds, limits) {
            var inside = false, midPointX = textBounds.X + (textBounds.Width / 2), midPointY = textBounds.Y + (textBounds.Height / 2);
            var dx = midPointX - limits.centerX, dy = midPointY - limits.centerY, angle = Math.atan2(dy, dx), pointRadius = Math.abs(Math.sqrt(dx * dx + dy * dy));
            if (pointRadius <= limits.radius) {
                var PI = 2 * Math.PI;
                angle = (angle < 0) ? (PI + angle) : angle;
                limits.startAngle = (limits.startAngle < 0) ? (PI + limits.startAngle) : limits.startAngle;
                limits.endAngle = (limits.endAngle < 0) ? (PI + limits.endAngle) : limits.endAngle;
                if (angle <= limits.endAngle && angle >= limits.startAngle) {
                    inside = true;
                }
                else if ((angle <= PI && angle >= limits.startAngle && limits.endAngle < limits.startAngle) || (angle > 0 && angle <= limits.endAngle && limits.startAngle > limits.endAngle)) {
                    inside = true;
                }
            }
            return inside;
        },
        drawBezierSegment: function (controlpoints, currentseries, pointIndex, sender, seriesIndex) {
            //currentseries.points[pointIndex].marker = currentseries.points[pointIndex].marker ? currentseries.points[pointIndex].marker : {};
            //var marker = $.extend(true, {}, currentseries.marker, currentseries.points[pointIndex].marker);
            var polyLine = sf.EjSvgRender.utils._getStringBuilder();
            var seriesType = new sf.seriesTypes[currentseries.type.toLowerCase()]();
            for (var i = 0; i <= 16; i++) {
                var t = i / 16;
                var points = seriesType.GetBezierPoint(t, controlpoints, 0, controlpoints.length, currentseries);
                polyLine.append(points.X + "," + points.Y + " ");
            }
            var connectorOptions = {
                'id': sender.svgObject.id + "_bezierLine_series" + seriesIndex + "_point" + pointIndex,
                'stroke': (currentseries.marker.dataLabel.connectorLine.color) ? currentseries.marker.dataLabel.connectorLine.color : sender.model.pointColors[pointIndex],
                'stroke-width': currentseries.marker.dataLabel.connectorLine.width,
                'fill': 'none',
                'points': polyLine.toString()
            };
            if (!currentseries._enableSmartLabels)
                sender.svgRenderer.drawPolyline(connectorOptions, sender.gConnectorEle);
            else
                return connectorOptions;
        },
        GetBezierPoint: function (t, controlPoints, index, count, currentseries) {
            var seriesType = new sf.seriesTypes[currentseries.type.toLowerCase()]();
            if (count == 1)
                return controlPoints[index];
            var p0 = seriesType.GetBezierPoint(t, controlPoints, index, count - 1, currentseries);
            var p1 = seriesType.GetBezierPoint(t, controlPoints, index + 1, count - 1, currentseries);
            var x = (p0.X) ? p0.X : p0.x;
            var y = (p0.Y) ? p0.Y : p0.y;
            var x1 = (p1.X) ? p1.X : p1.x;
            var y1 = (p1.Y) ? p1.Y : p1.y;
            var X = (1 - t) * x + t * x1;
            var Y = (1 - t) * y + t * y1;
            if (p0.x)
                return { x: X, y: Y }
            else
                return { X: X, Y: Y };;



            // return new Point((1 - t) * p0.X + t * p1.X, (1 - t) * p0.Y + t * p1.Y);
        },

        drawLabelTemplate: function (series, point, pointIndex, location, sender) {
            // method for data label template
            if (sender)
                this.chartObj = sender;
            var areaBoundsX = this.chartObj.model.m_AreaBounds.X;
            var areaBoundsY = this.chartObj.model.m_AreaBounds.Y;
            var areaBoundsWidth = this.chartObj.model.m_AreaBounds.Width;
            var areaBoundsHeight = this.chartObj.model.m_AreaBounds.Height;
            var seriesIndex = $.inArray(series, this.chartObj.model._visibleSeries);
            var areaType = this.chartObj.model.AreaType;
            var currentSeries = this.chartObj.model.series[seriesIndex];
            var xPosition = 0, yPosition = 0;
            var chartContainer = this.chartObj._id;
            var marker = $.extend(true, {}, series.marker, point.marker);
            var style = { 'interior': marker.dataLabel.fill, 'opacity': marker.dataLabel.opacity, 'borderColor': marker.dataLabel.border.color, 'borderWidth': marker.dataLabel.border.width };
            var color, width, height;
            var type = this.chartObj.model.chartRegions[pointIndex] ? this.chartObj.model.chartRegions[pointIndex].type : "";
            if (areaType != "none" || this.chartObj.model.enable3D) {

                if ($('#template_group_' + chartContainer).length != 0)
                    var templateContainer = $('#template_group_' + chartContainer);
                else
                    templateContainer = $("<div></div>").attr('id', "template_group_" + chartContainer);

                templateContainer.css('position', 'relative').css('z-index', 1000);
                if ($("#" + marker.dataLabel.template).length == 0) // To check the specified div is in DOM
                    return;
                else
                    var cloneNode = $("#" + marker.dataLabel.template).clone();
                $(cloneNode).attr("id", marker.dataLabel.template + '_' + seriesIndex + '_' + pointIndex + '_' + chartContainer);
                var $cloneNode = $(cloneNode);
                $cloneNode.css("position", "absolute");

                var pointX = point.x;
                point.dataLabeltemplate = true;
                point.id = marker.dataLabel.template + '_' + seriesIndex + '_' + pointIndex + '_' + chartContainer;
                if (series.xAxis._valueType.indexOf("datetime") > -1)
                    point.x = (sf.format(new Date(point.xValue), ((sf.util.isNullOrUndefined(series.xAxis.labelFormat)) ? (series.xAxis._valueType == "datetime" ? sf.EjSvgRender.utils._dateTimeLabelFormat(series.xAxis._intervalType, series.xAxis) : sf.EjSvgRender.utils._dateTimeLabelFormat(series.xAxis.intervalType, series.xAxis)) : series.xAxis.labelFormat), this.chartObj.model.locale));
                if (series.xAxis._valueType.toLowerCase() == "category")
                    point.x = sf.EjSvgRender.utils._getLabelContent(pointIndex, series.xAxis, this.chartObj.model.locale);

                point.count = 1;
                var data = { series: series, point: point };
                $cloneNode.html($cloneNode.html().parseTemplate(data));

                point.x = pointX;
                var display = (areaType == "cartesianaxes" || !series.enableAnimation || (series.type.toLowerCase() == "pyramid" || series.type.toLowerCase() == "funnel")) ? "block" : "none";
                $cloneNode.css("display", display).appendTo($(templateContainer));
                //template_group_container Div appended in chartcontainer_container Div 
                $(templateContainer).appendTo('#' + 'chartContainer_' + chartContainer);
                var areaBound = this.chartObj.model.m_AreaBounds;
                if (areaType == "cartesianaxes" && !this.chartObj.model.enable3D) {
                    xPosition = areaBound.X + (this.chartObj.model.requireInvertedAxes ? currentSeries.yAxis.plotOffset : currentSeries.xAxis.plotOffset);
                    yPosition = currentSeries.yAxis.y;
                }
                width = $cloneNode.width() / 2;
                height = $cloneNode.height();
                if (sf.util.isNullOrUndefined(style) && style.interior)
                    color = style.interior;
                else
                    color = (areaType == "none") ? this.chartObj.model.pointColors[pointIndex] : this.chartObj.model.seriesColors[seriesIndex];
            }
            else {
                if (sf.util.isNullOrUndefined(style) && style.interior)
                    color = style.interior;
                else
                    color = this.chartObj.model.pointColors[pointIndex];
                width = this.chartObj.model.circleCenterX[seriesIndex] > location.X ? point.size.width : 0;
                $cloneNode = $('#template_group_' + chartContainer).find("#" + marker.dataLabel.template + '_' + seriesIndex + '_' + pointIndex + '_' + chartContainer);
                point.id = marker.dataLabel.template + '_' + seriesIndex + '_' + pointIndex + '_' + chartContainer;
                height = (!this.chartObj.model.enable3D) ? point.size.height / 2 : 0;
            }

            if (currentSeries.type == 'hilo' || currentSeries.type == 'hiloopenclose' || currentSeries.type == 'candle')
                color = currentSeries._visiblePoints[pointIndex]._hiloFill;
            color = jQuery.type(color) == "array" ? color[0].color : color;


            if (currentSeries.type.indexOf("bar") != -1) {
                var left = location.X + xPosition - width;
                var top = location.Y + ((!this.chartObj.model.enable3D) ? areaBound.Y : 0) - height + currentSeries.xAxis.plotOffset;
                var right = location.X + xPosition + width;
            } else {
                var left = location.X + xPosition - width;
                var top = yPosition + location.Y - height;
                var right = location.X + xPosition + width;
            }
            var backgroundColor = $cloneNode[0].style.backgroundColor;
            $cloneNode.css("left", left).css("top", top).css("background-color", (backgroundColor != '' ? backgroundColor : color)).css("display", "block").css("cursor", "default");

            if (this.chartObj.model.AreaType != "cartesianaxes") {
                point.xPos = left - this.chartObj.pyrX;
                point.yPos = top - this.chartObj.pyrY;
                point.textOptionsacc = { x: left - this.chartObj.pyrX, y: top - this.chartObj.pyrY };
            }
            else {
                if (point.y == point.low) {
                    point.xPosLow = left;
                    point.yPosLow = top;
                    point.textOptionsLow = { x: left, y: top };
                    point.dataLabelLow = { textX: left, textY: top, x: left, y: top };
                }
                else {
                    point.xPos = left;
                    point.yPos = top;
                    point.seriesIndex = seriesIndex;
                    point.textOptions = { x: left, y: top };
                    point.dataLabel = { textX: left, textY: top, x: left, y: top };
                    point.margin = { top: 0, bottom: 0, left: 0, right: 0 };
                }
            }
            point.height = $cloneNode.outerHeight();
            point.width = $cloneNode.outerWidth();
            var topHeight, leftWidth, rightWidth;
            topHeight = leftWidth = rightWidth = 0;
            var bottomHeight = 0;
            if (areaType == "cartesianaxes") {
                if ((left > xPosition + areaBound.Width || top + height > areaBound.Y + areaBound.Height) || ((left < xPosition || top < yPosition || left > xPosition + areaBound.Width || top > yPosition + areaBound.Height || right > areaBound.Width + areaBound.X))) {
                    width = $cloneNode.outerWidth();
                    if (left < areaBoundsX) {
                        leftWidth = areaBoundsX - left;
                    }
                    if (areaBoundsHeight + areaBoundsY < top + height) {
                        var excessHeight = (top + height) - (areaBoundsHeight + areaBoundsY);
                        bottomHeight = height - excessHeight;
                    }
                    if (top < areaBoundsY) {
                        topHeight = areaBoundsY - top;
                    }
                    if (areaBoundsWidth + areaBoundsX < left + width) {
                        var excessWidth = (left + width) - (areaBoundsWidth + areaBoundsX);
                        rightWidth = width - excessWidth;
                    }
                    rightWidth = (rightWidth == 0) ? width : rightWidth;
                    bottomHeight = (bottomHeight == 0) ? height : bottomHeight;
                    if (!currentSeries.marker.dataLabel.showEdgeLabels) {
                        document.getElementById($cloneNode[0].id).style.clip = "rect(" + topHeight + "px," +
                            rightWidth + "px," +
                            bottomHeight + "px," +
                            leftWidth + "px)";
                    }
                }
            }
        },

        animateLabelTemplate: function (options) {
            // method to animate data label template
            var seriesIndex = $.inArray(options, this.chartObj.model._visibleSeries);
            var length = options._visiblePoints.length;
            var secondsPerPoint = 1000;

            for (var i = 0; i < length; i++) {
                var ele = options.marker.dataLabel.template + '_' + seriesIndex + '_' + i + '_' + this.chartObj._id;
                ele = $('#' + ele);
                ele.css("display", "none");
                ele.delay(secondsPerPoint).fadeIn(300);
            }
        },

        textPosition: function (series, seriesIndex, point, textOffset, type, x, y, chartRegionIndex, index, params, textPosition) {
            var marker = $.extend(true, {}, series.marker, point.marker),
                dataLabel = marker.dataLabel,
                isRTL = dataLabel.isReversed,
                horizontalTextAlignment = dataLabel.horizontalTextAlignment.toLowerCase(),
                verticalTextAlignment = dataLabel.verticalTextAlignment.toLowerCase(),
                visiblePointLength = series._visiblePoints.length,
                seriesPointIndex = chartRegionIndex,
                lineHeight = 10,
                padding = 3,
                margin = dataLabel.margin,
                isYInversed = series.yAxis.isInversed,
                xOrigin = this.chartObj._getXCrossValue(series, series.xAxis, params);
            var seriesType = (type.indexOf("bar") != -1 || (type.indexOf("column") != -1 && type != "rangecolumn")) ? (this.chartObj.model.requireInvertedAxes) ? "bar" : "column" : type;
            if (seriesType == 'column' || seriesType == 'stackingcolumn' || seriesType == 'stackingcolumn100') {
                var bounds = this.chartObj.model.chartRegions[seriesPointIndex].Region.Bounds,
                    originChanged = params.axes[series.xAxis.name]._validCross || false;
                pointHeight = bounds.Height,
                    pointWidth = bounds.Width;

                if (!originChanged) {
                    if (textPosition == "bottom") {
                        if ((point.y >= xOrigin && !series.yAxis.isInversed) || (point.y < xOrigin && series.yAxis.isInversed))
                            y = y + pointHeight - margin.bottom;
                        else
                            y = textOffset.height + margin.bottom;
                    } else if (textPosition == "middle") {
                        if ((point.y > xOrigin && !series.yAxis.isInversed) || (point.y < xOrigin && series.yAxis.isInversed))
                            y += pointHeight / 2 + (textOffset.height) / 4;
                        else
                            y -= pointHeight / 2;
                    }
                    else {
                        if ((point.y > xOrigin && series.yAxis.isInversed) || (point.y < xOrigin && !series.yAxis.isInversed))
                            y += lineHeight;
                        else
                            y -= lineHeight;
                    }
                }
                else {
                    var origin = Math.abs((isYInversed ? series.yAxis.visibleRange.min : series.yAxis.visibleRange.max) - xOrigin) / series.yAxis.visibleRange.delta * series.yAxis.height;
                    if (textPosition == "bottom") {
                        if (y <= origin)
                            y = y + pointHeight - margin.bottom;
                        else
                            y = y - pointHeight + textOffset.height - margin.bottom;
                    } else if (textPosition == "middle") {
                        if (y < origin)
                            y += pointHeight / 2 + (textOffset.height) / 4;
                        else
                            y -= pointHeight / 2;
                    }
                    else {
                        if ((y < origin && isYInversed) || (y < origin && !isYInversed))
                            y -= (lineHeight + (2 * textOffset.height) / 2);
                        else
                            y += (lineHeight + (2 * textOffset.height) / 2);
                    }
                }

                if (horizontalTextAlignment && horizontalTextAlignment == "far")
                    x = isRTL ? x - pointWidth / 2 : x + pointWidth / 2;
                else if (horizontalTextAlignment && horizontalTextAlignment == "near")
                    x = isRTL ? x + pointWidth / 2 : x - pointWidth / 2;

                if (verticalTextAlignment && verticalTextAlignment == "near") {
                    if (textPosition == "bottom")
                        y += lineHeight;
                    else
                        y += lineHeight - padding;
                }
                else if (verticalTextAlignment && verticalTextAlignment == "far") {
                    if (textPosition == "bottom")
                        y -= lineHeight;
                    else
                        y -= lineHeight;
                }
            }

            else if (seriesType.indexOf("bar") != -1) {
                var bounds = this.chartObj.model.chartRegions[seriesPointIndex].Region.Bounds,
                    pointWidth = bounds.Width,
                    originChanged = params.axes[series.xAxis.name]._validCross || false,
                    pointHeight = bounds.Height;
                y = y + textOffset.height / 4;
                if (!originChanged) {
                    if (textPosition == "bottom") {
                        if ((point.y >= 0 && !series.yAxis.isInversed) || (point.y < 0 && series.yAxis.isInversed))
                            x = (seriesType.indexOf("stacking") == -1 && seriesIndex > 0) ? x - pointWidth + textOffset.width / 2 : margin.left + textOffset.width / 4;
                        else
                            x += (pointWidth - textOffset.height - margin.right);
                    } else if (textPosition == "middle") {
                        if ((point.y > 0 && !series.yAxis.isInversed) || (point.y < 0 && series.yAxis.isInversed))
                            x -= pointWidth / 2 + textOffset.width / 2;
                        else
                            x += pointWidth / 2;
                    } else {
                        if ((point.y >= 0 && !series.yAxis.isInversed) || (point.y < 0 && series.yAxis.isInversed))
                            x += textOffset.width / 4 + lineHeight;
                        else
                            x -= textOffset.width / 4 + lineHeight;
                    }
                }
                else {
                    var yOrigin = series.xAxis._crossValue || 0,
                        origin = Math.abs(isYInversed ? series.yAxis.visibleRange.max : series.yAxis.visibleRange.min - yOrigin) / series.yAxis.visibleRange.delta * series.yAxis.width;
                    if (textPosition == "bottom") {
                        if ((x < origin && !isYInversed) || (x >= origin && isYInversed))
                            x = x + pointWidth - textOffset.width;
                        else
                            x = x - pointWidth + margin.left;
                    } else if (textPosition == "middle") {
                        if ((x < origin && !isYInversed) || (x >= origin && isYInversed))
                            x = x + pointWidth / 2 - textOffset.width / 2;
                        else
                            x = x - pointWidth / 2 - textOffset.width / 2;
                    }
                    else {
                        if ((x < origin && !isYInversed) || (x >= origin && isYInversed))
                            x -= (lineHeight + (2 * textOffset.width) / 2);
                        else
                            x += (lineHeight + (2 * textOffset.width) / 2);
                    }
                }

                if (horizontalTextAlignment && horizontalTextAlignment == "far") {
                    if (textPosition == "bottom")
                        x += textOffset.width - textOffset.width / 4;
                    else
                        x += textOffset.width / 4 + lineHeight;
                }
                else if (horizontalTextAlignment && horizontalTextAlignment == "near") {
                    if (textPosition == "bottom")
                        x -= textOffset.width / 4;
                    else
                        x -= lineHeight - textOffset.width / 4 - padding;
                }
                else // for center
                    x += textOffset.width / 4;

                if (verticalTextAlignment && verticalTextAlignment == "near")
                    y += pointHeight / 2;
                else if (verticalTextAlignment && verticalTextAlignment == "far")
                    y -= pointHeight / 2;
            }
            else if (seriesType == "rangecolumn") {
                var bounds = this.chartObj.model.chartRegions[seriesPointIndex].Region.Bounds;
                var height = 0;
                var width = 0;
                if (point.high != point.y) {
                    height = bounds.Height;
                    width = bounds.Width;
                }
                if (this.chartObj.model.requireInvertedAxes) {
                    if (textPosition == "top")
                        x = x - width + (lineHeight + (2 * textOffset.width) / 2);
                    else if (textPosition == "bottom")
                        x = x - width - (2 * textOffset.width + lineHeight);
                    else if (textPosition == "middle")
                        x = x - width;
                }
                else {
                    if (textPosition == "top")
                        y += height - lineHeight;

                    else if (textPosition == "bottom")
                        y = y + height + (2 * textOffset.height + lineHeight);
                    else if (textPosition == "middle")
                        y = y + height;
                }
                if (horizontalTextAlignment && horizontalTextAlignment.toLowerCase() == "far")
                    x += bounds.Width / 2;
                else if (horizontalTextAlignment && horizontalTextAlignment.toLowerCase() == "near")
                    x -= bounds.Width / 2;
                if (verticalTextAlignment && verticalTextAlignment.toLowerCase() == "near")
                    y += lineHeight - padding;
                else if (verticalTextAlignment && verticalTextAlignment.toLowerCase() == "far")
                    y -= lineHeight;

            }

            else if (seriesType == "boxandwhisker") {
                var bounds = this.chartObj.model.chartRegions[seriesPointIndex].Region.Bounds;
                var height = 0;
                var width = 0;
                if (this.chartObj.model.requireInvertedAxes) {
                    if (textPosition == "top")
                        x = x - width + (lineHeight + (2 * textOffset.width) / 2);
                    else if (textPosition == "bottom")
                        x = x - width - (2 * textOffset.width + lineHeight);
                    else if (textPosition == "middle")
                        x = x - width;
                }
                else {
                    if (textPosition == "top")
                        y += height - padding;
                    else if (textPosition == "bottom")
                        //  y = y + height + (2 * textOffset.height + lineHeight);
                        y += height + lineHeight + (textOffset.width / 2);
                    else if (textPosition == "middle")
                        y += height + lineHeight;
                }
                if (horizontalTextAlignment && horizontalTextAlignment.toLowerCase() == "far")
                    x += 2 * textOffset.width;
                else if (horizontalTextAlignment && horizontalTextAlignment.toLowerCase() == "near")
                    x -= 2 * textOffset.width;

                if (verticalTextAlignment && verticalTextAlignment.toLowerCase() == "near")
                    y = (textPosition == "top") ? y + lineHeight : y - lineHeight;
                else if (verticalTextAlignment && verticalTextAlignment.toLowerCase() == "far")
                    y = (textPosition == "top") ? y - lineHeight : y + lineHeight;

            }

            else if (type == "waterfall") {
                var bounds = this.chartObj.model.chartRegions[seriesPointIndex].Region.Bounds,
                    pointHeight = bounds.Height,
                    pointWidth = bounds.Width;

                var isNegativePoint = point.waterfallSum < 0 || (!point.showIntermediateSum && !point.showTotalSum && point.y < 0);

                switch (textPosition) {
                    case "bottom":
                        if (!series.isTransposed) {
                            if (!series.yAxis.isInversed)
                                y = y + pointHeight - margin.bottom - (isNegativePoint ? pointHeight : 0);
                            else
                                y = y - textOffset.height + margin.bottom + (isNegativePoint ? pointHeight : 0);
                        } else {
                            if (!series.yAxis.isInversed)
                                x = x - pointWidth + (lineHeight + (2 * textOffset.height) / 2) + (isNegativePoint ? pointWidth : 0);
                            else
                                x = x + pointWidth - (lineHeight + (2 * textOffset.height) / 2) - (isNegativePoint ? pointWidth : 0);
                        }
                        break;

                    case "middle":
                        if (!series.isTransposed) {
                            if (!series.yAxis.isInversed)
                                y = y + (pointHeight / 2 + (textOffset.height) / 4) - (isNegativePoint ? pointHeight : 0);
                            else
                                y = y - (pointHeight / 2) + (isNegativePoint ? pointHeight : 0);
                        } else {
                            if (!series.yAxis.isInversed)
                                x = x - (pointWidth / 2 + (textOffset.width) / 4) + (isNegativePoint ? pointWidth : 0);
                            else
                                x = x + (pointWidth / 2) - (isNegativePoint ? pointWidth : 0);
                        }
                        break;

                    default:
                        if (!series.isTransposed) {
                            if (!series.yAxis.isInversed)
                                y = y - (lineHeight + (2 * textOffset.height) / 2) - (isNegativePoint ? pointHeight : 0);
                            else
                                y = y + (lineHeight + (2 * textOffset.height) / 2) + (isNegativePoint ? pointHeight : 0);
                        } else {
                            if (!series.yAxis.isInversed)
                                x = x + (lineHeight + (2 * textOffset.height) / 2) + (isNegativePoint ? pointWidth : 0);
                            else
                                x = x - (lineHeight + (2 * textOffset.height) / 2) - (isNegativePoint ? pointWidth : 0);
                        }
                }

                if (horizontalTextAlignment && horizontalTextAlignment == "far")
                    x += pointWidth / 2;
                else if (horizontalTextAlignment && horizontalTextAlignment == "near")
                    x -= pointWidth / 2;

                if (verticalTextAlignment && verticalTextAlignment == "near") {
                    if (textPosition == "bottom")
                        y += textOffset.height / 3;
                    else
                        y += (textOffset.height + lineHeight);
                }
                else if (verticalTextAlignment && verticalTextAlignment == "far") {
                    if (textPosition == "bottom")
                        y -= textOffset.height / 3;
                    else
                        y -= (lineHeight + (textOffset.height) / 2);
                }

            }
            else if (type == "polar" || type == "radar") {
                y += textOffset.height / 4;
                if (textPosition == "bottom")
                    y += (textOffset.height);
                else if (textPosition == "top")
                    y -= (textOffset.height);

                if (horizontalTextAlignment && horizontalTextAlignment == "far")
                    x += textOffset.width;
                else if (horizontalTextAlignment && horizontalTextAlignment == "near")
                    x -= (textOffset.width);

                if (verticalTextAlignment && verticalTextAlignment == "near")
                    y += (textOffset.height) / 2;
                else if (verticalTextAlignment && verticalTextAlignment == "far")
                    y -= ((textOffset.height) / 2);
            }
            else {
                if ((seriesType == "rangearea" || seriesType == "splinerangearea") && (point.high != point.y)) {
                    if (this.chartObj.model.series.length == 1) {
                        var length = this.chartObj.model.chartRegions[seriesIndex][index].region.length;
                        y = this.chartObj.model.chartRegions[seriesIndex][index].region[length - 1].Y;
                        x = this.chartObj.model.chartRegions[seriesIndex][index].region[length - 1].X;
                    }
                    else {
                        var precount = 0;
                        for (var a = 0; a < seriesIndex; a++) {
                            var pretype = this.chartObj.model.series[a].type;
                            if (pretype != "rangearea" && pretype != "splinerangearea")
                                precount = precount + this.chartObj.model.series[a].points.length;
                            else
                                precount = precount + 1;
                            if (this.chartObj.model.series[a].visibility == "hidden")
                                precount = 0;
                        }
                        var length = this.chartObj.model.chartRegions[precount][index].region.length;
                        y = this.chartObj.model.chartRegions[precount][index].region[length - 1].Y;
                        x = this.chartObj.model.chartRegions[precount][index].region[length - 1].X;
                    }


                }
                if (this.chartObj.model.requireInvertedAxes) {
                    if (textPosition == "top")
                        x += lineHeight;
                    else if (textPosition == "bottom")
                        x -= (lineHeight + (2 * textOffset.width) / 2);
                }
                else {
                    if (textPosition == "bottom") {
                        if (dataLabel.showEdgeLabels)
                            y += (2 * textOffset.height - lineHeight);
                        else
                            y += (2 * textOffset.height + lineHeight);
                    }
                    else if (textPosition == "top")
                        y -= lineHeight;
                }
                if (horizontalTextAlignment && horizontalTextAlignment == "far")
                    x += textOffset.width + lineHeight;
                else if (horizontalTextAlignment && horizontalTextAlignment == "near")
                    x -= ((textOffset.width) + lineHeight);

                if (verticalTextAlignment && verticalTextAlignment == "near")
                    y += lineHeight - padding;
                else if (verticalTextAlignment && verticalTextAlignment == "far")
                    y -= lineHeight;
                else {
                    if ((type == "bubble" || type == "scatter") && textPosition == "middle")
                        y += textOffset.height / 4;   // for placing the data label at the center of bubble
                }
            }
            var location = { x: x, y: y };
            return location;
        },




        changeCrossHairSymbol: function (element, track, ptIndex, serIndex, series) {
            var drawType = series.drawType;
            if (!sf.util.isNullOrUndefined(track)) {
                var trackMarker = {};
                element = $.extend(true, {}, series.marker, element);
                trackMarker = $.extend(true, {}, this.chartObj.model.crosshair.marker, trackMarker);
                var point = series.points[ptIndex], seriesType = series.type.toLowerCase();
                if (sf.util.isNullOrUndefined(trackMarker.shape)) {
                    trackMarker.shape = element.shape;
                    if (seriesType == 'bubble') {
                        trackMarker.border.color = ((point.border) && point.border.color) ? point.border.color : series.border.color;
                        trackMarker.border.width = ((point.border) && point.border.width) ? point.border.width : series.border.width;
                    }
                }

                if ((!this.chartObj.model.crosshair.visible || sf.util.isNullOrUndefined(trackMarker.fill)) && series.type.toLowerCase() != "bubble" && series.type.toLowerCase() != "scatter" && (drawType != "scatter")) {
                    if (trackMarker.shape.toLowerCase() == "cross" || trackMarker.shape.toLowerCase() == "horizline" || trackMarker.shape.toLowerCase() == "vertline")
                        trackMarker.fill = jQuery.type(this.chartObj.model.seriesColors[serIndex]) == "array" ? this.chartObj.model.seriesColors[serIndex][0].color : this.chartObj.model.seriesColors[serIndex];
                    else
                        trackMarker.fill = element.border.color;
                }
                if (series.type.toLowerCase() == "bubble" && !this.chartObj.model.enableCanvasRendering) {
                    var box = $(this.chartObj.gSeriesEle).find("#" + this.chartObj.svgObject.id + '_Series' + serIndex + '_Point' + ptIndex)[0].getBoundingClientRect();
                    trackMarker.size.width = (box.right - box.left) / 2 + 15;
                    trackMarker.size.height = (box.bottom - box.top) / 2 + 15;
                } else {
                    if (trackMarker.size.width <= element.size.width)
                        trackMarker.size.width = element.size.width + 2;
                    if (trackMarker.size.height <= element.size.height)
                        trackMarker.size.height = element.size.height + 2;

                    if (sf.util.isNullOrUndefined(trackMarker.border.color) || !this.chartObj.model.crosshair.visible) {
                        if (!sf.util.isNullOrUndefined(element.fill))
                            trackMarker.border.color = jQuery.type(element.fill) == "array" ? element.fill._gradientStop[0].color : element.fill;
                        else if (seriesType == 'scatter') {
                            trackMarker.border.color = ((point.border) && point.border.color) ? point.border.color : series.border.color;
                            trackMarker.border.width = ((point.border) && point.border.width) ? point.border.width : series.border.width;
                        }
                        else
                            trackMarker.border.color = (point.fill) ? point.fill : (jQuery.type(this.chartObj.model.seriesColors[serIndex]) == "array" ? this.chartObj.model.seriesColors[serIndex][0].color : this.chartObj.model.seriesColors[serIndex]);
                    }
                }
            }
            series._trackMarker = trackMarker;
            return trackMarker;


        },

        dataLabelSymbol: function (seriesIndex, series, pointIndex, x, y, width, height, symbolName, sender, group) {
            var chartObj = sender;
            if (symbolName == 'None')
                return;
            var point = chartObj.model._isPieOfPie ? sf.ejChart._getPieOfPiePoint(pointIndex, series) : series._visiblePoints[pointIndex];
            var location = { startX: x, startY: y };
            if (!sender.model.enable3D)
                var symbolEle = group ? group : chartObj.gDataLabelEle[seriesIndex];
            symbolEle = chartObj.model.enableCanvasRendering ? null : symbolEle;
            var element = $.extend(true, {}, series.marker, point.marker);
            var gradientName = "symbol";
            var style = { 'interior': element.dataLabel.fill, 'opacity': element.dataLabel.opacity, 'borderColor': element.dataLabel.border.color, 'borderWidth': element.dataLabel.border.width };
            var options = {
                'style': style,
                'gradientName': gradientName,
                'symbolEle': symbolEle,
                'width': width,
                'height': height,
                'point': point,
                'location': location,
                'seriesIndex': seriesIndex,
                'pointIndex': pointIndex,
                'element': element,
                'symbolName': symbolName,
                'id': chartObj.svgObject.id + '_dataLabel_series' + seriesIndex + "_" + pointIndex
            };
            this.drawSymbolStyle(options, chartObj);
        },

        drawSymbolStyle: function (options, sender) {
            var chartObj = sender;
            var borderColor, borderWidth, opacity;
            var style = options.style, gradientName = options.gradientName, symbolEle = options.symbolEle,
                width = options.width, dashArray = options.dashArray;
            var height = options.height, point = options.point, location = options.location,
                seriesIndex = options.seriesIndex, visibility = options.visibility;
            var pointIndex = options.pointIndex, element = options.element, symbolName = options.symbolName;
            var trackSymbol = options.trackSymbol;
            var isCanvas = chartObj.model.enableCanvasRendering;
            var isPolar = chartObj.model.AreaType == 'polaraxes';
            var series = chartObj.model.series[seriesIndex];

            if (style != null) {
                if (style.borderColor != "")
                    borderColor = style.borderColor ? style.borderColor : "transparent";

                opacity = style.opacity;
                borderWidth = style.borderWidth < 0 ? 0 : style.borderWidth;
            }
            var colors = null;
            if (style.interior) {
                colors = sf.util.isNullOrUndefined(style.interior._gradientStop) ? style.interior : style.interior._gradientStop;
            }
            else {
                if (point.fill)
                    colors = jQuery.type(point.fill) == "array" ? point.fill[0].color : point.fill;
                else {
                    var pointColors = chartObj.model.pointColors;
                    colors = (chartObj.model.AreaType != "none") ? ((series.type.toLowerCase() == "waterfall" && series.positiveFill && (point.y > 0 || point.waterfallSum > 0)) ? series.positiveFill :
                        chartObj.model.seriesColors[seriesIndex]) : jQuery.type(pointColors[pointIndex]) == "array" ? pointColors[pointIndex][0].color : pointColors[pointIndex];
                }
            }
            chartObj.symbolColorName = chartObj.svgRenderer.createGradientElement(gradientName + seriesIndex, colors, 0, 0, 0, $(chartObj.svgObject).height(), symbolEle);

            var symbolStyle = {
                dashArray: options.dashArray,
                ShapeSize: {
                    width: width,
                    height: height
                },
                Style: {
                    BorderColor: borderColor,
                    BorderWidth: borderWidth,
                    Opacity: opacity,
                    Visibility: visibility,
                    Color: chartObj.symbolColorName
                },
                PointIndex: pointIndex,
                SeriesIndex: seriesIndex,
                Imageurl: element.imageUrl,
                Image: element.image,
                ID: options.id
            };

            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { location: location, style: symbolStyle };
            chartObj._trigger("symbolRendering", commonEventArgs);
            if (!commonEventArgs.cancel) {
                if (isCanvas) {
                    //Added for Marker location while setting plotoffset value to axis
                    location.startY = (!chartObj.model.requireInvertedAxes) ? (location.startY + (series.yAxis.y ? (series.yAxis.y - chartObj.canvasY) : 0)) : location.startY;
                    location.startX = (!chartObj.model.requireInvertedAxes) ? (location.startX + (series.xAxis.x ? (series.xAxis.x - chartObj.canvasX) : 0)) : location.startX;

                    commonEventArgs.data.location.startY = location.startY;
                    if (sf.util.isNullOrUndefined(trackSymbol)) { // to draw marker/datalabel
                        if (chartObj.model.AreaType == "cartesianaxes") {
                            symbolEle = chartObj.svgRenderer.ctx;
                            chartObj.svgRenderer.ctx.save();
                            chartObj.svgRenderer.ctx.beginPath();
                            if (!chartObj.model.requireInvertedAxes)
                                chartObj.svgRenderer.ctx.rect(series.xAxis.x, series.yAxis.y, series.xAxis.width, series.yAxis.height);
                            else
                                chartObj.svgRenderer.ctx.rect(series.yAxis.x, series.xAxis.y, series.yAxis.width, series.xAxis.height);
                            chartObj.svgRenderer.ctx.clip();
                            sf.EjSvgRender.chartSymbol["_draw" + symbolName](commonEventArgs.data.location, commonEventArgs.data.style, chartObj, symbolEle);
                            chartObj.svgRenderer.ctx.restore();
                        }
                        else {
                            if (isCanvas && isPolar) {
                                chartObj.svgRenderer.ctx.save();
                                chartObj.svgRenderer.ctx.beginPath();
                                chartObj.svgRenderer.ctx.arc(chartObj.model.centerX, chartObj.model.centerY, chartObj.model.Radius, 0, 2 * Math.PI, false);
                                chartObj.svgRenderer.ctx.clip();
                            }
                            sf.EjSvgRender.chartSymbol["_draw" + symbolName](commonEventArgs.data.location, commonEventArgs.data.style, chartObj, symbolEle);
                            if (isCanvas && isPolar)
                                chartObj.svgRenderer.ctx.restore();
                        }

                    }
                    else {
                        var ptIndex = commonEventArgs.data.style.PointIndex;
                        var serIndex = commonEventArgs.data.style.SeriesIndex;
                        if (!chartObj.model.series[serIndex].highlightSettings.enable) {
                            if ($('#' + chartObj._id + '_selection_' + serIndex + '_' + ptIndex + '_canvas').length == 0)
                                chartObj.svgRenderer.trackSymbol(commonEventArgs.data.style, commonEventArgs.data.location, symbolName, trackSymbol, chartObj);
                        }
                    }
                }
                else {
                    var ptIndex = commonEventArgs.data.style.PointIndex;
                    var serIndex = commonEventArgs.data.style.SeriesIndex;
                    var type = series.type;
                    var className;
                    if (series.highlightSettings.enable && trackSymbol && !chartObj.model.crosshair.visible) {
                        var style = $.extend(true, commonEventArgs.data.style);
                        var highlight = series.highlightSettings;
                        style.Style.Color = (highlight.pattern.toLowerCase() == "none" || highlight.pattern == "") ? (highlight.color != "" ? highlight.color : style.Style.Color) : "url(#" + highlight.pattern.toLowerCase() + '_Highlight_2D_' + serIndex + ")";
                        style.Style.Opacity = highlight.opacity;
                        style.Style.BorderColor = highlight.border.color;
                        style.Style.BorderWidth = highlight.border.width;
                        // checked condition for is already selected or not
                        if (type == 'bubble')
                            className = $('#' + this.chartObj.svgObject.id + '_Series' + serIndex + '_Point' + ptIndex).attr('class');
                        else
                            className = $('#' + this.chartObj.svgObject.id + '_Series' + serIndex + '_Point' + ptIndex + '_symbol').attr('class');
                        if (className != "SelectionStyleseries" + serIndex)
                            sf.EjSvgRender.chartSymbol["_draw" + symbolName](commonEventArgs.data.location, style, chartObj, (chartObj.model.enable3D) ? sender.chart3D : symbolEle);
                    }
                    else {
                        if (type == 'scatter')
                            className = $('#' + chartObj.svgObject.id + '_Series' + serIndex + '_Point' + ptIndex + '_symbol').attr('class');
                        else
                            className = $('#' + chartObj.svgObject.id + '_Series' + serIndex + '_Point' + ptIndex).attr('class');
                        if (className != "SelectionStyleseries" + serIndex)
                            sf.EjSvgRender.chartSymbol["_draw" + symbolName](commonEventArgs.data.location, commonEventArgs.data.style, chartObj, (chartObj.model.enable3D) ? sender.chart3D : symbolEle);
                    }
                }
            }

            if (!sender.chart3D && type != "pieofpie" && chartObj.model.AreaType == "none" && $(symbolEle).children().not("defs").length > chartObj.model._visibleSeries[seriesIndex]._visiblePoints.length) {
                $(symbolEle.childNodes[options.pointIndex]).replaceWith($(symbolEle.childNodes[$(symbolEle.childNodes).length - 1]));
            }

        },

        drawSymbol: function (seriesIndex, series, pointIndex, x, y, chart, trackSymbol, trackcount) {
            var drawType = series.drawType;
            if (sf.util.isNullOrUndefined(this.chartObj)) this.chartObj = chart;


            var point = series._visiblePoints[pointIndex], seriesType = series.type.toLowerCase(),
                index = seriesType == "boxandwhisker" ? trackcount : pointIndex,
                dashArray = (seriesType == 'bubble' || seriesType == 'scatter') ? series.border.dashArray : "";
            var symbolName = "None";
            var tracker = this.changeCrossHairSymbol(point.marker ? point.marker : series.marker, trackSymbol, pointIndex, seriesIndex, series);
            if (seriesType.toLowerCase() == 'boxandwhisker')
                var element = tracker ? tracker : $.extend(true, {}, series.outlierSettings, point.outlierSettings, series.border, point.border);
            else
                var element = tracker ? tracker : $.extend(true, {}, series.marker, point.marker);

            $.each(this.chartObj.model.symbolShape, function (name) {
                if (element.shape.toLowerCase() == name.toLowerCase())
                    symbolName = name;
            });
            if (symbolName == "None")
                return;
            var location = this.chartObj.model.AreaType == "cartesianaxes" ? { startX: x + this.chartObj.canvasX, startY: y + this.chartObj.canvasY } : { startX: x, startY: y };
            var borderColor, borderWidth, style;
            if (seriesType == 'scatter' || series.drawType == "scatter") {
                borderColor = ((point.border) && point.border.color) ? point.border.color : series.border.color;
                borderWidth = ((point.border) && point.border.width) ? point.border.width : series.border.width;
                style = { 'interior': element.fill, 'opacity': element.opacity, 'borderColor': borderColor, 'borderWidth': borderWidth };
            }
            else if (seriesType == "boxandwhisker") {
                borderColor = ((point.border) && point.border.color) ? (point.border.color == "transparent" ? this.chartObj._saturationColor(series.fill, -0.6) : point.border.color) : (series.border.color == "transparent" ? this.chartObj._saturationColor(series.fill, -0.6) : series.border.color);
                borderWidth = ((point.border) && point.border.width) ? point.border.width : series.border.width;
                style = { 'interior': series.fill, 'opacity': series.opacity, 'borderColor': borderColor, 'borderWidth': borderWidth };
            }
            else {
                var style = { 'interior': element.fill, 'opacity': element.opacity, 'borderColor': element.border.color, 'borderWidth': element.border.width };
            }
            var symbolEle = (trackSymbol) ? this.chartObj.gTrackerEle : this.chartObj.gSymbolGroupEle[seriesIndex];
            var id = (trackSymbol) ? (this.chartObj.svgObject.id + '_trackSymbol_' + seriesIndex + "_" + index) : (this.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + index + '_symbol');
            var gradientName = trackSymbol ? "TrackSymbol" : "symbol";
            var width = element.size.width;
            var height = element.size.height;
            var options = {
                'style': style,
                'gradientName': gradientName,
                'symbolEle': symbolEle,
                'width': width,
                'height': height,
                'point': point,
                'location': location,
                'seriesIndex': seriesIndex,
                'pointIndex': pointIndex,
                'element': element,
                'visibility': (point.visible) ? 'visible' : 'hidden',
                'symbolName': symbolName,
                'trackSymbol': trackSymbol,
                'id': id,
                'dashArray': dashArray
            };
            if (!this.chartObj.model.enableCanvasRendering)
                var imgMarkerEle = this.chartObj.gSymbolGroupEle[seriesIndex].childNodes[pointIndex];
            if (!sf.util.isNullOrUndefined(imgMarkerEle) && symbolName.toLowerCase() == "image") {
                imgMarkerEle.setAttribute('width', width);
                imgMarkerEle.setAttribute('height', height);
            }
            else
                this.drawSymbolStyle(options, this.chartObj, trackSymbol);

            if (series.type.toLowerCase() == "scatter") {
                var areaBoundsX = series.xAxis.x;
                var areaBoundsY = series.yAxis.y;
                if (this.chartObj.model.enableCanvasRendering) {
                    areaBoundsX = 0;
                    areaBoundsY = 0;
                }
                var bounds = { X: areaBoundsX + location.startX - (height / 2), Y: areaBoundsY + location.startY - (width / 2), Height: height, Width: width };
                sf.EjSvgRender.utils._addRegion(this.chartObj, bounds, series, null, pointIndex);
            }
        },

        chartAreaType: "cartesianAxes",
        requireInvertedAxes: false,
        stackingSeries: false,
        hiloTypes: false

    };


    function ejExtendClass(parent, members) {
        var object = function () { };
        object.prototype = new parent();
        $.extend(object.prototype, members);
        return object;
    }

    sf.ejLineSeries = ejExtendClass(sf.EjSeriesRender);

    sf.seriesTypes.line = sf.ejLineSeries;


    sf.ejStepLineSeries = ejExtendClass(sf.EjSeriesRender, {

        draw: function (chart, options) {
            var chartObj = this.chartObj = chart;
            var lDirection;
            options._animationType = "path";
            var sb = sf.EjSvgRender.utils._getStringBuilder();
            var currentseries = options;
            var style = this.setLineSeriesStyle(currentseries);
            if (currentseries.sorting)
                currentseries.points = sf.DataManager(currentseries.points, sf.Query().sortBy("xValue")).executeLocal();
            var visiblePoints = options._visiblePoints = currentseries.points.length > 100 || !currentseries.enableSmartLabels ? this.improveChartPerformance(currentseries) : this._isVisiblePoints(currentseries);
            var firstPoint = null;
            var startPath = "M";
            var secondPoint, nextpoint, point1, point2, point3;
            var firstIndex = -1;
            for (var i = 0; i < visiblePoints.length; i++) {
                secondPoint = visiblePoints[i];
                if (secondPoint.visible) {
                    if (firstPoint != null) {
                        if (visiblePoints.length > firstIndex + 1) {
                            nextpoint = { xValue: visiblePoints[firstIndex + 1].xValue, YValues: [firstPoint.YValues[0]] };
                            point1 = sf.EjSvgRender.utils._getPoint(firstPoint, currentseries);
                            point2 = sf.EjSvgRender.utils._getPoint(nextpoint, currentseries);
                            point3 = sf.EjSvgRender.utils._getPoint(visiblePoints[firstIndex + 1], currentseries);
                            chartObj = this.chartObj;
                            sb.append(startPath + " " + (point1.X + chartObj.canvasX) + " " + ((point1.Y + chartObj.canvasY)) + " " +
                                "L" + " " + (point2.X + chartObj.canvasX) + " " + ((point2.Y + chartObj.canvasY)) + " " +
                                "L" + " " + (point3.X + chartObj.canvasX) + " " + ((point3.Y + chartObj.canvasY)) + " ");
                        }
                        startPath = "L";
                    }
                    firstPoint = secondPoint;
                    firstIndex = i;
                }
                else {
                    firstPoint = null;
                    startPath = "M";
                }
            }
            lDirection = sb.toString();

            this._drawLinePath(currentseries, style, lDirection);

            if (this.chartObj.dragPoint)
                this.chartObj.svgRenderer.append(this.chartObj.gPreviewSeriesGroupEle, this.chartObj.gSeriesEle);
            else
                this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);
        }

    });

    sf.ejStepAreaSeries = ejExtendClass(sf.EjSeriesRender, {

        draw: function (chart, options, params) {
            this.chartObj = chart;
            options._animationType = "path";
            var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
            var aDirection;
            var sb = sf.EjSvgRender.utils._getStringBuilder();
            var currentseries = options;
            var style = this.setAreaSeriesStyle(currentseries);
            if (currentseries.sorting)
                currentseries.points = sf.DataManager(currentseries.points, sf.Query().sortBy("xValue")).executeLocal();
            var visiblePoints = options._visiblePoints = currentseries.points.length > 100 || !currentseries.enableSmartLabels ? this.improveChartPerformance(currentseries) : this._calculateVisiblePoints(currentseries).visiblePoints;
            var xOffset = 0;
            var firstPoint = null;
            var secondPoint;
            if (currentseries.xAxis._valueType.toLowerCase() == "category" && currentseries.xAxis.labelPlacement.toLowerCase() != "onticks")
                xOffset = 0.5;
            var origin = sf.EjSeriesRender.prototype.getOrigin(this, currentseries, params);
            var startPoint = null;
            var start = true;
            var chartObj = this.chartObj;
            for (var i = 0; i <= visiblePoints.length; i++) {

                if (i < visiblePoints.length) {
                    if (visiblePoints[i].visible) {

                        secondPoint = { xValue: visiblePoints[i].xValue - xOffset, YValues: [visiblePoints[i].y] };
                        point1 = sf.EjSvgRender.utils._getPoint(secondPoint, currentseries);
                        if (!startPoint) {
                            startPoint = { xValue: visiblePoints[i].xValue - xOffset, YValues: [origin] }
                            var startLoc = sf.EjSvgRender.utils._getPoint(startPoint, currentseries);
                            sb.append("M" + " " + (startLoc.X + chartObj.canvasX) + " " + (startLoc.Y + chartObj.canvasY) + " ");
                        }
                        if (firstPoint != null) {
                            var step = { xValue: secondPoint.xValue, YValues: [firstPoint.YValues[0]] };
                            var stepPoint = sf.EjSvgRender.utils._getPoint(step, currentseries);
                            if (start) {
                                sb.append("L" + " " + (point2.X + chartObj.canvasX) + " " + (point2.Y + chartObj.canvasY) + " ");
                                start = false;
                            }
                            sb.append("L" + " " + (stepPoint.X + chartObj.canvasX) + " " + ((stepPoint.Y + chartObj.canvasY)) + " " + "L" + " " + (point1.X + chartObj.canvasX) + " " + (point1.Y + chartObj.canvasY) + " ");
                            if ((xOffset == 0 && i == visiblePoints.length - 1) || (i < (visiblePoints.length - 1) && !visiblePoints[i + 1].visible)) {
                                if (xOffset > 0) {
                                    secondPoint = { xValue: visiblePoints[i].xValue + xOffset, YValues: [visiblePoints[i].y] };
                                    var point1 = sf.EjSvgRender.utils._getPoint(secondPoint, currentseries);
                                    if (requireInvertedAxes)
                                        sb.append("L" + " " + (point1.X + chartObj.canvasX) + " " + (point1.Y + chartObj.canvasY) + " " + "L" + " " + (point1.Y + chartObj.canvasX) + " " + (startLoc.X + chartObj.canvasY) + " ");
                                    else
                                        sb.append("L" + " " + (point1.X + chartObj.canvasX) + " " + (point1.Y + chartObj.canvasY) + " " + "L" + " " + (point1.X + chartObj.canvasX) + " " + (startLoc.Y + chartObj.canvasY) + " ");
                                }
                                else
                                    if (requireInvertedAxes)
                                        sb.append("L" + " " + (startLoc.X + chartObj.canvasY) + " " + (point1.Y + chartObj.canvasX) + " ");
                                    else
                                        sb.append("L" + " " + (point1.X + chartObj.canvasX) + " " + (startLoc.Y + chartObj.canvasY) + " ");
                                startPoint = null;
                                firstPoint = null;
                                start = true;
                            }
                        }
                        if (startPoint) {
                            var point2 = point1;
                            firstPoint = secondPoint;
                        }
                    }
                    else {
                        startPoint = null;
                        firstPoint = null;
                        start = true;
                    }

                }
                else {
                    if (visiblePoints[i - 1].visible && xOffset > 0) {
                        secondPoint = { xValue: visiblePoints[i - 1].xValue + xOffset, YValues: [visiblePoints[i - 1].y] };
                        var point1 = sf.EjSvgRender.utils._getPoint(secondPoint, currentseries);
                        if (requireInvertedAxes)
                            sb.append("L" + " " + (point1.X + chartObj.canvasX) + " " + (point1.Y + chartObj.canvasY) + " " + "L" + " " + (point1.Y + chartObj.canvasX) + " " + (startLoc.X + chartObj.canvasY) + " ");
                        else
                            sb.append("L" + " " + (point1.X + chartObj.canvasX) + " " + (point1.Y + chartObj.canvasY) + " " + "L" + " " + (point1.X + chartObj.canvasX) + " " + (startLoc.Y + chartObj.canvasY) + " ");
                    }
                }

            }
            aDirection = sb.toString();

            this.drawAreaPath(currentseries, style, aDirection);
            if (this.chartObj.dragPoint)
                this.chartObj.svgRenderer.append(this.chartObj.gPreviewSeriesGroupEle, this.chartObj.gSeriesEle);
            else
                this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

        }
    });
    sf.seriesTypes.steparea = sf.ejStepAreaSeries;


    sf.seriesTypes.stepline = sf.ejStepLineSeries;


    sf.ejColumnSeries = ejExtendClass(sf.EjSeriesRender, {



        draw: function (chart, options, params) {
            this.chartObj = chart;
            var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
            options._animationType = "rect";
            if (options.columnFacet == "cylinder")
                options._animationType = "cylinder";
            var series = options;
            var cornerRadius = series.cornerRadius;
            var seriesIndex = $.inArray(series, this.chartObj.model._visibleSeries);
            var origin = sf.EjSeriesRender.prototype.getOrigin(this, series, params);

            var sidebysideinfo = this.getSideBySideInfo(series, params);
            if (series.dragSettings.enable) series.sidebysideInfo = sidebysideinfo;
            var visiblePoints = this._isVisiblePoints(series);

            var trans = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);

            var pointMarker;

            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };

            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);

            var cSer = this;
            for (var i = 0; i < visiblePoints.length; i++) {
                var pointIndex = i;
                var point = visiblePoints[i];
                pointMarker = visiblePoints[i].marker;

                var y1 = point.YValues[0];
                var y2 = origin;
                if (point.visible) {
                    //calculate sides
                    var data = cSer.calculateSides(point, sidebysideinfo);
                    var x1 = data.x1;
                    var x2 = data.x2;

                    var styleOptions = this.chartObj.setStyle(cSer, series, seriesIndex, pointIndex);

                    var rect = cSer.getRectangle(x1, y1, x2, y2, series, chart);

                    //drawing part
                    var xr = Math.min(0, rect.Width);
                    var yr = Math.min(0, rect.Height);

                    var bounds;
                    if ((xr == 0 || yr == 0) && rect.Width > 0) {
                        options = {
                            'id': cSer.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex,
                            'x': rect.X + cSer.chartObj.canvasX,
                            'y': rect.Y + cSer.chartObj.canvasY,
                            'width': rect.Width,
                            'height': rect.Height,
                            'fill': styleOptions.interior,
                            'plot': y1 < 0 ? "negative" : "positive",
                            'stroke-width': styleOptions.borderWidth,
                            'opacity': styleOptions.opacity,
                            'stroke': styleOptions.borderColor,
                            'stroke-dasharray': styleOptions.dashArray,
                        };
                        var cylinderSeriesOption = {
                            'isColumn': true,
                            'stacking': false,
                            'isLastSeries': true,
                        };
                        if (series.columnFacet == "cylinder")
                            cSer.chartObj.svgRenderer.drawCylinder(options, cSer.gSeriesGroupEle, cylinderSeriesOption);
                        //calculate path for rounded corner
                        else if ((typeof (cornerRadius) != "object" && cornerRadius > 0) || cornerRadius.topLeft > 0 || cornerRadius.bottomLeft > 0 || cornerRadius.topRight > 0
                            || cornerRadius.bottomRight > 0) {
                            var roundrect = sf.EjSvgRender.utils._calculateroundedCorner(cornerRadius, options);
                            options.d = roundrect;
                            series._animationType = "path";
                            cSer.chartObj.svgRenderer.drawPath(options, cSer.gSeriesGroupEle);
                        }
                        else if (series.columnFacet == "rectangle")
                            cSer.chartObj.svgRenderer.drawRect(options, cSer.gSeriesGroupEle);
                        var svgXy = sf.EjSvgRender.utils._getSvgXY(rect.X, (rect.Y), series, cSer.chartObj);
                        bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };
                        sf.EjSvgRender.utils._addRegion(cSer.chartObj, bounds, series, point, pointIndex);
                    }
                    options.plot = y1 < 0 ? "negative" : "positive";
                    if (requireInvertedAxes)
                        point.symbolLocation = { X: ((y1 < (series.xAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.xAxis._crossValue || 0))) ? (rect.X) : (rect.X + rect.Width), Y: ((rect.Y) + (rect.Height / 2)) };
                    else
                        point.symbolLocation = { X: rect.X + (rect.Width / 2), Y: ((y1 < (series.xAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.xAxis._crossValue || 0))) ? ((rect.Y) + (rect.Height)) : (rect.Y) };

                }
            }

            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);


        },

        isRegion: true

    });
    sf.seriesTypes.column = sf.ejColumnSeries;

    sf.ejStackingColumnSeries = ejExtendClass(sf.EjSeriesRender, {

        draw: function (chart, options, params) {
            this.chartObj = chart;
            options._animationType = "rect";
            if (options.columnFacet == "cylinder")
                options._animationType = "cylinder";
            var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
            var series = options;
            var cornerRadius = series.cornerRadius;
            var seriesIndex = $.inArray(series, this.chartObj.model._visibleSeries);
            //var origin = Math.max(options.yAxis.visibleRange.min, 0);

            var sidebysideinfo = this.getSideBySideInfo(series, params);
            var visiblePoints = this._isVisiblePoints(series);

            var trans = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);

            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };

            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
            var cSer = this;
            for (var i = 0; i < visiblePoints.length; i++) {
                var pointIndex = i;
                var point = series._visiblePoints[i];

                var y2 = series.stackedValue.StartValues[i];
                var y1 = series.stackedValue.EndValues[i];
                if (point.visible) {
                    //calculate sides
                    var data = cSer.calculateSides(point, sidebysideinfo);
                    var x1 = data.x1;
                    var x2 = data.x2;

                    var styleOptions = this.chartObj.setStyle(cSer, series, seriesIndex, pointIndex);

                    var rect = cSer.getRectangle(x1, y1, x2, y2, series, chart);

                    //drawing part
                    var xr = Math.min(0, rect.Width);
                    var yr = Math.min(0, rect.Height);

                    var bounds;
                    var isstacking100 = series.type == 'stackingcolumn100' ? true : false;
                    if ((xr == 0 || yr == 0) && rect.Width > 0) {
                        options = {
                            'id': cSer.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex,
                            'x': rect.X + cSer.chartObj.canvasX,
                            'y': rect.Y + cSer.chartObj.canvasY,
                            'width': rect.Width,
                            'height': rect.Height,
                            'fill': styleOptions.interior,
                            'stroke-width': styleOptions.borderWidth,
                            'plot': y1 < 0 ? "negative" : "positive",
                            'opacity': styleOptions.opacity,
                            'stroke': styleOptions.borderColor,
                            'stroke-dasharray': styleOptions.dashArray,
                        };
                        var cylinderSeriesOption = {
                            'isColumn': true,
                            'stacking': isstacking100,
                            'isLastSeries': series.stackedValue.stackedSeries,
                        };
                        if (series.columnFacet == "cylinder")
                            cSer.chartObj.svgRenderer.drawCylinder(options, cSer.gSeriesGroupEle, cylinderSeriesOption);
                        else if ((typeof (cornerRadius) != "object" && cornerRadius > 0) || cornerRadius.topLeft > 0 || cornerRadius.bottomLeft > 0
                            || cornerRadius.topRight > 0 || cornerRadius.bottomRight > 0)           //calculate path for rounded corner
                        {
                            var roundrect = sf.EjSvgRender.utils._calculateroundedCorner(cornerRadius, options);
                            options.d = roundrect;
                            series._animationType = "path";
                            cSer.chartObj.svgRenderer.drawPath(options, cSer.gSeriesGroupEle);
                        }
                        else if (series.columnFacet == "rectangle")
                            cSer.chartObj.svgRenderer.drawRect(options, cSer.gSeriesGroupEle);

                        var svgXy = sf.EjSvgRender.utils._getSvgXY(rect.X, (rect.Y), series, cSer.chartObj);
                        bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };
                        var rx = rect.Width / 2,
                            length = Math.round(rect.Height),
                            ry = Math.round(rx / 4);
                        if (ry == length)
                            bounds.Height = rect.Height + 2 * ry;
                        sf.EjSvgRender.utils._addRegion(cSer.chartObj, bounds, series, point, pointIndex);
                    }

                    if (requireInvertedAxes)
                        point.symbolLocation = { X: ((y1 < (series.xAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.xAxis._crossValue || 0))) ? (rect.X) : (rect.X + rect.Width), Y: ((rect.Y) + (rect.Height / 2)) };
                    else
                        point.symbolLocation = { X: rect.X + (rect.Width / 2), Y: ((y1 < (series.xAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.xAxis._crossValue || 0))) ? ((rect.Y) + (rect.Height)) : (rect.Y) };

                }
            }

            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);



        },

        stackingSeries: true,
        isRegion: true

    });
    sf.seriesTypes.stackingcolumn = sf.ejStackingColumnSeries;

    sf.seriesTypes.stackingcolumn100 = sf.ejStackingColumnSeries;

    sf.seriesTypes.rangecolumn = sf.ejRangeColumnSeries;

    sf.ejRangeColumnSeries = ejExtendClass(sf.EjSeriesRender, {

        draw: function (chart, options, params) {
            this.chartObj = chart;
            options._animationType = "rect";
            var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
            var series = options;
            var cornerRadius = series.cornerRadius;
            var seriesIndex = $.inArray(series, this.chartObj.model._visibleSeries);

            var sidebysideinfo = this.getSideBySideInfo(series, params);
            var visiblePoints = this._isVisiblePoints(series);

            var trans = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);

            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };

            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
            var cSer = this;
            for (var i = 0; i < visiblePoints.length; i++) {
                var pointIndex = i;
                var point = visiblePoints[i];

                var y1 = point.YValues[0];
                var y2 = point.YValues[1];
                if (point.visible) {
                    //calculate sides
                    var data = cSer.calculateSides(point, sidebysideinfo);
                    var x1 = data.x1;
                    var x2 = data.x2;

                    var styleOptions = this.chartObj.setStyle(cSer, series, seriesIndex, pointIndex);

                    var rect = cSer.getRectangle(x1, y1, x2, y2, series, chart);
                    var width = cSer.chartObj.model.m_AreaBounds.Width;
                    //drawing part
                    var xr = Math.min(0, rect.Width);
                    var yr = Math.min(0, rect.Height);

                    var bounds;
                    if (xr == 0 || yr == 0) {
                        options = {
                            'id': cSer.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex,
                            'x': rect.X + cSer.chartObj.canvasX,
                            'y': rect.Y + cSer.chartObj.canvasY,
                            'width': rect.Width,
                            'height': rect.Height,
                            'fill': styleOptions.interior,
                            'stroke-width': styleOptions.borderWidth,
                            'opacity': styleOptions.opacity,
                            'stroke': styleOptions.borderColor,
                            'stroke-dasharray': styleOptions.dashArray,
                        };

                        if ((typeof (cornerRadius) != "object" && cornerRadius > 0) || cornerRadius.topLeft > 0 || cornerRadius.bottomLeft > 0
                            || cornerRadius.topRight > 0 || cornerRadius.bottomRight > 0)           //calculate path for rounded corner
                        {
                            var roundrect = sf.EjSvgRender.utils._calculateroundedCorner(cornerRadius, options);
                            options.d = roundrect;
                            series._animationType = "path";
                            cSer.chartObj.svgRenderer.drawPath(options, cSer.gSeriesGroupEle);
                        }
                        else
                            cSer.chartObj.svgRenderer.drawRect(options, cSer.gSeriesGroupEle, trans.y);

                        cSer.chartObj.svgRenderer.drawRect(options, cSer.gSeriesGroupEle, trans.y);

                        //Add region for each rect
                        var svgXy = sf.EjSvgRender.utils._getSvgXY(rect.X, (rect.Y), series, cSer.chartObj);
                        bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };
                        sf.EjSvgRender.utils._addRegion(cSer.chartObj, bounds, series, point, pointIndex);
                    }
                    //Add rect location details for symbol                
                    if (series.type.toLowerCase() == "waterfall")
                        y1 = point.waterfallSum ? point.waterfallSum : point.y;
                    if (requireInvertedAxes)
                        point.symbolLocation = { X: ((y1 < 0 && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > 0)) ? (rect.X) : (rect.X + rect.Width), Y: ((rect.Y) + (rect.Height / 2)) };
                    else
                        point.symbolLocation = { X: rect.X + (rect.Width / 2), Y: ((y1 < 0 && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > 0)) ? ((rect.Y) + (rect.Height)) : (rect.Y) };

                }
            }

            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);



        },

        hiloTypes: true,
        isRegion: true

    });
    sf.seriesTypes.rangecolumn = sf.ejRangeColumnSeries;


    sf.ejBoxandwhiskerSeries = ejExtendClass(sf.EjSeriesRender, {

        draw: function (chart, options, params) {
            this.chartObj = chart;
            var requireInvertedAxes = this.chartObj.model.requireInvertedAxes, previousStyle;
            options._animationType = "rect";
            var series = options,
                seriesIndex = $.inArray(series, this.chartObj.model._visibleSeries),
                origin = sf.EjSeriesRender.prototype.getOrigin(this, series, params),
                sidebysideinfo = this.getSideBySideInfo(series, params),
                visiblePoints = this._isVisiblePoints(series),
                trans = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes),
                pointMarker, trackCount = 0,
                serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };
            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
            var cSer = this;
            for (var i = 0; i < visiblePoints.length; i++) {
                var pointIndex = i, list1, list2, count = 0, y1, y2, data, x1, x2, styleOptions, rect, xr, yr, seriesIndex, sb, newPoint, boxplotmidpoint,
                    bounds, options1, whiskerpath, newPoint1, outlierpoint, svgXyOutlier, boundsOutlier, svgXy,
                    point = visiblePoints[i];
                pointMarker = visiblePoints[i].marker;
                list1 = point.YValues[0];
                list2 = cSer.calculateMean(list1, series, pointIndex);
                y1 = list2.UpperQuartile;
                y2 = list2.LowerQuartile;
                if (point.visible) {
                    //calculate sides
                    data = cSer.calculateSides(point, sidebysideinfo);
                    x1 = data.x1;
                    x2 = data.x2;
                    styleOptions = this.chartObj.setStyle(cSer, series, seriesIndex, pointIndex);
                    rect = cSer.getRectangle(x1, y1, x2, y2, series, chart);
                    //drawing part
                    xr = Math.min(0, rect.Width);
                    yr = Math.min(0, rect.Height);
                    seriesIndex = $.inArray(series, this.chartObj.model._visibleSeries);
                    previousStyle = this.chartObj.setStyle(this, series, seriesIndex, i);
                    sb = sf.EjSvgRender.utils._getStringBuilder();
                    newPoint = { "xValue": point.xValue, "YValues": list2.midvalue };
                    boxplotmidpoint = sf.EjSvgRender.utils._getPoint(newPoint, series);
                    var boxStrokeColor = styleOptions.borderColor == "transparent" ? this.chartObj._saturationColor(styleOptions.interior, -0.6) : styleOptions.borderColor;

                    bounds;
                    if ((xr == 0 || yr == 0) && rect.Width > 0) {
                        options = {
                            'id': cSer.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex,
                            'x': rect.X + cSer.chartObj.canvasX,
                            'y': rect.Y + cSer.chartObj.canvasY,
                            'width': rect.Width,
                            'height': rect.Height,
                            'fill': styleOptions.interior,
                            'stroke-width': styleOptions.borderWidth,
                            'plot': y1 < 0 ? "negative" : "positive",
                            'opacity': styleOptions.opacity,
                            'stroke': boxStrokeColor,
                            'stroke-dasharray': styleOptions.dashArray,
                        };

                        options1 = {
                            'id': this.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex + '_median',
                            x1: series._isTransposed ? boxplotmidpoint.X + cSer.chartObj.canvasX : rect.X + cSer.chartObj.canvasX,
                            y1: series._isTransposed ? rect.Y + cSer.chartObj.canvasY : boxplotmidpoint.Y + cSer.chartObj.canvasY,
                            x2: series._isTransposed ? boxplotmidpoint.X + cSer.chartObj.canvasX : rect.X + rect.Width + cSer.chartObj.canvasX,
                            y2: series._isTransposed ? rect.Y + rect.Height + cSer.chartObj.canvasY : boxplotmidpoint.Y + cSer.chartObj.canvasY,
                            'stroke-width': styleOptions.borderWidth,
                            'stroke': boxStrokeColor,
                        };

                        cSer.chartObj.svgRenderer.drawRect(options, cSer.gSeriesGroupEle);

                        //draw mean line for boxandwhisker
                        cSer.chartObj.svgRenderer.drawLine(options1, cSer.gSeriesGroupEle);
                        //draw lowerwhisker path calculation
                        whiskerpath = cSer.calculateBoxAndWhiskerPath(options, rect, options1, list2, series, point, pointIndex);
                        options.d = whiskerpath.lowerWhisker;
                        options.id = options.id + '_whisker';
                        cSer.chartObj.svgRenderer.drawPath(options, cSer.gSeriesGroupEle);
                        //draw upperwhisker path calculation
                        options.d = whiskerpath.upperWhisker;
                        cSer.chartObj.svgRenderer.drawPath(options, cSer.gSeriesGroupEle);

                        if (series.showMedian == true) {
                            options.d = whiskerpath.mean;
                            cSer.chartObj.svgRenderer.drawPath(options, cSer.gSeriesGroupEle);
                        }


                        //draw outliers
                        for (var k = 0; k < list2.outliers.length; k++) {
                            newPoint1 = { "xValue": point.xValue, "YValues": list2.outliers[k] };
                            outlierpoint = sf.EjSvgRender.utils._getPoint(newPoint1, series);


                            outlierpoint.X = series._isTransposed ? outlierpoint.X : (rect.X + (rect.Width / 2));
                            outlierpoint.Y = series._isTransposed ? rect.Y + rect.Height / 2 : outlierpoint.Y;

                            this.drawSymbol(seriesIndex, series, pointIndex, outlierpoint.X, outlierpoint.Y, null, null, trackCount);
                            trackCount++;
                            //to store the outlier regions
                            svgXyOutlier = sf.EjSvgRender.utils._getSvgXY(outlierpoint.X, outlierpoint.Y, series, cSer.chartObj);
                            boundsOutlier = { X: svgXyOutlier.X - (series.outlierSettings.size.width / 2), Y: svgXyOutlier.Y - (series.outlierSettings.size.height / 2), Width: series.outlierSettings.size.width, Height: series.outlierSettings.size.height };
                            sf.EjSvgRender.utils._addRegion(cSer.chartObj, boundsOutlier, series, point, pointIndex);

                        }
                        svgXy = sf.EjSvgRender.utils._getSvgXY(rect.X, (rect.Y), series, cSer.chartObj);
                        bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };
                        sf.EjSvgRender.utils._addRegion(cSer.chartObj, bounds, series, point, pointIndex);
                    }
                }
            }

            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);


        },

        isRegion: true



    });
    sf.seriesTypes.boxandwhisker = sf.ejBoxandwhiskerSeries;

    sf.ejWaterfallSeries = ejExtendClass(sf.EjSeriesRender, {

        draw: function (chart, options, params) {

            sf.ejRangeColumnSeries.prototype.draw.call(this, chart, options, params);
            options._animationType = "rect";
            var chartRegions = this.chartObj.model.chartRegions;
            var seriesRegions = [];
            var areaBounds = this.chartObj.model.m_AreaBounds;
            var seriesIndex = $.inArray(options, this.chartObj.model._visibleSeries);
            options.index = seriesIndex;

            for (var j = 0, i = 0; j < chartRegions.length; j++) {
                if (seriesIndex == chartRegions[j].SeriesIndex) {
                    seriesRegions[i] = chartRegions[j];
                    i += 1;
                }
            }
            var serOptions1 = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_waterfallLine_' + seriesIndex };

            this.connectorLineGroup = this.chartObj.svgRenderer.createGroup(serOptions1);

            var sb, point1, point2, y, y1, y2, t1, t2, lineOptions, x, x1, x2, w1, w2, h1, h2, lDirection;
            for (var k = 0; k < seriesRegions.length - 1; k++) {
                sb = sf.EjSvgRender.utils._getStringBuilder();
                point1 = seriesRegions[k].Region.Bounds;
                point2 = seriesRegions[k + 1].Region.Bounds;

                if (!options.isTransposed) {
                    y1 = Math.ceil(point1.Y), h1 = Math.ceil(point1.Height), y2 = Math.ceil(point2.Y), h2 = Math.ceil(point2.Height);
                    t1 = Math.ceil(point1.Y + point1.Height);
                    y = ((y1 == y2) ? point1.Y : (t1 == y2 ? point2.Y : (point2.Y + point2.Height)));
                    sb.append("M " + (point1.X) + " " + (y) + " L " + (point2.X + point2.Width) + " " + y);
                } else {
                    x1 = Math.ceil(point1.X), w1 = Math.ceil(point1.Width), x2 = Math.ceil(point2.X), w2 = Math.ceil(point2.Width);
                    t1 = Math.ceil(point1.X + point1.Width);
                    t2 = Math.ceil(point2.X + point2.Width);
                    x = ((t1 == t2) ? (point1.X + point1.Width) : (x1 == x2 ? point1.X : (x1 == t2 ? point1.X : (point1.X + point1.Width))));
                    sb.append("M " + (x) + " " + (point1.Y + point1.Height) + " L " + x + " " + (point2.Y));
                }


                lDirection = sb.toString();
                if (lDirection != "" && point1.Height >= 0) {
                    lineOptions = {
                        'id': this.chartObj.svgObject.id + "_waterFall_" + seriesIndex + "_connectorLine_" + k,
                        'fill': 'none',
                        'stroke-dasharray': options.connectorLine.dashArray,
                        'stroke-width': options.connectorLine.width,
                        'stroke': options.connectorLine.color,
                        'opacity': options.connectorLine.opacity,
                        'd': lDirection
                    };
                    this.chartObj.svgRenderer.drawPath(lineOptions, this.connectorLineGroup);
                }
            }
            this.chartObj.svgRenderer.append(this.connectorLineGroup, this.chartObj.gSeriesEle);

            if (options.enableAnimation && !options._animatedSeries)
                this.chartObj.svgRenderer._setAttr(this.connectorLineGroup, { "visibility": "hidden" });
        },

        hiloTypes: false,
        isRegion: true
    });
    sf.seriesTypes.waterfall = sf.ejWaterfallSeries;

    sf.ejStackingBarSeries = ejExtendClass(sf.EjSeriesRender, {

        draw: function (chart, options, params) {
            this.chartObj = chart;
            options._animationType = "rect";
            if (options.columnFacet == "cylinder")
                options._animationType = "cylinder";
            var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
            var series = options;
            var cornerRadius = series.cornerRadius;
            var seriesIndex = $.inArray(series, this.chartObj.model._visibleSeries);
            //var origin = Math.max(options.yAxis.visibleRange.min, 0);
            var sidebysideinfo = this.getSideBySideInfo(series, params);
            var visiblePoints = this._isVisiblePoints(series);
            var trans = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);

            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };

            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
            var cSer = this;
            for (var i = 0; i < visiblePoints.length; i++) {
                var pointIndex = i;
                var point = visiblePoints[i];
                var y1 = series.stackedValue.EndValues[i];
                var y2 = series.stackedValue.StartValues[i];
                if (point.visible) {
                    //calculate sides
                    var data = cSer.calculateSides(point, sidebysideinfo);
                    var x1 = data.x1;
                    var x2 = data.x2;

                    var styleOptions = this.chartObj.setStyle(cSer, series, seriesIndex, pointIndex);

                    var rect = cSer.getRectangle(x1, y1, x2, y2, series, chart);
                    var xr = Math.min(0, rect.Width);
                    var yr = Math.min(0, rect.Height);
                    var isstacking100 = series.type == 'stackingbar100' ? true : false;
                    if (xr == 0 || yr == 0) {
                        var bounds;
                        options = {
                            'id': cSer.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex,
                            'x': rect.X + cSer.chartObj.canvasX,
                            'y': rect.Y + cSer.chartObj.canvasY,
                            'width': rect.Width,
                            'height': rect.Height,
                            'fill': styleOptions.interior,
                            'stroke-width': styleOptions.borderWidth,
                            'opacity': styleOptions.opacity,
                            'stroke': styleOptions.borderColor,
                            'stroke-dasharray': styleOptions.dashArray,
                        };
                        var cylinderSeriesOption = {
                            'isColumn': false,
                            'stacking': isstacking100,
                            'isLastSeries': series.stackedValue.stackedSeries,
                        };
                        if (series.columnFacet == "cylinder")
                            cSer.chartObj.svgRenderer.drawCylinder(options, cSer.gSeriesGroupEle, cylinderSeriesOption);
                        else if ((typeof (cornerRadius) != "object" && cornerRadius > 0) || cornerRadius.topLeft > 0 || cornerRadius.bottomLeft > 0
                            || cornerRadius.topRight > 0 || cornerRadius.bottomRight > 0)           //calculate path for rounded corner
                        {
                            var roundrect = sf.EjSvgRender.utils._calculateroundedCorner(cornerRadius, options);
                            options.d = roundrect;
                            series._animationType = "path";
                            cSer.chartObj.svgRenderer.drawPath(options, cSer.gSeriesGroupEle);
                        }
                        else if (series.columnFacet == "rectangle")
                            cSer.chartObj.svgRenderer.drawRect(options, cSer.gSeriesGroupEle);

                        var svgXy = sf.EjSvgRender.utils._getSvgXY((rect.X), (rect.Y), series, cSer.chartObj);
                        bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };

                        sf.EjSvgRender.utils._addRegion(cSer.chartObj, bounds, series, point, pointIndex);
                    }


                    if (!requireInvertedAxes)
                        point.symbolLocation = { X: rect.X + (rect.Width / 2), Y: ((y1 < (series.yAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.yAxis._crossValue || 0))) ? ((rect.Y) + (rect.Height)) : (rect.Y) };
                    else
                        point.symbolLocation = { X: ((y1 < (series.yAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.yAxis._crossValue || 0))) ? (rect.X) : (rect.X + rect.Width), Y: ((rect.Y) + (rect.Height / 2)) };

                }
            }

            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);


        },

        stackingSeries: true,
        requireInvertedAxes: true,
        isRegion: true

    });
    sf.seriesTypes.stackingbar = sf.ejStackingBarSeries;

    sf.seriesTypes.stackingbar100 = sf.ejStackingBarSeries;

    sf.ejBarSeries = ejExtendClass(sf.EjSeriesRender, {

        draw: function (chart, options, params) {
            this.chartObj = chart;
            options._animationType = "rect";
            if (options.columnFacet == "cylinder")
                options._animationType = "cylinder";
            var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
            var series = options;
            var cornerRadius = series.cornerRadius;
            var seriesIndex = $.inArray(series, this.chartObj.model._visibleSeries);
            var origin = sf.EjSeriesRender.prototype.getOrigin(this, series, params);
            var style = $.extend(true, {}, this.chartObj.model.seriesStyle, series.style);
            var sidebysideinfo = this.getSideBySideInfo(series, params);
            if (series.dragSettings.enable) series.sidebysideInfo = sidebysideinfo;
            var visiblePoints = this._isVisiblePoints(series);
            var colors;
            var trans = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);

            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };

            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
            var cSer = this;
            for (var i = 0; i < visiblePoints.length; i++) {
                var pointIndex = i;
                var point = visiblePoints[i];
                var y1 = point.YValues[0];
                var y2 = origin;
                if (point.visible) {
                    //calculate sides
                    var data = cSer.calculateSides(point, sidebysideinfo);
                    var x1 = data.x1;
                    var x2 = data.x2;

                    var styleOptions = this.chartObj.setStyle(cSer, series, seriesIndex, pointIndex);

                    var rect = cSer.getRectangle(x1, y1, x2, y2, series, chart);

                    var xr = Math.min(0, rect.Width);
                    var yr = Math.min(0, rect.Height);

                    if (xr == 0 || yr == 0) {
                        var bounds;
                        options = {
                            'id': cSer.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex,
                            'x': rect.X + cSer.chartObj.canvasX,
                            'y': rect.Y + cSer.chartObj.canvasY,
                            'width': rect.Width,
                            'height': rect.Height,
                            'fill': styleOptions.interior,
                            'stroke-width': styleOptions.borderWidth,
                            'plot': y1 < 0 ? "negative" : "positive",
                            'opacity': styleOptions.opacity,
                            'stroke': styleOptions.borderColor,
                            'stroke-dasharray': styleOptions.dashArray,
                        };
                        var cylinderSeriesOption = {
                            'isColumn': false,
                            'stacking': false,
                            'isLastSeries': true,
                        };
                        if (series.columnFacet == "cylinder")
                            cSer.chartObj.svgRenderer.drawCylinder(options, cSer.gSeriesGroupEle, cylinderSeriesOption);
                        else if ((typeof (cornerRadius) != "object" && cornerRadius > 0) || cornerRadius.topLeft > 0 || cornerRadius.bottomLeft > 0
                            || cornerRadius.topRight > 0 || cornerRadius.bottomRight > 0)           //calculate path for rounded corner
                        {
                            var roundrect = sf.EjSvgRender.utils._calculateroundedCorner(cornerRadius, options);
                            options.d = roundrect;
                            series._animationType = "path";
                            cSer.chartObj.svgRenderer.drawPath(options, cSer.gSeriesGroupEle);
                        }
                        else if (series.columnFacet == "rectangle")
                            cSer.chartObj.svgRenderer.drawRect(options, cSer.gSeriesGroupEle);

                        var svgXy = sf.EjSvgRender.utils._getSvgXY((rect.X), (rect.Y), series, cSer.chartObj);
                        bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };

                        sf.EjSvgRender.utils._addRegion(cSer.chartObj, bounds, series, point, pointIndex);
                    }



                    if (!requireInvertedAxes)
                        point.symbolLocation = { X: rect.X + (rect.Width / 2), Y: ((y1 < (series.xAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.xAxis._crossValue || 0))) ? ((rect.Y) + (rect.Height)) : (rect.Y) };
                    else
                        point.symbolLocation = { X: ((y1 < (series.xAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.xAxis._crossValue || 0))) ? (rect.X) : (rect.X + rect.Width), Y: ((rect.Y) + (rect.Height / 2)) };

                }
            }

            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);


        },

        requireInvertedAxes: true,
        isRegion: true
    });
    sf.seriesTypes.bar = sf.ejBarSeries;


    sf.ejStackingAreaSeries = ejExtendClass(sf.EjSeriesRender, {

        draw: function (chart, options) {
            this.chartObj = chart;
            options._animationType = "path";
            var aDirection, currentPoint, point1;
            var areasb = sf.EjSvgRender.utils._getStringBuilder();
            var currentSeries = options;
            var style = this.setAreaSeriesStyle(currentSeries);





            var visiblePoints = this._isVisiblePoints(currentSeries);

            var origin = Math.max(options.yAxis.visibleRange.min, currentSeries.stackedValue.StartValues[0]);
            var canvasX = this.chartObj.canvasX;
            var canvasY = this.chartObj.canvasY;

            var startPoint = { xValue: visiblePoints[0].xValue, YValues: [origin] };
            var startLoc = sf.EjSvgRender.utils._getPoint(startPoint, currentSeries), startValue = 0, endLength = currentSeries.stackedValue.EndValues.length;
            areasb.append("M" + " " + (startLoc.X + canvasX) + " " + (startLoc.Y + canvasY) + " ");

            //var index = $.inArray(currentSeries, this.chartObj.model._visibleSeries);

            for (var j = 0; j <= endLength; j++) {
                if (j != endLength && visiblePoints[j].visible) {
                    currentPoint = { xValue: visiblePoints[j].xValue, YValues: [currentSeries.stackedValue.EndValues[j]] };
                    if (visiblePoints[j].visible) {
                        point1 = visiblePoints[j].location = sf.EjSvgRender.utils._getPoint(currentPoint, currentSeries);
                        areasb.append("L" + " " + (point1.X + canvasX) + " " + ((point1.Y + canvasY)) + " ");
                        visiblePoints[j].YValues[0] = currentPoint.YValues[0];
                    }

                }
                else {
                    origin = currentSeries.stackedValue.StartValues[j + 1];
                    for (var i = j - 1; i >= startValue; i--) {
                        currentPoint = { xValue: visiblePoints[i].xValue, YValues: [currentSeries.stackedValue.StartValues[i]] };
                        point1 = sf.EjSvgRender.utils._getPoint(currentPoint, currentSeries);
                        areasb.append("L" + " " + (point1.X + canvasX) + " " + ((point1.Y + canvasY)) + " ");
                    }
                    if (visiblePoints[j + 1] && visiblePoints[j + 1].visible) {
                        var startPoint = { xValue: visiblePoints[j + 1].xValue, YValues: [currentSeries.stackedValue.StartValues[j + 1]] };
                        var startLoc = sf.EjSvgRender.utils._getPoint(startPoint, currentSeries);
                        areasb.append("M" + " " + (startLoc.X + canvasX) + " " + (startLoc.Y + canvasY) + " ");
                    }
                    startValue = j + 1;
                }
            }




            aDirection = areasb.toString();

            this.drawAreaPath(currentSeries, style, aDirection);

            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);




        },

        stackingSeries: true

    });
    sf.seriesTypes.stackingarea = sf.ejStackingAreaSeries;

    sf.seriesTypes.stackingarea100 = sf.ejStackingAreaSeries;

    sf.ejAreaSeries = ejExtendClass(sf.EjSeriesRender, {


        draw: function (chart, options, params) {
            this.chartObj = chart;
            var aDirection;
            options._animationType = "path";
            var areasb = sf.EjSvgRender.utils._getStringBuilder();
            var currentSeries = options;
            var style = this.setAreaSeriesStyle(currentSeries);
            var chartObj = this.chartObj;
            if (currentSeries.sorting)
                currentSeries.points = sf.DataManager(currentSeries.points, sf.Query().sortBy("xValue")).executeLocal();

            var visiblePoints = this.chartObj.dragPoint ? currentSeries.pointCollection : this._isVisiblePoints(currentSeries);
            var origin = sf.EjSeriesRender.prototype.getOrigin(this, currentSeries, params);

            var startPoint;
            var translate = [];
            translate[0] = chartObj.canvasX;
            translate[1] = chartObj.canvasY;
            if (visiblePoints.length > 0) {
                for (var i = 0; i < visiblePoints.length; i++) {
                    if (visiblePoints[i].visible) {
                        if (visiblePoints.length > i + 1) {
                            if (!startPoint) {
                                startPoint = { xValue: visiblePoints[i].xValue, YValues: [origin] }
                                var point1 = sf.EjSvgRender.utils._getPoint(startPoint, currentSeries);
                                areasb.append("M" + " " + (point1.X) + " " + ((point1.Y)) + " ");
                            }


                            var point1 = sf.EjSvgRender.utils._getPoint(visiblePoints[i], currentSeries);

                            areasb.append("L" + " " + (point1.X) + " " + ((point1.Y)) + " ");

                            if (!visiblePoints[i + 1].visible) {
                                var point = { xValue: visiblePoints[i].xValue, YValues: [origin] }
                                var point2 = sf.EjSvgRender.utils._getPoint(point, currentSeries);
                                var point3 = sf.EjSvgRender.utils._getPoint(startPoint, currentSeries);
                                areasb.append("L" + " " + (point2.X) + " " + ((point2.Y)) + " " + "L" + " " + (point3.X) + " " + ((point3.Y)) + " ");
                                startPoint = null;
                            }
                        }
                        else {
                            if (visiblePoints[i - 1] && visiblePoints[i - 1].visible) {
                                var point1 = sf.EjSvgRender.utils._getPoint(visiblePoints[i], currentSeries);
                                areasb.append("L" + " " + (point1.X) + " " + ((point1.Y)) + " ");
                            }
                        }
                    }
                }

                var endPoint = { xValue: visiblePoints[visiblePoints.length - 1].xValue, YValues: [origin] };
                var endLoc = sf.EjSvgRender.utils._getPoint(endPoint, currentSeries);
                if (visiblePoints.length > 1)
                    areasb.append("L" + " " + (endLoc.X) + " " + ((endLoc.Y)) + " ");

                aDirection = areasb.toString();

                this.drawAreaPath(currentSeries, style, aDirection, translate);
            }
            if (this.chartObj.dragPoint)
                this.chartObj.svgRenderer.append(this.chartObj.gPreviewSeriesGroupEle, this.chartObj.gSeriesEle);
            else
                this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);




        }

    });

    sf.seriesTypes.area = sf.ejAreaSeries;

    sf.ejRangeAreaSeries = ejExtendClass(sf.EjSeriesRender, {


        draw: function (chart, options) {
            this.chartObj = chart;
            var aDirection;
            options._animationType = "path";
            var areasb = sf.EjSvgRender.utils._getStringBuilder();
            var currentSeries = options;
            var style = this.setAreaSeriesStyle(currentSeries);
            var seriesIndex = $.inArray(currentSeries, this.chartObj.model._visibleSeries);
            currentSeries.points = sf.DataManager(currentSeries.points, sf.Query().sortBy("xValue")).executeLocal();

            var visiblePoints = this._isVisiblePoints(currentSeries);
            var translate = [];
            translate[0] = this.chartObj.canvasX;
            translate[1] = this.chartObj.canvasY;
            var startPoint;
            var internalRegion = []
            for (var i = 0; i < visiblePoints.length; i++) {
                internalRegion[i] = { Region: { PointIndex: i }, SeriesIndex: seriesIndex, region: [] };
                if (visiblePoints[i].visible) {
                    if (!startPoint) {
                        var origin = visiblePoints[i].low;
                        startPoint = { xValue: visiblePoints[i].xValue, YValues: [origin] }
                        var point1 = sf.EjSvgRender.utils._getPoint(startPoint, currentSeries);
                        areasb.append("M" + " " + (point1.X) + " " + ((point1.Y)) + " ");
                    }
                    var point1 = sf.EjSvgRender.utils._getPoint(visiblePoints[i], currentSeries);
                    areasb.append("L" + " " + (point1.X) + " " + ((point1.Y)) + " ");
                    internalRegion[i].region.push({ X: point1.X, Y: point1.Y });
                    if (i != 0)
                        internalRegion[i - 1].region.push({ X: point1.X, Y: point1.Y });

                    if ((i + 1) < visiblePoints.length && !visiblePoints[i + 1].visible && (i + 1) != visiblePoints.length -1) {
                        for (var j = i; j >= 0; j--) {
                            if (visiblePoints[j].visible) {
                                origin = visiblePoints[j].low;
                                var point = { xValue: visiblePoints[j].xValue, YValues: [origin] };
                                var point2 = sf.EjSvgRender.utils._getPoint(point, currentSeries);
                                areasb.append("L" + " " + (point2.X) + " " + ((point2.Y)) + " ");
                                internalRegion[j].region.push({ X: point2.X, Y: point2.Y });
                                if (j != 0)
                                    internalRegion[j - 1].region.push({ X: point2.X, Y: point2.Y });
                            }
                            else
                                break;
                        }
                        startPoint = null;
                    }


                }
            }
            for (var i = visiblePoints.length - 1; i >= 0; i--) {
                if (visiblePoints[i].visible) {
                    origin = visiblePoints[i].low;
                    var point = { xValue: visiblePoints[i].xValue, YValues: [origin] };
                    var point2 = sf.EjSvgRender.utils._getPoint(point, currentSeries);
                    areasb.append("L" + " " + (point2.X) + " " + ((point2.Y)) + " ");
                    internalRegion[i].region.push({ X: point2.X, Y: point2.Y });
                    if (i != 0)
                        internalRegion[i - 1].region.push({ X: point2.X, Y: point2.Y });

                }
                else if (visiblePoints.length > i && visiblePoints[i].visible) {
                    var point2 = sf.EjSvgRender.utils._getPoint(visiblePoints[i], currentSeries);
                    areasb.append("L" + " " + (point2.X) + " " + ((point2.Y)) + " ");
                    break;
                }
                else if (i != (visiblePoints.length - 1)) {
                    var count = 0;
                    for (var k = i - 1; k >= 0; k--) {
                        if (visiblePoints[k].visible)
                            count++;
                        else if (!visiblePoints[k].visible)
                            break;
                    }
                    i = i - count;
                }
            }
            aDirection = areasb.toString();
            this.chartObj.model.chartRegions.push(internalRegion);

            this.drawAreaPath(currentSeries, style, aDirection, translate);
            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);
        },

        hiloTypes: true

    });

    sf.seriesTypes.rangearea = sf.ejRangeAreaSeries;

    sf.ejSplineRangeAreaSeries = ejExtendClass(sf.EjSeriesRender, {
        draw: function (chart, options, params) {
            this.chartObj = chart;
            var series = new sf.seriesTypes["splinearea"]();
            series.draw(chart, options, params);
        },
        chartAreaType: "cartesianAxes",
        hiloTypes: true
    });
    sf.seriesTypes.splinerangearea = sf.ejSplineRangeAreaSeries;

    sf.ejSplineSeries = ejExtendClass(sf.EjSeriesRender, {

        draw: function (chart, options, params) {
            if (!params.seriesCollection) {
                params.seriesCollection = {};
                options._name = sf.util.isNullOrUndefined(options.name) ? "" : options.name.replace(/ /g, '');
            }
            if (!params.seriesCollection[options._name])
                params.seriesCollection[options._name] = {};
            this.chartObj = chart;
            options._animationType = "path";
            var series = options,
                spDirection = "",
                splinesb = sf.EjSvgRender.utils._getStringBuilder(),
                style = this.setLineSeriesStyle(series),
                yIndex = 0,
                visiblePoints = this.chartObj.dragPoint ? series.pointCollection : this._isVisiblePoints(series),
                ySpline = this.naturalSpline(visiblePoints, series) || params.seriesCollection[series._name].naturalSpline,
                firstPoint = null,
                secondPoint = null,
                firstIndex = -1, controlPointsCount = 0,
                controlPoints = params.seriesCollection[series._name].controlPoints || [];

            //Removed spline sorting behavior based on the 'X' points.
            //series.points = sf.DataManager(series.points, sf.Query().sortBy("X")).executeLocal();

            for (var i = 0; i < visiblePoints.length; i++) {
                var pointIndex = i;
                secondPoint = visiblePoints[i];
                if (secondPoint.visible) {
                    if (firstPoint != null) {
                        var controlPoint1 = null;
                        var controlPoint2 = null;
                        var data = this.getBezierControlPoints(firstPoint, secondPoint, ySpline[firstIndex], ySpline[pointIndex], yIndex, series, this) || controlPoints[controlPointsCount++];
                        controlPoint1 = data["controlPoint1"];
                        controlPoint2 = data["controlPoint2"];
                        var pt1 = sf.EjSvgRender.utils._getPoint(firstPoint, series);
                        var pt2 = sf.EjSvgRender.utils._getPoint(secondPoint, series);
                        var bpt1 = sf.EjSvgRender.utils._getPoint(controlPoint1, series);
                        var bpt2 = sf.EjSvgRender.utils._getPoint(controlPoint2, series);
                        var chartObj = this.chartObj;
                        splinesb.append("M" + " " + (pt1.X + chartObj.canvasX) + " " + (pt1.Y + chartObj.canvasY) + " " + "C" + " " + (bpt1.X + chartObj.canvasX) + " " + (bpt1.Y + chartObj.canvasY) + " " + (bpt2.X + chartObj.canvasX) + " " + (bpt2.Y + chartObj.canvasY) + " " + (pt2.X + chartObj.canvasX) + " " + (pt2.Y + chartObj.canvasY) + " ");

                    }
                    firstPoint = secondPoint;
                    firstIndex = pointIndex;
                } else {
                    firstPoint = null;
                }
            }

            spDirection = splinesb.toString();
            this._drawLinePath(series, style, spDirection);
            if (this.chartObj.dragPoint)
                this.chartObj.svgRenderer.append(this.chartObj.gPreviewSeriesGroupEle, this.chartObj.gSeriesEle);
            else
                this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

        }

    });

    sf.seriesTypes.spline = sf.ejSplineSeries;

    sf.ejSplineAreaSeries = ejExtendClass(sf.EjSeriesRender, {


        draw: function (chart, options, params) {
            if (!params.seriesCollection) {
                params.seriesCollection = {};
                options._name = sf.util.isNullOrUndefined(options.name) ? "" : options.name.replace(/ /g, '');
            }
            if (!params.seriesCollection[options._name])
                params.seriesCollection[options._name] = {};
            this.chartObj = chart;
            options._animationType = "path";
            var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
            var series = options;
            var spDirection = "";
            var splinesb = sf.EjSvgRender.utils._getStringBuilder();
            var style = this.setAreaSeriesStyle(series);
            var yIndex = 0, yIndex1 = 1;
            //Removed splineArea sorting behavior based on the 'X' points.
            if (series.sorting)
                series.points = sf.DataManager(series.points, sf.Query().sortBy("xValue")).executeLocal();
            var visiblePoints = this.chartObj.dragPoint ? series.pointCollection : this._isVisiblePoints(series);
            var ySpline = params.seriesCollection[series._name].naturalSpline || this.naturalSpline(visiblePoints, series, yIndex);
            var ySpline1 = params.seriesCollection[series._name].naturalSpline1 || this.naturalSpline(visiblePoints, series, yIndex1);
            var firstPoint = null;
            var secondPoint = null;
            var firstIndex = -1;
            var internalRegion = [];
            var origin = sf.EjSeriesRender.prototype.getOrigin(this, series, params);
            var startPoint = null;
            var start = true;
            var chartObj = this.chartObj;
            var translate = [], controlPointsCount = 0, controlPoints = params.seriesCollection[series._name].controlPoints || [];
            translate[0] = chartObj.canvasX;
            translate[1] = chartObj.canvasY;
            var count = 0, rangeDirection;
            var seriesIndex = chartObj.model._seriesIndex;
            var previousSeriesPoints = null;
            var stackingsplinepath = [];
            var seriesType = series.type.toLowerCase();
            var emptyPointSettings = series.emptyPointSettings;
            chartObj.model._previousSeries = sf.util.isNullOrUndefined(chartObj.model._previousSeries) ? null : chartObj.model._previousSeries;
            series._prevpointIndex = null;
            for (var i = 0; i < visiblePoints.length; i++) {
                internalRegion[i] = { Region: { PointIndex: i }, SeriesIndex: seriesIndex, region: [] };
                var pointIndex = i;
                secondPoint = visiblePoints[i];
                secondPoint.YValues[0] = seriesType.indexOf("stackingsplinearea") != -1 ? series.stackedValue.EndValues[i] : secondPoint.YValues[0];
                if (secondPoint.visible) {
                    if (!startPoint) {
                        if (seriesIndex == 0 || seriesType.indexOf('stackingsplinearea') == -1)
                            startPoint = { xValue: visiblePoints[i].xValue, YValues: [origin] };
                        else {
                            var actualIndex = $.inArray(options, chartObj.model._visibleSeries);
                            for (var m = actualIndex; m > 0; m--) {
                                var ser = chartObj.model.series[m - 1];
                                if (ser.visibility != "hidden") {
                                    previousSeriesPoints = ser.points;
                                    break;
                                }
                            }
                            startPoint = { xValue: visiblePoints[i].xValue, YValues: [previousSeriesPoints[i].YValues[0]] };
                        }
                        var startLoc = sf.EjSvgRender.utils._getPoint(startPoint, series);
                    }
                    if (seriesType == "splinerangearea")
                    {
                        var point1 = sf.EjSvgRender.utils._getPoint(visiblePoints[i], series);
                        internalRegion[i].region.push({ X: point1.X, Y: point1.Y });
                        if (i != 0)
                            internalRegion[i - 1].region.push({ X: point1.X, Y: point1.Y });
                    }
                    if (firstPoint != null) {
                        var controlPoint1 = null;
                        var controlPoint2 = null;
                        if (seriesType.indexOf("stackingsplinearea") != -1 || seriesType == "splinerangearea")
                            var data = controlPoints[pointIndex - 1] || this.getBezierControlPoints(firstPoint, secondPoint, ySpline[firstIndex], ySpline[pointIndex], yIndex, series, this);
                        else
                            var data = controlPoints[controlPointsCount++] || this.getBezierControlPoints(firstPoint, secondPoint, ySpline[firstIndex], ySpline[pointIndex], yIndex, series, this);
                        controlPoint1 = data["controlPoint1"];
                        controlPoint2 = data["controlPoint2"];
                        var pt1 = sf.EjSvgRender.utils._getPoint(firstPoint, series);
                        var pt2 = sf.EjSvgRender.utils._getPoint(secondPoint, series);
                        var bpt1 = sf.EjSvgRender.utils._getPoint(controlPoint1, series);
                        var bpt2 = sf.EjSvgRender.utils._getPoint(controlPoint2, series);
                        if (start) {
                            if (requireInvertedAxes)
                                splinesb.append("M" + " " + (startLoc.X) + " " + (pt1.Y) + " " + "L" + " " + (pt1.X) + " " + ((pt1.Y)) + " ");
                            else
                                splinesb.append("M" + " " + (pt1.X) + " " + (startLoc.Y) + " " + "L" + " " + (pt1.X) + " " + ((pt1.Y)) + " ");
                            start = false;
                        }
                        splinesb.append("C" + " " + (bpt1.X) + " " + (bpt1.Y) + " " + (bpt2.X) + " " + (bpt2.Y) + " " + (pt2.X) + " " + (pt2.Y) + " ");
                        if (seriesType == "splinerangearea") {
                            if (requireInvertedAxes)
                                stackingsplinepath[pointIndex] = ("C" + " " + (bpt2.low) + " " + (bpt2.Y) + " " + (bpt1.low) + " " + (bpt1.Y) + " " + (pt1.low) + " " + (pt1.Y) + " ");
                            else
                                stackingsplinepath[pointIndex] = ("C" + " " + (bpt2.X) + " " + (bpt2.low) + " " + (bpt1.X) + " " + (bpt1.low) + " " + (pt1.X) + " " + (pt1.low) + " ");

                        }if (seriesType.indexOf("stackingsplinearea") != -1)
                            stackingsplinepath[pointIndex] = ("C" + " " + (bpt2.X) + " " + (bpt2.Y) + " " + (bpt1.X) + " " + (bpt1.Y) + " " + (pt1.X) + " " + (pt1.Y) + " ");
                        if (pointIndex == visiblePoints.length - 1 || (pointIndex < visiblePoints.length - 1 && !visiblePoints[i + 1].visible)) {
                            if ((seriesIndex != 0 && seriesType.indexOf("stackingsplinearea") != -1) || seriesType == "splinerangearea") {
                                startPoint = { xValue: visiblePoints[i].xValue, YValues: seriesType == "splinerangearea" ? visiblePoints[i].YValues : [previousSeriesPoints[i].YValues[0]] };
                                startLoc = sf.EjSvgRender.utils._getPoint(startPoint, series);
                            }
                            if (requireInvertedAxes)
                                splinesb.append("L" + " " + (seriesType == "splinerangearea" ? pt2.low :startLoc.X) + " " +  (pt2.Y) + " ");
                            else
                                splinesb.append("L" + " " + (pt2.X) + " " + (seriesType == "splinerangearea" ? startLoc.low : startLoc.Y) + " ");
                            startPoint = null;
                            start = true;
                            if (emptyPointSettings.displayMode.toLowerCase() == "gap" && pointIndex != visiblePoints.length - 1 && seriesIndex != 0 && seriesType.indexOf("stacking") != -1) {
                                var minvalue = sf.util.isNullOrUndefined(series._prevpointIndex) ? 1 : series._prevpointIndex;
                                for (var j = pointIndex; j >= minvalue; j--) {
                                    if (visiblePoints[j - 1].visible && !sf.util.isNullOrUndefined(chartObj.model._previousSeries)) {
                                        splinesb.append(chartObj.model._previousSeries[j]);
                                        chartObj.model._previousSeries[j] = "";
                                    }
                                    else
                                        break;

                                }
                                series._prevpointIndex = pointIndex + 3;
                            }
                        }
                    }
                    else if (seriesType.indexOf('stackingsplinearea') != -1 || seriesType.indexOf("splinerangearea") != -1) {
                        if (pointIndex > 0 && emptyPointSettings.displayMode == "gap") {
                            this.drawbackCurve(controlPoints, series, stackingsplinepath, pointIndex, secondPoint);
                        }

                    }
                    firstPoint = secondPoint;
                    firstIndex = pointIndex;
                } else {
                    firstPoint = null;
                    if ((seriesType.indexOf("stackingsplinearea") != -1 || seriesType.indexOf("splinerangearea") != -1) && pointIndex > 0 && emptyPointSettings.displayMode == "gap") {
                        this.drawbackCurve(controlPoints, series, stackingsplinepath, pointIndex, secondPoint);
                    }
                }
            }
            if (chartObj.model.series[seriesIndex].type.toLowerCase() == "splinerangearea") {
                for (var i = visiblePoints.length - 1; i >= 0; i--) {
                    origin = visiblePoints[i].low;
                    var point = { xValue: visiblePoints[i].xValue, YValues: [origin] };
                    var point2 = sf.EjSvgRender.utils._getPoint(point, series);
                    internalRegion[i].region.push({ X: point2.X, Y: point2.Y });
                    if (i != 0)
                        internalRegion[i - 1].region.push({ X: point2.X, Y: point2.Y });
                }
            }
            spDirection = splinesb.toString();
            if (seriesType.indexOf("stackingsplinearea") != -1 && seriesIndex > 0) {
                chartObj.model._previousSeries = this._getReversePath(chartObj, seriesIndex, chartObj.model._previousSeries);
            }
            if (seriesType == "splinerangearea") {
                rangeDirection = this._getReversePath(chartObj, seriesIndex, stackingsplinepath);
                spDirection = spDirection + rangeDirection + "Z";
            }
            else {
                spDirection = sf.util.isNullOrUndefined(chartObj.model._previousSeries) ? spDirection : spDirection + chartObj.model._previousSeries + "Z";
                chartObj.model._previousSeries = stackingsplinepath;
            }
            if (seriesType == "splinerangearea")
                this.chartObj.model.chartRegions.push(internalRegion);
            this.drawAreaPath(series, style, spDirection, translate);
            if (this.chartObj.dragPoint)
                this.chartObj.svgRenderer.append(this.chartObj.gPreviewSeriesGroupEle, this.chartObj.gSeriesEle);
            else
                this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);
			this.chartObj.gSeriesGroupEle = this.gSeriesGroupEle;

        },
        stackingSeries: true,

        _getReversePath: function (chartObj, seriesIndex, reversePath) {
            var emptyPointSettings = chartObj.model.series[seriesIndex].emptyPointSettings,
                path = "", points = chartObj.model.series[seriesIndex].points;
            if (!sf.util.isNullOrUndefined(reversePath)) {
                for (var i = 0; i < points.length; i++) {
                    var pointIndex = i;
                    if (!points[pointIndex].visible) {
                        if (!points[pointIndex].isEmpty || emptyPointSettings.displayMode == "gap") {
                            if (pointIndex == 0) {
                                if (reversePath[pointIndex + 1])
                                    reversePath[pointIndex + 1] = "";
                            }
                            else if (pointIndex == points.length - 1) {
                                if (reversePath[pointIndex])
                                    reversePath[pointIndex] = "";
                            }
                            else {
                                if (reversePath[pointIndex])
                                    reversePath[pointIndex] = "";
                                if (reversePath[pointIndex + 1])
                                    reversePath[pointIndex + 1] = "";
                            }
                        }

                    }
                }
                for (var j = reversePath.length - 1; j > 0; j--) {
                    path = path + reversePath[j];
                }
            }
            return path;
        },

        drawbackCurve: function (controlPoints, series, stackingsplinepath, pointIndex, secondPoint) {
            var data = controlPoints[pointIndex - 1],
            controlPoint1 = data["controlPoint1"],
            controlPoint2 = data["controlPoint2"];
            var pt1 = sf.EjSvgRender.utils._getPoint(series.points[pointIndex - 1], series);
            var pt2 = sf.EjSvgRender.utils._getPoint(secondPoint, series);
            var bpt1 = sf.EjSvgRender.utils._getPoint(controlPoint1, series);
            var bpt2 = sf.EjSvgRender.utils._getPoint(controlPoint2, series);
            stackingsplinepath[pointIndex] = ("C" + " " + (bpt2.X) + " " + (bpt2.Y) + " " + (bpt1.X) + " " + (bpt1.Y) + " " + (pt1.X) + " " + (pt1.Y) + " ");
        }
    });

    sf.seriesTypes.splinearea = sf.ejSplineAreaSeries;
    sf.seriesTypes.stackingsplinearea = sf.ejSplineAreaSeries;
    sf.seriesTypes.stackingsplinearea100 = sf.ejSplineAreaSeries;



    sf.ejScatterSeries = ejExtendClass(sf.EjSeriesRender, {



        draw: function (chart, options) {
            this.chartObj = chart;
            var series = options;
            options._animationType = "scatter";
            var seriesIndex = $.inArray(options, this.chartObj.model._visibleSeries);
            var visiblePoints = series.points.length > 100 || !series.enableSmartLabels ? this.improveChartPerformance(series) : this._isVisiblePoints(series);
            var visiblePointsLength = visiblePoints.length;
            var point, point1;
            options._visiblePoints = visiblePoints;
            for (var i = 0; i < visiblePointsLength; i++) {
                point = visiblePoints[i];
                var pointIndex = i;
                point1 = sf.EjSvgRender.utils._getPoint(point, options);
                this.drawSymbol(seriesIndex, options, pointIndex, point1.X, point1.Y);
            }

        }
    });

    sf.seriesTypes.scatter = sf.ejScatterSeries;


    sf.ejBubbleSeries = ejExtendClass(sf.EjSeriesRender, {

        createBubbleGroup: function (series) {

            var seriesIndex = $.inArray(series, this.chartObj.model.series);
            var areaBoundsX = this.chartObj.model.m_AreaBounds.X;
            var areaBoundsY = this.chartObj.model.m_AreaBounds.Y;
            var isTransposed = series._isTransposed;
            var transX = isTransposed ? areaBoundsX : series.xAxis.x;

            var transY = isTransposed ? areaBoundsY : series.yAxis.y;
            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + transX + ',' + transY + ')' };

            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);

        },
        draw: function (chart, options) {
            this.chartObj = chart;
            options._animationType = "bubble";
            var series = options;
            var cornerRadius = series.cornerRadius;
            series.points = sf.DataManager(series.points, sf.Query().sortBy("xValue")).executeLocal();
            var seriesIndex = $.inArray(series, this.chartObj.model._visibleSeries);
            var visiblePoints = this._isVisiblePoints(series);
            var sizeValueIndex = 1;
            //bubble responsive
            var bubbleOptions = options.bubbleOptions;
            var mode = bubbleOptions.radiusMode.toLowerCase();
            var temp = 100, minRadius, maxRadius, maxValue, points;
            var areaBounds = chart.model.m_AreaBounds;
            var visibleSeries = chart.model._visibleSeries, maximumSize = 0;
            var value = Math.max(areaBounds.Height, areaBounds.Width);
            var segmentRadius, radius, percentChange;

            if (mode == "minmax") {  // minmax mode radius calculation
                percentChange = value / temp;
                minRadius = bubbleOptions.minRadius * percentChange;
                maxRadius = bubbleOptions.maxRadius * percentChange;
                radius = maxRadius - minRadius;
                maximumSize = Math.max.apply(0, $.map(visiblePoints, function (v) { return v.YValues[sizeValueIndex]; }));
            } else {    // auto mode radius calculation
                maxValue = (value / 5) / 2;
                minRadius = maxRadius = 1;
                radius = maxValue * maxRadius;
                for (var m = 0; m < visibleSeries.length; m++) {
                    if (visibleSeries[m].type.toLowerCase() == "bubble" && visibleSeries[m].visibility == "visible"
                        && visibleSeries[m].bubbleOptions.radiusMode.toLowerCase() == "auto") {
                        points = visibleSeries[m]._visiblePoints;
                        for (var n = 0; n < points.length; n++)
                            maximumSize = maximumSize < points[n].YValues[sizeValueIndex] ? points[n].YValues[sizeValueIndex] : maximumSize;
                    }
                }
            }
            this.createBubbleGroup(series);
            for (var i = 0; i < visiblePoints.length; i++) {
                var point = visiblePoints[i];
                var pointIndex = i;
                if (point.visible) {
					maximumSize = maximumSize ? maximumSize : 1;
                    if (series.bubbleOptions.radiusMode.toLowerCase() == "minmax")
                        segmentRadius = minRadius + radius * Math.abs(point.YValues[sizeValueIndex] / maximumSize);
                    else
                        segmentRadius = radius * Math.abs(point.YValues[sizeValueIndex] / maximumSize);

                    var location = sf.EjSvgRender.utils._getPoint(point, series);

                    var styleOptions = this.chartObj.setStyle(this, series, seriesIndex, pointIndex);

                    var options = {
                        'id': this.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex,
                        'cx': location.X + this.chartObj.canvasX,
                        'cy': (location.Y) + this.chartObj.canvasY,
                        'r': segmentRadius,
                        'fill': styleOptions.interior,
                        'cornerRadius': cornerRadius,
                        'stroke-width': styleOptions.borderWidth,
                        'stroke-dasharray': styleOptions.dashArray,
                        'opacity': styleOptions.opacity,
                        'stroke': styleOptions.borderColor
                    };
                    if ((typeof (cornerRadius) != "object" && cornerRadius > 0) || cornerRadius.topLeft > 0 || cornerRadius.bottomLeft > 0
                        || cornerRadius.topRight > 0 || cornerRadius.bottomRight > 0)           //calculate path for rounded corner
                    {
                        var roundrect = sf.EjSvgRender.utils.calculateroundedCorner(options);
                        options.d = roundrect;
                        this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle);
                    }
                    else

                        point.radius = segmentRadius; // radius is stored to draw tracksymbol for bubble in canvas

                    this.chartObj.svgRenderer.drawCircle(options, this.gSeriesGroupEle);



                    var cx = location.X;
                    var cy = location.Y;
                    var r = segmentRadius;


                    var valwidth, x, y, valheight;
                    x = ((cx - r) + (series.isTransposed ? this.chartObj.model.m_AreaBounds.X : series.xAxis.x));
                    y = ((cy - r) + (series.isTransposed ? this.chartObj.model.m_AreaBounds.Y : series.yAxis.y));

                    valheight = 2 * r;
                    valwidth = 2 * r;

                    var bounds = { X: x, Y: y, Width: valwidth, Height: valheight };
                    sf.EjSvgRender.utils._addRegion(this.chartObj, bounds, series, null, i);
                }
            }
            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

        }
    });

    sf.seriesTypes.bubble = sf.ejBubbleSeries;
    sf.ejhiloSeries = ejExtendClass(sf.EjSeriesRender, {
        draw: function (chart, options, params) {

            this.chartObj = chart;
            options._animationType = "hilo";
            var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
            //DrawHiloGraph      

            var currentseries = options;
            currentseries.points = sf.DataManager(currentseries.points, sf.Query().sortBy("xValue")).executeLocal();
            var visiblePoints = this._isVisiblePoints(currentseries);
            var sidebysideinfo = this.getSideBySideInfo(currentseries, params);
            var point = null;

            var seriesIndex = $.inArray(currentseries, this.chartObj.model._visibleSeries);
            var trans = sf.EjSvgRender.utils._getTransform(currentseries.xAxis, currentseries.yAxis, requireInvertedAxes);
            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };
            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);


            for (var i = 0; i < visiblePoints.length; i++) {
                point = visiblePoints[i];
                var pointIndex = i;
                if (point.visible) {

                    var lDirection = "";
                    if (sf.util.isNullOrUndefined(point.YValues[0]) || sf.util.isNullOrUndefined(point.YValues[1]))
                        continue;

                    var styleOptions = this.chartObj.setStyle(this, currentseries, seriesIndex, pointIndex);

                    var pathInterior = this.chartObj.setHiloStyle(currentseries, pointIndex, seriesIndex);


                    var lowvalue = {}, highvalue = {};
                    if (point.YValues[0] < point.YValues[1]) {
                        lowvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[0]] };
                        highvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[1]] };
                    } else {
                        lowvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[1]] };
                        highvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[0]] };
                    }
                    var point1 = sf.EjSvgRender.utils._getPoint(lowvalue, currentseries);
                    var point2 = sf.EjSvgRender.utils._getPoint(highvalue, currentseries);
                    lDirection = "M" + " " + (point1.X + this.chartObj.canvasX) + " " + ((point1.Y + this.chartObj.canvasY)) + " " + "L" + " " + (point2.X + this.chartObj.canvasX) + " " + ((point2.Y + this.chartObj.canvasY)) + " ";
                    var pointbounds = { point1: point1, point2: point2 };
                    this._drawHiloPath(currentseries, styleOptions, pathInterior, lDirection, i, pointbounds);
                }
            }

            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);
        },

        hiloTypes: true
    });

    sf.seriesTypes.hilo = sf.ejhiloSeries;

    //Draw HiloOpenClose
    sf.ejhiloopencloseSeries = ejExtendClass(sf.EjSeriesRender, {
        draw: function (chart, options, params) {

            this.chartObj = chart;
            var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
            //DrawHiloGraph      
            options._animationType = "hilo";
            var currentseries = options;
            currentseries.points = sf.DataManager(currentseries.points, sf.Query().sortBy("xValue")).executeLocal();
            var visiblePoints = this._isVisiblePoints(currentseries);
            var sidebysideinfo = this.getSideBySideInfo(currentseries, params);
            var point = null;
            var paletteColor = this.chartObj.model.palette;
            var seriesIndex = $.inArray(currentseries, this.chartObj.model._visibleSeries);
            var trans = sf.EjSvgRender.utils._getTransform(currentseries.xAxis, currentseries.yAxis, requireInvertedAxes);
            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };
            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);

            var interior;




            for (var i = 0; i < visiblePoints.length; i++) {
                var pointIndex = i;
                point = visiblePoints[i];
                if (point.visible) {

                    var lDirection = "";
                    var drawOpenWing = (sf.util.isNullOrUndefined(currentseries.drawMode) ? true : (currentseries.drawMode.toLowerCase() == "both" || currentseries.drawMode.toLowerCase() == "open") ? true : false);
                    var drawCloseWing = (sf.util.isNullOrUndefined(currentseries.drawMode) ? true : (currentseries.drawMode.toLowerCase() == "both" || currentseries.drawMode.toLowerCase() == "close") ? true : false);


                    var lowvalue = {}, highvalue = {}, openvalue = {}, closevalue = {};


                    if (point.YValues[0] < point.YValues[1]) {
                        lowvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[0]] };
                        highvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[1]] };
                        openvalue = { xValue: point.xValue, YValues: [point.YValues[2]] };
                        closevalue = { xValue: point.xValue, YValues: [point.YValues[3]] };

                    } else {
                        lowvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[1]] };
                        highvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[0]] };
                        openvalue = { xValue: point.xValue, YValues: [point.YValues[2]] };
                        closevalue = { xValue: point.xValue, YValues: [point.YValues[3]] };

                    }
                    currentseries.fill = currentseries.isFill ? currentseries.fill : null;
                    if (point.YValues[2] < point.YValues[3])
                        currentseries.bearFillColor = interior = (sf.util.isNullOrUndefined(currentseries.bearFillColor)) ? ((currentseries.fill) ? currentseries.fill : ((paletteColor && paletteColor.length > 0) ? paletteColor[seriesIndex] : "#339933")) : currentseries.bearFillColor;

                    else
                        currentseries.bullFillColor = interior = (sf.util.isNullOrUndefined(currentseries.bullFillColor)) ? ((currentseries.fill) ? currentseries.fill : ((paletteColor && paletteColor.length > 0) ? paletteColor[seriesIndex] : "#E51400")) : currentseries.bullFillColor;


                    var styleOptions = this.chartObj.setStyle(this, currentseries, seriesIndex, pointIndex, interior);

                    var pathInterior = this.chartObj.setHiloStyle(currentseries, pointIndex, seriesIndex, interior);


                    if (point.fill) {
                        interior = jQuery.type(point.interior) == "array" ? point.fill[0] : point.fill;
                    }
                    else {
                        point._hiloFill = interior;
                    }
                    var canvasX = this.chartObj.canvasX;
                    var canvasY = this.chartObj.canvasY;

                    //Draw open points
                    if (drawOpenWing) {

                        var startOpenValue = { xValue: openvalue.xValue + sidebysideinfo.Median, YValues: openvalue.YValues };
                        var pto1 = sf.EjSvgRender.utils._getPoint(startOpenValue, currentseries);
                        var endOpenValue = { xValue: openvalue.xValue + sidebysideinfo.Start, YValues: openvalue.YValues };
                        var pto2 = sf.EjSvgRender.utils._getPoint(endOpenValue, currentseries);
                        lDirection = "M" + " " + (pto1.X + canvasX) + " " + ((pto1.Y + canvasY)) + " " + "L" + " " + (pto2.X + canvasX) + " " + ((pto2.Y + canvasY)) + " ";
                        var openbounds = { point1: pto1, point2: pto2 };
                        this._drawHiloPath(currentseries, styleOptions, pathInterior, lDirection, i, openbounds);
                        lDirection = "";

                    }
                    //Draw close points
                    if (drawCloseWing) {
                        var startCloseValue = { xValue: closevalue.xValue + sidebysideinfo.Median, YValues: closevalue.YValues };
                        var ptc1 = sf.EjSvgRender.utils._getPoint(startCloseValue, currentseries);
                        var endCloseValue = { xValue: closevalue.xValue + sidebysideinfo.End, YValues: closevalue.YValues };
                        var ptc2 = sf.EjSvgRender.utils._getPoint(endCloseValue, currentseries);
                        lDirection = "M" + " " + (ptc1.X + canvasX) + " " + ((ptc1.Y + canvasY)) + " " + "L" + " " + (ptc2.X + canvasX) + " " + ((ptc2.Y + canvasY)) + " ";
                        var pointbounds = { point1: ptc1, point2: ptc2 };
                        this._drawHiloPath(currentseries, styleOptions, pathInterior, lDirection, i, pointbounds);
                        lDirection = "";

                    }
                    // Draw High low points
                    var point1 = sf.EjSvgRender.utils._getPoint(lowvalue, currentseries);
                    var point2 = sf.EjSvgRender.utils._getPoint(highvalue, currentseries);
                    lDirection = "M" + " " + (point1.X + canvasX) + " " + ((point1.Y + canvasY)) + " " + "L" + " " + (point2.X + canvasX) + " " + ((point2.Y + canvasY)) + " ";
                    var bounds = { point1: point1, point2: point2 };
                    this._drawHiloPath(currentseries, styleOptions, pathInterior, lDirection, i, bounds);
                }

            }
            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

        },

        hiloTypes: true

    });

    sf.seriesTypes.hiloopenclose = sf.ejhiloopencloseSeries;

    //Draw candle
    sf.ejCandleSeries = ejExtendClass(sf.EjSeriesRender, {
        draw: function (chart, options, params) {

            this.chartObj = chart;
            options._animationType = "hilo";
            var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
            //DrawCandleGraph      

            var currentseries = options;
            currentseries.points = sf.DataManager(currentseries.points, sf.Query().sortBy("xValue")).executeLocal();
            var visiblePoints = this._isVisiblePoints(currentseries);
            var sidebysideinfo = this.getSideBySideInfo(currentseries, params);
            var point = null;
            var paletteColor = this.chartObj.model.palette;
            var seriesIndex = $.inArray(currentseries, this.chartObj.model._visibleSeries);
            var trans = sf.EjSvgRender.utils._getTransform(currentseries.xAxis, currentseries.yAxis, requireInvertedAxes);
            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };
            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
            var interior, defaultrectHeight = 1;

            for (var i = 0; i < visiblePoints.length; i++) {
                point = visiblePoints[i];
                var pointIndex = i;
                if (point.visible) {

                    var lDirection = "";

                    var lowvalue = {}, highvalue = {}, openvalue = {}, closevalue = {};


                    if (point.YValues[0] < point.YValues[1]) {
                        lowvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[0]] };
                        highvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[1]] };
                        openvalue = { xValue: point.xValue, YValues: [point.YValues[2]] };
                        closevalue = { xValue: point.xValue, YValues: [point.YValues[3]] };

                    } else {
                        lowvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[1]] };
                        highvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[0]] };
                        openvalue = { xValue: point.xValue, YValues: [point.YValues[2]] };
                        closevalue = { xValue: point.xValue, YValues: [point.YValues[3]] };

                    }
                    if (point.YValues[2] < point.YValues[3]) {

                        openvalue = { xValue: point.xValue, YValues: [point.YValues[2]] };
                        closevalue = { xValue: point.xValue, YValues: [point.YValues[3]] };
                        currentseries.bearFillColor = interior = (sf.util.isNullOrUndefined(currentseries.bearFillColor)) ? ((paletteColor && paletteColor.length > 0) ? paletteColor[seriesIndex] : "#339933") : currentseries.bearFillColor;

                    } else {

                        openvalue = { xValue: point.xValue, YValues: [point.YValues[3]] };
                        closevalue = { xValue: point.xValue, YValues: [point.YValues[2]] };
                        currentseries.bullFillColor = interior = (sf.util.isNullOrUndefined(currentseries.bullFillColor)) ? ((paletteColor && paletteColor.length > 0) ? paletteColor[seriesIndex] : "#E51400") : currentseries.bullFillColor;

                    }

                    var styleOptions = this.chartObj.setStyle(this, currentseries, seriesIndex, pointIndex, interior);

                    var pathInterior = this.chartObj.setHiloStyle(currentseries, pointIndex, seriesIndex, interior);

                    if (point.style && point.style.interior) {
                        interior = jQuery.type(point.style.interior) == "array" ? point.style.interior[0] : point.style.interior;
                    }

                    else {
                        point._hiloFill = pathInterior;
                    }

                    //Draw High low points
                    var point1 = sf.EjSvgRender.utils._getPoint(lowvalue, currentseries);
                    var point2 = sf.EjSvgRender.utils._getPoint({ xValue: openvalue.xValue + sidebysideinfo.Median, YValues: [openvalue.YValues[0]] }, currentseries);
                    var point3 = sf.EjSvgRender.utils._getPoint({ xValue: closevalue.xValue + sidebysideinfo.Median, YValues: [closevalue.YValues[0]] }, currentseries);
                    var point4 = sf.EjSvgRender.utils._getPoint(highvalue, currentseries);
                    var canvasX = this.chartObj.canvasX;
                    var canvasY = this.chartObj.canvasY;
                    lDirection = "M" + " " + (point1.X + canvasX) + " " + ((point1.Y + canvasY)) + " " + "L" + " " + (point2.X + canvasX) + " " + ((point2.Y + canvasY)) + " " + "M" + " " + (point3.X + canvasX) + " " + ((point3.Y + canvasY)) + " " + "L" + " " + (point4.X + canvasX) + " " + ((point4.Y + canvasY)) + " ";
                    var pointbounds = { point1: point1, point2: point2 };
                    this._drawHiloPath(currentseries, styleOptions, pathInterior, lDirection, i, pointbounds);
                    //Draw open and close points

                    var startRect = { xValue: closevalue.xValue + sidebysideinfo.Start, YValues: closevalue.YValues };
                    var orginRect = sf.EjSvgRender.utils._getPoint(startRect, currentseries);

                    var rectSize = { xValue: openvalue.xValue + sidebysideinfo.End, YValues: openvalue.YValues },
                        sizeRect = sf.EjSvgRender.utils._getPoint(rectSize, currentseries),
                        rect = sf.EjSvgRender.utils._correctRect(orginRect.X, orginRect.Y, sizeRect.X, sizeRect.Y);
                    //line is drawn when open and close value are same 
                    if (openvalue.YValues[0] == closevalue.YValues[0]) {
                        rect.Y = orginRect.Y - (defaultrectHeight / 2);
                        rect.Height = defaultrectHeight;
                    }
                    var candleOptions = {
                        'id': this.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + i,
                        'x': rect.X + this.chartObj.canvasX,
                        'y': rect.Y + this.chartObj.canvasY,
                        'width': rect.Width,
                        'height': rect.Height,
                        'fill': styleOptions.interior,
                        'stroke-width': styleOptions.borderWidth,
                        'stroke-dasharray': styleOptions.dashArray,
                        'stroke': styleOptions.borderColor
                    };

                    this.chartObj.svgRenderer.drawRect(candleOptions, this.gSeriesGroupEle);

                    var svgXy = sf.EjSvgRender.utils._getSvgXY(rect.X, rect.Y, currentseries, this.chartObj);
                    var bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };

                    sf.EjSvgRender.utils._addRegion(this.chartObj, bounds, currentseries, point, i);

                }

            }
            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);


        },

        hiloTypes: true
    });
    sf.seriesTypes.candle = sf.ejCandleSeries;

    sf.ejPieOfPieSeries = ejExtendClass(sf.EjSeriesRender, {
        draw: function (chart, options) {
            this.chartObj = chart;
            var series = new sf.seriesTypes["pie"]();
            series.draw(chart, options);
        },
        chartAreaType: "None"
    });
    sf.seriesTypes.pieofpie = sf.ejPieOfPieSeries;

    sf.ejPieSeries = ejExtendClass(sf.EjSeriesRender, {

        draw: function (chart, options) {

            this.chartObj = chart;
            var currentseries = options;
            var internalRegion = [];
            var seriesType = options.type.toLowerCase();
            var pieSeriesIndex = options.collectionIndex;
            var coefficient = pieSeriesIndex == 0 ? currentseries.pieCoefficient : currentseries.pieOfPieCoefficient;
            var isCanvas = this.chartObj.model.enableCanvasRendering;
            var visiblePoints = this._calculateVisiblePoints(options, this.chartObj).visiblePoints;

            var size = this.calculatingSliceAngle(currentseries);
            var seriesIndex = $.inArray(currentseries, this.chartObj.model._visibleSeries);
            var seriesLength = this.chartObj.model._visibleSeries.length;

            var currentSeries = this.chartObj.model._visibleSeries[seriesIndex];
            currentSeries._pieCoefficient = currentSeries.pieCoefficient;
            if (this.chartObj.model.circularRadius.length > 1) {
                for (var i = seriesIndex; !sf.util.isNullOrUndefined(currentSeries.zOrder) ? i >= 0 : i < this.chartObj.model.circularRadius.length; !sf.util.isNullOrUndefined(currentSeries.zOrder) ? i-- : i++) {
                    if (!sf.util.isNullOrUndefined(this.chartObj.model.circularRadius[i])) {
                        this.chartObj.model.circularRadius[seriesIndex] = this.chartObj.model.circularRadius[i] * currentSeries._pieCoefficient;
                        break;
                    }
                }
            }
            else {
                if (seriesType == "pieofpie" && currentSeries.splitMode != "")
                    this.chartObj.model.circularRadius[pieSeriesIndex] = 0.25 * coefficient * Math.min(size.width, size.height);
                else
                    this.chartObj.model.circularRadius[seriesIndex] = 0.5 * currentSeries._pieCoefficient * Math.min(size.width, size.height);
            }

            var min = Math.min(size.width, size.height);
            if (min < 0) {
                return min;
            }
            var totalDegree = Math.abs(currentseries.endAngle - currentseries.startAngle);
            if (totalDegree < 270)
                this.pieDoughnutCenter(currentseries);
            var text;

            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex };
            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);

            var visibility = (currentseries.enableAnimation && !currentseries._animatedSeries) ? 'hidden' : 'visible';


            var txtOptions = { 'id': this.chartObj.svgObject.id + '_TextGroup' + '_' + seriesIndex, 'visibility': visibility };
            if (!this.chartObj.gSeriesTextEle) this.chartObj.gSeriesTextEle = [];
            this.chartObj.gSeriesTextEle[seriesIndex] = pieSeriesIndex == 1 ? this.chartObj.gSeriesTextEle[0] : this.chartObj.svgRenderer.createGroup(txtOptions);
            var symbolOptions = { 'id': this.chartObj.svgObject.id + '_symbolGroup' + '_' + seriesIndex, 'visibility': visibility };
            if (!this.chartObj.gSymbolGroupEle) this.chartObj.gSymbolGroupEle = [];
            this.chartObj.gSymbolGroupEle[seriesIndex] = this.chartObj.svgRenderer.createGroup(symbolOptions);

            var connectorOptions = { 'id': this.chartObj.svgObject.id + '_connectorGroup' + '_' + seriesIndex, 'visibility': visibility };
            if (!this.chartObj.gConnectorEle) this.chartObj.gConnectorEle = [];
            this.chartObj.gConnectorEle[seriesIndex] = this.chartObj.svgRenderer.createGroup(connectorOptions);
            var dataLabelOptions = { 'id': this.chartObj.svgObject.id + '_DataLabel_' + seriesIndex, 'visibility': visibility };
            if (!this.chartObj.gDataLabelEle) this.chartObj.gDataLabelEle = [];
            this.chartObj.gDataLabelEle[seriesIndex] = pieSeriesIndex == 1 ? this.chartObj.gDataLabelEle[0] : this.chartObj.svgRenderer.createGroup(dataLabelOptions);


            for (var j = 0; j < visiblePoints.length; j++) {
                var pointIndex = this.chartObj.model._isPieOfPie ? visiblePoints[j].actualIndex : j;
                if (isNaN(currentseries._visiblePoints[j].startAngle)) continue;
                var point = currentseries._visiblePoints[j];
                if (point.visible) {
                    var result = this._calculateArcData(this.chartObj, pointIndex, point, currentseries, seriesIndex, pieSeriesIndex);
                    var sliceXY = result.Direction.split(" ");
                    var styleOptions = this.chartObj.setStyle(this, currentseries, seriesIndex, j);
                    if (currentseries.startAngle < currentseries.endAngle) // for canvas rendering with modified start and end angle
                        var counterClockWise = false;
                    else
                        counterClockWise = true;
                    if (!this.chartObj.model._isPieOfPie) {
                        for (var k = 0; k < currentseries.visiblePoints.length; k++) {
                            if (point == currentseries.visiblePoints[k]) {
                                pointIndex = k;
                                break;
                            }
                        }
                    }
                    options = {
                        'id': this.chartObj.svgObject.id + '_Series' + seriesIndex + "_Point" + pointIndex,
                        'fill': styleOptions.interior,
                        'stroke-width': styleOptions.borderWidth,
                        'stroke': styleOptions.borderColor,
                        'stroke-dasharray': styleOptions.dashArray,
                        'stroke-linecap': currentseries.lineCap,
                        'stroke-linejoin': currentseries.lineJoin,
                        'd': result.Direction,
                        'opacity': styleOptions.opacity,
                        'data-pointIndex': pointIndex,
                    };

                    var canvasOptions = {
                        'id': this.chartObj.svgObject.id + '_Series' + seriesIndex + "_Point" + pointIndex,
                        'fill': styleOptions.interior,
                        'stroke-width': styleOptions.borderWidth,
                        'stroke': styleOptions.borderColor,
                        'stroke-dasharray': styleOptions.dashArray,
                        'stroke-linecap': currentseries.lineCap,
                        'stroke-linejoin': currentseries.lineJoin,
                        'd': result.Direction,
                        'opacity': styleOptions.opacity,
                        'radius': seriesType == "pieofpie" ? this.chartObj.model.circularRadius[pieSeriesIndex] : this.chartObj.model.circularRadius[seriesIndex],
                        'start': point.startAngle - 1.57,
                        'end': point.endAngle - 1.57,
                        'data-pointIndex': pointIndex,
                        'counterClockWise': counterClockWise,
                        'innerR': 0,
                        'cx': result.centerX,
                        'cy': result.centerY,
                        'x': sliceXY[12],
                        'y': sliceXY[13]
                    };

                    if (isCanvas)
                        this.chartObj.svgRenderer.drawPath(canvasOptions, this.gSeriesGroupEle);
                    else
                        this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle);

                    region = {
                        PointIndex: pointIndex, Index: j, StartAngle: point.startAngle, EndAngle: point.endAngle, StartX: this.chartObj.model.startX[pointIndex], StartY: this.chartObj.model.startY[pointIndex],
                        PieSeriesIndex: pieSeriesIndex, SeriesIndex: $.inArray(currentseries, this.chartObj.model._visibleSeries)
                    };
                    internalRegion.push(region);

                }
            }
            var seriesIndex = this.chartObj.model._isPieOfPie ? pieSeriesIndex : seriesIndex;

            if (this.chartObj.model._isPieOfPie && pieSeriesIndex == 1
                && currentSeries.pieCollections[0].length > 0 && currentSeries.pieCollections[1].length == 0) {
                var emptyCircleOptions = this._drawEmptyPieOfPie(this.chartObj);
                this.chartObj.svgRenderer.drawPath(emptyCircleOptions, this.gSeriesGroupEle);
            }

            var seriesData = { Radius: this.chartObj.model.circularRadius[seriesIndex], CenterX: this.chartObj.model.circleCenterX[seriesIndex], CenterY: this.chartObj.model.circleCenterY[seriesIndex] };
            var region = { Series: currentseries, SeriesData: seriesData, Region: internalRegion, SeriesIndex: $.inArray(currentseries, this.chartObj.model._visibleSeries) };
            this.chartObj.model.chartRegions.push(region);

            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);
        },

        chartAreaType: "None"

    });

    sf.seriesTypes.pie = sf.ejPieSeries;

    sf.ejDoughnutSeries = ejExtendClass(sf.EjSeriesRender, {
        draw: function (chart, options) {
            this.chartObj = chart;
            var currentseries = options;
            var internalRegion = [];

            var visiblePoints = this._calculateVisiblePoints(options).visiblePoints;
            var size = this.calculatingSliceAngle(currentseries), isCanvas = this.chartObj.model.enableCanvasRendering;
            var visiblePointslength = visiblePoints.length;
            var seriesIndex = $.inArray(currentseries, this.chartObj.model._visibleSeries);
            var seriesLength = this.chartObj.model._visibleSeries.length;
            var seriesLength = this.chartObj.model._visibleSeries.length;
            var currentSeries = this.chartObj.model._visibleSeries[seriesIndex];
            currentSeries._doughnutSize = currentSeries.doughnutSize;
            currentSeries._doughnutCoefficient = currentSeries.doughnutCoefficient;
            if (this.chartObj.model.circularRadius.length > 1) {
                for (var i = seriesIndex; !sf.util.isNullOrUndefined(currentSeries.zOrder) ? i >= 0 : i < this.chartObj.model.circularRadius.length; !sf.util.isNullOrUndefined(currentSeries.zOrder) ? i-- : i++) {
                    if (!sf.util.isNullOrUndefined(this.chartObj.model.circularRadius[i])) {
                        this.chartObj.model.circularRadius[seriesIndex] = this.chartObj.model.circularRadius[i] * currentSeries._doughnutSize;
                        break;
                    }
                }
            }
            else
                this.chartObj.model.circularRadius[seriesIndex] = 0.5 * currentSeries._doughnutSize * Math.min(size.width, size.height);
            var min = Math.min(size.width, size.height);
            if (min < 0) {
                return min;
            }
            var totalDegree = Math.abs(currentseries.endAngle - currentseries.startAngle);
            if (totalDegree < 270)//for centering the chart
                this.pieDoughnutCenter(currentseries);
            this.chartObj.model.innerRadius[seriesIndex] = currentSeries._doughnutCoefficient * this.chartObj.model.circularRadius[seriesIndex];


            var numberToFixed = sf.util.isNullOrUndefined(this.chartObj.model.roundingPlaces) ? 2 : this.chartObj.model.roundingPlaces;

            var seriesIndex = $.inArray(currentseries, this.chartObj.model._visibleSeries);
            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex };
            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);

            var visibility = (currentseries.enableAnimation && !currentseries._animatedSeries) ? 'hidden' : 'visible';


            var txtOptions = { 'id': this.chartObj.svgObject.id + '_TextGroup' + '_' + seriesIndex, 'visibility': visibility };
            if (!this.chartObj.gSeriesTextEle) this.chartObj.gSeriesTextEle = [];
            this.chartObj.gSeriesTextEle[seriesIndex] = this.chartObj.svgRenderer.createGroup(txtOptions);

            var symbolOptions = { 'id': this.chartObj.svgObject.id + '_symbolGroup' + '_' + seriesIndex, 'visibility': visibility };
            if (!this.chartObj.gSymbolGroupEle) this.chartObj.gSymbolGroupEle = [];
            this.chartObj.gSymbolGroupEle[seriesIndex] = this.chartObj.svgRenderer.createGroup(symbolOptions);

            var connectorOptions = { 'id': this.chartObj.svgObject.id + '_connectorGroup' + '_' + seriesIndex, 'visibility': visibility };
            if (!this.chartObj.gConnectorEle) this.chartObj.gConnectorEle = [];
            this.chartObj.gConnectorEle[seriesIndex] = this.chartObj.svgRenderer.createGroup(connectorOptions);

            var dataLabelOptions = { 'id': this.chartObj.svgObject.id + '_DataLabel_' + seriesIndex, 'visibility': visibility };
            if (!this.chartObj.gDataLabelEle) this.chartObj.gDataLabelEle = [];
            this.chartObj.gDataLabelEle[seriesIndex] = this.chartObj.svgRenderer.createGroup(dataLabelOptions);
            if ((currentseries._doughnutSize > 0) && (currentSeries._doughnutCoefficient >= 0) && (currentseries._doughnutSize <= 1) && (currentSeries._doughnutCoefficient <= 1)) {

                for (var j = 0; j < visiblePointslength; j++) {
                    var point = currentseries._visiblePoints[j];
                    var pointIndex = j;
                    if (point.visible) {
                        var explodeX = 0;
                        var explodeY = 0;
                        var result = this._calculateArcData(this.chartObj, pointIndex, point, currentseries, seriesIndex);
                        //for canvas slice explode
                        if ((point.actualIndex == currentseries.explodeIndex || currentseries.explodeAll) && !this.chartObj.vmlRendering) {
                            var chartStartAngle = -.5 * Math.PI;
                            var startAngle = point.startAngle + chartStartAngle;
                            var endAngle = point.endAngle + chartStartAngle - 0.000001;
                            var midAngle = (startAngle + endAngle) / 2;
                            explodeX = this.chartObj.model.circleCenterX[seriesIndex] + Math.cos(midAngle) * currentseries.explodeOffset;
                            explodeY = this.chartObj.model.circleCenterY[seriesIndex] + Math.sin(midAngle) * currentseries.explodeOffset;
                        }

                        var styleOptions = this.chartObj.setStyle(this, currentseries, seriesIndex, pointIndex);

                        if (currentseries.startAngle < currentseries.endAngle) // for canvas rendering with modified start and end angle
                            var counterClockWise = false;
                        else
                            counterClockWise = true;
                        for (var k = 0; k < currentseries.visiblePoints.length; k++) {
                            if (point == currentseries.visiblePoints[k]) {
                                pointIndex = k;
                                break;
                            }
                        }
                        options = {
                            'id': this.chartObj.svgObject.id + '_Series' + seriesIndex + "_Point" + pointIndex,
                            'fill': styleOptions.interior,
                            'stroke-width': styleOptions.borderWidth,
                            'stroke': styleOptions.borderColor,
                            'stroke-dasharray': styleOptions.dashArray,
                            'stroke-linecap': currentseries.lineCap,
                            'opacity': styleOptions.opacity,
                            'stroke-linejoin': currentseries.lineJoin,
                            'd': result.Direction,
                            'data-pointIndex': pointIndex,
                        };
                        var canvasOptions = {
                            'id': this.chartObj.svgObject.id + '_Series' + seriesIndex + "_Point" + pointIndex,
                            'fill': styleOptions.interior,
                            'stroke-width': styleOptions.borderWidth,
                            'stroke': styleOptions.borderColor,
                            'stroke-dasharray': styleOptions.dashArray,
                            'stroke-linecap': currentseries.lineCap,
                            'opacity': styleOptions.opacity,
                            'stroke-linejoin': currentseries.lineJoin,
                            'd': result.Direction,
                            'start': point.startAngle - 1.57,
                            'end': point.endAngle - 1.57,
                            'data-pointIndex': pointIndex,
                            'radius': this.chartObj.model.circularRadius[seriesIndex],
                            'innerR': this.chartObj.model.innerRadius[seriesIndex],
                            'counterClockWise': counterClockWise,
                            'x': explodeX != 0 ? explodeX : this.chartObj.model.circleCenterX[seriesIndex],
                            'y': explodeY != 0 ? explodeY : this.chartObj.model.circleCenterY[seriesIndex]
                        };
                        if (isCanvas)
                            this.chartObj.svgRenderer.drawPath(canvasOptions, this.gSeriesGroupEle);
                        else
                            this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle);


                        region = { PointIndex: pointIndex, Index: j, StartAngle: point.startAngle, EndAngle: point.endAngle, StartX: this.chartObj.model.startX[pointIndex], StartY: this.chartObj.model.startY[pointIndex], SeriesIndex: $.inArray(currentseries, this.chartObj.model._visibleSeries) };
                        internalRegion.push(region);

                    }
                }
            }
            var seriesData = { Radius: this.chartObj.model.circularRadius[seriesIndex], DRadius: this.chartObj.model.innerRadius[seriesIndex], CenterX: this.chartObj.model.circleCenterX[seriesIndex], CenterY: this.chartObj.model.circleCenterY[seriesIndex] };
            var region = { Series: currentseries, SeriesData: seriesData, Region: internalRegion, SeriesIndex: $.inArray(currentseries, this.chartObj.model._visibleSeries) };
            this.chartObj.model.chartRegions.push(region);

            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

        },

        chartAreaType: "None"
    });

    sf.seriesTypes.doughnut = sf.ejDoughnutSeries;

    sf.ejPyramidSeries = ejExtendClass(sf.EjSeriesRender, {
        draw: function (chart, options) {

            this.chartObj = chart;
            var chartModel = chart.model,
                point,
                seriesRender = this,
                legendActualBounds = chartModel.LegendActualBounds,
                currentseries = options,
                visiblePoints = this._calculateVisiblePoints(currentseries).visiblePoints,
                visiblePointslength = visiblePoints.length,
                internalRegion = [],
                translate = [],
                legend = chartModel.legend,
                dataLabel = currentseries.marker.dataLabel,
                legendPosition = legend.position.toLowerCase(),
                legendWidth = legend.border.width,
                textSize = 0,
                text,
                title = chartModel.title,
                subTitle = chartModel.title.subTitle,
                borderSize = chartModel.border.width,
                titleVisibility = title.text != '' && title.visible && title.enableTrim ? true : false,
                subTitleVisibility = subTitle.text != '' && subTitle.visible && subTitle.enableTrim ? true : false,
                measureTitle = (chartModel.title.text && chartModel.title.visible) ? sf.EjSvgRender.utils._measureText(chartModel.title.text, $(this.svgObject).width() - chartModel.margin.left - chartModel.margin.right, chartModel.title.font) : 0,
                measureSubTitle = (chartModel.title.subTitle.text && chartModel.title.subTitle.visible) ? sf.EjSvgRender.utils._measureText(chartModel.title.subTitle.text, $(this.svgObject).width() - chartModel.margin.left - chartModel.margin.right, chartModel.title.subTitle.font) : 0,
                measureTitleHeight = (chart.model.title.text == '' || !chart.model.title.visible) ? 0 : ((titleVisibility && title.textOverflow == 'wrap') ? measureTitle.height * chart.model.titleWrapTextCollection.length : (titleVisibility && title.textOverflow == 'wrapandtrim') ?
                    measureTitle.height * chart.model.titleWrapTextCollection.length : measureTitle.height),
                measureSubTitleHeight = (chart.model.title.subTitle.text == '' || !chart.model.title.subTitle.visible) ? 0 : ((subTitleVisibility && subTitle.textOverflow == 'wrap') ? measureSubTitle.height * chart.model.subTitleWrapTextCollection.length : (subTitleVisibility && subTitle.textOverflow == 'wrapandtrim') ?
                    measureSubTitle.height * chart.model.subTitleWrapTextCollection.length : measureSubTitle.height),
                xOffset = (chartModel.margin.left + chartModel.elementSpacing + (borderSize * 2) + chartModel.elementSpacing + chartModel.margin.right + ((legendPosition === "right" || legendPosition === "left") ? legendActualBounds.Width + (2 * legendWidth) : 0)),
                yOffset = (((chartModel.title.text && chartModel.title.visible) ? (chartModel._titleLocation.Y + measureTitleHeight + measureSubTitleHeight) : chartModel.elementSpacing) + (borderSize * 2) + chartModel.margin.top + chartModel.elementSpacing + chartModel.elementSpacing + ((legendPosition === "top" || legendPosition === "bottom") ? legendActualBounds.Height + (2 * legendWidth) + chartModel.elementSpacing : 0));
            if (dataLabel.visible && dataLabel.shape != 'none' && currentseries.labelPosition == 'outside')
                xOffset = xOffset + (dataLabel.margin.left + dataLabel.margin.right);
            chartModel.chartRegions = [];
            chartModel.sumofYValues = 0;

            if (currentseries.labelPosition.toLowerCase() === 'outside') {
                for (var i = 0; i < visiblePointslength; i++) {
                    var textWidth = sf.EjSvgRender.utils._measureText((sf.util.isNullOrUndefined(visiblePoints[i].text) ? visiblePoints[i].y : visiblePoints[i].text), null, currentseries.marker.dataLabel.font).width;
                    if (textSize < textWidth)
                        textSize = textWidth;
                }
                chartModel.textSize = textSize;
            }
            if (currentseries._enableSmartLabels) {
                chartModel.actualWidth = ($(chart.svgObject).width() - xOffset) * 0.8; //calculate a pyramid width when smartlabel is enabled
                chartModel.resWidth = ($(chart.svgObject).width() - xOffset - chartModel.actualWidth) / 2;
            }
            else {
                chartModel.actualWidth = $(chart.svgObject).width() - xOffset - textSize;
                chartModel.resWidth = 0;
            }
            var seriesIndex = $.inArray(currentseries, chartModel._visibleSeries);
            chartModel.actualHeight = $(chart.svgObject).height() - yOffset;
            var subtitleHeight = (chart.model.title.subTitle.text == '') ? 0 : measureSubTitleHeight;
            var pyrX = chart.pyrX = ((legendPosition === "left") ? (legendActualBounds.Width + (2 * legendWidth)) : 0) + chartModel.elementSpacing + chartModel.margin.left;
            var pyrY = chart.pyrY = ((legendPosition === "top") ? (legendActualBounds.Height + (2 * legendWidth)) : 0) + ((title.text && title.visible) ? (chartModel._titleLocation.Y + measureTitleHeight + subtitleHeight) : (chartModel.margin.top + chartModel.elementSpacing));
            translate[0] = pyrX;
            translate[1] = pyrY;
            for (var j = 0; j < visiblePointslength; j++) {
                chartModel.sumofYValues += visiblePoints[j].YValues[0];
            }
            var dataLabelOptions = { 'id': chart.svgObject.id + '_DataLabel_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            chart.gDataLabelEle = [];
            chart.gDataLabelEle[seriesIndex] = chart.svgRenderer.createGroup(dataLabelOptions);


            var numberToFixed = sf.util.isNullOrUndefined(chartModel.roundingPlaces) ? 2 : chartModel.roundingPlaces;

            var serOptions = { 'id': chart.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            this.gSeriesGroupEle = chart.svgRenderer.createGroup(serOptions);


            var txtOptions = { 'id': chart.svgObject.id + '_textGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            chart.gSeriesTextEle = [];
            chart.gSeriesTextEle[seriesIndex] = chart.svgRenderer.createGroup(txtOptions);

            var symbolOptions = { 'id': chart.svgObject.id + '_symbolGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            chart.gSymbolGroupEle = [];
            chart.gSymbolGroupEle[seriesIndex] = chart.svgRenderer.createGroup(symbolOptions);

            var connectorOptions = { 'id': chart.svgObject.id + '_connectorGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            chart.gConnectorEle = [];
            chart.gConnectorEle[seriesIndex] = chart.svgRenderer.createGroup(connectorOptions);


            if (currentseries.pyramidMode.toLowerCase() == "linear")
                this.calculateLinearSegments(currentseries);
            else
                this.calculateSurfaceSegments(currentseries);

            for (j = 0; j < visiblePointslength; j++) {
                var pointIndex = j;
                point = currentseries._visiblePoints[j];
                if (point.visible) {
                    var result = this._getPyramidData(currentseries, pointIndex);

                    var styleOptions = chart.setStyle(this, currentseries, 0, pointIndex);

                    options = {
                        'id': chart.svgObject.id + '_Series' + seriesIndex + "_Point" + pointIndex,
                        'fill': styleOptions.interior,
                        'stroke-width': styleOptions.borderWidth,
                        'stroke': styleOptions.borderColor,
                        'stroke-dasharray': styleOptions.dashArray,
                        'stroke-linecap': currentseries.lineCap,
                        'stroke-linejoin': currentseries.lineJoin,
                        'opacity': styleOptions.opacity,
                        'pointIndex': pointIndex,
                        'd': result.Direction
                    };
                    chart.svgRenderer.drawPath(options, this.gSeriesGroupEle, translate);

                    if (currentseries.marker.dataLabel.template) {
                        sf.EjSvgRender.utils._getSeriesTemplateSize(point, pointIndex, currentseries, true, chart);
                    }

                    point.xLocation = result.PositionX;
                    point.yLocation = result.PositionY;
                    point.connectorLine = result.Connector;
                    point.startX = result.startX;
                    point.startY = result.startY;
                    point.Polygon = result.Polygon;
                    region = { PointIndex: pointIndex, Line1: result.Line1, Line2: result.Line2, Line3: result.Line3, Line4: result.Line4, Polygon: result.Polygon };
                    internalRegion.push(region);
                }
            }
            var region = { Series: currentseries, Region: internalRegion, SeriesIndex: $.inArray(currentseries, chartModel._visibleSeries) };
            chartModel.chartRegions.push(region);

            if (this.gSeriesGroupEle) {
                $(this.gSeriesGroupEle.childNodes[pointIndex]).bind('mousemove', function (evt) {
                    evt.target = seriesRender.gSeriesGroupEle.childNodes[pointIndex];
                    seriesRender.chartObj.chartInteractiveBehavior(evt);
                });

                chart.svgRenderer.append(this.gSeriesGroupEle, chart.gSeriesEle);
            }



        },

        _getPyramidData: function (series, index) {

            var model = this.chartObj.model;
            var pointMarker = series._visiblePoints[index].marker;
            var actualIndex = series._visiblePoints[index].actualIndex;
            var offset = ((series.explodeIndex == actualIndex) || (series.explodeAll) ? series.explodeOffset : 0);
            var resWidth = model.resWidth;
            var top = model.pyramidData[index].CurrY;
            var bottom = model.pyramidData[index].CurrY + model.pyramidData[index].Height;
            var topRadius = 0.5 * (1 - model.pyramidData[index].CurrY);
            var bottomRadius = 0.5 * (1 - bottom);
            var point = series.points[index];

            var line1 = { x: resWidth + offset + topRadius * model.actualWidth, y: top * model.actualHeight };
            var line2 = { x: resWidth + offset + (1 - topRadius) * model.actualWidth, y: top * model.actualHeight };
            var line3 = { x: resWidth + offset + (1 - bottomRadius) * model.actualWidth, y: bottom * model.actualHeight };
            var line4 = { x: resWidth + offset + bottomRadius * model.actualWidth, y: bottom * model.actualHeight };

            var direction = "M" + " " + (line1.x) + " " + (line1.y) + " " + "L" + " " + (line2.x) + " " + (line2.y) + " " + "L" + " " + (line3.x) + " " + (line3.y) + " " + "L" + " " + (line4.x) + " " + (line4.y) + " " + "z";
            var polygon = [
                { x: line1.x, y: line1.y },
                { x: line2.x, y: line2.y },
                { x: line3.x, y: line3.y },
                { x: line4.x, y: line4.y }
            ];
            if ((pointMarker && pointMarker.dataLabel && pointMarker.dataLabel.visible) || (!pointMarker || !pointMarker.dataLabel) && series.marker.dataLabel.visible) {
                var positionX;
                var positionY;
                var startX = (line2.x + line3.x) / 2;
                var startY = (line2.y + line3.y) / 2;
                if (series.labelPosition.toLowerCase() === 'outside') {

                    positionX = (line2.x + line3.x) / 2;
                    positionY = (line2.y + line3.y) / 2;

                    var pyrX = ((this.chartObj.model.legend.position.toLowerCase() == "left" || this.chartObj.model.legend.position.toLowerCase() == "right") ? (this.chartObj.model.LegendActualBounds.Width) : 0) + this.chartObj.model.elementSpacing + this.chartObj.model.margin.left;

                    if (sf.util.isNullOrUndefined(series.marker.dataLabel.connectorLine.height)) {
                        if (series._enableSmartLabels)
                            var textOffset = $(this.chartObj.svgObject).width() - (pyrX + positionX + resWidth + (2 * this.chartObj.model.elementSpacing));
                        else
                            var textOffset = $(this.chartObj.svgObject).width() - (pyrX + positionX + this.chartObj.model.textSize + this.chartObj.model.elementSpacing);
                    }
                    else
                        textOffset = series.marker.dataLabel.connectorLine.height;

                    var connectorX = this.getXCordinate(positionX, textOffset, 0);
                    var connectorY = this.getYCordinate(positionY, textOffset, 0);

                    var connectorDirection = "M" + " " + positionX + " " + positionY + " " + "L" + " " + connectorX + " " + connectorY;

                    positionX = connectorX;
                    positionY = connectorY;


                }
                else {
                    positionX = (line1.x + line2.x) / 2;
                    positionY = (line3.y + line1.y) / 2;
                }
            }
            return { Direction: direction, PositionX: positionX, PositionY: positionY, Connector: connectorDirection, Line1: line1, Line2: line2, Line3: line3, Line4: line4, startX: startX, startY: startY, Polygon: polygon };
        },

        calculateLinearSegments: function (series) {
            var currY = 0;
            var model = this.chartObj.model;
            model.pyramidData = [];
            var gapRatio = series.gapRatio >= 0 ? (series.gapRatio <= 1 ? series.gapRatio : 1) : 0;
            var coef = 1 / (model.sumofYValues * (1 + gapRatio / (1 - gapRatio)));
            var count = series._visiblePoints.length;
            for (var i = 0; i < count; i++) {
                if (series._visiblePoints[i].visible || series._visiblePoints[i].gapMode) {
                    var height = coef * series._visiblePoints[i].YValues[0];
                    model.pyramidData[i] = { CurrY: currY, Height: height };
                    currY += (gapRatio / (count - 1)) + height;
                }
            }
        },

        calculateSurfaceSegments: function (series) {
            var count = series._visiblePoints.length;
            var model = this.chartObj.model;
            model.pyramidData = [];
            var currY = 0;
            var y = [];
            var height = [];
            var gapRatio = series.gapRatio >= 0 ? (series.gapRatio <= 1 ? series.gapRatio : 1) : 0;
            var gapHeight = gapRatio / (count - 1);
            var preSum = this.getSurfaceHeight(0, model.sumofYValues);
            for (i = 0; i < count; i++) {
                if (series._visiblePoints[i].visible || series._visiblePoints[i].gapMode) {
                    y[i] = currY;
                    height[i] = this.getSurfaceHeight(currY, Math.abs(series._visiblePoints[i].YValues[0]));
                    currY += height[i] + gapHeight * preSum;
                }
            }
            var coef = 1 / (currY - gapHeight * preSum);
            for (var i = 0; i < count; i++) {
                if (series._visiblePoints[i].visible || series._visiblePoints[i].gapMode) {
                    var currHeight = coef * y[i];
                    model.pyramidData[i] = { CurrY: currHeight, Height: coef * height[i] };
                }
            }
        },

        getSurfaceHeight: function (y, surface) {
            var result = this.solveQuadraticEquation(1, 2 * y, -surface);
            if (result) {
                return result;
            }
            return 0;
        },
        solveQuadraticEquation: function (a, b, c) {
            var root1;
            var root2;

            if (a != 0) {
                var d = b * b - 4 * a * c;

                if (d >= 0) {
                    var sd = Math.sqrt(d);

                    root1 = (-b - sd) / (2 * a);
                    root2 = (-b + sd) / (2 * a);
                    return Math.max(root1, root2);

                }
            }
            else if (b != 0) {
                root1 = -c / b;
                root2 = -c / b;
                return Math.max(root1, root2);
            }

            return false;
        },

        chartAreaType: "None"
    });

    sf.seriesTypes.pyramid = sf.ejPyramidSeries;

    sf.ejFunnelSeries = ejExtendClass(sf.EjSeriesRender, {
        draw: function (chart, options) {
            this.chartObj = chart;
            var chartModel = chart.model,
                legend = chartModel.legend,
                legendPosition = legend.position.toLowerCase(),
                legendActualBounds = chartModel.LegendActualBounds,
                point,
                seriesRender = this,
                currentseries = options,
                visiblePoints = this._calculateVisiblePoints(currentseries).visiblePoints,
                visiblePointslength = visiblePoints.length,
                internalRegion = [],
                dataLabel = currentseries.marker,
                legendWidth = legend.border.width,
                translate = [],
                textSize = 0,
                text,
                title = (chart.model.title.text == '') ? '' : chartModel.title,
                subTitle = (chart.model.title.subTitle.text == '') ? '' : chartModel.title.subTitle,
                borderSize = chartModel.border.width,
                titleVisibility = title.text != '' && title.visible && title.enableTrim ? true : false,
                subTitleVisibility = subTitle.text != '' && subTitle.visible && subTitle.enableTrim ? true : false,
                measureTitle = (chartModel.title.text && chartModel.title.visible) ? sf.EjSvgRender.utils._measureText(chartModel.title.text, $(this.svgObject).width() - chartModel.margin.left - chartModel.margin.right, chartModel.title.font) : 0,
                measureSubTitle = (chartModel.title.subTitle.text && chartModel.title.subTitle.visible) ? sf.EjSvgRender.utils._measureText(chartModel.title.subTitle.text, $(this.svgObject).width() - chartModel.margin.left - chartModel.margin.right, chartModel.title.subTitle.font) : 0,
                measureTitleHeight = (chart.model.title.text == '' || !chart.model.title.visible) ? 0 : ((titleVisibility && title.textOverflow == 'wrap') ? measureTitle.height * chart.model.titleWrapTextCollection.length : (titleVisibility && title.textOverflow == 'wrapandtrim') ?
                    measureTitle.height * chart.model.titleWrapTextCollection.length : measureTitle.height),
                measureSubTitleHeight = (chart.model.title.subTitle.text == '' || !chart.model.title.subTitle.visible) ? 0 : ((subTitleVisibility && subTitle.textOverflow == 'wrap') ? measureSubTitle.height * chart.model.subTitleWrapTextCollection.length : (subTitleVisibility && subTitle.textOverflow == 'wrapandtrim') ?
                    measureSubTitle.height * chart.model.subTitleWrapTextCollection.length : measureSubTitle.height),
                xOffset = (chartModel.margin.left + chartModel.elementSpacing + chartModel.elementSpacing + chartModel.margin.right + (borderSize * 2) + ((legendPosition === "right" || legendPosition === "left") ? legendActualBounds.Width + (2 * legendWidth) : 0)),
                yOffset = (((chartModel.title.text && chartModel.title.visible) ? (chartModel._titleLocation.Y + measureTitleHeight + measureSubTitleHeight) : chartModel.elementSpacing) + chartModel.margin.top + (borderSize * 2) + chartModel.elementSpacing + chartModel.elementSpacing + ((legendPosition === "top" || legendPosition === "bottom") ? legendActualBounds.Height + (2 * legendWidth) + chartModel.elementSpacing : 0));
            if (dataLabel.visible && dataLabel.shape != 'none' && currentseries.labelPosition == 'outside')
                xOffset = xOffset + (dataLabel.margin.left + dataLabel.margin.right);
            chartModel.chartRegions = [];
            chartModel.sumofYValues = 0;
            if (currentseries.labelPosition.toLowerCase() === 'outside') {
                for (var i = 0; i < visiblePointslength; i++) {
                    var textWidth = sf.EjSvgRender.utils._measureText((sf.util.isNullOrUndefined(visiblePoints[i].text) ? visiblePoints[i].y : visiblePoints[i].text), null, currentseries.marker.dataLabel.font).width;
                    if (textSize < textWidth)
                        textSize = textWidth;
                }
                chartModel.textSize = textSize;
            }
            if (currentseries._enableSmartLabels) {
                chartModel.actualWidth = ($(chart.svgObject).width() - xOffset) * 0.8;  //calculate a width of a funnel chart when smartlabel is enabled
                chartModel.resWidth = ($(chart.svgObject).width() - xOffset - chartModel.actualWidth) / 2;
            }
            else {
                chartModel.actualWidth = $(chart.svgObject).width() - xOffset - textSize;
                chartModel.resWidth = 0;
            }
            var subtitleHeight = (chart.model.title.subTitle.text == '') ? 0 : measureSubTitleHeight;
            chartModel.actualHeight = $(chart.svgObject).height() - yOffset;
            var pyrX = chart.pyrX = ((legendPosition === "left") ? (legendActualBounds.Width + (2 * legendWidth)) : 0) + chartModel.elementSpacing + chartModel.margin.left;
            var pyrY = chart.pyrY = ((legendPosition === "top") ? (legendActualBounds.Height + (2 * legendWidth)) : 0) + ((chartModel.title.text && chartModel.title.visible) ? (chartModel._titleLocation.Y + measureTitleHeight + subtitleHeight) : (chartModel.margin.top + chartModel.elementSpacing));
            translate[0] = pyrX;
            translate[1] = pyrY;
            for (var j = 0; j < visiblePointslength; j++) {
                chartModel.sumofYValues += visiblePoints[j].YValues[0];
            }


            var numberToFixed = sf.util.isNullOrUndefined(chartModel.roundingPlaces) ? 2 : chartModel.roundingPlaces;

            var seriesIndex = $.inArray(currentseries, chartModel._visibleSeries);
            var serOptions = { 'id': chart.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            this.gSeriesGroupEle = chart.svgRenderer.createGroup(serOptions);
            var dataLabelOptions = { 'id': chart.svgObject.id + '_DataLabel_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            chart.gDataLabelEle = [];
            chart.gDataLabelEle[seriesIndex] = chart.svgRenderer.createGroup(dataLabelOptions);


            var txtOptions = { 'id': chart.svgObject.id + '_textGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            chart.gSeriesTextEle = [];
            chart.gSeriesTextEle[seriesIndex] = chart.svgRenderer.createGroup(txtOptions);

            var symbolOptions = { 'id': chart.svgObject.id + '_symbolGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            chart.gSymbolGroupEle = [];
            chart.gSymbolGroupEle[seriesIndex] = chart.svgRenderer.createGroup(symbolOptions);

            var connectorOptions = { 'id': chart.svgObject.id + '_connectorGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            chart.gConnectorEle = [];
            chart.gConnectorEle[seriesIndex] = chart.svgRenderer.createGroup(connectorOptions);

            var currY = 0;
            var model = chartModel;
            model.funnelData = [];
            var gapRatio = currentseries.gapRatio >= 0 ? (currentseries.gapRatio <= 1 ? currentseries.gapRatio : 1) : 0;
            var coef = 1 / (model.sumofYValues * (1 + gapRatio / (1 - gapRatio)));
            var spacing = gapRatio / visiblePointslength;
            for (var i = visiblePointslength - 1; i >= 0; i--) {
                if (currentseries._visiblePoints[i].visible || currentseries._visiblePoints[i].gapMode) {
                    var height = coef * currentseries._visiblePoints[i].YValues[0];
                    model.funnelData[i] = { CurrY: currY, Height: height };
                    currY += height + spacing;
                }
            }
            for (j = 0; j < visiblePointslength; j++) {
                var pointIndex = j;
                point = currentseries._visiblePoints[j];
                if (point.visible) {
                    var result = this._getFunnelData(currentseries, pointIndex, chart);

                    var styleOptions = chart.setStyle(this, currentseries, 0, pointIndex);

                    options = {
                        'id': chart.svgObject.id + '_Series' + seriesIndex + "_Point" + pointIndex,
                        'fill': styleOptions.interior,
                        'stroke-width': styleOptions.borderWidth,
                        'stroke': styleOptions.borderColor,
                        'stroke-dasharray': styleOptions.dashArray,
                        'stroke-linecap': currentseries.lineCap,
                        'stroke-linejoin': currentseries.lineJoin,
                        'opacity': styleOptions.opacity,
                        'pointIndex': pointIndex,
                        'd': result.Direction
                    };
                    chart.svgRenderer.drawPath(options, this.gSeriesGroupEle, translate);

                    if (currentseries.marker.dataLabel.template) {
                        sf.EjSvgRender.utils._getSeriesTemplateSize(point, pointIndex, currentseries, true, chart);
                    }

                    point.xLocation = result.PositionX;
                    point.yLocation = result.PositionY;
                    point.connectorLine = result.Connector;
                    point.startX = result.startX;
                    point.startY = result.startY;
                    point.Polygon = result.Polygon;
                    region = { PointIndex: pointIndex, Line1: result.Line1, Line2: result.Line2, Line3: result.Line3, Line4: result.Line4, Line5: result.Line5, Line6: result.Line6, Polygon: result.Polygon };
                    internalRegion.push(region);
                }
            }
            var region = { Series: currentseries, Region: internalRegion, SeriesIndex: $.inArray(currentseries, chartModel._visibleSeries) };
            chartModel.chartRegions.push(region);

            if (this.gSeriesGroupEle)
                $(this.gSeriesGroupEle.childNodes[pointIndex]).bind('mousemove', function (evt) {
                    evt.target = seriesRender.gSeriesGroupEle.childNodes[pointIndex];
                    seriesRender.chartObj.chartInteractiveBehavior(evt);
                });

            chart.svgRenderer.append(this.gSeriesGroupEle, chart.gSeriesEle);


        },

        _getFunnelData: function (series, index, chart) {

            var model = this.chartObj.model,
                point = series._visiblePoints[index],
                pointMarker = point.marker,
                seriesMarer = series.marker,
                funnelWidth = series.funnelWidth,
                funnelHeight = series.funnelHeight,
                actualHeight = model.actualHeight,
                actualWidth = model.actualWidth,
                elementSpacing = model.elementSpacing,
                pyrX, legendPosition = model.legend.position.toLowerCase(),
                actualIndex = point.actualIndex,
                direction,
                resWidth = model.resWidth, polygon,
                textOffset, connectorDirection,
                offset = ((series.explodeIndex == actualIndex) || (series.explodeAll) ? series.explodeOffset : 0),
                topRadius, minRadius, bottomRadius, endTop,
                endMin, endBottom, top, bottomY,
                bottom, connectorX, connectorY,
                positionX, positionY, startX, startY,
                line1, line2, line3, line4, line5, line6,
                lineWidth, minimumHeight, minimumWidth;
            if (funnelHeight.indexOf("%") != -1)
                minimumHeight = actualHeight * (parseInt(funnelHeight) / 100);
            else
                minimumHeight = parseInt(funnelHeight);
            if (funnelWidth.indexOf("%") != -1)
                minimumWidth = actualWidth * (parseInt(funnelWidth) / 100);
            else
                minimumWidth = parseInt(funnelWidth);

            top = model.funnelData[index].CurrY * actualHeight;
            bottom = top + model.funnelData[index].Height * actualHeight;
            lineWidth = minimumWidth + (actualWidth - minimumWidth) * ((actualHeight - minimumHeight - top) / (actualHeight - minimumHeight));
            topRadius = (actualWidth / 2) - lineWidth / 2;
            endTop = topRadius + lineWidth;
            if (bottom > actualHeight - minimumHeight || actualHeight == minimumHeight)
                lineWidth = minimumWidth;
            else
                lineWidth = minimumWidth + (actualWidth - minimumWidth) * ((actualHeight - minimumHeight - bottom) / (actualHeight - minimumHeight));
            bottomRadius = (actualWidth / 2) - (lineWidth / 2);
            endBottom = bottomRadius + lineWidth;
            if (top >= actualHeight - minimumHeight) {
                topRadius = bottomRadius = minRadius = (actualWidth / 2) - minimumWidth / 2;
                endTop = endBottom = endMin = (actualWidth / 2) + minimumWidth / 2;

            } else if (bottom > (actualHeight - minimumHeight)) {
                minRadius = bottomRadius = (actualWidth / 2) - lineWidth / 2;
                endMin = endBottom = minRadius + lineWidth;
                bottomY = actualHeight - minimumHeight;
            }

            line1 = { x: resWidth + offset + topRadius, y: top };
            line2 = { x: resWidth + offset + endTop, y: top };
            line4 = { x: resWidth + offset + endBottom, y: bottom };
            line5 = { x: resWidth + offset + bottomRadius, y: bottom };
            line3 = { x: resWidth + offset + endBottom, y: bottom };
            line6 = { x: resWidth + offset + bottomRadius, y: bottom };
            if (bottomY) {
                line3 = { x: resWidth + offset + endMin, y: bottomY };
                line6 = { x: resWidth + offset + minRadius, y: bottomY };
            }
            direction = "M" + " " + (line1.x) + " " + (line1.y) + " " + "L" + " " + (line2.x) + " " + (line2.y) + " " + "L" + " " + (line3.x) + " " + (line3.y) + " " + "L" + " " + (line4.x) + " " + (line4.y) + " " + "L" + " " + (line5.x) + " " + (line5.y) + " " + "L" + " " + (line6.x) + " " + (line6.y) + " " + "z";
            polygon = [
                { x: line1.x, y: line1.y },
                { x: line2.x, y: line2.y },
                { x: line3.x, y: line3.y },
                { x: line4.x, y: line4.y },
                { x: line5.x, y: line5.y },
                { x: line6.x, y: line6.y }
            ];
            if ((pointMarker && pointMarker.dataLabel && pointMarker.dataLabel.visible) || (!pointMarker || !pointMarker.dataLabel) && seriesMarer.dataLabel.visible) {
                positionX;
                positionY;
                startX = (line2.x + line3.x) / 2;
                startY = (line2.y + line3.y) / 2;
                if (series.labelPosition.toLowerCase() === 'outside') {

                    positionX = (line2.x + line3.x) / 2;
                    positionY = (line2.y + line3.y) / 2;

                    pyrX = ((legendPosition == "left" || legendPosition == "right") ? (model.LegendActualBounds.Width) : 0) + elementSpacing + model.margin.left;

                    if (sf.util.isNullOrUndefined(seriesMarer.dataLabel.connectorLine.height)) {
                        if (series._enableSmartLabels)
                            textOffset = $(this.chartObj.svgObject).width() - (pyrX + positionX + resWidth + (2 * elementSpacing));
                        else
                            textOffset = $(this.chartObj.svgObject).width() - (positionX + model.textSize + elementSpacing);
                    }
                    else
                        textOffset = seriesMarer.dataLabel.connectorLine.height;

                    connectorX = this.getXCordinate(positionX, textOffset, 0);
                    connectorY = this.getYCordinate(positionY, textOffset, 0);

                    connectorDirection = "M" + " " + positionX + " " + positionY + " " + "L" + " " + connectorX + " " + connectorY;

                    positionX = connectorX;
                    positionY = connectorY;


                }
                else {
                    positionX = (line1.x + line2.x) / 2;
                    positionY = (line1.y + line4.y) / 2;
                }
            }
            return { Direction: direction, PositionX: positionX, PositionY: positionY, Connector: connectorDirection, Line1: line1, Line2: line2, Line3: line3, Line4: line4, Line5: line5, Line6: line6, startX: startX, startY: startY, Polygon: polygon };
        },


        chartAreaType: "None"
    });

    sf.seriesTypes.funnel = sf.ejFunnelSeries;
    /*Funnel series*/

    sf.ejPolarSeries = ejExtendClass(sf.EjSeriesRender, {

        draw: function (chart, options) {

            this.chartObj = chart;
            var point;
            var seriesRender = this;
            var currentseries = options;
            var visiblePoints = this._isVisiblePoints(currentseries);
            var internalRegion = [];


            var style = this.setLineSeriesStyle(currentseries);

            if (currentseries.drawType.toLowerCase() == "column" || currentseries.drawType.toLowerCase() == "rangecolumn") {
                var range = currentseries.xAxis.visibleRange;
                range.interval = 1;
                var length = (currentseries.xAxis._valueType == "category") ? range.max : range.max - 1;
                this.chartObj.model.sumofYValues = 0;
                var count = range.interval;
                var min = range.min;
                do {
                    this.chartObj.model.sumofYValues += range.interval;
                    min += range.interval;
                } while (min <= length)
                //  this.chartObj.model.sumofYValues = visiblePoints.length;
            }

            var direction = this._calculatePolarAxesSegment(currentseries);

            if (currentseries.drawType.toLowerCase() == "area")
                this.drawAreaPath(currentseries, style, direction);
            else if (currentseries.drawType.toLowerCase() == "line")
                this._drawLinePath(currentseries, style, direction);
            else if (currentseries.drawType.toLowerCase() == "spline")
                this._drawLinePath(currentseries, style, direction);



            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);


        },

        chartAreaType: "PolarAxes"

    });

    sf.seriesTypes.polar = sf.ejPolarSeries;
    sf.ejRadarSeries = ejExtendClass(sf.EjSeriesRender, {

        draw: function (chart, options) {

            this.chartObj = chart;
            var point;
            var seriesRender = this;
            var currentseries = options;
            var visiblePoints = this._isVisiblePoints(currentseries);
            var internalRegion = [];

            var style = this.setLineSeriesStyle(currentseries);

            if (currentseries.drawType.toLowerCase() == "column" || currentseries.drawType.toLowerCase() == "rangecolumn") {
                var range = currentseries.xAxis.visibleRange;
                range.interval = 1;
                var length = (currentseries.xAxis._valueType == "category") ? range.max : range.max - 1;
                this.chartObj.model.sumofYValues = 0;
                var count = range.interval;
                var min = range.min;
                do {
                    this.chartObj.model.sumofYValues += range.interval;
                    min += range.interval;
                } while (min <= length)
                //  this.chartObj.model.sumofYValues = visiblePoints.length;
            }

            var direction = this._calculatePolarAxesSegment(currentseries);

            if (currentseries.drawType.toLowerCase() == "area")
                this.drawAreaPath(currentseries, style, direction);
            else if (currentseries.drawType.toLowerCase() == "line")
                this._drawLinePath(currentseries, style, direction);
            else if (currentseries.drawType.toLowerCase() == "spline")
                this._drawLinePath(currentseries, style, direction);



            this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);



        },
        doAnimation: function (series, chart) {     // for polar/radar animation
            var chartObj = chart.chartObj;
            var drawType = series.drawType.toLowerCase();
            series.regionAdded = true;
            chartObj.model._radius = chartObj.model.Radius || chartObj.model._radius;
            chartObj.model.Radius = 0;
            var seriesRender = chart;
            var seriesIndex = $.inArray(series, chartObj.model._visibleSeries);
            var Path = $(chartObj.gSeriesEle).find("#" + seriesRender.gSeriesGroupEle.id)[0].childNodes[0];
            $(Path).animate(
                { Radius: chartObj.model._radius },

                {
                    duration: 1200, queue: false, step: function (now, fx) {
                        if (!sf.util.isNullOrUndefined(chartObj.model)) {
                            chartObj.model.Radius = now;

                            var direction = seriesRender._calculatePolarAxesSegment(series);
                            if ((series.drawType.toLowerCase() != 'column') && (series.drawType.toLowerCase() != 'rangecolumn') && (drawType != 'scatter'))
                                chartObj.svgRenderer._setAttr($(Path), { "d": direction });
                            chartObj.model.Radius = chartObj.model._radius;
                        }
                        else
                            $(Path).stop(true, true);
                    },
                    complete: function () {
                        if (!sf.util.isNullOrUndefined(chartObj.model)) {
                            series.regionAdded = false;
                            chartObj.svgRenderer._setAttr($(chartObj.gSeriesEle).find("#" + chartObj.svgObject.id + '_TextGroup' + '_' + seriesIndex), { "visibility": "visible" });

                            chartObj.svgRenderer._setAttr($(chartObj.gSeriesEle).find("#" + chartObj.svgObject.id + '_symbolGroup' + '_' + seriesIndex), { "visibility": "visible" });
                            chartObj.svgRenderer._setAttr($(chartObj.gSeriesEle).find("#" + chartObj.svgObject.id + '_DataLabel' + '_' + seriesIndex), { "visibility": "visible" });
                            chartObj.model.AnimationComplete = true;
                            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                            commonEventArgs.data = { series: series };
                            chartObj._trigger("animationComplete", commonEventArgs);
                        }
                    }

                });
        },
        chartAreaType: "PolarAxes"

    });

    sf.seriesTypes.radar = sf.ejRadarSeries;
})(jQuery);;
/* global jQuery, sf, document, navigator, window, clearTimeout, setTimeout, event */
sf.ejChart = {};
(function ($) {
    if (!Object.keys) {
        Object.keys = (function () {
            'use strict';
            var hasOwnProperty = Object.prototype.hasOwnProperty,
                hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),
                dontEnums = [
                    'toString',
                    'toLocaleString',
                    'valueOf',
                    'hasOwnProperty',
                    'isPrototypeOf',
                    'propertyIsEnumerable',
                    'constructor'
                ],
                dontEnumsLength = dontEnums.length;

            return function (obj) {
                if (typeof obj !== 'function' && (typeof obj !== 'object' || obj === null)) {
                    return;
                }

                var result = [], prop, i;

                for (prop in obj) {
                    if (hasOwnProperty.call(obj, prop)) {
                        result.push(prop);
                    }
                }

                if (hasDontEnumBug) {
                    for (i = 0; i < dontEnumsLength; i++) {
                        if (hasOwnProperty.call(obj, dontEnums[i])) {
                            result.push(dontEnums[i]);
                        }
                    }
                }
                return result;
            };
        }());
    }

    if (!Array.isArray) {
        Array.isArray = function (arg) {
            return Object.prototype.toString.call(arg) === '[object Array]';
        };
    }
    if (Array.prototype.map === undefined) {
        Array.prototype.map = function (fn) {
            var rv = [];

            for (var i = 0, l = this.length; i < l; i++)
                rv.push(fn(this[i]));

            return rv;
        };
    }
    String.prototype.parseTemplate = function () {
        var str = this, substr;
		var count = 0;
		var arabic = /[\u0600-\u06FF]/;
        $.each(arguments[0], function (dataIndex, dataValue) {
            if (dataValue.count > 0) {
                $.each(dataValue, function (datachildIndex, datachildValue) {
                    var val = new RegExp('#' + dataIndex + '.' + datachildIndex + '#', 'gm');
					count++;
					if(arabic.test(str) && count == 2)
					{
						var str1 = str.split(' ');
						for(var i=0;i<str1.length;i++){
							var txt = str1[i];
							if(arabic.test(txt)){
								txt = txt + '&lrm;' ;
							    str1[i] = txt;
							}
						}
						str = str1.join(' ');
					}
                    str = str.replace(val.source, datachildValue);
                });
            } else {
                str = str.replace(new RegExp('\\#' + dataIndex + '\\#', 'gm'), dataValue);
            }

        });
        while (str.indexOf('sf.') >= 0) {
            substr = str.substring(str.indexOf('sf.'), str.indexOf(")") + 1);
            str = str.replace(substr, eval(substr));
        }
        return str;
    };

    String.prototype.capitalizeFirstString = (function () {
        return this.charAt(0).toUpperCase() + this.slice(1);
    });

    var Gradient = function (colors) {
        this._gradientStop = [];
        for (var j = 0; j < colors.length; j++) {
            this._gradientStop.push(colors[j]);
        }
    };



    sf.ejChart = {

        _renderSfChart: function () {

            var svgSupport = (window.SVGSVGElement) ? true : false;
            var isCanvas = this.model.enableCanvasRendering;
			this.isChartElemId = false;
            //Create id to chart container, if the element don't have id
            if (!this.element[0].id)
                this._createChartId();
            $("#chartContainer_" + this._id).remove();
            if (svgSupport) {
                this.renderer = new sf.EjSvgRender(this.element);
                if (isCanvas) {
                    this.svgRenderer = new sf.EjCanvasRender(this.element);
                    this.legendSvgContainer = this.svgRenderer.createLegendCanvas(this.element); //creating new CANVAS element for legend
                } else {
                    this.svgRenderer = new sf.EjSvgRender(this.element);
                    this.legendSvgContainer = this.svgRenderer.createLegendSvg(this.element); //creating new SVG element for legend
                }
                this._appendChartElements();
                if (!isCanvas)
                    this.legendContainer.find("svg").attr("class", "e-designerhide");
                this._createChart();
                $(this.svgObject).appendTo(this.element);
            }
            else {
                isCanvas = false;
                this.svgRenderer = new sf.EjVmlRender(this.element);
                this.legendSvgContainer = this.svgRenderer.createLegendSvg(this.element); //creating new div element for legend
                this.renderer = new sf.EjVmlRender(this.element);
                this._appendChartElements();
                this._createChart();
                $(this.svgObject).appendTo(this.chartContainer);
            }
            return true;
        },

        _appendChartElements: function () {
            this.legendContainer = $("<div></div>").attr('id', "legend_" + this._id).css("height", "0px");
            this.scrollerContainer = $("<div></div>").attr('id', "legend_Scroller" + this._id).css("height", "0px");
            this.templateContainer = $("<div></div>").attr('id', this._id + "_container_svg_TrackToolTip").css("height", "0px");
            this.chartContainer = $("<div></div>").css("position", "relative").attr('id', "chartContainer_" + this._id);
            this.axisScroll = $("<div></div>").attr('id', "axisScrollbar_" + this._id).css("height", "0px");
            this.svgRenderer.append(this.legendSvgContainer, this.scrollerContainer);
            $(this.scrollerContainer).appendTo(this.legendContainer);
            $(this.axisScroll).appendTo(this.chartContainer);
            $(this.legendContainer).appendTo(this.chartContainer);
            $(this.templateContainer).appendTo(this.chartContainer);
            $(this.chartContainer).appendTo(this.element);
        },

        setSvgSize: function (sender) {
            var chartObj = sender;
            var containerHeight = $(chartObj.element).height();
            var height = 450; //set default height if size not specified to chart or container
            var width = (sf.isTouchDevice()) ? 250 : 600;
            var containerWidth = $(chartObj.element).width();
            var legendcontainerHeight = $(chartObj.chartContainer).height();
            if (chartObj.model.size.width) {
                var chartWidth = chartObj.model.size.width;
                if (typeof (chartWidth) == "string" && chartWidth.indexOf("%") != -1)
                    width = (containerWidth / 100) * parseInt(chartWidth);
                else
                    width = parseInt(chartWidth);
            }
            else if (containerWidth > 0)
                width = containerWidth;

            $(chartObj.svgObject).width(width);

            if (chartObj.model.size.height) {
                var chartHeight = chartObj.model.size.height;
                if (typeof (chartHeight) == "string" && chartHeight.indexOf("%") != -1)
                    height = (!this.vmlRendering) ? (containerHeight / 100) * parseInt(chartHeight) : height;
                else
                    height = parseInt(chartHeight);
            }
            else if (containerHeight > 0)
                height = containerHeight;
            else
                $(chartObj.svgObject).css("display", "block"); //Added css to chart due to 5px difference for container and svg (http://jsfiddle.net/Me5Zd/)       
            $(chartObj.svgObject).height(height);

            $("#" + chartObj._id).css("overflow", "hidden");//Added css to remove scrollbar on zooming the chart
            chartObj.svgObject.setAttribute('width', width);   // assigning width for canvas
            chartObj.svgObject.setAttribute('height', height);  // assigning height for 
        },
        compareExtend: function (temp, src, def) {
            if (typeof def === 'object' && def !== null) {
                var defProp = Object.keys(def), len = defProp.length, currPro;
                for (var i = 0; i < len; i++) {
                    currPro = defProp[i];
                    if (src.hasOwnProperty(currPro) && src[currPro] != null) {
                        if (Array.isArray(src[currPro]) || typeof src[currPro] === 'object' && src[currPro] !== null) {
                            this.compareExtend({}, src[currPro], def[currPro]);
                        }
                    }
                    else {
                        src[currPro] = def[currPro];
                    }
                }
            }
            return src;
        },
        setModelProperties: function (excludeDataUpdate) {

            //set size for the svgObject
            if (!excludeDataUpdate)
                this.setSvgSize(this);

            this.svgWidth = $(this.svgObject).width();
            this.svgHeight = $(this.svgObject).height();

            this.chartCross = {
                visible: (excludeDataUpdate) ? this.chartCross.visible : this.model.crosshair.visible,
                mArea: this.model.crosshair.type
            };

            // extend series with commonSeriesOptions
            this.serAnimation = [];
            if (this.model.series && !excludeDataUpdate) {
                var trendlines, len, currentPoint, currentSeries, nullValue = false, trendLineType, datasource;
                this.model._drawTrendline = false;
                for (var j = 0; j < this.model.series.length; j++) {
					datasource = null;
                    if (!sf.util.isNullOrUndefined(this.model.series[j].dataSource) || !sf.util.isNullOrUndefined(this.model.commonSeriesOptions.dataSource)) {
                        if (!sf.util.isNullOrUndefined(this.model.series[j].dataSource))
                            datasource = this.model.series[j].dataSource;
                        else
                            datasource = this.model.commonSeriesOptions.dataSource;
                    }
                    this.model.series[j] = sf.copyObject({}, this.model.commonSeriesOptions, this.model.series[j]);
                    this.model.series[j].dataSource = datasource;
                    currentSeries = this.model.series[j];
                    this.serAnimation.push((currentSeries.enableAnimation === null || currentSeries.enableAnimation === undefined) ? this.model.commonSeriesOptions.enableAnimation : currentSeries.enableAnimation);
                    trendlines = currentSeries.trendlines;
                    len = trendlines.length;
                    for (var i = 0; i < len; i++) {
                        trendlines[i] = sf.copyObject({}, this.model.trendlineDefaults, trendlines[i]);
                        trendlines[i]._visibility = trendlines[i].visibility;
                        if (trendlines[i].visibility.toLowerCase() == "visible") {
                            this.model._drawTrendline = true;
                            trendLineType = trendlines[i].type.toLowerCase();
                            if (!sf.util.isNullOrUndefined(currentSeries.points)) {
                                for (var l = 0; l < currentSeries.points.length; l++) {
                                    currentPoint = currentSeries.points[l];
                                    if (sf.util.isNullOrUndefined(currentPoint.y) || currentPoint.y == 0) {
                                        nullValue = true;
                                        break;
                                    }
                                }
                            }
                            trendlines[i].isNull = nullValue && (trendLineType == "power" || trendLineType == "exponential") ? true : false;
                        }
                    }
                }
            }
            if (this.model.indicators) {
                for (var k = 0; k < this.model.indicators.length; k++) {
                    this.model.indicators[k] = sf.copyObject({}, this.model.indicatorDefaults, this.model.indicators[k]);
                }
            }

        },

        _createChart: function () {
            this.svgObject = this.svgRenderer.svgObj;
            var commonlaodEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            this._trigger("load", commonlaodEventArgs);
            this.setTheme(sf.EjSvgRender.themes, this.model.theme);
            var model = this.model;

            if (model.series[0] && model.series[0]._isdesigntime) {
                model.series[0] = {};
                model.series[0].points = [];
                var randomPoints = [];
                for (var i = 1; i <= 10; i++) {
                    randomPoints.push({ x: i, y: (Math.floor(Math.random() * (10 - 40)) + 40) });

                }
                model.series[0].points = randomPoints;
            }
            this.vmlRendering = (this.svgRenderer.vmlNamespace) ? true : false;
			this._isEventsBinded = false;
            if ($(this.element).is(":visible") || $(this.element).css("visibility") != "hidden" || $(this.element).css('display') != 'none') {
                this.bindEvents();
                this.bindTo();
            }
        },
        setTheme: function (jsonObj, themeName) {
            var name = themeName.toLowerCase();
            if ((name.indexOf("azure") >= 0 || name.indexOf("lime") >= 0 || name.indexOf("saffron") >= 0) && (name.indexOf("gradient") == -1) && (name.indexOf("dark") == -1))
                jsonObj[name] = $.extend(true, {}, jsonObj["flatlight"], jsonObj[name]);
            else if ((name.indexOf("azuredark") >= 0 || name.indexOf("limedark") >= 0 || name.indexOf("saffrondark")) >= 0 && (name.indexOf("gradient") == -1))
                jsonObj[name] = $.extend(true, {}, jsonObj["flatdark"], jsonObj[name]);
            else if ((name.indexOf("azure") >= 0 || name.indexOf("lime") >= 0 || name.indexOf("saffron") >= 0) && (name.indexOf("gradient") >= 0) && (name.indexOf("dark") == -1))
                jsonObj[name] = $.extend(true, {}, jsonObj["gradientlight"], jsonObj[name]);
            else if ((name.indexOf("azuredark") >= 0 || name.indexOf("limedark") >= 0 || name.indexOf("saffrondark") >= 0) && (name.indexOf("gradient") >= 0))
                jsonObj[name] = $.extend(true, {}, jsonObj["gradientdark"], jsonObj[name]);
            else if ((name.indexOf("high") >= 0))
                jsonObj[name] = $.extend(true, {}, jsonObj["highcontrast01"], jsonObj[name]);
            else if ((name.indexOf("material") >= 0) || (name.indexOf("office") >= 0))
                jsonObj[name] = $.extend(true, {}, jsonObj["material"], jsonObj[name]);
            else if (!(jsonObj[name])) name = "flatlight";

            if (this.model._themeChanged)
                this.model = sf.copyObject({}, this.model, jsonObj[name]);
            else
                this.model = this.compareExtend({}, this.model, jsonObj[name]);
            // added default property background in synchart to work in angular 1
            this.model.background = sf.util.isNullOrUndefined(this.model.background) ? jsonObj[name].background : this.model.background;


        },
        _drawBackInterior: function () {
            if (this.model.backInterior && this.model.backInterior._gradientStop) {
                var options = {
                    'id': this.svgObject.id + '_backGradient',
                    'x1': '0%',
                    'y1': '0%',
                    'x2': '0%',
                    'y2': $(this.svgObject).height() + '%'
                };
                this.svgRenderer.drawGradient(options, this.model.backInterior._gradientStop);
            }
        },



        _drawBackImage: function () {
            var options = {
                'height': $(this.svgObject).height(),
                'width': $(this.svgObject).width(),
                'href': this.model.backGroundImageUrl,
                'x': 0,
                'y': 0,
                'id': this.svgObject.id + '_backImage',
                'visibility': 'visible',
                'preserveAspectRatio': 'none'
            };

            this.svgRenderer.drawImage(options, this.svgObject);

        },
        _getDataType: function (val) {
            var type = typeof (val);
            if (type === "number" || type === "string")
                return type;
            else if (jQuery.type(val) == "date")
                return "date";
            else if (val == null) {
                return null;
            }
            else
                return false;

        },
        addedXYValues: function (excludeDataUpdate) {
            excludeDataUpdate = (excludeDataUpdate) ? excludeDataUpdate : false;
            var model = this.model,
                series = model.series,
                type = series[0].type.toLowerCase(),
                pointLength, visiblePoints, i, j, k,
                isNullOrUndefined = sf.util.isNullOrUndefined,
                valueType = model.primaryXAxis.valueType,
                setXValueType, isDatetime = false, pointX, currentSeries,
                setSize, //do not compare and set size for all the points
                regExpTest, parsed, points,
                areaType;

            areaType = model.AreaType = sf.seriesTypes[type].prototype.chartAreaType;
            if (areaType != "cartesianAxes" && areaType != "None") {
                areaType = model.AreaType = "polaraxes";
                model.isPolar = (type == 'polar');
            }
            areaType = model.AreaType = model.AreaType.toLowerCase();
            if (!excludeDataUpdate) {
                for (i = 0; i < series.length; i++) {
                    if (series[i].visibility == "visible") {
                        setSize = true;
                        setXValueType = false;
                        if (!series[i].dataSource || series[i].dataSource.length == 0) {
                            points = series[i].points;
                            series[i].points = null;
                            series[i] = $.extend(true, {}, model.commonSeriesOptions, series[i]);
                            series[i].points = points;
                            currentSeries = series[i];
                            if (valueType == "datetime")
                                isDatetime = true;
                            pointLength = points.length;
                            for (var k = 0; k < pointLength; k++) {
                                points[k].YValues = [];

                                //test regular expression only for first point
                                regExpTest = (/^-?[0-9]*\.?[0-9]+$/.test(points[k].x) == true);

                                //avoid using parseFloat unnecessarily. If x is already a number, then no need to use parseFloat
                                parsed = (valueType != "category") && (valueType != "datetime") && (typeof points[k].x === 'string' || points[k].x instanceof String) && parseFloat(points[k].x);

                                if (!isNaN(parsed ? points[k].x : parseFloat(points[k].x)) && parsed && regExpTest && (valueType != "category") && (areaType != "none"))
                                    points[k].x = (!isDatetime ? parseFloat(points[k].x) : new Date(points[k].x));
                                if (typeof points[k].x == "string" && points[k].x.indexOf('<br>') != -1)
                                    points[k].x = points[k].x.replace(/(<br>)+/g, '<br>');
                                points[k].xValue = points[k].x;
                                if (!setXValueType) {
                                    pointX = points[k].x;
                                    if (!isNullOrUndefined(pointX)) {
                                        currentSeries._xAxisValueType = this._getDataType(pointX);
                                        setXValueType = true;
                                    }
                                }
                                if (!(currentSeries._hiloTypes) && (currentSeries.drawType.toLowerCase() != "rangecolumn")) {
                                    points[k].YValues[0] = currentSeries.points[k].y;

                                    setSize = setSize && !isNullOrUndefined(points[k].size);
                                    if (setSize)
                                        points[k].YValues[1] = points[k].size;
                                }
                                else {
                                    if (!isNullOrUndefined(points[k].high)) {
                                        points[k].YValues[0] = points[k].high;
                                        points[k].y = points[k].high;
                                    }
                                    if (!isNullOrUndefined(points[k].low))
                                        points[k].YValues[1] = points[k].low;
                                    if (!isNullOrUndefined(points[k].open))
                                        points[k].YValues[2] = points[k].open;
                                    if (!isNullOrUndefined(points[k].close))
                                        points[k].YValues[3] = points[k].close;
                                }
                            }
                        }
                        else {
                            currentSeries = series[i];
                            currentSeries._xAxisValueType = null;
                            pointLength = currentSeries.points.length;
                            pointX = currentSeries.points.length ? currentSeries.points[0].x : pointX;

                            if (pointX != null) {
                                currentSeries._xAxisValueType = this._getDataType(pointX);
                            }
                            var pointsLength = currentSeries.points.length;
                            var points = currentSeries.points;
                            for (var p = 0; p < pointsLength; p++) {
                                if (typeof points[p].x == "string" && points[p].x.indexOf('<br>') != -1)
                                    points[p].x = points[p].x.replace(/(<br>)+/g, '<br>');
                            }
                        }
                        //Calculate waterfall series points and remove on series changed
                        if (currentSeries.type.toLowerCase() == "waterfall")
                            this.calculateWaterfallSeriesPoints(currentSeries.points);
                        else if (currentSeries._previousType && currentSeries._previousType.toLowerCase() == "waterfall") {
                            visiblePoints = currentSeries.points;
                            for (j = 0; j < visiblePoints.length; j++) {
                                visiblePoints[j].waterfallSum = undefined;
                                visiblePoints[j].textOptions = null;
                            }
                        }
                    }
                }
                this._setInternalValues();
            }
        },
        calculateWaterfallSeriesPoints: function (visiblePoints) {

            var intermediateStartValue = 0;
            var totalSum = 0;
            var previousSum = 0;

            for (var j = 0; j < visiblePoints.length; j++) {
                if (!visiblePoints[j].isEmpty) {
                    totalSum += ((visiblePoints[j].showIntermediateSum || visiblePoints[j].showTotalSum) ? 0 : visiblePoints[j].y);

                    if (visiblePoints[j].showIntermediateSum) {
                        visiblePoints[j].YValues[1] = intermediateStartValue;
                        visiblePoints[j].YValues[0] = totalSum;
                        visiblePoints[j].waterfallSum = totalSum - intermediateStartValue;
                        intermediateStartValue = totalSum;
                    } else if (visiblePoints[j].showTotalSum) {
                        visiblePoints[j].YValues[1] = 0;
                        visiblePoints[j].YValues[0] = totalSum;
                        visiblePoints[j].waterfallSum = totalSum;
                    }
                    else {
                        visiblePoints[j].YValues[1] = previousSum;
                        visiblePoints[j].YValues[0] = previousSum + visiblePoints[j].y;
                        previousSum = totalSum;
                    }
                } else {
                    visiblePoints[j].YValues[1] = 0;
                    visiblePoints[j].YValues[0] = 0;
                }
            }
        },
        _setInternalValues: function () {

            for (var k = 0; k < this.model.series.length; k++) {
                var series = this.model.series[k];
                if (this.model.AreaType == "cartesianaxes" && sf.seriesTypes[series.type.toLowerCase()].prototype.chartAreaType == "cartesianAxes") {
                    series._zOrder = (series.zOrder) ? series.zOrder : 0;
                    this.model._visibleSeries.push(series);
                }
                else if (this.model.AreaType == "none" && sf.seriesTypes[series.type.toLowerCase()].prototype.chartAreaType == "None") {
                    series._zOrder = (series.zOrder) ? series.zOrder : 0;
                    var type = this.model.series[k].type.toLowerCase();
                    if (type == 'funnel' || type == 'pyramid') {
                        this.model._visibleSeries.push(series);
                        break;
                    }
                    else {
                        this.model._visibleSeries.push(series);
                    }
                }
                else if (this.model.AreaType == "polaraxes" && sf.seriesTypes[series.type.toLowerCase()].prototype.chartAreaType == "PolarAxes") {
                    series._zOrder = (series.zOrder) ? series.zOrder : 0;
                    this.model._visibleSeries.push(series);
                }

                if (series._yAxisName || series._xAxisName) {
                    if (this.model._axes) {
                        for (var t = 0; t < this.model._axes.length; t++) {
                            if (series._yAxisName && (series._yAxisName == this.model._axes[t].name)) {
                                this.model._axes[t].orientation = (this.model._axes[t].orientation) ? this.model._axes[t].orientation : (this.model.requireInvertedAxes) ? "horizontal" : "vertical";
                            }
                            if (series._xAxisName && (series._xAxisName == this.model._axes[t].name)) {
                                this.model._axes[t].orientation = (this.model._axes[t].orientation) ? this.model._axes[t].orientation : (this.model.requireInvertedAxes) ? "vertical" : "horizontal";
                            }
                        }
                    }
                }
            }
        },
        setHiloStyle: function (series, pointIndex, seriesIndex, interiorColor) {
            var point = series.points[pointIndex], interior, seriesInterior;

            if (point.fill)
                interior = point.fill;
            else
                interior = series.fill ? series.fill : interiorColor;

            // setting default series color		
            var colors = interior ? interior : this.model.seriesColors[seriesIndex];

            // applying gradient color		  

            seriesInterior = jQuery.type(colors) == "array" ? colors[0].color : colors;

            return seriesInterior;

        },
        setStyle: function (chart, series, seriesIndex, pointIndex, interiorColor, visiblePoints) {

            var pointsColl = visiblePoints || series._visiblePoints, point = pointsColl[pointIndex], interior, borderColor, borderWidth, dashArray, width,
                opacity, seriesFill, pointBorder = point.border, seriesBorder = series.border;
            // var pointStyle = point.style ? point.style : " ";

            if (series._hiloTypes)
                seriesFill = series.isFill ? series.fill : null;

            // setting interior
            if (chart.chartObj.model.AreaType == "cartesianaxes") {
                if (point.fill)
                    interior = point.fill;
                else {
                    if (series.type.toLowerCase() == "waterfall") {
                        if (((point.showIntermediateSum || point.showTotalSum) && (point.waterfallSum > 0)) || (point.y > 0) && !point.showIntermediateSum && !point.showTotalSum)
                            interior = series.positiveFill ? series.positiveFill : interiorColor;
                    } else
                        interior = seriesFill ? seriesFill : interiorColor;
                }

                // setting default series color		
                var colors = interior ? interior : this.model.seriesColors[seriesIndex];

                // applying gradient color		  
                if (chart.chartObj.model.requireInvertedAxes)
                    var seriesInterior = this.svgRenderer.createGradientElement(chart.getSeriesName(series) + "_" + seriesIndex + pointIndex, colors, 0, 0, 100, 0, chart.gSeriesGroupEle);
                else
                    seriesInterior = this.svgRenderer.createGradientElement(chart.getSeriesName(series) + "_" + seriesIndex + pointIndex, colors, 0, 0, 0, 100, chart.gSeriesGroupEle);
            }

            // interior for pie type series
            else {
                var pointColors = this.model.pointColors;
                interior = point.fill ? point.fill : jQuery.type(pointColors[pointIndex]) == "array" ? pointColors[pointIndex][0].color : pointColors[pointIndex];
                var pointInterior = this.svgRenderer.createGradientElement(chart.getSeriesName(series) + pointIndex, interior, 0, 0, 0, ($(chart.svgObject).height() || parseFloat(this.model.size.height)), chart.chartObj.gSeriesEle);
            }

            // setting borderColor
            borderColor = ((pointBorder) && pointBorder.color) ? pointBorder.color : seriesBorder.color;
            borderWidth = ((pointBorder) && !sf.util.isNullOrUndefined(pointBorder.width)) ? pointBorder.width : seriesBorder.width;
            opacity = point.opacity ? point.opacity : series.opacity;
            width = (point.width) ? point.width : series.width;
            dashArray = ((pointBorder) && pointBorder.dashArray) ? pointBorder.dashArray : seriesBorder.dashArray;

            var options = {
                'interior': seriesInterior ? seriesInterior : pointInterior,
                'borderColor': borderColor,
                'borderWidth': borderWidth,
                'width': width,
                'opacity': opacity,
                'dashArray': dashArray
            };
            return options;
        },

        colorNameToHex: function (colour) {
            var color = colour;
            var colours = {
                "aliceblue": "#f0f8ff", "antiquewhite": "#faebd7", "aqua": "#00ffff", "aquamarine": "#7fffd4", "azure": "#f0ffff",
                "beige": "#f5f5dc", "bisque": "#ffe4c4", "black": "#000000", "blanchedalmond": "#ffebcd", "blue": "#0000ff", "blueviolet": "#8a2be2", "brown": "#a52a2a", "burlywood": "#deb887",
                "cadetblue": "#5f9ea0", "chartreuse": "#7fff00", "chocolate": "#d2691e", "coral": "#ff7f50", "cornflowerblue": "#6495ed", "cornsilk": "#fff8dc", "crimson": "#dc143c", "cyan": "#00ffff",
                "darkblue": "#00008b", "darkcyan": "#008b8b", "darkgoldenrod": "#b8860b", "darkgray": "#a9a9a9", "darkgreen": "#006400", "darkkhaki": "#bdb76b", "darkmagenta": "#8b008b", "darkolivegreen": "#556b2f",
                "darkorange": "#ff8c00", "darkorchid": "#9932cc", "darkred": "#8b0000", "darksalmon": "#e9967a", "darkseagreen": "#8fbc8f", "darkslateblue": "#483d8b", "darkslategray": "#2f4f4f", "darkturquoise": "#00ced1",
                "darkviolet": "#9400d3", "deeppink": "#ff1493", "deepskyblue": "#00bfff", "dimgray": "#696969", "dodgerblue": "#1e90ff",
                "firebrick": "#b22222", "floralwhite": "#fffaf0", "forestgreen": "#228b22", "fuchsia": "#ff00ff",
                "gainsboro": "#dcdcdc", "ghostwhite": "#f8f8ff", "gold": "#ffd700", "goldenrod": "#daa520", "gray": "#808080", "green": "#008000", "greenyellow": "#adff2f",
                "honeydew": "#f0fff0", "hotpink": "#ff69b4",
                "indianred ": "#cd5c5c", "indigo ": "#4b0082", "ivory": "#fffff0", "khaki": "#f0e68c",
                "lavender": "#e6e6fa", "lavenderblush": "#fff0f5", "lawngreen": "#7cfc00", "lemonchiffon": "#fffacd", "lightblue": "#add8e6", "lightcoral": "#f08080", "lightcyan": "#e0ffff", "lightgoldenrodyellow": "#fafad2",
                "lightgrey": "#d3d3d3", "lightgreen": "#90ee90", "lightpink": "#ffb6c1", "lightsalmon": "#ffa07a", "lightseagreen": "#20b2aa", "lightskyblue": "#87cefa", "lightslategray": "#778899", "lightsteelblue": "#b0c4de",
                "lightyellow": "#ffffe0", "lime": "#00ff00", "limegreen": "#32cd32", "linen": "#faf0e6",
                "magenta": "#ff00ff", "maroon": "#800000", "mediumaquamarine": "#66cdaa", "mediumblue": "#0000cd", "mediumorchid": "#ba55d3", "mediumpurple": "#9370d8", "mediumseagreen": "#3cb371", "mediumslateblue": "#7b68ee",
                "mediumspringgreen": "#00fa9a", "mediumturquoise": "#48d1cc", "mediumvioletred": "#c71585", "midnightblue": "#191970", "mintcream": "#f5fffa", "mistyrose": "#ffe4e1", "moccasin": "#ffe4b5",
                "navajowhite": "#ffdead", "navy": "#000080",
                "oldlace": "#fdf5e6", "olive": "#808000", "olivedrab": "#6b8e23", "orange": "#ffa500", "orangered": "#ff4500", "orchid": "#da70d6",
                "palegoldenrod": "#eee8aa", "palegreen": "#98fb98", "paleturquoise": "#afeeee", "palevioletred": "#d87093", "papayawhip": "#ffefd5", "peachpuff": "#ffdab9", "peru": "#cd853f", "pink": "#ffc0cb", "plum": "#dda0dd", "powderblue": "#b0e0e6", "purple": "#800080",
                "red": "#ff0000", "rosybrown": "#bc8f8f", "royalblue": "#4169e1",
                "saddlebrown": "#8b4513", "salmon": "#fa8072", "sandybrown": "#f4a460", "seagreen": "#2e8b57", "seashell": "#fff5ee", "sienna": "#a0522d", "silver": "#c0c0c0", "skyblue": "#87ceeb", "slateblue": "#6a5acd", "slategray": "#708090", "snow": "#fffafa", "springgreen": "#00ff7f", "steelblue": "#4682b4",
                "tan": "#d2b48c", "teal": "#008080", "thistle": "#d8bfd8", "tomato": "#ff6347", "turquoise": "#40e0d0",
                "violet": "#ee82ee",
                "wheat": "#f5deb3", "white": "#ffffff", "whitesmoke": "#f5f5f5",
                "yellow": "#ffff00", "yellowgreen": "#9acd32"
            };

            if (Object.prototype.toString.call(color) == '[object Array]')
                return color;

            if (typeof colours[color.toLowerCase()] != 'undefined')
                return colours[color.toLowerCase()];

            return color;
        },

        _getLocalizedLabels: function () {
            return sf.getLocalizedConstants(this.sfType, this.model.locale);
        },

        // set culture for chart
        _setCulture: function (culture) {
            this.culture = sf.preferredCulture(culture);
        },


        draw: function (excludeDataUpdate) {
            this.removeMultiRect();
            var params = {};
            params.axes = {};
            this._drawBackInterior();
            this.model.chartRegions = [];
            this.model.outsideDataRegionPoints = [];
            this.model.regionCount = null;
            this.model.circularRadius = [];
			this.model.circleCenterX = [];
            this.model.circleCenterY = [];
            this.model.innerRadius = [];
            this.model.bounds = [];
            this.accDataLabelRegion = [];
            this.model.rightsidebounds = [];
            this.model.leftsidebounds = [];
            this.model.excludeDataUpdate = excludeDataUpdate;
            this.model.yAxisLabelRegions = [];
            this.model.xAxisLabelRegions = [];
            this.model.axisMultiLevelLabelRegions = [];
            this.model.multiLevelLabelRegions = [];
            this.model.minhightwidth = false;
            this.model._isPieOfPie = false;
            if (!excludeDataUpdate)
                this.model._visibleSeries = [];
            this.model.stackedValue = {};
            this.model._locale = this.model.locale || "en-US";
            this._setCulture(this.model._locale);
            this._localizedLabels = this._getLocalizedLabels();
            var seriesLength = this.model.series.length;
            var series, seriesType;
            if (sf.util.isNullOrUndefined(this.model.sideBySideSeriesPlacement))  // for setting sideBySideSeriesPlacement property values
                this.model._sideBySideSeriesPlacement = (this.model.enable3D) ? false : true;
            else
                this.model._sideBySideSeriesPlacement = this.model.sideBySideSeriesPlacement;
            for (var i = 0; i < seriesLength; i++) {
                series = this.model.series[i];
                seriesType = series.type.toLowerCase();
                series._isTransposed = (seriesType.indexOf("bar") == -1) ? series.isTransposed : !series.isTransposed;
            }
            if (seriesLength > 0)
                this.addedXYValues(excludeDataUpdate);
            this.model.AreaType = this.model.AreaType || "cartesianaxes";

            this._isEjScroller();

            var commonpreRenderEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonpreRenderEventArgs.data = {};
            this._trigger("preRender", commonpreRenderEventArgs);

            this.gLegendEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_Legend' });

            this.gTitleEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_ChartTitle', 'cursor': 'default' });
            this.gSubTitleEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_ChartsubTitle', 'cursor': 'default' });
            this._createAxisLabelAndRange();
            for (var i = 0; i < this.model._axes.length; i++)
                params.axes[this.model._axes[i].name] = {};
            this._initializeSeriesColors();

            this._calculateLegendBounds();

            this.legendRender = new sf.EjLegendRender(this);

            var commonLegendEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonLegendEventArgs.data = { legendBounds: this.model.LegendBounds };
            this._trigger("legendBoundsCalculate", commonLegendEventArgs);

            // Assigning indicator points
            for (var j = 0; j < this.model.indicators.length; j++) {
                var indicator = this.model.indicators[j];
                indicator._points = [];
                indicator.xAxisName = (!(indicator.xAxisName)) ? this.model._axes[0].name : indicator.xAxisName;
                indicator.yAxisName = (!(indicator.yAxisName)) ? this.model._axes[1].name : indicator.yAxisName;
                indicator.isIndicator = true;
                if (indicator.dataSource && indicator.dataSource.length > 0) {
                    indicator._hiloTypes = true;
                    this._processJsonData(indicator.dataSource, indicator);
                    //Indicator uses _points but ProcessJsonData only populate points collection
                    indicator._points = indicator.points;
                } else if (indicator.points.length > 0) {
                    for (var i = 0; i < indicator.points.length; i++) {
                        indicator._points = indicator.points;
                        indicator._points[i].xValue = indicator.points[i].x;
                        indicator._points[i].YValues = [];
                        indicator._points[i].YValues[0] = indicator.points[i].close;
                    }
                }
                else if (indicator.seriesName != "") {
                    for (var index = 0; index < this.model._visibleSeries.length; index++) {
                        var series = this.model._visibleSeries[index];
                        if (indicator.seriesName == series.name)
                            indicator._points = $.extend(true, [], series.points);
                    }
                }
            }

            // calculate category points
            for (k = 0; k < this.model._axes.length; k++) {
                if (this.model._axes[k].valueType && this.model._axes[k].valueType.toLowerCase() == "category") {
                    for (i = 0; i < this.model.indicators.length; i++) {
                        indicator = this.model.indicators[i];
                        if (this.model._axes[k].name == indicator.xAxisName) {
                            for (j = 0; j < indicator._points.length; j++)
                                indicator._points[j].xValue = j;
                        }
                    }
                }
            }

            // calculate ranges for indicator
            this.model.indicatorRange = [];
            for (index = 0; index < this.model.indicators.length; index++) {
                indicator = this.model.indicators[index];
                if (indicator._points.length > 0) {
                    type = indicator.type.toLowerCase();
                    options = new sf.indicatorTypes[type]();
                    options.calculateSegment(indicator, this);
                }
            }


            for (var m = 0; m < this.model._visibleSeries.length; m++) {
                var options = this.model._visibleSeries[m];
                for (i = 0; i < options.points.length; i++) {
                    if (typeof options.points[i].xValue == "string" && options.points[i].xValue.indexOf("/Date(") != -1)
                        options.points[i].xValue = new Date(parseInt(options.points[i].xValue.substr(6)));
                    else
                        break;
                }
            }
            this.model.hAxes = [];
            this.model.vAxes = [];
            var chartobj = this;
            var isStriplineOver = false, isStriplineBehind = false;
            this._arrangeAxis();
            var scrollbarSettings;
            this.model.crosshairLabelVisibility = false;
            for (var k = 0; k < this.model._axes.length; k++) {
                var axis = this.model._axes[k];
                this.model.crosshairLabelVisibility = axis.crosshairLabel.visible || this.model.crosshairLabelVisibility;
                var seriesCollection = [];
                var seriesLength = this.model.series.length;
                var orientation = this.model._axes[k].orientation.toLowerCase();
                var padding = this.model._axes[k].rangePadding.toLowerCase();
                if (sf.util.isNullOrUndefined(this.model._axes[k]._rangePadding))
                    this.model._axes[k]._rangePadding = this.model._axes[k].rangePadding;
                if (padding == "auto") {
                    if (orientation == "vertical") {
                        axis.rangePadding = (!this.model.requireInvertedAxes) ? "normal" : "none";
                    }
                    if (orientation == "horizontal") {
                        axis.rangePadding = (this.model.requireInvertedAxes) ? "normal" : "none";
                    }
                    for (var j = 0; j < seriesLength; j++) {
                        var type = this.model.series[j].type.toLowerCase();
                        if (type.indexOf("100") != -1) {
                            if (axis.name == this.model.series[j]._yAxisName) {
                                axis.rangePadding = "round"; break;
                            }
                        }
                    }
                }
                for (var slCount = 0; slCount < axis.stripLine.length; slCount++) {
                    axis.stripLine[slCount] = $.extend(true, {}, this.model.stripLineDefault, axis.stripLine[slCount]);
                    if (axis.stripLine[slCount].zIndex.toLowerCase() == 'over') {
                        isStriplineOver = true;
                    } else {
                        isStriplineBehind = true;
                    }
                }
                var axisOrientation = axis.orientation.toLowerCase();
                var zOrder = this.model._visibleSeries.length - 1;
                for (j = 0; j < this.model._visibleSeries.length; ++j) {
                    zOrder -= 1;

                    var series = this.model._visibleSeries[j];
                    this.model._hasSeriesPoints = series.points.length > 0 || this.model._hasSeriesPoints;
                    if ((!series.xAxisName)) {
                        series._xAxisName = chartobj.model._axes[0].name;
                    }
                    if (!series.yAxisName) {
                        series._yAxisName = chartobj.model._axes[1].name;
                    }
                    series._xAxisName = (!(series._xAxisName)) ? (!(series.xAxisName) ? chartobj.model._axes[0].name : series.xAxisName) : series._xAxisName;
                    series._yAxisName = (!(series._yAxisName)) ? (!(series.yAxisName) ? chartobj.model._axes[1].name : series.yAxisName) : series._yAxisName;
                    var xAxisName = series._xAxisName.toLowerCase();
                    var yAxisName = series._yAxisName.toLowerCase();
                    var name = axis.name.toLowerCase();
                    if (xAxisName || yAxisName) {
                        if (xAxisName == name || yAxisName == name) {
                            if ((axisOrientation == "horizontal" || (series.type.toLowerCase().indexOf("bar") != -1 && axisOrientation == "vertical")) && axis.valueType && axis.valueType.toLowerCase() == "datetime") {
                                for (var m = 0; m < series.points.length; m++) {
                                    if (typeof series.points[m].xValue == "string" && !isNaN(Date.parse(series.points[m].xValue)))
                                        series.points[m].xValue = new Date(Date.parse(series.points[m].xValue));
                                }
                            }
                            else {
                                if (series._xAxisValueType == "string" && !(axis.valueType))
                                    axis._valueType = (axisOrientation == 'horizontal' && !this.model.requireInvertedAxes) ? 'category' : (axisOrientation == 'vertical' && this.model.requireInvertedAxes) ? 'category' : 'double';

                                if (series._xAxisValueType == "date" && !(axis.valueType))
                                    axis._valueType = (axisOrientation == 'horizontal' && !this.model.requireInvertedAxes) ? "datetime" : (axisOrientation == 'vertical' && this.model.requireInvertedAxes) ? 'datetime' : 'double';
                            }
                            if (this.model._visibleSeries[j].visibility.toLowerCase() == 'visible')
                                seriesCollection.push(series);
                        }

                    }
                }
                if (axisOrientation == ((!this.model.requireInvertedAxes) ? "vertical" : "horizontal")) {
                    var isStacked100 = false;
                    var isStacked = false;
                    var seriesLength = seriesCollection.length;
                    axis.isStacked100 = (seriesCollection.length > 0) ? true : false;
                    for (var i = 0; i < seriesLength; i++) {
                        var type = seriesCollection[i].type.toLowerCase();
                        if (type.indexOf("stacking") != -1 || (this.model.AreaType == 'polaraxes' && (seriesCollection[i].drawType.toLowerCase() == 'column' || seriesCollection[i].drawType.toLowerCase() == 'area') && seriesCollection[i].isStacking)) {
                            if (type.indexOf("100") != -1 && (!isStacked100)) {
                                this._calculateStackingCumulativeValues(seriesCollection, axis, params);
                                isStacked100 = true;
                            } else if (type.indexOf("100") == -1 && (!isStacked)) {
                                this._calculateStackingValues(seriesCollection, axis, params);
                                isStacked = true;
                                axis.isStacked100 = false;
                            }
                        }
                        else {
                            axis.isStacked100 = false;
                        }
                    }
                }
                scrollbarSettings = axis.scrollbarSettings;
                if ((scrollbarSettings.visible) && (scrollbarSettings.pointsLength != null || scrollbarSettings.range.min != null || scrollbarSettings.range.max != null)) {
                    this.model.isLazyZooming = true;
                }
                axis._valueType = (!(axis._valueType)) ? (!(axis.valueType) ? "double" : axis.valueType) : axis._valueType;
                var axisRange = new sf.axisTypes[axis._valueType.toLowerCase()]();
                for (var ser = 0; ser < seriesCollection.length; ser++) {
                    for (var trend = 0; trend < seriesCollection[ser].trendlines.length; trend++) {
                        if (seriesCollection[ser].trendlines[trend].visibility == "visible") {
                            this.model._drawTrendline = true;
                            break;
                        }
                    }
                }
                axisRange._calculateRanges(chartobj, axis, seriesCollection, params, excludeDataUpdate);
            }
            chartobj._chartResize = false;

            var commonAxesInitEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonAxesInitEventArgs.data = { axes: this.model._axes };
            this._trigger("axesLabelsInitialize", commonAxesInitEventArgs);

            this.model.isLazyZooming ? 0 : this._updateScroll();
            var prevHeight,
                prevWidth;
            if (this.svgHeight != this.model.svgHeight || this.svgWidth != this.model.svgWidth) {
                // beforeResize event
                prevHeight = sf.util.isNullOrUndefined(this.prevHeight) ? this.svgHeight : this.prevHeight;
                prevWidth = sf.util.isNullOrUndefined(this.prevWidth) ? this.svgWidth : this.prevWidth;
                commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = { currentHeight: prevHeight, currentWidth: prevWidth, newHeight: this.model.svgHeight, newWidth: this.model.svgWidth };
                this._trigger("beforeResize", commonEventArgs);
                if (!commonEventArgs.cancel) {
                    if (this.model.enableCanvasRendering) {
                        this.svgRenderer.svgObj.width = commonEventArgs.data.newWidth;
                        this.svgRenderer.svgObj.height = commonEventArgs.data.newHeight;
                    }
                    this.model.svgWidth = commonEventArgs.data.newWidth;
                    this.model.svgHeight = commonEventArgs.data.newHeight;
                    $(this.svgObject).width(commonEventArgs.data.newWidth);
                    $(this.svgObject).height(commonEventArgs.data.newHeight);
                }
                else {
                    if (this.model.enableCanvasRendering) {
                        this.svgRenderer.svgObj.width = commonEventArgs.data.currentWidth;
                        this.svgRenderer.svgObj.height = commonEventArgs.data.currentHeight;
                    }
                    this.model.svgWidth = commonEventArgs.data.currentWidth;
                    this.model.svgHeight = commonEventArgs.data.currentHeight;
                    $(this.svgObject).width(commonEventArgs.data.currentWidth);
                    $(this.svgObject).height(commonEventArgs.data.currentHeight);
                }
            }
            this._calculateAreaBounds(params);

            if (this.model.enable3D) {

                var Ej3DRender = new sf.Ej3DRender();
                this.vector = new Ej3DRender.vector3D();
                this.matrixobj = new Ej3DRender.matrix3D();
                this.bsptreeobj = new Ej3DRender.BSPTreeBuilder();
                this.polygon = new Ej3DRender.polygon3D();
                this.graphics = new Ej3DRender.Graphics3D();

                this.chart3D = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_Chart3D' });
                sf.Ej3DRender.Polygons = [];
            }


            if (this.model.AreaType != "none") {

                this._calculateAxisSize(params);

                //AxisCrossing                
                for (var i = 0, len = this.model._axes.length; i < len; i++)
                    if (this._validateCrossing(this.model._axes[i]))
                        this._axisCrossing(this.model._axes[i], false, params);
                if (params._crossAxisOverlap) {
                    for (var i = 0, len = this.model._axes.length; i < len; i++)
                        if (params.axes[this.model._axes[i].name]._validCross)
                            this._axisCrossing(this.model._axes[i], true, params);
                    params._crossAxisOverlap = false;
                }

                var commonAreaEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonAreaEventArgs.data = { areaBounds: this.model.m_AreaBounds };
                this._trigger("chartAreaBoundsCalculate", commonAreaEventArgs);

                this._drawChartAreaRect();

                if (this.model.title.text != "" && this.model.title.text && this.model.title.visible)
                    this._drawTitle();

                this.gXaxisEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxis' });

                this.gYaxisEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxis' });

                this.gPolarAxisEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_AxisLine' });
                if (this.model.enable3D) {

                    $.extend(sf.Ej3DAxisRenderer.prototype, this);
                    this.chartaxis = new sf.Ej3DAxisRenderer(this);
                }
                else {
                    $.extend(sf.EjAxisRenderer.prototype, this);
                    this.chartaxis = new sf.EjAxisRenderer(this);
                }

                var chartaxis = this.chartaxis;
                this.model.xAxisTitleRegion = [];
                this.model.yAxisTitleRegion = [];

                if (this.model.enable3D) {
                    for (var l = 0; l < this.model._axes.length; l++) {
                        chartaxis._drawAxes(l, this.model._axes[l], params);
                    }
                    sf.Ej3DChart.prototype.update3DWall(this, params);
                }
                else {
                    for (var l = 0; l < this.model._axes.length; l++) {
                        chartaxis._drawGridLines(l, this.model._axes[l], params);
                        chartaxis._drawGridRect(l, this.model._axes[l], axis);
                    }
                }


                //Based on the column/bar series, modified primaryAxis append to the SVG Object
                if (!this.model.requireInvertedAxes) {
                    this.svgRenderer.append(this.gXaxisEle, this.svgObject);
                    this.svgRenderer.append(this.gYaxisEle, this.svgObject);
                } else {
                    this.svgRenderer.append(this.gYaxisEle, this.svgObject);
                    this.svgRenderer.append(this.gXaxisEle, this.svgObject);
                }

                var x = (this.model.AreaType == 'polaraxes') ? 0 : this.model.m_AreaBounds.X;
                var y = (this.model.AreaType == 'polaraxes') ? 0 : this.model.m_AreaBounds.Y;

                var width = (this.model.AreaType == 'polaraxes') ? $(this.svgObject).width() : this.model.m_AreaBounds.Width;
                var height = (this.model.AreaType == 'polaraxes') ? $(this.svgObject).height() : this.model.m_AreaBounds.Height;

                var clipRectOptions = {
                    'id': this.svgObject.id + '_ChartAreaClipRect',
                    'x': x,
                    'y': y,
                    'width': width,
                    'height': height,
                    'fill': 'white',
                    'stroke-width': 1,
                    'stroke': 'Gray'
                };

                this.svgRenderer.drawClipPath(clipRectOptions, this.svgObject);

                this._setZoomProperties();
            }

            else {
                this._drawChartAreaRect();

                clipRectOptions = {
                    'id': this.svgObject.id + '_ChartAreaClipRect',
                    'x': 0,
                    'y': 0,
                    'width': $(this.svgObject).width(),
                    'height': $(this.svgObject).height(),
                    'fill': 'white',
                    'stroke-width': 1,
                    'stroke': 'Gray'
                };

                this.svgRenderer.drawClipPath(clipRectOptions, this.svgObject);

                if (this.model.title.text != "" && this.model.title.text && this.model.title.visible)
                    this._drawTitle();
            }

            if (isStriplineBehind && this.model.AreaType == "cartesianaxes" && !this.model.enable3D) {
                this.gStriplineBehind = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_StriplineBehind', 'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)' });
                this._renderStripline('behind');
            }
            if (this.model.initSeriesRender) {
                this.seriesRender(params, excludeDataUpdate);
                this.indicatorRender();
            }

            var annotationsLength = this.model.annotations.length;
            $('#annotation_group_' + this._id).empty();
            for (var a = 0; a < annotationsLength; a++) {
                var currentAnnotation = this.model.annotations[a];
                if (currentAnnotation.visible) {
                    this.annotationRender(currentAnnotation, a);
                }
            }

            if (this.model.AreaType == "polaraxes" && this.model._axes[1].visible && !this.model.enable3D) {
                this.chartaxis._drawAxisLine(this.model._axes[1]);
            }

            if (this.model.AreaType === "cartesianaxes") {
                if (!this.model.requireInvertedAxes) {
                    this.svgRenderer.append(this.gXaxisEle, this.svgObject);
                    this.svgRenderer.append(this.gYaxisEle, this.svgObject);
                } else {
                    this.svgRenderer.append(this.gYaxisEle, this.svgObject);
                    this.svgRenderer.append(this.gXaxisEle, this.svgObject);
                }

                this.gXaxisTickEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisTick' });

                this.gYaxisTickEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisTick' });
            }

            $.extend(sf.EjAxisRenderer.prototype, this);
            this.chartaxis = new sf.EjAxisRenderer(this);
            var chartaxis = this.chartaxis;

            if (isStriplineOver && this.model.AreaType == "cartesianaxes" && !this.model.enable3D) {
                this.gStriplineOver = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_StriplineOver', 'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)' });
                this._renderStripline('over');
            }

            if (!this.model.enable3D) {
                var isCartesian = this.model.AreaType.toLowerCase() == "cartesianaxes",
                    axes = this.model._axes,
                    isCanvas = this.model.enableCanvasRendering;
                //draw axes, labels and ticks
                for (var l = 0, len = axes.length; l < len; l++) {
                    var axis = axes[l], lineOption = params.axes[axis.name]._lineOption, isValidCross = params.axes[axis.name]._validCross;
                    if (isCartesian) {
                        chartaxis._drawAxes(l, axis);
                        if (lineOption[0])
                            this.svgRenderer.drawLine(lineOption[0], lineOption[1]);
                        if (axis.orientation.toLowerCase() === "horizontal") {
                            chartaxis._drawXAxisTickLine(l, axis, isCanvas ? null : lineOption[1], params);
                            chartaxis._drawXAxisMultiLevelLabels(l, axis);
                        }
                        else {
                            chartaxis._drawYAxisTickLine(l, axis, isCanvas ? null : lineOption[1], isValidCross);
                            chartaxis._drawYAxisMultiLevelLabels(l, axis);
                        }
                        axis._crossValue = null;
                    }
                }
            }
            if (!this.resetZooming && (this.model._chartAreaZoom || this.panning))
                this._enableZoomingButtons();
            this.resetZooming = false;

            if (this.svgHeight != this.model.svgHeight || this.svgWidth != this.model.svgWidth) {

                this.prevHeight = this.model.svgHeight;
                this.prevWidth = this.model.svgWidth;
                // afterResize event 
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = { height: this.prevHeight, width: this.prevWidth, prevHeight: prevHeight, prevWidth: prevWidth, originalHeight: this.svgHeight, originalWidth: this.svgWidth };
                this._trigger("afterResize", commonEventArgs);
            }

            //Checking Selection setting enable 
            var seriesCollection = this.model._visibleSeries, selectionFound;
            selectionFound = $.grep(seriesCollection, function (series) { return series.selectionSettings.enable.toString() == "true"; });
            if (selectionFound.length == 0) {
                this.model.selectionEnable = false;
                this._removeSelection();
            } else
                this.model.selectionEnable = true;

            var selectedData = this.remove_duplicates(this.model.selectedDataPointIndexes);
            //Maintaning the selection state and triggering seleceted data
            if (this.model.selectionEnable) {
                this._removeSelection();
                this.model._isStateChaged = true;
                var data,
                    mode,
                    length = selectedData.length;
                for (var i = 0; i < length; i++) {
                    data = selectedData[i];
                    series = this.model._visibleSeries[data.seriesIndex];
                    if (series) {
                        mode = series.selectionSettings.mode;
                        if ((mode != 'series' && series.points[data.pointIndex]) || mode == 'series')
                            this.segmentSelection(data.event, data.legendData, data.seriesIndex, data.pointIndex, data.data);
                    }
                }
            }
            this.chartUpdating = false;
			$(document).find("#measureTex").remove();
            var commonLoadedEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonLoadedEventArgs.data = { model: this.model };
            this._trigger("loaded", commonLoadedEventArgs);
            for (var i = 0; i < this.model._axes.length; i++) {
                var axis = $.extend(true, {}, this.model._axes[i]);
                if (axis._valueType.toLowerCase() != "logarithmic")
                    this.model._axes[i].range = axis._initialRange;
            }


        },
        remove_duplicates: function (arr) {
            var arr1 = [],
                arr2 = [],
                length = arr.length,
                mode,
                currentSeries,
                series = this.model._visibleSeries;
            for (var i = 0; i < length; i++) {
                currentSeries = series[arr[i].seriesIndex];
                mode = currentSeries ? currentSeries.selectionSettings.mode : "";
                if (mode == "series") {
                    if (!(arr1.indexOf(arr[i].seriesIndex) > -1))
                        arr2.push(arr[i]);
                    arr1.push(arr[i].seriesIndex);
                }
                else if (mode == "cluster") {
                    if (!(arr1.indexOf(arr[i].pointIndex) > -1))
                        arr2.push(arr[i]);
                    arr1.push(arr[i].pointIndex);
                } else {
                    if (!(arr[i] in arr1))
                        arr2.push(arr[i]);
                    arr1.push(arr[i]);
                }
            }

            return arr2;

        },

        // set value to private variable for two way binding
        _setZoomProperties: function () {

            var axis, _zf, _zp, orientation;
            for (var l = 0; l < this.model._axes.length; l++) {
                axis = this.model._axes[l];
                orientation = axis.orientation.toLowerCase();
                _zf = axis.zoomFactor.toFixed(3);
                _zp = axis.zoomPosition.toFixed(3);
                if (orientation == "horizontal" && (_zf != this._xZoomFactor() || _zp != this._xZoomPosition())) {
                    this._xZoomFactor(axis.zoomFactor.toFixed(3));
                    this._xZoomPosition(axis.zoomPosition.toFixed(3));
                }
                if (orientation == "vertical" && (_zf != this._yZoomFactor() || _zp != this._yZoomPosition())) {
                    this._yZoomFactor(axis.zoomFactor.toFixed(3));
                    this._yZoomPosition(axis.zoomPosition.toFixed(3));
                }
            }
        },

        annotationRender: function (currentAnnotation, a) {                           // method to render annotation
            //declaration and initialization
            var chartContainer = this._id;
            var flag = false;
            var currentSeries = this.model.series[0];
            var seriesType = currentSeries.type.toLowerCase();
            var areaBoundsX = this.model.m_AreaBounds.X;
            var areaBoundsY = this.model.m_AreaBounds.Y;
            var areaBoundsWidth = this.model.m_AreaBounds.Width;
            var areaBoundsHeight = this.model.m_AreaBounds.Height;
            var marginLeft = this.model.margin.left;
            var marginTop = this.model.margin.top;

            var seriesIndex = $.inArray(currentSeries, this.model._visibleSeries);
            var radius = this.model.circularRadius[seriesIndex];
            var centerX = this.model.circleCenterX[seriesIndex];
            var centerY = this.model.circleCenterY[seriesIndex];
            var currentDocument = $(document);
            var annotationIndex = false;
			var positionX, positionY;
            currentAnnotation = $.extend(true, {}, this.model.annotationsDefault, currentAnnotation);   // extending defaults

            // creating annotation group
            if ($('#annotation_group_' + chartContainer).length != 0)
                var annotationContainer = $('#annotation_group_' + chartContainer);
            else
                annotationContainer = $("<div></div>").attr('id', "annotation_group_" + chartContainer);
            annotationContainer.css({ "position": "absolute", "left": "0px", "top": "0px" });

            var content = currentAnnotation.content;
            element = $("#" + content);
            if (element.get(0).tagName == "SCRIPT")                // for jsrender
                var element = $($("#" + content)[0].innerHTML);
            var cloneNode = element.clone();                        // clone
            var id = 'annotation_' + chartContainer + "_" + content + "_" + a;
            $(cloneNode).attr("id", id);
            var $cloneNode = $(cloneNode);
            $cloneNode.css({
                'position': "absolute",
                'z-index': 2000
            });

            // initialization
            var region = currentAnnotation.region.toLowerCase();
            var coordinateUnit = currentAnnotation.coordinateUnit.toLowerCase();
            var annotationX = (typeof currentAnnotation.x == "string" || typeof currentAnnotation.x == "object") ? Date.parse(currentAnnotation.x) : currentAnnotation.x;
            var annotationY = currentAnnotation.y;
            var horizontalAlignment = currentAnnotation.horizontalAlignment.toLowerCase();
            var verticalAlignment = currentAnnotation.verticalAlignment.toLowerCase();

            if (coordinateUnit == "pixels") {                          //pixels
                if (region == "series") {                             // chart area / series
                    if ((areaBoundsWidth + areaBoundsX + marginLeft > annotationX + areaBoundsX) &&
                        areaBoundsHeight + areaBoundsY + marginTop > annotationY + areaBoundsY) {
                        var left = annotationX + areaBoundsX;
                        var top = annotationY + areaBoundsY;
                    }
                }
                else if (region == "chart") {                         // chart
                    if (($(this.svgObject).width() > annotationX) &&
                        $(this.svgObject).height() > annotationY) {
                        left = annotationX;
                        top = annotationY;
                    }
                }

                $cloneNode.css({
                    "left": left,
                    "top": top
                });
                flag = true;                                // to denote that the annotation should be appended in DOM
            } else if (coordinateUnit == "points") {        //points
                var point = {
                    'x': annotationX,
                    'y': annotationY
                };

                if (this.model.AreaType == "polaraxes") {   // polar
                    xAxis = this.model._axes[0];
                    yAxis = this.model._axes[1];
                    if ((annotationX >= xAxis.visibleRange.min && annotationX <= xAxis.visibleRange.max)
                        && (annotationY >= yAxis.visibleRange.min && annotationY <= yAxis.visibleRange.max)) {
                        var location = this.TransformToVisibleAnnotation(xAxis, yAxis, annotationX, annotationY, this);
                        $cloneNode.css({
                            "left": location.X,
                            "top": location.Y
                        });
                        flag = true;
                    }
                } else if (seriesType == "pyramid" || seriesType == "funnel") { // pyramid and funnel
                    for (var k = 0; k < currentSeries._visiblePoints.length; k++) {
                        annotationIndex = (currentSeries._visiblePoints[k].xValue <= annotationX && annotationX < currentSeries._visiblePoints.length) ? true
                            : (Date.parse(currentSeries._visiblePoints[k].xValue) <= annotationX && annotationX < currentSeries._visiblePoints.length) ? true : false;
                        if (annotationIndex) {
                            var currentPoint = currentSeries._visiblePoints[annotationX];
                            $cloneNode.css({
                                "left": currentPoint.xLocation + this.pyrX,
                                "top": currentPoint.yLocation + this.pyrY - (currentPoint.height / 2)
                            });
                            flag = true;
                        }
                    }
                } else if (seriesType == "pie" || seriesType == "doughnut" || seriesType == "pieofpie") { // pie, pieofpie and doughnut
                    for (var k = 0; k < currentSeries._visiblePoints.length; k++) {
                        annotationIndex = (currentSeries._visiblePoints[k].xValue <= annotationX && annotationX < currentSeries._visiblePoints.length) ? true
                            : (Date.parse(currentSeries._visiblePoints[k].xValue) <= annotationX && annotationX < currentSeries._visiblePoints.length) ? true : false;
                        if (annotationIndex) {
                            currentPoint = currentSeries._visiblePoints[annotationX];
                            var pointIndex = annotationX;
                            var startX, startY;
                            var series = new sf.seriesTypes[seriesType]();
                            var midAngle = currentPoint ? currentPoint.currentMidAngle : 0;
                            if ((pointIndex == currentSeries.explodeIndex || currentSeries.explodeAll) && !this.vmlRendering) {
                                startX = centerX + Math.cos(midAngle) * currentSeries.explodeOffset;
                                startY = centerY + Math.sin(midAngle) * currentSeries.explodeOffset;
                            } else {
                                startX = centerX;
                                startY = centerY;
                            }
                            var midX = series.getXCordinate(startX, (radius), midAngle);
                            var midY = series.getYCordinate(startY, (radius), midAngle);

                            positionX = (midX + startX) / 2;
                            positionY = (midY + startY) / 2;

                            positionX = (midX + positionX) / 2;
                            positionY = (midY + positionY) / 2;

                            $cloneNode.css({
                                "left": positionX,
                                "top": positionY
                            });
                            flag = true;
                        }
                    }
                } else {                                               // cartesianaxes
                    var xAxisName = currentAnnotation.xAxisName;
                    var yAxisName = currentAnnotation.yAxisName;
                    var axesLength = this.model._axes.length;
                    for (var i = 0; i < axesLength; i++) {
                        if (this.model._axes[i].name == xAxisName)
                            var xAxis = this.model._axes[i];
                        if (this.model._axes[i].name == yAxisName)
                            var yAxis = this.model._axes[i];
                    }
                    if (!xAxis) xAxis = this.model._axes[0];           // setting primary axis by default
                    if (!yAxis) yAxis = this.model._axes[1];
                    var minRange = (typeof xAxis.range.min == "string" || typeof xAxis.range.min == "object") ? Date.parse(xAxis.range.min) : xAxis.range.min;
                    var maxRange = (typeof xAxis.range.max == "string" || typeof xAxis.range.max == "object") ? Date.parse(xAxis.range.max) : xAxis.range.max;
                    if (minRange <= annotationX && maxRange >= annotationX) {

                        if (!this.model.requireInvertedAxes) {
                            location = this._getAnnotationPoint(point, xAxis, yAxis);
                            $cloneNode.css({
                                "left": location.X + areaBoundsX,
                                "top": location.Y + yAxis.y
                            });
                        }
                        else {
                            point.x = point.y + (point.y = point.x, 0);// swapping x, y => a = b + (b=a, 0)
                            location = this._getAnnotationPoint(point, yAxis, xAxis);
                            $cloneNode.css({
                                "left": location.X + areaBoundsX,
                                "top": location.Y + xAxis.y
                            });
                        }
                        flag = true;
                    }
                }
            } else {                                                                      //other alignment
                $cloneNode.css("display", "block").appendTo($(annotationContainer));       //append
                $(annotationContainer).appendTo('#' + 'chartContainer_' + chartContainer);
                var width = $cloneNode.outerWidth();
                var height = $cloneNode.outerHeight();
                if (region == "chart") {
                    switch (horizontalAlignment) {
                        case "middle":
                            left = $(this.svgObject).width() / 2 - width / 2;
                            break;
                        case "left":
                            left = 0;
                            break;
                        case "right":
                            left = $(this.svgObject).width() - width;
                    }
                    switch (verticalAlignment) {
                        case "middle":
                            top = $(this.svgObject).height() / 2 - height / 2;
                            break;
                        case "top":
                            top = 0;
                            break;
                        case "bottom":
                            top = $(this.svgObject).height() - height;
                    }
                } else {
                    if (seriesType == "pie" || seriesType == "doughnut" || seriesType == "pieofpie") {             // for pie, pieofpie and doughnut
                        left = centerX;
                        top = centerY;
                        switch (horizontalAlignment) {
                            case "middle":
                                left = centerX - width / 2;
                                break;
                            case "left":
                                left = centerX - radius;
                                break;
                            case "right":
                                left = centerX + radius - width;
                        }

                        switch (verticalAlignment) {
                            case "middle":
                                top = centerY - height / 2;
                                break;
                            case "top":
                                top = centerY - radius;
                                break;
                            case "bottom":
                                top = centerY + radius;
                        }
                    } else {
                        switch (horizontalAlignment) {
                            case "middle":
                                left = areaBoundsX + (areaBoundsWidth / 2) - width / 2;
                                break;
                            case "left":
                                left = areaBoundsX;
                                break;
                            case "right":
                                left = areaBoundsX + areaBoundsWidth - width;
                        }

                        switch (verticalAlignment) {
                            case "middle":
                                top = areaBoundsY + (areaBoundsHeight / 2) - height / 2;
                                break;
                            case "top":
                                top = areaBoundsY;
                                break;
                            case "bottom":
                                top = areaBoundsY + areaBoundsHeight - height;
                        }
                    }
                }
                if (seriesType == "pyramid" || seriesType == "funnel") {         // to remove margin value
                    left -= marginLeft;
                }
                $cloneNode.css({
                    "left": left,
                    "top": top
                });
            }

            left = parseFloat($cloneNode.css("left"));
            top = parseFloat($cloneNode.css("top"));                              // get left and top value
            if (coordinateUnit != "none" && flag) {
                $cloneNode.css("display", "block").appendTo($(annotationContainer));   //append
                $(annotationContainer).appendTo('#' + 'chartContainer_' + chartContainer);
                width = $cloneNode.outerWidth();
                height = $cloneNode.outerHeight();
                switch (horizontalAlignment) {
                    case "middle":
                        left -= width / 2;
                        break;
                    case "left":
                        left -= width;
                        break;
                }
                switch (verticalAlignment) {
                    case "middle":
                        top -= height / 2;
                        break;
                    case "top":
                        top -= height;
                        break;
                }
            }
            var margin = currentAnnotation.margin;                      // margin values
            left = left + margin.left - margin.right;
            top = top + margin.top - margin.bottom;

            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);          // trigger event
            commonEventArgs.data = {
                content: $cloneNode.html(), location: { x: left, y: top },
                opacity: currentAnnotation.opacity, angle: currentAnnotation.angle
            };
            this._trigger("annotationRendering", commonEventArgs);

            $cloneNode.html(commonEventArgs.data.content);
            $cloneNode.css({
                "left": commonEventArgs.data.location.x,
                "top": commonEventArgs.data.location.y,
                "opacity": commonEventArgs.data.opacity                  //opacity
            });

            var angle = commonEventArgs.data.angle;                     // angle
            if (angle) {
                $cloneNode.css({
                    '-ms-transform': 'rotate(' + angle + 'deg)',        //IE 10 and 9
                    '-webkit-transform': 'rotate(' + angle + 'deg)',    // chrome
                    '-moz-transform': 'rotate(' + angle + 'deg)',       // firefox
                    '-o-transform': 'rotate(' + angle + 'deg)',         // opera
                    '-transform': 'rotate(' + angle + 'deg)'            // general
                });
            }

            var eleId = $cloneNode.attr("id");                          // id of annotation
            var topHeight = bottomHeight = leftWidth = rightWidth = 0;
            var chartWidth = $("#" + this._id).width();
            var chartHeight = $("#" + this._id).height();
            if (flag && (angle == 0) && (region == "series" || coordinateUnit == "points")) {
                if (areaBoundsWidth + areaBoundsX < left + width) {                       // clip right width
                    var excessWidth = (left + width) - (areaBoundsWidth + areaBoundsX);
                    rightWidth = width - excessWidth;
                }
                if (left < areaBoundsX) {                                                  // clip left width
                    leftWidth = areaBoundsX - left;
                }
                if (areaBoundsHeight + areaBoundsY < top + height) {                      // clip bottom height
                    excessHeight = (top + height) - (areaBoundsHeight + areaBoundsY);
                    bottomHeight = height - excessHeight;
                }
                if (top < areaBoundsY) {                                                 // clip top height
                    topHeight = areaBoundsY - top;
                }
                rightWidth = (rightWidth == 0) ? width : rightWidth;
                bottomHeight = (bottomHeight == 0) ? height : bottomHeight;
                document.getElementById(eleId).style.clip = "rect(" + topHeight.toString() + "px," +  // clipping annotation
                    rightWidth.toString() + "px," +
                    bottomHeight.toString() + "px," +
                    leftWidth + "px)";
            }
            else if (flag && (angle == 0) && region == "chart") {
                if (chartWidth < left + width) {                              // clip right width
                    excessWidth = (left + width) - chartWidth;
                    var rightWidth = width - excessWidth;
                }
                if (left < 0) {                                              // clip left width
                    var leftWidth = width + left;
                    leftWidth = (leftWidth == 0) ? width : leftWidth;
                }
                if (chartHeight < top + height) {                            // clip bottom height
                    var excessHeight = (top + height) - chartHeight;
                    var bottomHeight = height - excessHeight;
                }
                if (top < 0) {                                               // clip top height
                    topHeight = height + top;
                    topHeight = (topHeight == 0) ? height : topHeight;
                }
                rightWidth = (rightWidth == 0) ? width : rightWidth;
                bottomHeight = (bottomHeight == 0) ? height : bottomHeight;
                document.getElementById(eleId).style.clip = "rect(" +
                    topHeight.toString() + "px," +
                    rightWidth.toString() + "px," +
                    bottomHeight.toString() + "px," +
                    leftWidth + "px)";
            }
            else if (flag && (angle == 90) && (region == "series" || coordinateUnit == "points")) {

                var clientRect = document.getElementById(eleId).getBoundingClientRect();
                left = clientRect.left - $(this.svgObject).offset().left + currentDocument.scrollLeft();
                top = clientRect.top - $(this.svgObject).offset().top + currentDocument.scrollTop();

                if (areaBoundsHeight + areaBoundsY < top + width) {                      // clip right width
                    excessWidth = (top + width) - (areaBoundsHeight + areaBoundsY);
                    rightWidth = width - excessWidth;
                }

                if (left < areaBoundsX) {                                                  // clip bottom height

                    excessHeight = areaBoundsX - left;
                    bottomHeight = height - excessHeight;
                }

                if (top < areaBoundsY) {                                                 // clip left width
                    leftWidth = areaBoundsY - top;
                }

                if (areaBoundsWidth + areaBoundsX < left + height) {                       // clip top height
                    excessHeight = (left + height) - (areaBoundsWidth + areaBoundsX);
                    topHeight = excessHeight;
                }

                rightWidth = (rightWidth == 0) ? width : rightWidth;
                bottomHeight = (bottomHeight == 0) ? height : bottomHeight;

                document.getElementById(eleId).style.clip = "rect(" + topHeight.toString() + "px," +         // clipping annotation
                    rightWidth.toString() + "px," +
                    bottomHeight.toString() + "px," +
                    leftWidth + "px)";
            }
            else if (flag && (angle == 90) && region == "chart") {
                var clientRect = document.getElementById(eleId).getBoundingClientRect();
                left = clientRect.left - $(this.svgObject).offset().left;
                top = clientRect.top - $(this.svgObject).offset().top;

                if (chartHeight < top + width) {                              // clip right width
                    excessWidth = (top + width) - chartHeight;
                    rightWidth = width - excessWidth;
                }
                if (left < 0) {                                              // clip bottom height
                    excessHeight = 0 - left;
                    bottomHeight = height - excessHeight;
                    bottomHeight = (bottomHeight == 0) ? height : bottomHeight;
                }
                if (top < 0) {                                               // clip left width
                    leftWidth = 0 - top;
                    leftWidth = (leftWidth == 0) ? width : leftWidth;
                }
                if (chartWidth < left + height) {                            // clip top height
                    excessHeight = (left + height) - chartWidth;
                    topHeight = excessHeight;
                }

                rightWidth = (rightWidth == 0) ? width : rightWidth;
                bottomHeight = (bottomHeight == 0) ? height : bottomHeight;
                document.getElementById(eleId).style.clip = "rect(" +
                    topHeight.toString() + "px," +
                    rightWidth.toString() + "px," +
                    bottomHeight.toString() + "px," +
                    leftWidth + "px)";
            }
        },                                                                 // ---------------------------- end of annotation 

        TransformToVisibleAnnotation: function (xAxis, yAxis, x, y, sender) {       // method to get the position of points in polar/ radar
            x = (xAxis._valueType == "logarithmic") && x > 0 ? Math.log(x, xAxis.logBase) : x;
            y = (xAxis._valueType == "logarithmic") && y > 0 ? Math.log(y, yAxis.logBase) : y;
            var radius = sender.model.Radius * sf.EjSvgRender.utils._valueToCoefficient(yAxis, y, this);
            var point = sf.EjSvgRender.utils._valueToVector(xAxis, x);
            return { X: sender.model.centerX + radius * point.X, Y: sender.model.centerY + radius * point.Y };
        },

        _getAnnotationPoint: function (point, xAxis, yAxis) {                     // method to get the position of points (cartesianaxes)
            var requireInvertedAxes = this.model.requireInvertedAxes;
            var x = point.x;
            var y = point.y;

            var xvalue = (xAxis._valueType == "logarithmic") ? sf.EjSvgRender.utils._logBase((x == 0 ? 1 : x), xAxis.logBase) : x;
            var yvalue = (yAxis._valueType == "logarithmic") ? sf.EjSvgRender.utils._logBase((y == 0 ? 1 : y), xAxis.logBase) : y;
            xvalue = sf.EjSvgRender.utils._getPointXY(xvalue, xAxis.visibleRange, xAxis.isInversed) * (xAxis.width);
            yvalue = (1 - sf.EjSvgRender.utils._getPointXY(yvalue, yAxis.visibleRange, yAxis.isInversed)) * (yAxis.height);

            point.location = { X: xvalue, Y: yvalue };
            return point.location;
        },

        indicatorRender: function () {
            if ($(this.svgObject).find("#" + this.svgObject.id + "_IndicatorCollection").length > 0) {
                $(this.svgObject).find("#" + this.svgObject.id + "_IndicatorCollection").remove();
            }

            var indOptions = { 'id': this.svgObject.id + '_IndicatorCollection', 'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)' };

            this.gIndicatorEle = this.svgRenderer.createGroup(indOptions);

            for (var i = 0; i < this.model.indicators.length && this.model.indicators[i].visible && this.model.indicators[i]._points.length > 0; i++) {
                var indicator = this.model.indicators[i];
                var options;
                var duration = indicator.animationDuration;
                for (var j = 0; j < this.model._axes.length; j++) {
                    var axis = this.model._axes[j];

                    if (axis.name && axis.orientation.toLowerCase() == 'horizontal' && axis.name.toLowerCase() == indicator.xAxisName.toLowerCase()) {
                        indicator.xAxis = axis;
                    } else if (axis.name && axis.orientation.toLowerCase() == 'vertical' && axis.name.toLowerCase() == indicator.yAxisName.toLowerCase()) {
                        indicator.yAxis = axis;
                    }
                }
                var type = indicator.type.toLowerCase();
                options = new sf.indicatorTypes[type]();
                //Clip the canvas Chart indicator series out of chartArea Bounds
                if (this.model.enableCanvasRendering) {
                    this.svgRenderer.ctx.save();
                    this.svgRenderer.ctx.beginPath();
                    this.svgRenderer.ctx.rect(this.model.m_AreaBounds.X, indicator.yAxis.y, indicator.xAxis.width, indicator.yAxis.height);
                    this.svgRenderer.ctx.clip();
                    options.draw(indicator, this);
                    this.svgRenderer.ctx.restore();
                } else
                    options.draw(indicator, this);
                var element = options.gIndicatorGroupEle;
                if (element) sf.EjSvgRender.utils._drawAxesBoundsClipPath(element, indicator, this);

                if (!this.vmlRendering && !this.model.enableCanvasRendering) {
                    if (indicator.enableAnimation && (!indicator._animatedSeries || indicator.type != indicator._previousType)) {
                        this.svgRenderer.append(this.gIndicatorEle, this.svgObject);
                        var clipRect = $(this.gIndicatorEle).find("#" + this.svgObject.id + '_indicatorGroup' + '_' + i + "_ClipRect").children();
                        sf.EjSeriesRender.prototype._doLineAnimation(this, clipRect, duration);    // for indicator animation
                        this.model.AnimationComplete = true;
                        indicator._animatedSeries = true;
                        indicator._previousType = indicator.type;

                    }
                }
                this.svgRenderer.append(this.gIndicatorEle, this.svgObject);
            }

        },

        doAnimation: function (series) {
            // Declaration
            var chartObj = this,
                model = chartObj.model,
                requireInvertedAxes = model.requireInvertedAxes,
                type = series.type.toLowerCase(),
                seriesIndex = $.inArray(series, model._visibleSeries),
                gSeriesGroupId = this.svgObject.id + "_SeriesGroup_" + seriesIndex,
                markerElements = $(chartObj.gSymbolGroupEle)[seriesIndex].childNodes,
                markerLength = markerElements.length,
                dataLabels = $(chartObj.gDataLabelEle)[seriesIndex].childNodes,
                dataLabelLength = dataLabels.length,
                connectorLines = $(chartObj.gConnectorEle)[seriesIndex].childNodes,
                connectorLineLength = connectorLines.length,
                errorBarElements = $(chartObj.gErrorBarGroupEle)[seriesIndex] == undefined ?
                    undefined : $(chartObj.gErrorBarGroupEle)[seriesIndex].childNodes,
                errorBarEleLength = sf.util.isNullOrUndefined(errorBarElements) ? 0 : errorBarElements.length,
                animationType = series._animationType, clipRect, errorBarInterval, boxWhiskerInterval, lineEle, pathEle,
                markerInterval, dataLabelInterval, index, elements, elementsLength, clipRect, time,
                ubound = 20, lbound = 0, randomValue, delayInterval, marker, i, j, defaultDuration, doLineSymbolDuration,
                animateSymbolDuration, animateRectDuration, animationDuration,
                seriesRender = sf.EjSeriesRender.prototype;
            chartObj.gSeriesGroupEle = $("#" + gSeriesGroupId)[0];
            animationDuration = chartObj.model.series[seriesIndex].animationDuration;
            if (!sf.util.isNullOrUndefined(animationDuration)) {
                defaultDuration = animateSymbolDuration = animateRectDuration = parseFloat(animationDuration);
                doLineSymbolDuration = defaultDuration / 10;
            } else {
                defaultDuration = 2000;
                doLineSymbolDuration = 200;
                animateSymbolDuration = 500;
                animateRectDuration = 1000;
            }

            switch (animationType) {
                case "rect":
                    elements = $(this.gSeriesEle).find("#" + gSeriesGroupId).children("rect");
                    elementsLength = elements.length;
                    clipRect = $(chartObj.gSeriesEle).find("#" + gSeriesGroupId + "_ClipRect").children();
                    if (type == "boxandwhisker") {
                        lineEle = $(this.gSeriesEle).find("#" + gSeriesGroupId).children("line");
                        pathEle = $(this.gSeriesEle).find("#" + gSeriesGroupId).children("path");
                        boxWhiskerInterval = defaultDuration / pathEle.length;
                        for (var k = 0; k < lineEle.length; k++) {
                            seriesRender._doLineSymbol(lineEle[k], boxWhiskerInterval, k, series, requireInvertedAxes, chartObj, doLineSymbolDuration);
                            seriesRender._doLineSymbol(elements[k], boxWhiskerInterval, k, series, requireInvertedAxes, chartObj, doLineSymbolDuration);
                        }
                        for (var j = 0; j < pathEle.length; j++) {
                            seriesRender._doLineSymbol(pathEle[j], boxWhiskerInterval, j, series, requireInvertedAxes, chartObj, doLineSymbolDuration);
                        }
                    }
                    else {
                        if (!type.indexOf("stacking") > -1 && series.animationType.toLowerCase() == "smooth") {
                            seriesRender.animateRect(clipRect, series, requireInvertedAxes, chartObj, animateRectDuration);
                        } else {
                            for (i = 0; i < elementsLength; i++) {
                                if (type.indexOf("stacking") > -1)
                                    seriesRender.animateStackingRect(elements[i], series, requireInvertedAxes, chartObj, animateRectDuration);
                                else
                                    seriesRender.animateRect(elements[i], series, requireInvertedAxes, chartObj, animateRectDuration);
                            }
                        }                        
                    }
                    markerInterval = dataLabelInterval = errorBarInterval = (defaultDuration / 4);
                    break;
                case "path":
                    clipRect = $(chartObj.gSeriesEle).find("#" + gSeriesGroupId + "_ClipRect").children();
                    seriesRender._doLineAnimation(chartObj, clipRect, defaultDuration);
                    markerInterval = defaultDuration / markerLength;
                    dataLabelInterval = defaultDuration / dataLabelLength;
                    errorBarInterval = defaultDuration / errorBarEleLength;
                    break;
                case "scatter":
                    for (i = 0; i < markerLength; i++) {
                        randomValue = Math.floor(Math.random() * (ubound - lbound) + lbound);
                        delayInterval = parseInt(randomValue * 50);
                        seriesRender.animateSymbol(markerElements[i], delayInterval, series, requireInvertedAxes, chartObj, animateSymbolDuration);
                    }
                    break;
                case "bubble":
                    elements = $(this.gSeriesGroupEle).children().not("defs");
                    delayInterval = 0;
                    for (i = 0; i < elements.length; i++)
                        seriesRender.animateSymbol(elements[i], delayInterval, series, requireInvertedAxes, chartObj, animateSymbolDuration);
                    for (i = 0; i < markerLength; i++)
                        seriesRender.animateSymbol(markerElements[i], delayInterval, series, requireInvertedAxes, chartObj, animateSymbolDuration);
                    for (i = 0; i < dataLabelLength; i++)
                        seriesRender.animateSymbol(dataLabels[i], delayInterval, series, requireInvertedAxes, chartObj, animateSymbolDuration);
                    for (i = 0; i < connectorLineLength; i++)
                        seriesRender.animateSymbol(connectorLines[i], delayInterval, series, requireInvertedAxes, chartObj, animateSymbolDuration);
                    break;
                case "hilo":
                    elements = $(this.gSeriesGroupEle).children().not("defs");
                    elementsLength = elements.length;
                    time = defaultDuration / elementsLength;
                    for (var i = 0; i < elementsLength; i++)
                        seriesRender._doLineSymbol(elements[i], time, i, series, requireInvertedAxes, chartObj, doLineSymbolDuration);
                    dataLabelInterval = defaultDuration / dataLabelLength;
                    break;
                case "cylinder":
                    clipRect = $(chartObj.gSeriesEle).find("#" + gSeriesGroupId + "_ClipRect").children();
                    seriesRender.animateCylinder(chartObj, series, requireInvertedAxes, clipRect, defaultDuration);
                    markerInterval = dataLabelInterval = errorBarInterval = (defaultDuration / 4);
                    break;
            }

            if (animationType != "bubble") {
                for (j = 0; j < markerLength; j++) {              // for marker
                    index = animationType == "rect" || animationType == "stackingRect" ? 2 : j;
                    seriesRender._doLineSymbol(markerElements[j], markerInterval, index, series, requireInvertedAxes, chartObj, doLineSymbolDuration);
                }

                for (j = 0; j < dataLabelLength; j++) {            // for data label
                    index = animationType == "rect" || animationType == "stackingRect" ? 2 : j;
                    seriesRender._doLineSymbol(dataLabels[j], dataLabelInterval, index, series, requireInvertedAxes, chartObj, doLineSymbolDuration);
                }

                time = defaultDuration / connectorLineLength;
                for (j = 0; j < connectorLineLength; j++) {        // for connector lines
                    index = animationType == "rect" || animationType == "stackingRect" ? 2 : j;
                    seriesRender._doLineSymbol(connectorLines[j], time, index, series, requireInvertedAxes, chartObj, doLineSymbolDuration);
                }
            }

            if (series.errorBar.visibility == "visible") {
                for (j = 0; j < errorBarEleLength; j++) {      // for error bar
                    index = animationType == "rect" || animationType == "stackingRect" ? 2 : j;
                    seriesRender._doLineSymbol(errorBarElements[j], errorBarInterval, index, series, requireInvertedAxes, chartObj, doLineSymbolDuration);
                }
            }
        },
        _animationElements: function (seriesOptions, seriesType, seriesIndex) {
            var chartObj = this;
            var animationDuration = chartObj.model.series[seriesIndex].animationDuration;
            var duration = !sf.util.isNullOrUndefined(animationDuration) ? parseFloat(animationDuration) : 2000;
            seriesOptions._previousType = sf.util.isNullOrUndefined(seriesOptions._previousType) ? seriesOptions.type : seriesOptions._previousType;
            if (seriesOptions.enableAnimation && !this.vmlRendering && !this.model.enableCanvasRendering && (!seriesOptions._animatedSeries || seriesOptions.type != seriesOptions._previousType)) {
                sf.EjSeriesRender.prototype.doCircularAnimation(this, seriesOptions, seriesType, seriesIndex, duration);
                seriesOptions._previousType = seriesOptions.type;
                seriesOptions._animatedSeries = chartObj.isSplitted ? false : true;
            }
            chartObj.isSplitted = false;
            this.drawAccDisplayText(seriesType, seriesOptions, seriesIndex);
            //Show the datalabel text element on redraw when enable animation of series
            if (seriesOptions.enableAnimation && seriesOptions._visiblePoints.length > 0 && seriesOptions.AnimationComplete && !this.vmlRendering && !this.model.enableCanvasRendering) {
                chartObj.svgRenderer._setAttr($(chartObj.gSeriesEle).find("#" + chartObj.gSeriesTextEle[seriesIndex].id), { "visibility": "visible" });
                if (chartObj.gSymbolGroupEle)
                    chartObj.svgRenderer._setAttr($(chartObj.gSeriesEle).find("#" + chartObj.gSymbolGroupEle[seriesIndex].id), { "visibility": "visible" });
                var elements;
                if (seriesOptions.marker.dataLabel.template) {
                    elements = $(chartObj.element[0].childNodes[0].childNodes);
                    for (var i = 0; i < elements.length; i++)
                        $(elements[i]).css('display', 'block');
                }
                if (chartObj.gConnectorEle)
                    chartObj.svgRenderer._setAttr($(chartObj.gSeriesEle).find("#" + chartObj.gConnectorEle[seriesIndex].id), { "visibility": "visible" });
                if (chartObj.gDataLabelEle)
                    chartObj.svgRenderer._setAttr($(chartObj.gSeriesEle).find("#" + chartObj.gDataLabelEle[seriesIndex].id), { "visibility": "visible" });
            }



        },
        _appendConnectorElements: function (i) {
            var visibleSeries = sf.DataManager(this.model._visibleSeries, sf.Query().sortBy("_zOrder")).executeLocal();
            var currentSeries = visibleSeries[i];
            var type = currentSeries.type.toLowerCase();
            if (currentSeries.visibility == "visible" && !this.model.enable3D && currentSeries.connectorLine && (currentSeries.connectorLines || this.model.AreaType == "none")) {
                this.svgRenderer.append(this.gConnectorEle[i], this.gSeriesEle);
                currentSeries.connectorLines = false;
            }
        },
        _appendDataLabelElement: function (i) {
            var currentSeries, type, index;
            currentSeries = this.model._visibleSeries[i];
            index = !sf.util.isNullOrUndefined(currentSeries.zOrder) ? currentSeries.zOrder : index;
            if (currentSeries.visibility == "visible" && !this.model.enable3D) {
                this.svgRenderer.append(this.gSymbolGroupEle[i], this.gSeriesEle);
                if (!this.model.enable3D && !this.model.enableCanvasRendering) {
                    if (this.gDataLabelEle[i].childNodes.length > 0)
                        this.svgRenderer.append(this.gDataLabelEle[i], this.gSeriesEle);
                    if (this.gSeriesTextEle[i].childNodes.length > 0)
                        this.svgRenderer.append(this.gSeriesTextEle[i], this.gSeriesEle);
                }
            }
            if (!this.vmlRendering && currentSeries.visibility == "visible" && !this.model.enableCanvasRendering && !this.model.enable3D) {
                this.svgRenderer.append(this.gSeriesEle, this.svgObject);
                this.svgRenderer.append(this.svgObject, this.element);
            }

        },
        _accSeriesDraw: function (index, seriesOptions, type) {
            var chartObj = this;
            var visibleSeries = sf.DataManager(this.model._visibleSeries, sf.Query().sortBy("_zOrder")).executeLocal();
            var seriesIndex = $.inArray(visibleSeries[index], this.model._visibleSeries);
            this.model._visibleSeries[seriesIndex] = visibleSeries[index] = $.extend(true, seriesOptions, visibleSeries[index]);
            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { series: seriesOptions };
            this._trigger("seriesRendering", commonEventArgs);
            var seriesType = new sf.seriesTypes[type.toLowerCase()]();
            var minhightwidth = seriesType.draw(chartObj, seriesOptions);
            if (!minhightwidth) {
                this.model.minhightwidth = true;
                chartObj._animationElements(seriesOptions, seriesType, seriesIndex);
            }


        },
        // to split the series for pie of pie rendering
        _splitSeries: function (visibleSeries) {
            //declaration of splitseries variables            
            var pieCollections = [];
            pieCollections[0] = $.extend(true, [], visibleSeries._visiblePoints);
            pieCollections[1] = [];
            var series = visibleSeries,
                splitValue = parseInt(series.splitValue),
                splitMode = series.splitMode.toLowerCase(),
                length = pieCollections[0].length,
                count = 0, j = 0, yValues = [], i = 0, totalValue = 0, yvalue, valueType;
            // to calculate sum of y values
            while (i != length) {
                totalValue += pieCollections[0][i].y;
                i++;
            }
            // to split points based on splitmode    
            if (splitMode == "position") {
                for (var i = length - 1; i >= 0 && j != splitValue; i--) {
                    count = count + pieCollections[0][i].y;
                    pieCollections[1][j] = pieCollections[0][i];
                    j++;
                    pieCollections[0].splice(i, 1);
                }
                pieCollections[1].reverse();
            }
            else if (splitMode == "value" || splitMode == "percentage") {
                for (var k = 0; k < pieCollections[0].length; k++) {
                    yvalue = splitMode == "value" ? pieCollections[0][k].y : Math.round((pieCollections[0][k].y / totalValue) * 100);
                    if (yvalue < splitValue) {
                        count = count + pieCollections[0][k].y;
                        pieCollections[1][j] = pieCollections[0][k];
                        j++;
                        pieCollections[0].splice(k, 1);
                        k = -1;
                    }
                }
            }
            else if (splitMode == "indexes") {
                var splitArray = JSON.parse("[" + series.splitValue + "]");
                // to remove duplicate indices
                splitArray = splitArray.filter(function (item, d, inputArray) {
                    return inputArray.indexOf(item) == d;
                });
                splitArray.sort();
                for (var k = 0; k < pieCollections[0].length; k++) {
                    for (var s = 0; s < splitArray.length; s++) {
                        if (k == splitArray[s]) {
                            count = count + pieCollections[0][k].y;
                            pieCollections[1][j] = pieCollections[0][k];
                            j++;
                        }
                    }
                }
                for (var i = 0; i < splitArray.length; i++) {
                    var index = splitArray[i] - i;
                    pieCollections[0].splice(index, 1);
                }
            }

            // to append the added point in first pie collection
            if (pieCollections[1].length > 0) {
                yValues[0] = count,
                    valueType = series._xAxisValueType,
                    pieCollections[0].unshift({
                        _visibility: "visible",
                        visible: true,
                        text: "Others",
                        // dataPoint: undefined,
                        x: valueType == "string" ? "Others" : count,
                        xValue: valueType == "string" ? series.points.length : count,
                        y: count,
                        YValues: yValues,
                        fill: this.model.colors[(series.points.length + 1) % this.model.colors.length],
                        isFill: false,
                        actualIndex: series.points.length
                    });
            }
            this.isSplitted = true;
            series.pieCollections = pieCollections;
        },
        _calculateGapWidth: function (currentSeries) {
            var circle1end = 0, circle2start = 0, coefficient, centerX, gapWidth;
            var constantWidth = 0.1 * Math.min($(this.svgObject).width(), $(this.svgObject).width());
            sf.EjSeriesRender.prototype._calculateVisiblePoints(currentSeries).visiblePoints;
            this._splitSeries(currentSeries);  // to split the series points for pieofpie seriestype
            this.chartObj = this;
            // gapwidth calculation for pieofpie series type
            for (var j = 0; j < 2; j++) {
                coefficient = (j == 0) ? currentSeries.pieCoefficient : currentSeries.pieOfPieCoefficient;
                currentSeries._visiblePoints = currentSeries.pieCollections[j];
                currentSeries.collectionIndex = j;
                gapWidth = currentSeries.gapWidth;
                var size = sf.EjSeriesRender.prototype.calculatingSliceAngle(currentSeries, this.chartObj);
                var circleradius = size.width < constantWidth ? 0.25 * coefficient * constantWidth : 0.25 * coefficient * Math.min(size.width, size.height);
                centerX = this.model.circleCenterX[j];
                if (j == 0)
                    circle1end = centerX + circleradius;
                else
                    circle2start = centerX - circleradius;
            }
            var pieGapWidth = (circle2start - circle1end) - gapWidth;
            this.model.pieGapWidth = (pieGapWidth > 0) ? pieGapWidth : 0;
            // to draw connector lines for pieofpie series type
            if (currentSeries.pieCollections[0].length > 0 && currentSeries.pieCollections[1].length > 0 && currentSeries.connectorLine.width > 0)
                this.drawPieofPieConnectors(size, currentSeries);
            return currentSeries;
        },
        seriesRender: function (params, excludeDataUpdate) {
            this.model.allPoints = [];
            this.model.markerRegion = [];
            this.model.startX = [];
            this.model.startY = [];
            this.model.centerCount = 0;
            this.gTrendlinesGroupEle = null;
            this.model._seriesIndex = null;
            this.model._previousSeries = null;

            if (!params) {
                params = { _crossAxisOverlap: false, axes: {} };
                for (var i = 0; i < this.model._axes.length; i++)
                    params.axes[this.model._axes[i].name] = {};
            }
            if ($(this.svgObject).find("#" + this.svgObject.id + "_SeriesCollection").length > 0) {
                $(this.svgObject).find("#" + this.svgObject.id + "_SeriesCollection").remove();
            }
            var chartObj = this,
                svg = this.svgObject,
                serOptions = { 'id': svg.id + '_SeriesCollection', 'clip-path': 'url(#' + svg.id + '_ChartAreaClipRect)' },
                enable3D = this.model.enable3D,
                areaType = this.model.AreaType,
                enableCanvasRendering = this.model.enableCanvasRendering,
                axesLength = this.model._axes.length,
                visibleSeries = sf.DataManager(this.model._visibleSeries, sf.Query().sortBy("_zOrder")).executeLocal(),
                visibleSeriesLength = visibleSeries.length,
                i, j, axis, index, axisOrientation, index,
                seriesOptions, seriesOptionsVisibility, type, commonEventArgs,
                currentSeries, currentPoint, points, currentSeriesType,
                isCanvas = enableCanvasRendering, renderer = this.svgRenderer,
                areaBounds = this.model.m_AreaBounds, currentPointXPos, currentPointYPos,
                currentPointLabel, areaBoundsX = areaBounds.X, box,
                h, currentPointVisibility, visiblePointsLength, p, length,
                s, series, templateContainer, dataLabel, clipRect, drawType,
                trendlines, trendline, trendlineType, options, trendLineLength, duration,
                seriesEle, symbolEle, svgObjectId, waterfallLineEle, size, detachEle,
                seriesIndex, seriesType, minhightwidth, showLabels, l, visibility, xVisibleRange, yVisibleRange, yValue, zoomed = this.zoomed;

            this.gSeriesEle = renderer.createGroup(serOptions);

            for (i = 0; i < visibleSeriesLength; i++) {
                if (visibleSeries[i].visibility == "visible") {
                    if (sf.util.isNullOrUndefined(this.model.series[i].enableSmartLabels))  // for setting enablesmartlabels property values
                        this.model.series[i]._enableSmartLabels = (areaType) == "none" ? true : false;
                    else
                        this.model.series[i]._enableSmartLabels = this.model.series[i].enableSmartLabels;
                    if (!sf.util.isNullOrUndefined(visibleSeries[i].xAxis)) {
                        visibleSeries[i].xAxis = null;
                        visibleSeries[i].yAxis = null;
                    }
                    for (j = 0; j < axesLength; j++) {
                        axis = this.model._axes[j];
                        index = i;
                        axisOrientation = axis.orientation.toLowerCase();
                        if (axis.name && axisOrientation == 'horizontal' && axis.name.toLowerCase() == visibleSeries[i]._xAxisName.toLowerCase()) {
                            visibleSeries[i].xAxis = axis;
                        }
                        else if (axis.name && axisOrientation == 'vertical' && axis.name.toLowerCase() == visibleSeries[i]._yAxisName.toLowerCase()) {
                            visibleSeries[i].yAxis = axis;
                        }
                        if (this.model.requireInvertedAxes) {
                            if (axis.name && axisOrientation == 'vertical' && axis.name.toLowerCase() == visibleSeries[i]._xAxisName.toLowerCase()) {
                                visibleSeries[i].xAxis = axis;
                            }
                            else if (axis.name && axisOrientation == 'horizontal' && axis.name.toLowerCase() == visibleSeries[i]._yAxisName.toLowerCase()) {
                                visibleSeries[i].yAxis = axis;
                            }
                        }

                    }
                }
            }
            if (visibleSeriesLength > 0) {
                currentSeries = visibleSeries[0];
                seriesType = currentSeries.type.toLowerCase(),
                    visibility = currentSeries.visibility.toLowerCase();
                if (seriesType == "pieofpie" && visibility == 'visible' && !enable3D) {
                    this.model._isPieOfPie = true;
                    currentSeries = this._calculateGapWidth(currentSeries); // method to split point, gapwidth calculation and to draw pieofpie connectors
                    // pieofpie rendering with splitted points
                    for (var k = 0; k < 2; k++) {
                        currentSeries.collectionIndex = k;
                        currentSeries._visiblePoints = currentSeries.pieCollections[k];
                        this._accSeriesDraw(0, currentSeries, seriesType);
                    }
                    currentSeries._visiblePoints = $.merge(currentSeries.pieCollections[0], currentSeries.pieCollections[1]);
                    this.model.pieGapWidth = null;
                    currentSeries.collectionIndex = 0;
                }
                else {
                    //pie doughnut rendering from higher order to lower order
                    for (var l = visibleSeriesLength; l > 0 && areaType == "none"; l--) {
                        index = l - 1;
                        seriesOptions = visibleSeries[l - 1];
                        seriesOptionsVisibility = seriesOptions.visibility.toLowerCase();
                        type = seriesOptions.type.toLowerCase();
                        if (seriesOptionsVisibility === 'visible' && !enable3D && (type == "pie" || type == "doughnut")) {

                            this._accSeriesDraw(index, seriesOptions, type);


                        }
                        else {
                            if ((areaType == "none") && seriesOptionsVisibility === 'visible' && !enableCanvasRendering)
                                sf.Ej3DChart.prototype.renderSeries(this, seriesOptions, excludeDataUpdate);
                        }
                    }
                }
            }
            for (var m = 0; m < visibleSeriesLength; m++) {
                index = m;
                seriesOptions = visibleSeries[m];
                seriesOptionsVisibility = seriesOptions.visibility.toLowerCase();
                type = seriesOptions.type.toLowerCase();
                if (areaType == "none" && seriesOptionsVisibility === 'visible' && !enable3D && (index === 0) && (type == "pyramid" || type == "funnel")) {
                    this._accSeriesDraw(index, seriesOptions, type);


                }
                else {
                    if (seriesOptionsVisibility === 'visible' && !enable3D && areaType != "none") {
                        this.model._seriesIndex = sf.util.isNullOrUndefined(this.model._seriesIndex) ? 0 : this.model._seriesIndex + 1;
                        this.renderSeries(seriesOptions, params, excludeDataUpdate);
                        if (areaType == "cartesianaxes" && this.model.series[m].type != "boxandwhisker")
                            this._renderTrendline(chartObj, seriesOptions);
                    }
                    else {
                        if (!enable3D && areaType != "none")
                            renderer.append(svg, this.element);
                        else {
                            if ((areaType == "cartesianaxes") && seriesOptionsVisibility === 'visible' && !enableCanvasRendering)
                                sf.Ej3DChart.prototype.renderSeries(this, seriesOptions, params, excludeDataUpdate);
                        }
                    }
                    if (!sf.util.isNullOrUndefined(seriesOptions.xAxis) && seriesOptions.xAxis._valueType == "datetime") {
                        for (var i = 0; i < seriesOptions.points.length; i++) {
                            if (seriesOptions.points[i].xValue instanceof Date == false)
                                seriesOptions.points[i].xValue = new Date(seriesOptions.points[i].xValue);
                        }
                    }
                }
            }

            if (areaType != "none") {
                // smart labels for cartesian axis
                for (i = 0; i < visibleSeriesLength; i++) {
                    currentSeries = this.model.series[i];
                    points = currentSeries._visiblePoints;
                    if (currentSeries._enableSmartLabels && this.model.AreaType == "cartesianaxes") {
                        currentSeriesType = currentSeries.type.toLowerCase();
                        if (currentSeriesType == "column" || currentSeriesType == "stackingcolumn" ||
                            currentSeriesType == "bar" || currentSeriesType == "stackingbar" || currentSeriesType == "waterfall"
                            || currentSeriesType == "stackingbar100" || currentSeriesType == "stackingcolumn100" || currentSeriesType == "rangecolumn")
                            this.cartesianColumnSmartLabels(currentSeries, points, i)
                        else if (currentSeriesType != "boxandwhisker") {
                            this.cartesianSmartLabels(currentSeries, points, i);
                        }
                        for (j = 0; j < points.length; j++) {
                            currentPoint = points[j]; // condition to hide partially visible labels
                            currentPoint.hide = sf.util.isNullOrUndefined(currentPoint.hide) ? false : currentPoint.hide;
                            currentPointXPos = isCanvas ? currentPoint.xPos - this.canvasX : currentPoint.xPos;
                            currentPointYPos = isCanvas ? currentPoint.yPos - this.canvasY : currentPoint.yPos;
                            xVisibleRange = currentSeries.xAxis.visibleRange;
                            yVisibleRange = currentSeries.yAxis.visibleRange;
							yValue = (type.indexOf("100") != -1) ? parseFloat(currentPoint.percentage) : currentPoint.y;
                            if ((currentPointXPos - currentPoint.width / 2 < 0) || (currentPointXPos + currentPoint.width / 2 > areaBounds.Width) ||
                                (currentPointYPos + currentPoint.height / 2 > areaBounds.Height) || (currentPointYPos - currentPoint.height / 2 < 0) || (zoomed && currentPoint.xValue <= xVisibleRange.min || currentPoint.xValue >= xVisibleRange.max) || yValue <= yVisibleRange.min || yValue >= yVisibleRange.max)
                                currentPoint.hide = currentSeries.marker.dataLabel.showEdgeLabels && !currentPoint.hide ? false : true;
                        }
                    }
                }

                // to draw connector lines for data label
                for (i = 0; i < visibleSeriesLength; i++) {
                    currentSeries = visibleSeries[i];
                    //For series with improved performance, it will avoid unnecessary looping
                    showLabels = currentSeries._dataLabels ? (currentSeries.marker.dataLabel.visible || currentSeries._dataLabels > 0) : true;
                    if (currentSeries.visibility == "visible" && showLabels) {
                        visiblePointsLength = currentSeries._visiblePoints.length;
                        for (h = 0; h < visiblePointsLength; h++) {
                            currentPoint = currentSeries._visiblePoints[h];
                            currentPointVisibility = currentPoint.marker && currentPoint.marker.dataLabel && currentPoint.marker.dataLabel.visible;
                            if (currentSeries.marker.dataLabel.visible || currentPointVisibility) {
                                if ((currentPoint.connectorFlag || currentPoint.newConnectorFlag) && !currentPoint.hide && currentPoint.drawText != "" && currentSeries.visibility == "visible" && !sf.util.isNullOrUndefined(currentPoint.textOptions)) {
                                    currentSeries.connectorLine = true;
                                    if (enableCanvasRendering) {
                                        renderer.ctx.save();
                                        if (!chartObj.model.requireInvertedAxes)
                                            renderer.ctx.rect(areaBoundsX, currentSeries.yAxis.y, currentSeries.xAxis.width, currentSeries.yAxis.height);
                                        else
                                            renderer.ctx.rect(areaBoundsX + currentSeries.yAxis.plotOffset, currentSeries.xAxis.y, currentSeries.yAxis.width, currentSeries.xAxis.height);
                                        renderer.ctx.clip();
                                        this.drawConnectorLines(i, h, currentPoint);
                                        renderer.ctx.restore();
                                    } else if (currentSeries._enableSmartLabels)
                                        this.drawConnectorLines(i, h, currentPoint);
                                }
								currentPoint.newConnectorFlag = false;
                            }
                        }
                    }
                }

                // to draw data label symbol and text

                for (i = 0; i < visibleSeriesLength; i++) {
                    currentSeries = visibleSeries[i];
                    type = currentSeries.type.toLowerCase();
                    //For series with improved performance, it will avoid unnecessary looping
                    showLabels = currentSeries._dataLabels ? (currentSeries.marker.dataLabel.visible || currentSeries._dataLabels > 0) : true;
                    if (currentSeries.visibility == "visible" && showLabels && !this.model.enable3D) {
                        visiblePointsLength = currentSeries._visiblePoints.length;
                        for (h = 0; h < visiblePointsLength; h++) {
                            currentPoint = currentSeries._visiblePoints[h];
                            currentPointLabel = currentPoint.marker && currentPoint.marker.dataLabel && currentPoint.marker.dataLabel.visible;
                            if ((currentSeries.marker.dataLabel.visible || currentPointLabel) && !currentPoint.hide && !currentPoint.dataLabeltemplate && currentSeries.visibility == "visible" && !sf.util.isNullOrUndefined(currentPoint.textOptions) && !currentPoint.hide) {
                                if (!sf.util.isNullOrUndefined(currentPoint.textOptions.angle))
                                    currentPoint.textOptions.transform = 'rotate(' + currentPoint.textOptions.angle + ',' + (currentPoint.xPos) + ',' + (currentPoint.yPos) + ')';
                                if (enableCanvasRendering) {    // for canvas
                                    currentPoint.textOptions.labelRotation = currentPoint.textOptions.angle;  //for canvas label rotation
                                    renderer.ctx.save();
                                    if (!chartObj.model.requireInvertedAxes)
                                        renderer.ctx.rect(areaBoundsX, currentSeries.yAxis.y, currentSeries.xAxis.width, currentSeries.yAxis.height);
                                    else
                                        chartObj.svgRenderer.ctx.rect(areaBoundsX + currentSeries.yAxis.plotOffset, currentSeries.xAxis.y, currentSeries.yAxis.width, currentSeries.xAxis.height);
                                    chartObj.svgRenderer.ctx.save();
                                    chartObj.svgRenderer.ctx.clip();

                                    if (type.toLowerCase() == "boxandwhisker") {
                                        if (currentSeries.showMedian == true && currentPoint.textOptionsBoxValues != "") {
                                            if (!sf.util.isNullOrUndefined(currentPoint.textOptionsBoxValues[0].angle)) {
                                                currentPoint.textOptionsBoxValues[0].labelRotation = currentPoint.textOptionsBoxValues[0].angle;
                                                currentPoint.textOptionsBoxValues[0].transform = 'rotate(' + currentPoint.textOptionsBoxValues[0].angle + ',' + (currentPoint.textOptionsBoxValues[0].xPos) + ',' + (currentPoint.textOptionsBoxValues[0].yPos) + ')';
                                            }
                                            sf.EjSeriesRender.prototype.dataLabelSymbol(i, currentSeries, h, currentPoint.textOptionsBoxValues[0].xPos, currentPoint.textOptionsBoxValues[0].yPos, currentPoint.textOptionsBoxValues[0].width, currentPoint.textOptionsBoxValues[0].height, currentPoint.textOptionsBoxValues[0].symbolName, this)
                                            delete currentPoint.textOptionsBoxValues[0].angle;
                                            this.svgRenderer.drawText(currentPoint.textOptionsBoxValues[0], currentPoint.textOptionsBoxValues[0].drawText, this.gSeriesTextEle[i]);
                                        }
                                        for (var box = 1; box < currentPoint.textOptionsBoxValues.length; box++) {
                                            if (!sf.util.isNullOrUndefined(currentPoint.textOptionsBoxValues[box].angle)) {
                                                currentPoint.textOptionsBoxValues[box].labelRotation = currentPoint.textOptionsBoxValues[box].angle;
                                                currentPoint.textOptionsBoxValues[box].transform = 'rotate(' + currentPoint.textOptionsBoxValues[box].angle + ',' + (currentPoint.textOptionsBoxValues[box].xPos) + ',' + (currentPoint.textOptionsBoxValues[box].yPos) + ')';

                                            }
                                            sf.EjSeriesRender.prototype.dataLabelSymbol(i, currentSeries, h, currentPoint.textOptionsBoxValues[box].xPos, currentPoint.textOptionsBoxValues[box].yPos, currentPoint.textOptionsBoxValues[box].width, currentPoint.textOptionsBoxValues[box].height, currentPoint.textOptionsBoxValues[box].symbolName, this)
                                            delete currentPoint.textOptionsBoxValues[box].angle;
                                            this.svgRenderer.drawText(currentPoint.textOptionsBoxValues[box], currentPoint.textOptionsBoxValues[box].drawText, this.gSeriesTextEle[i]);
                                        }
                                    }
                                    else {
                                        sf.EjSeriesRender.prototype.dataLabelSymbol(i, currentSeries, h, currentPoint.xPos, currentPoint.yPos, currentPoint.width, currentPoint.height, currentPoint.symbolName, this)
                                        delete currentPoint.textOptions.angle;
                                        this.svgRenderer.drawText(currentPoint.textOptions, currentPoint.drawText, this.gSeriesTextEle);
                                    }
                                    chartObj.svgRenderer.ctx.restore();
                                } else {
                                    sf.EjSeriesRender.prototype.dataLabelSymbol(i, currentSeries, h, currentPoint.xPos, currentPoint.yPos, currentPoint.width, currentPoint.height, currentPoint.symbolName, this, this.gDataLabelEle[i])
                                    delete currentPoint.textOptions.angle;
                                    renderer.drawText(currentPoint.textOptions, currentPoint.drawText, this.gSeriesTextEle[i]);
                                }
                                if (type == "rangecolumn" || type == "rangearea" || type == "splinerangearea") {

                                    currentPoint.textOptionsLow.transform = 'rotate(' + currentPoint.textOptionsLow.angle + ',' + (currentPoint.xPosLow) + ',' + (currentPoint.yPosLow) + ')';
                                    if (enableCanvasRendering) {    // for canvas
                                        currentPoint.textOptionsLow.labelRotation = currentPoint.textOptionsLow.angle;  //for canvas label rotation
                                        renderer.ctx.save();
                                        if (!chartObj.model.requireInvertedAxes)
                                            renderer.ctx.rect(areaBoundsX, currentSeries.yAxis.y, currentSeries.xAxis.width, currentSeries.yAxis.height);
                                        else
                                            renderer.ctx.rect(areaBoundsX + currentSeries.yAxis.plotOffset, currentSeries.xAxis.y, currentSeries.yAxis.width, currentSeries.xAxis.height);
                                        renderer.ctx.clip();

                                        sf.EjSeriesRender.prototype.dataLabelSymbol(i, currentSeries, h, currentPoint.xPosLow, currentPoint.yPosLow, currentPoint.widthLow, currentPoint.heightLow, currentPoint.symbolName, this)
                                        delete currentPoint.textOptionsLow.angle;
                                        renderer.drawText(currentPoint.textOptionsLow, currentPoint.drawTextLow, this.gSeriesTextEle);
                                        renderer.ctx.restore();
                                    }
                                    else {

                                        sf.EjSeriesRender.prototype.dataLabelSymbol(i, currentSeries, h, currentPoint.xPosLow, currentPoint.yPosLow, currentPoint.widthLow, currentPoint.heightLow, currentPoint.symbolName, this, this.gDataLabelEle[i])
                                        delete currentPoint.textOptionsLow.angle;
                                        renderer.drawText(currentPoint.textOptionsLow, currentPoint.drawTextLow, this.gSeriesTextEle[i]);
                                    }
                                }
                                else if (type.toLowerCase() == "boxandwhisker") {
                                    if (currentSeries.showMedian == true && currentPoint.textOptionsBoxValues != "") {
                                        if (!sf.util.isNullOrUndefined(currentPoint.textOptionsBoxValues[0].angle))
                                            currentPoint.textOptionsBoxValues[0].transform = 'rotate(' + currentPoint.textOptionsBoxValues[0].angle + ',' + (currentPoint.textOptionsBoxValues[0].xPos) + ',' + (currentPoint.textOptionsBoxValues[0].yPos) + ')';
                                        sf.EjSeriesRender.prototype.dataLabelSymbol(i, currentSeries, h, currentPoint.textOptionsBoxValues[0].xPos, currentPoint.textOptionsBoxValues[0].yPos, currentPoint.textOptionsBoxValues[0].width, currentPoint.textOptionsBoxValues[0].height, currentPoint.textOptionsBoxValues[0].symbolName, this)
                                        delete currentPoint.textOptionsBoxValues[0].angle;
                                        this.svgRenderer.drawText(currentPoint.textOptionsBoxValues[0], currentPoint.textOptionsBoxValues[0].drawText, this.gSeriesTextEle[i]);
                                    }
                                    for (var box = 1; box < currentPoint.textOptionsBoxValues.length; box++) {
                                        if (!sf.util.isNullOrUndefined(currentPoint.textOptionsBoxValues[box].angle))
                                            currentPoint.textOptionsBoxValues[box].transform = 'rotate(' + currentPoint.textOptionsBoxValues[box].angle + ',' + (currentPoint.textOptionsBoxValues[box].xPos) + ',' + (currentPoint.textOptionsBoxValues[box].yPos) + ')';
                                        sf.EjSeriesRender.prototype.dataLabelSymbol(i, currentSeries, h, currentPoint.textOptionsBoxValues[box].xPos, currentPoint.textOptionsBoxValues[box].yPos, currentPoint.textOptionsBoxValues[box].width, currentPoint.textOptionsBoxValues[box].height, currentPoint.textOptionsBoxValues[box].symbolName, this)
                                        delete currentPoint.textOptionsBoxValues[box].angle;
                                        this.svgRenderer.drawText(currentPoint.textOptionsBoxValues[box], currentPoint.textOptionsBoxValues[box].drawText, this.gSeriesTextEle[i]);
                                    }
                                }
                            }
                        }
                    }
                }

                // to append connector lines
                if (areaType != "none") {
                    // to append connector lines
                    for (i = 0; i < visibleSeriesLength; i++) {
                        this._appendConnectorElements(i);

                    }

                    // to append marker, data label symbol and text
                    length = this.model._visibleSeries.length;
                    for (i = 0; i < length; i++) {
                        this._appendDataLabelElement(i);
                    }
                }
            }  //to append conector lines ,marker,datalabel symbol and text  for pie and doughnut 
            else {
                for (p = visibleSeriesLength - 1; p >= 0; p--) {
                    currentSeries = this.model._visibleSeries[p];
                    type = currentSeries.type.toLowerCase();
                    if ((type == "pie" || type == "doughnut") && this.model.minhightwidth)
                        this._appendConnectorElements(p);
                }
                length = this.model._visibleSeries.length;
                if (length > 0 && type == "pieofpie")
                    this._appendDataLabelElement(0);
                else {
                    for (p = visibleSeriesLength - 1; p >= 0; p--) {
                        currentSeries = this.model._visibleSeries[p];
                        type = currentSeries.type.toLowerCase();
                        if ((type == "pie" || type == "doughnut") && this.model.minhightwidth)
                            this._appendDataLabelElement(p);
                    }
                }
            }
            length = this.model._visibleSeries.length;
            for (s = 0; s < length; s++) {
                options = this.model._visibleSeries[s];
                drawType = options.drawType;
                type = options.type.toLowerCase();
                options._previousType = sf.util.isNullOrUndefined(options._previousType) ? options.type : options._previousType;
                if (!this.vmlRendering && options.visibility == "visible" && !enableCanvasRendering && !enable3D && areaType != "none") {
                    this.renderer.append(this.gSeriesEle, this.svgObject);
                    this.renderer.append(this.svgObject, this.element);
                    series = new sf.seriesTypes[options.type.toLowerCase()]();
                    series.chartObj = chartObj;
                    if (drawType == "scatter")
                        series.gSeriesGroupEle = $("#" + this.svgObject.id + "_symbolGroup_" + s)[0];
                    else
                        series.gSeriesGroupEle = $("#" + this.svgObject.id + "_SeriesGroup_" + s)[0];
                    if (options.enableAnimation && (!options._animatedSeries || options._previousType != options.type) && this.model.AreaType != "none") {
                        options._animatedSeries = true;
                        options._previousType = options.type;
                        templateContainer = $('#template_group_' + this._id);
                        dataLabel = options.marker.dataLabel;
                        if (templateContainer.children().length != 0 && (dataLabel.visible && dataLabel.template))
                            series.animateLabelTemplate(options);
                        if (type == "polar" || type == "radar")
                            sf.ejRadarSeries.prototype.doAnimation(options, series); // to animate polar/ radar
                        else
                            this.doAnimation(options);   // to animate cartesian series
                    }
                }
            }

            // to append trend line to DOM and perform animation
            visibleSeries = this.model._visibleSeries;
            length = visibleSeries.length;
            if (!enableCanvasRendering && !enable3D) {
                for (k = 0; k < length; k++) {
                    if (visibleSeries[k].visibility.toLowerCase() == "visible" && this.gTrendlinesGroupEle &&
                        this.gTrendlinesGroupEle[k] && this.gTrendlinesGroupEle[k].childElementCount != 0)
                        this.renderer.append(this.gTrendlinesGroupEle[k], svg);
                }
            }
            for (i = 0; i < length; i++) {
                currentSeries = this.model._visibleSeries[i];
                trendlines = currentSeries.trendlines;
                trendLineLength = currentSeries.trendlines.length;
                duration = currentSeries.animationDuration;
                for (j = 0; j < trendLineLength; j++) {
                    trendline = trendlines[j];
                    if (trendline.visibility) {
                        trendlineType = trendline.type.toLowerCase();
                        options = new sf.trendlineTypes[trendlineType]();
                        if (trendline.visibility.toLowerCase() === 'visible' && trendline.points && trendline.points.length > 1 &&
                            currentSeries.enableAnimation && !this.vmlRendering && (!currentSeries._animatedTrendline || trendline._previousType != trendline.type)) {
                            trendline._previousType = trendline.type;
                            clipRect = $(this.svgObject).find("#" + this.svgObject.id + '_TrendGroup' + '_' + i + '_' + j + "_ClipRect").children();
                            sf.EjSeriesRender.prototype._doLineAnimation(this, clipRect, duration); // for trendline animation
                            currentSeries._animatedTrendline = (trendLineLength - 1 == i) ? true : false;
                        }
                    }
                }
            }

            length = this.model._visibleSeries.length;
            svgObjectId = svg.id;
            for (i = 0; i < length; i++) {
                seriesEle = $("#" + svgObjectId + "_SeriesGroup_" + i);
                waterfallLineEle = $("#" + svgObjectId + '_SeriesGroup_waterfallLine_' + i);
                symbolEle = $("#" + svgObjectId + "_symbolGroup_" + i);
                if (seriesEle.length > 0 && symbolEle.length > 0)
                    symbolEle.insertAfter(seriesEle);
                if (seriesEle.length > 0 && waterfallLineEle.length > 0)
                    waterfallLineEle.insertAfter(seriesEle);
            }


            this.model.AnimationComplete = true;
            commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { series: options };
            this._trigger("animationComplete", commonEventArgs);

            if (enableCanvasRendering) {
                renderer.append(svg, this.element);
                if (this.panning) $("#" + this._id + "_canvas").css({ "cursor": "pointer" });
            }
            if (enable3D && !enableCanvasRendering) {
                renderer.append(this.chart3D, svg);

                size = { Width: $(svg).width(), Height: $(svg).height() };
                this.graphics.prepareView(this.model.perspectiveAngle, this.model.depth, this.model.rotation, this.model.tilt, size, this);
                this.graphics.view(svg, this);
                renderer.append(svg, this.element);
                //for (var i = 0; i < visibleSeries.length; i++) {
                //    if (visibleSeries[i].visibility.toLowerCase() == "visible" && visibleSeries[i].enableAnimation && !(this.model.animated)) {
                //        var seriesRendering = new sf.Ej3DSeriesRender();
                //        var type = visibleSeries[i].type.toLowerCase();
                //        var options = sf.series3DTypes[type];
                //        if (this.model.AreaType == "none" && i > 0)
                //            break;
                //        options.doAnimation(visibleSeries[i], seriesRendering);
                //    }

                //}

            }

            if (renderer.vmlNamespace)
                renderer.append(this.gSeriesEle, svg);
            if (areaType == 'polaraxes')
                renderer.append(this.gPolarAxisEle, svg);
            if ($(svg).find("#" + svg.id + "_StriplineOver").length > 0) {
                detachEle = $(svg).find("#" + svg.id + "_StriplineOver").detach();
                detachEle.appendTo(svg);
            }

            this._renderScrollbar();

            this.legendRender.drawLegend(params);

            chartObj.model.initSeriesRender = true;
        },

        _calculateZoomValue: function (startX, endX, axis, scrollObj) {
            var model = this.model,
                delta, zoomPos, zoomFact, start, end,
                scrollRange = axis.scrollbarSettings.range,
                valueType = axis._valueType.toLowerCase();
            if (valueType == "datetime") {
                start = Date.parse(!sf.util.isNullOrUndefined(scrollRange.min) ? new Date(scrollRange.min) : startX);
                end = Date.parse(!sf.util.isNullOrUndefined(scrollRange.max) ? new Date(scrollRange.max) : endX);
            } else {
                start = parseFloat(!sf.util.isNullOrUndefined(scrollRange.min) ? scrollRange.min : startX);
                end = parseFloat(!sf.util.isNullOrUndefined(scrollRange.max) ? scrollRange.max : endX);
            }
            start = Math.min(start, startX);
            end = Math.max(end, endX);
            delta = end - start;
            if (!scrollObj.isRTL) {
                zoomPos = (startX - start) / delta;
                zoomFact = (endX - startX) / delta;
            } else {
                zoomPos = (end - endX) / delta;
                zoomFact = (endX - startX) / delta;
            }
            scrollObj.scrollRange = { min: start, max: end, delta: end - start };
            scrollObj._previousStart = startX;
            scrollObj._previousEnd = endX;
            scrollObj.zoomPosition = zoomPos;
            scrollObj.zoomFactor = zoomFact;
        },

        _renderScrollbar: function () {

            var model = this.model,
                scrollSize = model.scrollerSize,
                scrollObj, index,
                chartOffsetVal = $('#' + this._id).offset(),
                offsetVal = ($(this.svgObject).offset().left - chartOffsetVal.left),
                scrollerWidth, scrollerHeight, scrollerX,
                scrollerY, scrollerX, axis, posY, width, isRedraw,
                zoomFac, zoomPos, opposed,
                axesCollections = model._axes,
                axesLength = axesCollections.length, inversed,
                zoomingScroll = model.zooming.enableScrollbar, range,
                areaType = model.AreaType, scrollbarSettings, pointLength,
                scrollEleLength, scrollRange, scrObj,
                orientation, valueType, isZoomAble;

            model.scrollObj = model.scrollObj ? model.scrollObj : [];


            for (var r = 0; r < axesLength; r++) {
                axis = axesCollections[r];
                valueType = axis._valueType;
                scrollbarSettings = axis.scrollbarSettings;
                range = scrollbarSettings.range;
                inversed = axis.isInversed,
                    isZoomAble = areaType == "cartesianaxes" && !model.enable3D;
                opposed = axis._opposed;
                pointLength = scrollbarSettings.pointsLength;
                orientation = axis.orientation.toLowerCase();
                zoomFac = axis.zoomFactor;
                scrollEleLength = $("#scrollbar_" + this.axisScroll[0].id + r).length;
                zoomPos = axis.zoomPosition;

                if (isZoomAble && ((axis._isScroll && model.isLazyZooming) || ((zoomFac < 1 || zoomPos > 0) && zoomingScroll))) {

                    scrollerX = axis.x + ((orientation == "vertical") ? (-scrollSize + (opposed ? scrollSize : 0)) : 0) + (offsetVal <= 0 ? 0 : offsetVal);
                    scrollerY = axis.y + ((orientation == "horizontal") ? (axis.height + (opposed ? -scrollSize : 0)) : 0);
                    posY = scrollerY - (orientation == 'horizontal' ? 0 : axis.plotOffset);
                    width = axis.plotOffset + (orientation == 'horizontal' ? axis.width : axis.height);
                    scrObj = model.scrollObj;
                    if (range.min != null || range.max != null)
                        isRedraw = scrObj[r] ? (scrObj[r].actualRange.min != range.min || scrObj[r].actualRange.max != range.max) : false;
                    else
                        isRedraw = scrObj[r] ? (scrObj[r].actualRange != scrollbarSettings.pointsLength) : false;
                    this.scrollDraw = scrObj[r] ? (scrObj[r].x != scrollerX || scrObj[r].y != scrollerY || scrObj[r].width != width) : this.scrollDraw;
                    var options = {
                        'orientation': axis.orientation,
                        'index': r,
                        'width': width,
                        'x': scrollerX,
                        'y': posY,
                        'opposed': opposed,
                        'isRTL': inversed,
                        'parent': this.axisScroll,
                        'enableResize': scrollbarSettings.canResize,
                    }
                    if (model.isLazyZooming) {

                        if (scrollEleLength == 0 || this.scrollDraw || isRedraw) {
                            $("#scrollbar_" + this.axisScroll[0].id + r).remove();
                            if (range.min != null || range.max != null) {
                                scrollRange = (scrObj[r] && scrObj[r].scrollRange) ? scrObj[r].scrollRange : axis.visibleRange;
                                if (!this.scrollDraw || isRedraw) {
                                    scrObj[r] = {
                                        'isVirtual': true,
                                        'valueType': valueType,
                                        'scrollRange': scrollRange
                                    };
                                    scrObj[r].actualRange = $.extend(scrObj[r].actualRange, scrollbarSettings.range);
                                    $.extend(scrObj[r], options);
                                    if (valueType == 'datetime') {
                                        scrObj[r].startDateTime = new Date(axis.visibleRange.min);
                                        scrObj[r].endDateTime = new Date(axis.visibleRange.max);
                                    } else {
                                        scrObj[r].startValue = axis.visibleRange.min;
                                        scrObj[r].endValue = axis.visibleRange.max;
                                    }

                                    this._calculateZoomValue(axis.visibleRange.min, axis.visibleRange.max, axis, this.model.scrollObj[r]);
                                } else {
                                    scrObj[r].width = width;
                                    scrObj[r].x = scrollerX;
                                    scrObj[r].y = posY;
                                }
                            } else if (pointLength >= axis.maxPointLength) {
                                zoomFac = axis.maxPointLength / pointLength;
                                zoomPos = (inversed) ? (1 - axis.zoomPosition) : axis.zoomPosition;
                                if (!this.scrollDraw || isRedraw) {
                                    scrObj[r] = {
                                        'isVirtual': true,
                                        'zoomPosition': zoomPos,
                                        'zoomFactor': zoomFac,
                                        'scrollRange': {
                                            'min': 0,
                                            'max': pointLength - 1,
                                            'delta': pointLength - 1
                                        },
                                        'valueType': 'double'
                                    };
                                    scrObj[r].actualRange = scrollbarSettings.pointsLength;
                                    $.extend(scrObj[r], options);
                                    scrObj[r].startValue = 0;
                                    scrObj[r].endValue = axis.maxPointLength;
                                } else {
                                    scrObj[r].width = width;
                                    scrObj[r].x = scrollerX;
                                    scrObj[r].y = posY;
                                }

                            }
                            if (this.model.scrollObj[r]) {
                                this.scrollbarContainer = new sf.EjSvgScrollbarRender(this.axisScroll, this.model.scrollObj[r]);
                                this.scrollbarContainer._initializeScrollbarVariables(this.model.scrollObj[r]);
                                this.scrollbarContainer._renderScrollbar.call(this, this.model.scrollObj[r]);
                            }
                        }
                    }
                    else if (scrollbarSettings.visible) {

                        //* Started Resizable Scrollbar here *// 
                        scrObj = model.scrollObj;

                        if (scrollEleLength == 0 || this.scrollDraw) {
                            $("#scrollbar_" + this.axisScroll[0].id + r).remove();
                            scrObj[r] = {
                                'zoomPosition': zoomPos,
                                'zoomFactor': zoomFac,
                                'valueType': valueType,
                                'scrollRange': axis.actualRange,
                                'isZooming': true
                            };
                            $.extend(scrObj[r], options);
                            if (scrObj[r].valueType == 'datetime') {
                                scrObj[r].startDateTime = new Date(scrObj[r].scrollRange.min);
                                scrObj[r].endDateTime = new Date(scrObj[r].scrollRange.max);
                            } else {
                                scrObj[r].startValue = scrObj[r].scrollRange.min;
                                scrObj[r].endValue = scrObj[r].scrollRange.max;
                            }
                            this.scrollbarContainer = new sf.EjSvgScrollbarRender(this.axisScroll, this.model.scrollObj[r]);
                            this.scrollbarContainer._initializeScrollbarVariables(this.model.scrollObj[r]);
                            this.scrollbarContainer._renderScrollbar.call(this, this.model.scrollObj[r]);
                        }
                    }

                } else {
                    if (scrollEleLength > 0)
                        $("#scrollbar_" + this.axisScroll[0].id + r).remove();

                }
            }
            this.scrollDraw = false;
        },

        //Draw the trendline series
        _renderTrendline: function (chartObj, seriesOptions) {
            // declaration
            var seriesIndex = $.inArray(seriesOptions, chartObj.model.series),
                transX = chartObj.model.requireInvertedAxes ? seriesOptions.yAxis.x : seriesOptions.xAxis.x,
                transY = chartObj.model.requireInvertedAxes ? seriesOptions.xAxis.y : seriesOptions.yAxis.y,
                translate = 'translate(' + transX + ',' + transY + ')',
                trendlinesOptions = { 'id': chartObj.svgObject.id + '_TrendlinesGroup' + '_' + seriesIndex, 'clip-path': 'url(#' + chartObj.svgObject.id + '_TrendlinesGroup' + '_' + seriesIndex + '_ClipRect)' },
                trendlines = seriesOptions.trendlines, m, element, polynomialSlopes, slopeLength,
                options, trendline, i, slope, intercept, displayText, text = "",
                length = trendlines.length, trendOptions, trendlineType, commonEventArgs, backwardPoints, forwardPoints;

            if (!chartObj.gTrendlinesGroupEle) chartObj.gTrendlinesGroupEle = [];
            chartObj.gTrendlinesGroupEle[seriesIndex] = chartObj.svgRenderer.createGroup(trendlinesOptions);
            for (i = 0; i < length; i++) {
                trendline = trendlines[i];
                trendline.seriesIndex = seriesIndex;
                trendline.isTrendLine = true;
                trendline.trendlineIndex = i;
                if (trendline.visibility.toLowerCase() === 'visible' && !trendline.isNull && trendline.points) {
                    trendOptions = { 'id': chartObj.svgObject.id + '_TrendGroup' + '_' + seriesIndex + '_' + i, 'transform': translate, 'clip-path': 'url(#' + chartObj.svgObject.id + '_TrendGroup' + '_' + seriesIndex + '_' + i + '_ClipRect)' };
                    seriesOptions.gTrendGroupEle = null;
                    seriesOptions.gTrendGroupEle = chartObj.svgRenderer.createGroup(trendOptions);
                    trendlineType = trendline.type.toLowerCase();
                    options = new sf.trendlineTypes[trendlineType]();
                    slope = trendline.slope;
                    intercept = trendline._intercept;
                    switch (trendlineType) {
                        case "linear":
                            text = "y = " + slope.toFixed(4) + "x + " + intercept.toFixed(4);
                            break;
                        case "exponential":
                            text = "y = " + intercept.toFixed(3) + "e" + "^" + slope.toFixed(4) + "x";
                            break;
                        case "logarithmic":
                            text = "y = " + slope.toFixed(3) + "ln(x) + " + intercept.toFixed(4);
                            break;
                        case "power":
                            text = "y = " + intercept.toFixed(3) + "x^" + slope.toFixed(4);
                            break;
                        case "polynomial":
                            polynomialSlopes = trendline.polynomialSlopes;
                            slopeLength = polynomialSlopes.length;
                            text = "y = ";
                            for (m = slopeLength - 1; m >= 0; m--) {
                                displayText = polynomialSlopes[m];
                                text += displayText > 0 ? "+" + displayText : "-" + Math.abs(displayText);
                                if (m != 0)
                                    text += "x^" + m + " ";
                            }
                            break;
                    }
                    trendline.equation = text;   // for equation

                    ////Trigger Trendline rendering events
                    commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                    backwardPoints = trendline.points[0];
                    forwardPoints = trendline.points[trendline.points.length - 1];
                    commonEventArgs.data = { series: seriesOptions, trendline: trendline, forwardForecastPoints: forwardPoints, backwardForecastPoints: backwardPoints };
                    this._trigger("trendlineRendering", commonEventArgs);

                    if (chartObj.model.enableCanvasRendering) {
                        this.svgRenderer.ctx.save();
                        this.svgRenderer.ctx.beginPath();
                        this.svgRenderer.ctx.rect(chartObj.model.m_AreaBounds.X, seriesOptions.yAxis.y, seriesOptions.xAxis.width, seriesOptions.yAxis.height);
                        this.svgRenderer.ctx.clip();
                        this.svgRenderer.ctx.beginPath();
                        options.draw(trendline, seriesOptions, chartObj);
                        this.svgRenderer.ctx.restore();
                    } else {
                        options.draw(trendline, seriesOptions, chartObj);
                        //Add axes bounds clip path for series
                        element = seriesOptions.gTrendGroupEle;
                        if (element) sf.EjSvgRender.utils._drawAxesBoundsClipPath(element, seriesOptions, this);
                    }
                }
            }

        },
        _renderStripline: function (zIndex) {
            $.extend(sf.EjStripline.prototype, this);
            this.chartstripline = new sf.EjStripline(this);
            var stripline = this.chartstripline;
            this.model._stripeline = false;
            for (var sl = 0; sl < this.model._axes.length; sl++) {
                var slAxis = this.model._axes[sl];
                for (var slCount = 0; slCount < slAxis.stripLine.length; slCount++) {
                    if (slAxis.stripLine[slCount].zIndex.toLowerCase() == zIndex)
                        stripline._drawStripline(slAxis, slAxis.stripLine[slCount], sl, slCount);
                }
            }
            if (zIndex == 'over' && this.model._stripeline) {

                this.svgRenderer.append(this.gStriplineOver, this.svgObject);
            } else if (this.model._stripeline) {
                this.svgRenderer.append(this.gStriplineBehind, this.svgObject);
            }
        },

        renderSeries: function (options, params, excludeDataUpdate) {

            var chart = this, axis, showLabels, index;
            var drawType = options.drawType;
            var seriesIndex = $.inArray(options, this.model._visibleSeries);

            for (var i = 0; i < options.points.length; i++) {
                if (typeof options.points[i].x == "string" && options.points[i].x.indexOf("/Date(") != -1)
                    options.points[i].x = new Date(parseInt(options.points[i].x.substr(6)));
                else
                    break;
            }
            options.xAxis = (options.xAxis === null || options.xAxis === undefined) ? this.model._axes[0] : options.xAxis;
            options.yAxis = (options.yAxis === null || options.yAxis === undefined) ? this.model._axes[1] : options.yAxis;
            var type = options.type.toLowerCase();
            var drawtype = options.drawType.toLowerCase();
            var symbolOptions;
            var translate = null;
            var visibility;

            if (this.model.AreaType == "cartesianaxes") {
                var trans = sf.EjSvgRender.utils._getTransform(options.xAxis, options.yAxis, this.model.requireInvertedAxes);
                var translate = 'translate(' + trans.x + ',' + trans.y + ')';
                visibility = 'visible';
            }
            else {
                visibility = (options.enableAnimation && !options._animatedSeries) ? 'hidden' : 'visible'
            }
            var txtOptions = { 'id': this.svgObject.id + '_TextGroup_' + seriesIndex, 'transform': translate, 'visibility': visibility };
            var dataLabelOptions = { 'id': this.svgObject.id + '_DataLabel_' + seriesIndex, 'transform': translate, 'visibility': visibility };
            if (type != "scatter")
                symbolOptions = { 'id': this.svgObject.id + '_symbolGroup_' + seriesIndex, 'transform': translate, 'visibility': visibility };
            else
                symbolOptions = { 'id': this.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': translate };
            var connectorOptions = { 'id': this.svgObject.id + '_ConnectorGroup_' + seriesIndex, 'transform': translate, 'visibility': visibility };
            if (!this.gSymbolGroupEle) this.gSymbolGroupEle = [];
            this.gSymbolGroupEle[seriesIndex] = this.svgRenderer.createGroup(symbolOptions);
            if (!this.gSeriesTextEle) this.gSeriesTextEle = [];
            this.gSeriesTextEle[seriesIndex] = this.svgRenderer.createGroup(txtOptions);
            if (!this.gConnectorEle) this.gConnectorEle = [];
            this.gConnectorEle[seriesIndex] = this.svgRenderer.createGroup(connectorOptions);
            if (!this.gDataLabelEle) this.gDataLabelEle = [];
            this.gDataLabelEle[seriesIndex] = this.svgRenderer.createGroup(dataLabelOptions);

            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { series: options };
            this._trigger("seriesRendering", commonEventArgs);

            var series = new sf.seriesTypes[type]();
            if (this.model.enableCanvasRendering && this.model.AreaType != "none") {
                this.svgRenderer.ctx.save();
                this.svgRenderer.ctx.beginPath();
                if (!this.model.requireInvertedAxes) { //checked for bar and stackingbar series
                    this.canvasX = options.xAxis.x;
                    this.canvasY = options.yAxis.y;
                    this.svgRenderer.ctx.rect(options.xAxis.x, options.yAxis.y, options.xAxis.width, options.yAxis.height);
                } else {
                    var translate = sf.EjSvgRender.utils._getTransform(options.xAxis, options.yAxis, this.model.requireInvertedAxes);
                    this.canvasX = translate.x;
                    this.canvasY = translate.y;
                    this.svgRenderer.ctx.rect(options.yAxis.x, options.xAxis.y, options.yAxis.width, options.xAxis.height);
                }
                this.svgRenderer.ctx.clip();
                series.draw(this, options, params, excludeDataUpdate);
                this.svgRenderer.ctx.restore();
            }
            else if (this.model.enableCanvasRendering && this.model.AreaType == "polaraxes") {
                this.svgRenderer.ctx.save();
                this.svgRenderer.ctx.beginPath();
                this.svgRenderer.ctx.arc(this.model.centerX, this.model.centerY, this.model.Radius, 0, 2 * Math.PI, false);
                this.svgRenderer.ctx.clip();
                this.canvasX = this.canvasY = 0;
                series.draw(this, options, excludeDataUpdate);
                this.svgRenderer.ctx.restore();
            }
            else {
                this.canvasX = this.canvasY = 0;
                if (this.model.AreaType == "cartesianaxes")
                    series.draw(this, options, params);
                else if (this.model.AreaType == "polaraxes" && (options._xAxisName == this.model._axes[0].name && options._yAxisName == this.model._axes[1].name))
                    series.draw(this, options, excludeDataUpdate);
            }
            var errorbar = this.model.series[seriesIndex].errorBar,
                areaType = this.model.AreaType;
            if (errorbar.visibility == 'visible' && areaType == 'cartesianaxes' && (this.model.series[seriesIndex].type != "boxandwhisker"))
                this.renderErrorBar(errorbar, options);                           // to render error bar
			if (type == "splinerangearea")
                series.gSeriesGroupEle = this.gSeriesGroupEle;
            //Add axes bounds clip path for series
            var element = series.gSeriesGroupEle;
            if (element) sf.EjSvgRender.utils._drawAxesBoundsClipPath(element, options, this);

            // Draw Symbols       
            if (!(type == "candle" || type == "hilo" || type == "hiloopenclose" || type == "boxandwhisker")) {
                var chartObj = this, point1,
                    areatype = chartObj.model.AreaType.toLowerCase(),
                    regiontype = sf.seriesTypes[type].prototype.isRegion;
                showLabels = options._pointMarker ? (options.marker.visible || options._pointMarker) : true;
                if (!(type == "scatter") && showLabels) {
                    $.each(options._visiblePoints, function (pointIndex, point) {
                        if ((point.visible !== false) && (point.x !== "") && ((point.marker && point.marker.visible) || (options.marker.visible))) {
                            //this condition provide for better Scatter performance
                            if ((areatype == "polaraxes" && drawtype == "column") || regiontype)
                                point1 = point.symbolLocation;
                            else
                                point1 = (areatype != "polaraxes")
                                    ? sf.EjSvgRender.utils._getPoint(point, options) : sf.EjSvgRender.utils.TransformToVisible(options, point.xValue, point.y, chartObj)
                            if (areatype == "polaraxes") {
                                var labelFormat = options.yAxis.labelFormat ? options.yAxis.labelFormat : "";
                                var pointText = (point.text) ? point.text : point.y + labelFormat.substring(labelFormat.indexOf('}') + 1);
                                var textOffset = sf.EjSvgRender.utils._measureText(pointText, null, options.marker.dataLabel.font);
                            }
                            if ((areatype == "polaraxes" && (options._xAxisName == chartObj.model._axes[0].name && options._yAxisName == chartObj.model._axes[1].name)) && ((type.toLowerCase() == "polar" || type.toLowerCase() == "radar") && (drawType != "scatter")) || areatype == "cartesianaxes")
                                series.drawSymbol(seriesIndex, options, pointIndex, point1.X, point1.Y);
                        }
                    });
                }
                if (type != "scatter") {
                    //Add axes bounds clip path for marker
                    if ((options.marker.visible) && (drawType != "scatter")) {
                        element = this.gSymbolGroupEle[seriesIndex];
                        sf.EjSvgRender.utils._drawAxesBoundsClipPath(element, options, this);
                    }
                    // Add axes bounds clip path for marker text
                    if (options.marker.dataLabel.visible) {
                        element = this.gSeriesTextEle[seriesIndex];
                        sf.EjSvgRender.utils._drawAxesBoundsClipPath(element, options, this);
                        // for data label shape
                        element = this.gDataLabelEle[seriesIndex];
                        sf.EjSvgRender.utils._drawAxesBoundsClipPath(element, options, this);
                    }
                    // Add axes bounds clip path for connector line
                    if (!sf.util.isNullOrUndefined(this.gConnectorEle) && this.gConnectorEle.length > 0) {
                        element = this.gConnectorEle[seriesIndex];
                        sf.EjSvgRender.utils._drawAxesBoundsClipPath(element, options, this);
                    }
                } else {
                    element = this.gSymbolGroupEle[seriesIndex];
                    sf.EjSvgRender.utils._drawAxesBoundsClipPath(element, options, this);
                    this.svgRenderer.append(element, this.gSeriesEle);

                    if (options.tooltip.visible || type == "scatter") {
                        if (this.vmlRendering) {
                            this.cloneSeriesEle = $(this.gSeriesEle).clone();
                            this.cloneobj = $(this.element).clone();
                            this.svgclone = $(this.svgObject).clone();
                            $(document.body).append(this.cloneobj);
                            this.svgRenderer.append(this.cloneSeriesEle, this.svgclone);
                            this.svgRenderer.append(this.svgclone, this.cloneobj);
                        }
                        else {
                            this.svgRenderer.append(this.gSeriesEle, this.svgObject);
                            this.svgRenderer.append(this.svgObject, this.element);
                        }

                        if (this.vmlRendering) {
                            $(this.cloneobj).remove();
                            $(this.svgclone).remove();
                        }
                    }
                }
            }



            //Draw Series Text
            showLabels = options._dataLabels ? (options.marker.dataLabel.visible || options._dataLabels > 0) : true;
            if (options.marker.dataLabel.visible || showLabels)
                this.drawDisplayText(series, options, params);


        },

        renderErrorBar: function (errorOptions, seriesOptions) {
            // declaration
            var chartobj = this,
                model = chartobj.model,
                currentseries = seriesOptions,
                type, mode, direction, fill, cap,
                capFill, capWidth, capLength,
                visiblePoints = currentseries._visiblePoints,
                len = visiblePoints.length,
                canvasX = chartobj.canvasX, canvasY = chartobj.canvasY,
                seriesIndex = $.inArray(currentseries, model._visibleSeries),
                translate = null, i,
                trans = sf.EjSvgRender.utils._getTransform(currentseries.xAxis, currentseries.yAxis, model.requireInvertedAxes),
                verticalErrorValue, horizontalErrorValue,
                requireInvertedAxes = model.requireInvertedAxes,
                verticalPositive, verticalNegative,
                horizontalPositive, horizontalNegative,
                svgObjectId = chartobj.svgObject.id,
                areaBounds = chartobj.model.m_AreaBounds,
                translate = 'translate(' + trans.x + ',' + trans.y + ')',
                errorBarElement, errorBarGroup, event, errorBarPoint,
                pointIndex, point, yValue, xVal, standY, standX,
                location, verHighvalue, verLowvalue,
                horHighvalue, horLowvalue, mean, verMean, horMean,
                verStandSquareRoot, horStandSquareRoot, centervalueX, centervalueY,
                verStandardDeviationValue, horStandardDeviationValue,
                verCentervalue, horCentervalue,
                verStandardErrorValue, horStandardErrorValue,
                values, values1, verHighCapX1, verHighCapX2,
                verLowCapX1, verLowCapX2, horHighCapY1, horHighCapY2,
                horLowCapY1, horLowCapY2, eDirectionV, cDirectionV,
                eDirectionH, cDirectionH, eDirection, cDirection,
                fixvalue, pervalue, perY, perX, standDeviValue, standError,
                custom, capValues, commonEventArgs, errorBarPointGroup;

            // parent group creation
            errorBarGroup = {
                'id': svgObjectId + '_ErrorBarGroup' + '_' + seriesIndex,
                'transform': translate,
                'clip-path': 'url(#' + svgObjectId + '_ChartAreaClipRect)'
            };

            if (sf.util.isNullOrUndefined(chartobj.gErrorBarGroupEle))
                chartobj.gErrorBarGroupEle = [];
            errorBarElement = chartobj.gErrorBarGroupEle[seriesIndex] = chartobj.svgRenderer.createGroup(errorBarGroup);

            commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = {
                errorBar: errorOptions
            };
            this._trigger("errorBarRendering", commonEventArgs);      // trigger event

            event = commonEventArgs.data.errorBar;
            type = event.type;
            mode = event.mode;
            direction = event.direction;
            fill = event.fill;
            cap = event.cap;
            capFill = event.cap.fill;
            capWidth = event.cap.width;
            capLength = event.cap.length;
            verticalErrorValue = event.verticalErrorValue;
            horizontalErrorValue = event.horizontalErrorValue;
            verticalPositive = event.verticalPositiveErrorValue;
            verticalNegative = event.verticalNegativeErrorValue;
            horizontalPositive = event.horizontalPositiveErrorValue;
            horizontalNegative = event.horizontalNegativeErrorValue;

            for (i = 0; i < len; i++) {
                if (visiblePoints[i].isEmpty !== true && visiblePoints[i].visible == true) {
                    // error bar group creation
                    errorBarPoint = {
                        'id': chartobj.svgObject.id + '_ErrorBarGroup' + '_' + seriesIndex + '_Point' + i
                    }
                    errorBarPointGroup = chartobj.svgRenderer.createGroup(errorBarPoint);

                    pointIndex = i;
                    point = visiblePoints[i];
                    yValue = point.YValues[0];
                    xVal = point.xValue;
                    standY = visiblePoints[i].YValues[0];
                    standX = visiblePoints[i].xValue;

                    if (type.indexOf("column") || type.indexOf("bar") > -1)
                        location = point.symbolLocation;
                    else
                        location = point.location;
                    if (sf.util.isNullOrUndefined(location))
                        location = sf.EjSvgRender.utils._getPoint(point, currentseries);
                    centervalueX = location.X;
                    centervalueY = location.Y;
                    //error bar type calculation
                    switch (type) {
                        case "fixedValue":
                            fixvalue = point;
                            if (mode == 'vertical' || mode == 'both') {          //vertical mode calculation for fixed value point location
                                fixvalue.YValues[0] = yValue + verticalErrorValue;
                                verHighvalue = sf.EjSvgRender.utils._getPoint(fixvalue, currentseries);
                                fixvalue.YValues[0] = yValue - verticalErrorValue;
                                verLowvalue = sf.EjSvgRender.utils._getPoint(fixvalue, currentseries);
                                if (!requireInvertedAxes)
                                    verHighvalue.X = verLowvalue.X = location.X;
                                else
                                    verHighvalue.Y = verLowvalue.Y = location.Y;
                            }
                            if (mode == 'horizontal' || mode == 'both') {
                                fixvalue.YValues[0] = yValue;
                                fixvalue.xValue = xVal;                    //horizontal mode calculation for fixed value point location
                                fixvalue.xValue = xVal + horizontalErrorValue;
                                horHighvalue = sf.EjSvgRender.utils._getPoint(fixvalue, currentseries);
                                fixvalue.xValue = xVal - horizontalErrorValue;
                                horLowvalue = sf.EjSvgRender.utils._getPoint(fixvalue, currentseries);
                            }
                            fixvalue.YValues[0] = yValue;
                            fixvalue.xValue = xVal;
                            break;

                        case "percentage":
                            pervalue = point;
                            perY = verticalErrorValue / 100 * yValue;
                            perX = horizontalErrorValue / 100 * xVal;
                            if (mode == 'vertical' || mode == 'both') {                  //vertical mode calculation for percentage point locaion
                                pervalue.YValues[0] = yValue + perY;
                                verHighvalue = sf.EjSvgRender.utils._getPoint(pervalue, currentseries);
                                pervalue.YValues[0] = yValue - perY;
                                verLowvalue = sf.EjSvgRender.utils._getPoint(pervalue, currentseries);
                                if (!requireInvertedAxes)
                                    verHighvalue.X = verLowvalue.X = location.X;
                                else
                                    verHighvalue.Y = verLowvalue.Y = location.Y;
                            }
                            if (mode == 'horizontal' || mode == 'both') {
                                pervalue.YValues[0] = yValue;
                                pervalue.xValue = xVal;                              //horizontal mode calculation for percentage
                                pervalue.xValue = xVal + perX;
                                horHighvalue = sf.EjSvgRender.utils._getPoint(pervalue, currentseries);
                                pervalue.xValue = xVal - perX;
                                horLowvalue = sf.EjSvgRender.utils._getPoint(pervalue, currentseries);
                            }
                            pervalue.YValues[0] = yValue;
                            pervalue.xValue = xVal;
                            break;

                        case "standardDeviation":
                            standDeviValue = point;
                            mean = chartobj.meanCalculation(mode, visiblePoints);
                            verMean = mean.verMean;
                            horMean = mean.horMean;
                            verStandSquareRoot = mean.verStandSquareRoot;
                            horStandSquareRoot = mean.horStandSquareRoot;
                            if (mode == 'vertical' || mode == 'both') {
                                verStandardDeviationValue = verticalErrorValue * verStandSquareRoot;
                                standDeviValue.YValues[0] = verMean;
                                verCentervalue = sf.EjSvgRender.utils._getPoint(standDeviValue, currentseries);
                                yValue = standDeviValue.YValues[0];
                                standDeviValue.YValues[0] = yValue + verStandardDeviationValue;
                                verHighvalue = sf.EjSvgRender.utils._getPoint(standDeviValue, currentseries);
                                standDeviValue.YValues[0] = yValue - verStandardDeviationValue;
                                verLowvalue = sf.EjSvgRender.utils._getPoint(standDeviValue, currentseries);
                                if (!requireInvertedAxes)
                                    verCentervalue.X = verHighvalue.X = verLowvalue.X = location.X;
                                else
                                    verCentervalue.Y = verHighvalue.Y = verLowvalue.Y = location.Y;
                                verCentervalue.X = verCentervalue.X + canvasX;
                                verCentervalue.Y = verCentervalue.Y + canvasY;
                            }
                            if (mode == 'horizontal' || mode == 'both') {
                                horStandardDeviationValue = horizontalErrorValue * horStandSquareRoot;
                                standDeviValue.xValue = horMean;
                                horCentervalue = sf.EjSvgRender.utils._getPoint(standDeviValue, currentseries);
                                if (!requireInvertedAxes)
                                    horCentervalue.Y = location.Y;
                                else
                                    horCentervalue.X = location.X;
                                standDeviValue.YValues[0] = standY;
                                xVal = standDeviValue.xValue;
                                standDeviValue.xValue = xVal + horStandardDeviationValue;
                                horHighvalue = sf.EjSvgRender.utils._getPoint(standDeviValue, currentseries);
                                standDeviValue.xValue = xVal - horStandardDeviationValue;
                                horLowvalue = sf.EjSvgRender.utils._getPoint(standDeviValue, currentseries);
                                horCentervalue.X = horCentervalue.X + canvasX;
                                horCentervalue.Y = horCentervalue.Y + canvasY;

                            }
                            standDeviValue.YValues[0] = standY;
                            standDeviValue.xValue = standX;

                            break;
                        case "standardError":
                            standError = point;
                            mean = chartobj.meanCalculation(mode, visiblePoints);
                            verStandSquareRoot = mean.verStandSquareRoot;
                            horStandSquareRoot = mean.horStandSquareRoot;
                            if (mode == 'vertical' || mode == 'both') {                                   //vertical mode standard Error calculation
                                verStandardDeviationValue = verticalErrorValue * verStandSquareRoot;
                                verStandardErrorValue = verStandardDeviationValue / Math.sqrt(len);
                                standError.YValues[0] = yValue + verStandardErrorValue;
                                verHighvalue = sf.EjSvgRender.utils._getPoint(standError, currentseries);
                                standError.YValues[0] = yValue - verStandardErrorValue
                                verLowvalue = sf.EjSvgRender.utils._getPoint(standError, currentseries);
                                if (!requireInvertedAxes)
                                    verHighvalue.X = verLowvalue.X = location.X;
                                else
                                    verHighvalue.Y = verLowvalue.Y = location.Y;
                            }
                            if (mode == 'horizontal' || mode == 'both') {                             //horizontal mode standard Error calculation
                                horStandardDeviationValue = horizontalErrorValue * horStandSquareRoot;
                                horStandardErrorValue = horStandardDeviationValue / Math.sqrt(len);
                                standError.YValues[0] = yValue;
                                standError.xValue = xVal;                      //horizontal mode calculation for  point location
                                standError.xValue = xVal + horStandardErrorValue;
                                horHighvalue = sf.EjSvgRender.utils._getPoint(standError, currentseries);
                                standError.xValue = xVal - horStandardErrorValue;
                                horLowvalue = sf.EjSvgRender.utils._getPoint(standError, currentseries);
                            }
                            standError.YValues[0] = yValue;
                            standError.xValue = xVal;
                            i = pointIndex;
                            break;

                        case "custom":
                            custom = point;
                            if (mode == 'vertical' || mode == 'both') {                         //calculation for vertical mode point locaton
                                custom.YValues[0] = yValue + verticalPositive;
                                verHighvalue = sf.EjSvgRender.utils._getPoint(custom, currentseries);
                                custom.YValues[0] = yValue - verticalNegative;
                                verLowvalue = sf.EjSvgRender.utils._getPoint(custom, currentseries);
                                if (!requireInvertedAxes)
                                    verHighvalue.X = verLowvalue.X = location.X;
                                else
                                    verHighvalue.Y = verLowvalue.Y = location.Y;
                            }
                            if (mode == 'horizontal' || mode == 'both') {
                                custom.YValues[0] = yValue;
                                custom.xValue = xVal;                     //calculation for horizontal mode point location
                                custom.xValue = xVal + horizontalPositive;
                                horHighvalue = sf.EjSvgRender.utils._getPoint(custom, currentseries);
                                custom.xValue = xVal - horizontalNegative;
                                horLowvalue = sf.EjSvgRender.utils._getPoint(custom, currentseries);
                            }
                            custom.YValues[0] = yValue;
                            custom.xValue = xVal;
                            break;
                    }

                    //to render cap 
                    if (cap.visible == true) {
                        if (mode == 'vertical' || mode == 'both')
                            values = { verHighvalue: verHighvalue, verLowvalue: verLowvalue }
                        if (mode == 'horizontal' || mode == 'both')
                            values1 = { horHighvalue: horHighvalue, horLowvalue: horLowvalue }
                        capValues = chartobj.renderCap(cap, mode, values, values1, requireInvertedAxes);
                        verHighCapX1 = capValues.verHighCapX1, verHighCapX2 = capValues.verHighCapX2,
                            verLowCapX1 = capValues.verLowCapX1, verLowCapX2 = capValues.verLowCapX2,
                            horHighCapY1 = capValues.horHighCapY1, horHighCapY2 = capValues.horHighCapY2,
                            horLowCapY1 = capValues.horLowCapY1, horLowCapY2 = capValues.horLowCapY2;
                    }
                    centervalueX = centervalueX + canvasX;
                    centervalueY = centervalueY + canvasY;
                    if (mode == 'vertical' || mode == 'both') {
                        verHighvalue.X = verHighvalue.X + canvasX;
                        verHighvalue.Y = verHighvalue.Y + canvasY;
                        verLowvalue.X = verLowvalue.X + canvasX;
                        verLowvalue.Y = verLowvalue.Y + canvasY;
                    }
                    if (mode == 'horizontal' || mode == 'both') {
                        horHighvalue.X = horHighvalue.X + canvasX;
                        horHighvalue.Y = horHighvalue.Y + canvasY;
                        horLowvalue.X = horLowvalue.X + canvasX;
                        horLowvalue.Y = horLowvalue.Y + canvasY;
                    }
                    //drawing error bar and error bar cap  
                    //drawing both direction    
                    if (direction == 'both') {
                        if (mode == 'vertical' || mode == 'both') {             //vertical mode for both direction
                            if (type != 'standardDeviation')
                                eDirectionV = "M" + " " + (centervalueX) + " " + (centervalueY) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "M" + " " + (centervalueX) + " " + (centervalueY) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " ";
                            else if (type == 'standardDeviation')
                                eDirectionV = "M" + " " + (verCentervalue.X) + " " + (verCentervalue.Y) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "M" + " " + (verCentervalue.X) + " " + (verCentervalue.Y) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " ";
                            if (!requireInvertedAxes)
                                cDirectionV = !cap.visible ? "" : "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighCapX1) + " " + (verHighvalue.Y) + " " + "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighCapX2) + " " + (verHighvalue.Y) + " " + "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowCapX1) + " " + (verLowvalue.Y) + " " + "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowCapX2) + " " + (verLowvalue.Y) + " ";
                            else
                                cDirectionV = !cap.visible ? "" : "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighCapX1) + " " + "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighCapX2) + " " + "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowCapX1) + " " + "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowCapX2) + " ";
                            eDirection = eDirectionV, cDirection = cDirectionV;
                        }
                        if (mode == 'horizontal' || mode == 'both') {
                            if (type != 'standardDeviation')                          //horizontal mode for both direction
                                eDirectionH = "M" + " " + (centervalueX) + " " + (centervalueY) + " " + "L" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "M" + " " + (centervalueX) + " " + (centervalueY) + " " + "L" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " ";
                            else if (type == 'standardDeviation')
                                eDirectionH = "M" + " " + (horCentervalue.X) + " " + (horCentervalue.Y) + " " + "L" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "M" + " " + (horCentervalue.X) + " " + (horCentervalue.Y) + " " + "L" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " ";
                            if (!requireInvertedAxes)
                                cDirectionH = !cap.visible ? "" : "M" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "L" + " " + (horHighvalue.X) + " " + (horHighCapY1) + " " + "M" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "L" + " " + (horHighvalue.X) + " " + (horHighCapY2) + " " + "M" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " " + "L" + " " + (horLowvalue.X) + " " + (horLowCapY1) + " " + "M" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " " + "L" + " " + (horLowvalue.X) + " " + (horLowCapY2) + " ";
                            else
                                cDirectionH = !cap.visible ? "" : "M" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "L" + " " + (horHighCapY1) + " " + (horHighvalue.Y) + " " + "M" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "L" + " " + (horHighCapY2) + " " + (horHighvalue.Y) + " " + "M" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " " + "L" + " " + (horLowCapY1) + " " + (horLowvalue.Y) + " " + "M" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " " + "L" + " " + (horLowCapY2) + " " + (horLowvalue.Y) + " ";
                            eDirection = eDirectionH, cDirection = cDirectionH;
                        }
                        if (mode == 'both') {
                            eDirectionH += eDirectionV, cDirectionH += cDirectionV;
                            eDirection = eDirectionH, cDirection = cDirectionH;
                        }
                    }
                    //drawing plus direction
                    else if (direction == 'plus') {
                        if (mode == 'vertical' || mode == 'both') {        //vertical mode for plus direction
                            if (type != 'standardDeviation')
                                eDirectionV = "M" + " " + (centervalueX) + " " + (centervalueY) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " ";
                            else if (type == 'standardDeviation')
                                eDirectionV = "M" + " " + (verCentervalue.X) + " " + (verCentervalue.Y) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " ";
                            if (!requireInvertedAxes)
                                cDirectionV = !cap.visible ? "" : "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighCapX1) + " " + (verHighvalue.Y) + " " + "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighCapX2) + " " + (verHighvalue.Y) + " ";
                            else
                                cDirectionV = !cap.visible ? "" : "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighCapX1) + " " + "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighCapX2) + " ";
                            var eDirection = eDirectionV, cDirection = cDirectionV;
                        }
                        if (mode == 'horizontal' || mode == 'both') {
                            if (type != 'standardDeviation')                        //horizontal mode for both direction
                                eDirectionH = "M" + " " + (centervalueX) + " " + (centervalueY) + " " + "L" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " ";
                            else if (type == 'standardDeviation')
                                eDirectionH = "M" + " " + (horCentervalue.X) + " " + (horCentervalue.Y) + " " + "L" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " ";
                            if (!requireInvertedAxes)
                                cDirectionH = !cap.visible ? "" : "M" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "L" + " " + (horHighvalue.X) + " " + (horHighCapY1) + " " + "M" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "L" + " " + (horHighvalue.X) + " " + (horHighCapY2) + " ";
                            else
                                cDirectionH = !cap.visible ? "" : "M" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "L" + " " + (horHighCapY1) + " " + (horHighvalue.Y) + " " + "M" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "L" + " " + (horHighCapY2) + " " + (horHighvalue.Y) + " ";
                            eDirection = eDirectionH, cDirection = cDirectionH;
                        }
                        if (mode == 'both') {
                            eDirectionH += eDirectionV, cDirectionH += cDirectionV;
                            eDirection = eDirectionH, cDirection = cDirectionH;
                        }
                    }
                    // drawing minus direction
                    else {
                        if (mode == 'vertical' || mode == 'both') {             //vertical mode for both direction
                            if (type != 'standardDeviation')
                                eDirectionV = "M" + " " + (centervalueX) + " " + (centervalueY) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " ";
                            else if (type == 'standardDeviation')
                                eDirectionV = "M" + " " + (verCentervalue.X) + " " + (verCentervalue.Y) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " ";
                            if (!requireInvertedAxes)
                                cDirectionV = !cap.visible ? "" : "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowCapX1) + " " + (verLowvalue.Y) + " " + "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowCapX2) + " " + (verLowvalue.Y) + " ";
                            else
                                cDirectionV = !cap.visible ? "" : "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowCapX1) + " " + "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowCapX2) + " ";
                            var eDirection = eDirectionV, cDirection = cDirectionV;
                        }
                        if (mode == 'horizontal' || mode == 'both') {
                            if (type != 'standardDeviation')                        //horizontal mode for both direction
                                eDirectionH = "M" + " " + (centervalueX) + " " + (centervalueY) + " " + "L" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " ";
                            else if (type == 'standardDeviation')
                                eDirectionH = "M" + " " + (horCentervalue.X) + " " + (horCentervalue.Y) + " " + "L" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " ";
                            if (!requireInvertedAxes)
                                cDirectionH = !cap.visible ? "" : "M" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " " + "L" + " " + (horLowvalue.X) + " " + (horLowCapY1) + " " + "M" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " " + "L" + " " + (horLowvalue.X) + " " + (horLowCapY2) + " ";
                            else
                                cDirectionH = !cap.visible ? "" : "M" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " " + "L" + " " + (horLowCapY1) + " " + (horLowvalue.Y) + " " + "M" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " " + "L" + " " + (horLowCapY2) + " " + (horLowvalue.Y) + " ";
                            eDirection = eDirectionH, cDirection = cDirectionH;
                        }
                        if (mode == 'both') {
                            eDirectionH += eDirectionV, cDirectionH += cDirectionV;
                            eDirection = eDirectionH, cDirection = cDirectionH;
                        }
                    }

                    var errorBarOptions = {             //error bar path creation
                        'id': chartobj.svgObject.id + '_ErrorBar' + '_' + seriesIndex + '_Point' + pointIndex,
                        'd': eDirection,
                        'stroke': fill,
                        'stroke-width': errorOptions.width,
                        'opacity': errorOptions.opacity
                    };
                    var errorBarCapOptions = {       //error bar cap creation
                        'id': chartobj.svgObject.id + '_ErrorBarCap' + '_' + seriesIndex + '_Point' + pointIndex,
                        'd': cDirection,
                        'stroke': capFill,
                        'stroke-width': capWidth
                    }
                    //canvas rendering
                    if (chartobj.model.enableCanvasRendering) {
                        this.svgRenderer.ctx.rect(areaBounds.X, areaBounds.Y, areaBounds.Width, areaBounds.Height);
                        this.svgRenderer.ctx.clip();
                        chartobj.svgRenderer.drawPath(errorBarOptions, null);              //To draw error bar for canvas
                        chartobj.svgRenderer.drawPath(errorBarCapOptions, null);           //To drae error bar cap for canvas
                    }
                    else {                                        //svg rendering
                        chartobj.svgRenderer.drawPath(errorBarOptions, errorBarPointGroup);
                        chartobj.svgRenderer.drawPath(errorBarCapOptions, errorBarPointGroup);
                        chartobj.svgRenderer.append(errorBarPointGroup, errorBarElement);
                    }
                }
            }
            //append with series group
            chartobj.svgRenderer.append(errorBarElement, chartobj.gSeriesEle);
            //clip-path 
            sf.EjSvgRender.utils._drawAxesBoundsClipPath(errorBarElement, currentseries, chartobj);
        },

        meanCalculation: function (mode, visiblePoints) {
            var temp = 0, temp1 = 0, total, verTotal, horTotal, verMean, horMean, ded, i,
                eachDev, squareEachDev, squareTotal, verEachDev, horEachDev,
                verSquareEachDev, verSquareTotal, horSquareTotal, horSquareTotal,
                verStandardMean, horStandardMean, verStandSquareRoot, horSquareEachDiv,
                horStandSquareRoot, values, len = visiblePoints.length;
            for (i = 0; i < len; i++) {
                if (mode == 'vertical') {             //vertical mode total calculation
                    total = temp + visiblePoints[i].y;
                    temp = total;
                }
                else if (mode == 'horizontal') {    //horizontal mode total calculation 
                    total = temp1 + visiblePoints[i].xValue;
                    temp1 = total;
                }
                else {                     //both mode  total calculation
                    verTotal = temp + visiblePoints[i].y;
                    temp = verTotal;
                    horTotal = temp1 + visiblePoints[i].xValue;
                    temp1 = horTotal;
                }
            }
            verMean = temp / len;
            horMean = temp1 / len;
            ded = len - 1;
            for (i = 0; i < len; i++) {
                if (mode == 'vertical') {
                    eachDev = visiblePoints[i].y - verMean;
                    squareEachDev = Math.pow(eachDev, 2);
                    squareTotal = temp + squareEachDev;
                    temp = squareTotal;
                }
                else if (mode == 'horizontal') {
                    eachDev = visiblePoints[i].xValue - horMean;
                    squareEachDev = Math.pow(eachDev, 2);
                    squareTotal = temp1 + squareEachDev;
                    temp1 = squareTotal;
                }
                else {
                    verEachDev = visiblePoints[i].y - verMean;
                    verSquareEachDev = Math.pow(verEachDev, 2);
                    verSquareTotal = temp + verSquareEachDev;
                    temp = verSquareTotal;
                    horEachDev = visiblePoints[i].xValue - horMean;
                    horSquareEachDiv = Math.pow(horEachDev, 2);
                    horSquareTotal = temp1 + horSquareEachDiv;
                    temp1 = horSquareTotal;
                }
            }
            verStandardMean = temp / ded;
            verStandSquareRoot = Math.sqrt(verStandardMean);
            horStandardMean = temp1 / ded;
            horStandSquareRoot = Math.sqrt(horStandardMean);
            values = { verStandSquareRoot: verStandSquareRoot, horStandSquareRoot: horStandSquareRoot, verMean: verMean, horMean: horMean }
            return values;
        },
        renderCap: function (cap, mode, values, values1, requireInvertedAxes) {
            //declaration
            var canvasX, canvasY, capLen, verHighvalue,
                verLowvalue, horHighvalue, horLowvalue,
                verHighCapX1, verHighCapX2, verLowCapX1,
                verLowCapX2, horHighCapY1, horHighCapY2,
                horLowCapY1, horLowCapY2, capValues;
            canvasX = this.canvasX;
            canvasY = this.canvasY;
            capLen = cap.length / 2;
            if (mode == 'vertical' || mode == 'both') {
                verHighvalue = values.verHighvalue;
                verLowvalue = values.verLowvalue;
            }
            if (mode == 'horizontal' || mode == 'both') {
                horHighvalue = values1.horHighvalue;
                horLowvalue = values1.horLowvalue;
            }
            if (mode == 'vertical' || mode == 'both') {
                if (!requireInvertedAxes) {
                    verHighCapX1 = verHighvalue.X + canvasX - capLen,
                        verHighCapX2 = verHighvalue.X + canvasX + capLen,
                        verLowCapX1 = verLowvalue.X + canvasX - capLen,
                        verLowCapX2 = verLowvalue.X + canvasX + capLen;
                }
                else {
                    verHighCapX1 = verHighvalue.Y + canvasY + capLen;
                    verHighCapX2 = verHighvalue.Y + canvasY - capLen;
                    verLowCapX1 = verLowvalue.Y + canvasY + capLen;
                    verLowCapX2 = verLowvalue.Y + canvasY - capLen;
                }
            }
            if (mode == 'horizontal' || mode == 'both') {
                if (!requireInvertedAxes) {
                    horHighCapY1 = horHighvalue.Y + canvasY - capLen,
                        horHighCapY2 = horHighvalue.Y + canvasY + capLen,
                        horLowCapY1 = horLowvalue.Y + canvasY - capLen,
                        horLowCapY2 = horLowvalue.Y + canvasY + capLen;
                }
                else {
                    horHighCapY1 = horHighvalue.X + canvasX + capLen;
                    horHighCapY2 = horHighvalue.X + canvasX - capLen;
                    horLowCapY1 = horLowvalue.X + canvasX + capLen;
                    horLowCapY2 = horLowvalue.X + canvasX - capLen;
                }
            }
            capValues = { verHighCapX1: verHighCapX1, verHighCapX2: verHighCapX2, verLowCapX1: verLowCapX1, verLowCapX2: verLowCapX2, horHighCapY1: horHighCapY1, horHighCapY2: horHighCapY2, horLowCapY1: horLowCapY1, horLowCapY2: horLowCapY2 }
            return capValues;
        },

        drawDisplayText: function (series, options, params) {
            // method to draw text 

            var chartObj = this;
            var point1;
            var type = options.type.toLowerCase();
            var areatype = chartObj.model.AreaType.toLowerCase();
            var regiontype = sf.seriesTypes[type].prototype.isRegion;
            var drawtype = options.drawType.toLowerCase();
            var pointMarker;
            var zoomed = false;
            var seriesIndex = $.inArray(options, chartObj.model._visibleSeries);
            if (sf.util.isNullOrUndefined(chartObj.model.regionCount))
                chartObj.model.regionCount = -1;

            var isCanvas = chartObj.model.enableCanvasRendering;
            var isPolar = chartObj.model.AreaType.toLowerCase() == 'polaraxes';
            var j = 0, stackingGroup = {}, length, name;
            for (length = chartObj.model.series.length; j < length; j++)
                stackingGroup[name = chartObj.model.series[j].stackingGroup] = { length: stackingGroup[name] ? stackingGroup[name].length + 1 : 1, seriesIndex: j }
            params.stackingGroup = stackingGroup;
            $.each(options._visiblePoints, function (pointIndex, point) {
                var type = chartObj.model.series[seriesIndex].type.toLowerCase();
                options._visiblePoints[pointIndex].textOptionsBoxValues = [];
                pointMarker = point.marker;
                if ((areatype == "polaraxes" && drawtype == "column") || regiontype || (drawtype == "rangecolumn"))
                    point1 = type.toLowerCase() == "boxandwhisker" ? point.dataLabelLocation : point.symbolLocation;
                else
                    point1 = (areatype != "polaraxes")
                        ? sf.EjSvgRender.utils._getPoint(point, options) : sf.EjSvgRender.utils.TransformToVisible(options, point.xValue, point.y, chartObj)
                if (point.visible !== false && ((pointMarker && pointMarker.dataLabel && pointMarker.dataLabel.visible) || (!pointMarker || !pointMarker.dataLabel) && options.marker.dataLabel.visible)) {
                    if (regiontype)
                        chartObj.model.regionCount++;

                    var type = chartObj.model.series[seriesIndex].type.toLowerCase();
                    for (i = 0; i < chartObj.model._axes.length; i++) {
                        if (chartObj.model._axes[i].zoomFactor < 1 || chartObj.model._axes[i].zoomPosition > 0) {
                            zoomed = true;
                            break;
                        }
                    }
                    //we have reset the chartRegions array based on the zooming points for column and stackingColumn series only
                    if ((chartObj.zoomed || options.xAxis._isScroll || zoomed) && (type == "column" || type == "stackingcolumn" || type == "stackingcolumn100")) {
                        for (var i = 0; i < chartObj.model.chartRegions.length; i++) {
                            if (seriesIndex == chartObj.model.chartRegions[i].SeriesIndex && pointIndex == chartObj.model.chartRegions[i].Region.PointIndex) {
                                if (isCanvas && chartObj.model.AreaType == "cartesianaxes") {
                                    chartObj.svgRenderer.ctx.save();
                                    chartObj.svgRenderer.ctx.beginPath();
                                    if (!chartObj.model.requireInvertedAxes) // checked for bar and stackingbar
                                        chartObj.svgRenderer.ctx.rect(options.xAxis.x, options.yAxis.y, options.xAxis.width, options.yAxis.height);
                                    else
                                        chartObj.svgRenderer.ctx.rect(options.yAxis.x, options.xAxis.y, options.yAxis.width, options.xAxis.height);
                                    chartObj.svgRenderer.ctx.clip();
                                    series.drawDataLabel(options, pointIndex, point, point1.X, point1.Y, i, params);
                                    chartObj.svgRenderer.ctx.restore();
                                }
                                else
                                    series.drawDataLabel(options, pointIndex, point, point1.X, point1.Y, i, params);
                            }
                        }
                    }
                    else {
                        if (isCanvas && chartObj.model.AreaType == "cartesianaxes") {
                            chartObj.svgRenderer.ctx.save();
                            chartObj.svgRenderer.ctx.beginPath();
                            if (!chartObj.model.requireInvertedAxes) // checked for bar and stackingbar
                                chartObj.svgRenderer.ctx.rect(options.xAxis.x, options.yAxis.y, options.xAxis.width, options.yAxis.height);
                            else
                                chartObj.svgRenderer.ctx.rect(options.yAxis.x, options.xAxis.y, options.yAxis.width, options.xAxis.height);
                            chartObj.svgRenderer.ctx.clip();
                            //Check regions for column type, bar type and waterfall series
                            if (chartObj.model.chartRegions[chartObj.model.regionCount] || (type.indexOf('column') == -1 && type.indexOf('bar') == -1 && type.indexOf('waterfall') == -1)) {
                                if (type.toLowerCase() == "boxandwhisker") {
                                    for (var box = 0; box < point1.length; box++) {
                                        point.y = point.boxPlotLocation[box].YValues;
                                        series.drawDataLabel(options, pointIndex, point, point1[box].X, point1[box].Y, chartObj.model.regionCount, params, point1[box].outlier);
                                    }
                                }
                                else
                                    series.drawDataLabel(options, pointIndex, point, point1.X, point1.Y, chartObj.model.regionCount, params);
                                if (type == "rangecolumn" || type == "rangearea" || type == "splinerangearea") {
                                    point.y = point.low;
                                    series.drawDataLabel(options, pointIndex, point, point1.X, point1.Y, chartObj.model.regionCount, params);
                                    point.y = point.high;
                                }
                            }
                            chartObj.svgRenderer.ctx.restore();
                        }
                        else {
                            if (isCanvas && isPolar) {
                                chartObj.svgRenderer.ctx.save();
                                chartObj.svgRenderer.ctx.beginPath();
                                chartObj.svgRenderer.ctx.arc(chartObj.model.centerX, chartObj.model.centerY, chartObj.model.Radius, 0, 2 * Math.PI, false);
                                chartObj.svgRenderer.ctx.clip();
                                point1.X -= chartObj.canvasX;
                                point1.Y -= chartObj.canvasY;
                            }
                            if ((type == "column" || type == "stackingcolumn" || type == "stackingcolumn100")) {
                                if (chartObj.model.chartRegions[chartObj.model.regionCount])
                                    series.drawDataLabel(options, pointIndex, point, point1.X, point1.Y, chartObj.model.regionCount, params);
                            }
                            else {
                                if (type.toLowerCase() == "boxandwhisker") {
                                    for (var box = 0; box < point1.length; box++) {
                                        point.y = point.boxPlotLocation[box].YValues;
                                        series.drawDataLabel(options, pointIndex, point, point1[box].X, point1[box].Y, chartObj.model.regionCount, params, point1[box].outlier);
                                    }
                                }
                                else
                                    series.drawDataLabel(options, pointIndex, point, point1.X, point1.Y, chartObj.model.regionCount, params);
                            }
                            if (type == "rangecolumn" || type == "rangearea" || type == "splinerangearea") {
                                point.y = point.low;
                                series.drawDataLabel(options, pointIndex, point, point1.X, point1.Y, chartObj.model.regionCount, params);
                                point.y = point.high;
                            }
                            if (isCanvas && isPolar)
                                chartObj.svgRenderer.ctx.restore();
                        }
                    }
                }
            });
        },

        // method to avoid collision between data labels 
        cartesianSmartLabels: function (currentSeries, points, seriesIndex) {
            // declaration
            var length = points.length;
            var count = 0;
            this.connectorFlag = false;
            this.processCount = 1;
            this.posObj = {
                top: [], rightTop: [],
                left: [], leftTop: [],
                right: [], rightTop: [],
                rightBottom: [], leftBottom: [],
                bottom: []
            };
            var markerWidth, markerHeight, i, d, c, currentPoint, location, xPosition, yPosition, 
                ele, leftValue, topValue, regionType, type;
            // loop to store marker region
            for (d = 0; d < this.model.series.length; d++) {
                markerWidth = this.model.series[d].marker.size.width;
                markerHeight = this.model.series[d].marker.size.height;
                type = this.model.series[d].type.toLowerCase();
                regionType = sf.seriesTypes[type].prototype.isRegion;
                if (this.model.series[d].visibility != "hidden" && this.model.series[d].marker.visible && !regionType) {
                    for (c = 0; c < this.model.series[d]._visiblePoints.length; c++) {
                        currentPoint = this.model.series[d]._visiblePoints[c];
                        location = currentPoint.location;
                        this.model.markerRegion[this.model.markerRegion.length] = { seriesIndex: d, xPos: location.X + this.canvasX, yPos: location.Y + this.canvasY, width: markerWidth, height: markerHeight };
                    }
                }
            }

            var currentPoint, j, padding = 10, diff;
            var areaBounds = this.model.m_AreaBounds;
            var width, height, xPos, yPos;
            for (j = 0; j < length; j++) {   // to reposition the partially visible data labels
                currentPoint = points[j];
                currentPoint.hide = false;
                xPos = currentPoint.xPos; yPos = currentPoint.yPos;
                width = currentPoint.width; height = currentPoint.height;
                if (xPos - width / 2 < 0 && xPos > -width / 2) {
                    diff = xPos - width / 2;
                    currentPoint.textOptions.x = currentPoint.xPos = xPos + Math.abs(diff) + 10;
                    currentPoint.newConnectorFlag = true;
                }
                if (xPos + width / 2 > areaBounds.Width && xPos + width / 2 < areaBounds.Width + width / 2) {
                    diff = xPos - width / 2;
                    currentPoint.textOptions.x = currentPoint.xPos = areaBounds.Width - width / 2 - 10;
                    currentPoint.newConnectorFlag = true;
                }
                if (yPos + width / 2 > areaBounds.Height && yPos + height / 2 < areaBounds.Height + height / 2) {
                    diff = yPos + height / 2 - areaBounds.Height;
                    currentPoint.yPos = yPos - diff - 10;
                    currentPoint.textOptions.y = currentPoint.yPos + 5;
                    currentPoint.newConnectorFlag = true;
                }
                if (yPos - height / 2 < 0 && yPos > -height / 2) {
                    diff = yPos - height / 2;
                    currentPoint.yPos = currentPoint.yPos + Math.abs(diff) + 10;
                    currentPoint.textOptions.y = currentPoint.yPos + 5;
                    currentPoint.newConnectorFlag = true;
                }
            }

            // loop to compare the points
            for (i = 0; i < length; i++) {
                if (!sf.util.isNullOrUndefined(points[i].yPos))
                    this.model.allPoints[this.model.allPoints.length] = points[i];
                else
                    continue;
                this.connectorFlag = false;
                this.compareDataLabels(i, points, count, this.processCount);
                currentPoint = points[i];
                currentPoint.connectorFlag = this.connectorFlag; // flag to draw connector lines
                if (points[i].dataLabeltemplate) {    // for repositioning data label template
                    ele = $("#" + points[i].id);
                    leftValue = points[i].xPos;
                    topValue = !this.model.enableCanvasRendering ? points[i].yPos : points[i].yPos + this.model.m_AreaBounds.Y;
                    ele.css("left", leftValue).css("top", topValue);
                    if (this.model.AreaType == "cartesianaxes") {   // to avoid template rendering outside area bounds
                        areaBounds = this.model.m_AreaBounds;
                        xPosition = areaBounds.X + (this.model.requireInvertedAxes ? currentSeries.yAxis.plotOffset : currentSeries.xAxis.plotOffset);
                        yPosition = currentSeries.yAxis.y;
                        width = points[i].width;
                        height = points[i].height;
                        if ((leftValue > xPosition + areaBounds.Width || leftValue + width < xPosition || topValue + height < yPosition || topValue + height > areaBounds.Y + areaBounds.Height) ||
                            (this.zoomed && (leftValue < xPosition || topValue < yPosition || leftValue > xPosition + areaBounds.Width || topValue > yPosition + areaBounds.Height)))
                            ele.remove();
                    }
                }
                // to store data label position for furture processing
                this.storeDataLabelPositions(currentPoint);

            }
        },

        storeDataLabelPositions: function (currentPoint) {
            var position = currentPoint.position;
            var posObj = this.posObj;
            switch (position) {
                case "top":
                    posObj.top[this.processCount - 1] = currentPoint;
                    this.processCount = 1;
                    break;
                case "rightTop":
                    posObj.rightTop[this.processCount - 1] = currentPoint;
                    this.processCount = 1;
                    break;
                case "right":
                    posObj.right[this.processCount - 1] = currentPoint;
                    this.processCount = 1;
                    break;
                case "rightBottom":
                    posObj.rightBottom[this.processCount - 1] = currentPoint;
                    this.processCount = 1;
                    break
                case "bottom":
                    posObj.bottom[this.processCount - 1] = currentPoint;
                    this.processCount = 1;
                    break;
                case "left":
                    posObj.left[this.processCount - 1] = currentPoint;
                    this.processCount = 1;
                    break;
                case "leftBottom":
                    posObj.leftBottom[this.processCount - 1] = currentPoint;
                    this.processCount = 1;
                    break;
                case "leftTop":
                    posObj.leftTop[this.processCount - 1] = currentPoint;
                    break;
            }
        },

        // method to avoid collision between data labels  - column series type
        cartesianColumnSmartLabels: function (currentSeries, points, seriesIndex) {
            var length = points.length, left, top, right, width, height, xPosition, yPosition;
            var count = 0;
            this.connectorFlag = false;
            this.processCount = 1;
            var i, currentPoint, ele;
            this.model.outsideLabels = [];
            // loop to compare the points
            for (i = 0; i < length; i++) {
                if (!sf.util.isNullOrUndefined(points[i].yPos) && !isNaN(points[i].yPos))
                    this.model.allPoints[this.model.allPoints.length] = points[i];
                else
                    continue;
                if (currentSeries._enableSmartLabels) {
                    this.connectorFlag = false;
                    this.compareColumnDataLabels(currentSeries, i, points, count, this.processCount);
                }
                currentPoint = currentSeries._visiblePoints[i];
                if (points[i].dataLabeltemplate) {
                    ele = $("#" + points[i].id);
                    ele.css("left", points[i].xPos).css("top", points[i].yPos);
                    left = points[i].xPos, top = points[i].yPos;
                    points.height = ele.outerHeight(); var areaBoundsX = this.model.m_AreaBounds.X;
                    var areaBoundsY = this.model.m_AreaBounds.Y;
                    var areaBoundsWidth = this.model.m_AreaBounds.Width;
                    var areaBoundsHeight = this.model.m_AreaBounds.Height;
                    points.width = ele.outerWidth(); width = ele.width() / 2;
                    height = ele.height();
                    var topHeight, leftWidth, rightWidth;
                    topHeight = leftWidth = rightWidth = 0;
                    var bottomHeight = 0, areaBound = this.model.m_AreaBounds;
                    xPosition = areaBound.X + (this.model.requireInvertedAxes ? currentSeries.yAxis.plotOffset : currentSeries.xAxis.plotOffset);
                    yPosition = currentSeries.yAxis.y; right = left - width;
                    if (currentSeries.marker.dataLabel.showEdgeLabels) {
                        if ((left > xPosition + areaBound.Width || top + height > areaBound.Y + areaBound.Height) || ((left < xPosition || top < yPosition || left > xPosition + areaBound.Width || top > yPosition + areaBound.Height || right > areaBound.Width + areaBound.X))) {
                            width = ele.outerWidth();
                            if (left < areaBoundsX) {
                                leftWidth = areaBoundsX - left;
                            }
                            if (areaBoundsHeight + areaBoundsY < top + height) {
                                var excessHeight = (top + height) - (areaBoundsHeight + areaBoundsY);
                                bottomHeight = height - excessHeight;
                            }
                            if (top < areaBoundsY) {
                                topHeight = areaBoundsY - top;
                            }
                            if (areaBoundsWidth + areaBoundsX < left + width) {
                                var excessWidth = (left + width) - (areaBoundsWidth + areaBoundsX);
                                rightWidth = width - excessWidth;
                            }
                            rightWidth = (rightWidth == 0) ? width : rightWidth;
                            bottomHeight = (bottomHeight == 0) ? height : bottomHeight;
                            document.getElementById(ele[0].id).style.clip = "rect(" + topHeight + "px," +
                                rightWidth + "px," +
                                bottomHeight + "px," +
                                leftWidth + "px)";
                        }
                    }
                }
            }
        },


        compareColumnDataLabels: function (currentSeries, i, points, count, processCount) {
            var length = this.model.allPoints.length - 1, areaBounds = this.model.m_AreaBounds, isOutside, collide, dataLabel, textPosition, pointColor, a, l;
            var prevLabel, currentLabel, padding, enableContrastColor = currentSeries.marker.dataLabel.enableContrastColor,
                contrastColorRegion = [];
            var type = currentSeries.type.toLowerCase();
            var seriesType = new sf.seriesTypes[currentSeries.type.toLowerCase()](); this.firstPoints = [];
            for (var j = 0; j < length; j++) {
                prevLabel = this.model.allPoints[j];
                currentLabel = this.model.allPoints[this.model.allPoints.length - 1];
                this.currentCollideLabel = prevLabel;
                padding = 5;
				dataLabel = currentSeries.marker.dataLabel,
				textPosition = dataLabel.textPosition.toLowerCase(),
				rotation = dataLabel.angle,
				chartObj = this,
                collide = this.isCollide(prevLabel, currentLabel, null, null, chartObj, rotation);
                
                    
                if (collide.state) {
                    // for vertical orientation series types
                    if (type == "column" || type == "stackingcolumn" || type == "rangecolumn" || type == "waterfall") {
                        if (dataLabel.showEdgeLabels)
                            currentLabel.textOptions.y = currentLabel.yPos = currentLabel.yPos + collide.height + padding;
                        else {
                            if (textPosition == "top" || textPosition == "middle")
                                currentLabel.textOptions.y = currentLabel.yPos = currentLabel.yPos + collide.height + padding;
                            else
                                currentLabel.textOptions.y = currentLabel.yPos = currentLabel.yPos - collide.height - padding;
                        }
                        currentLabel.textOptions.y = currentLabel.textOptions.y + padding + currentLabel.margin.top / 2 - currentLabel.margin.bottom / 2;
						if(currentLabel.textOptions.y > areaBounds.Height){
							currentLabel.hide = true;
							break;
						}
							
                    } else {
                        // for horizontal orientation series types
                        if (textPosition == "top" || textPosition == "middle")
                            currentLabel.textOptions.x = currentLabel.xPos = prevLabel.xPos - prevLabel.width / 2 - currentLabel.width / 2 - padding;
                        else
                            currentLabel.textOptions.x = currentLabel.xPos = prevLabel.xPos + prevLabel.width / 2 + currentLabel.width / 2 + padding;
                    }
                    this.compareColumnDataLabels(currentSeries, i, points, count, this.processCount);  // to call recursive
                    isOutside = this.checkOutsideLabels(this.model, currentLabel, areaBounds);
                    for (a = 0; a < this.model.allPoints.length; a++) {
                        if (a == 0)
                            this.firstPoints.push(this.model.allPoints[0])
                        else {
                            if (this.firstPoints[this.firstPoints.length - 1].x != this.model.allPoints[a].x)
                                this.firstPoints.push(this.model.allPoints[a]);
                        }
                    }
                    if (isOutside || this.zoomed) {
                        for (l = 0; l <= this.model.allPoints.length - 1; l++) {
                            this._positionOutsideLabels(currentLabel, this.model.allPoints, l, type);
                        }
                        this.model.outsideLabels.push(currentLabel);

                    }
                    if (enableContrastColor && (type.indexOf("stacking") > -1)) {
                        var region = this.model.chartRegions;
                        for (a = 0; a < this.model.chartRegions.length; a++) {
                            if (region[a].Region.PointIndex == i)
                                collide = this.isCollide(region[a], currentLabel, 0, enableContrastColor, this);
                            if (collide.state)
                                contrastColorRegion.push(region[a]);
                        }
                        if (contrastColorRegion.length > 5)
                            break;
                        else if (contrastColorRegion.length >= 1) {
                            pointColor = jQuery.type(this.model.seriesColors[contrastColorRegion[0].SeriesIndex]) == "array" ?
                                this.model.seriesColors[contrastColorRegion[0].SeriesIndex][0].color : this.model.seriesColors[contrastColorRegion[0].SeriesIndex];
                            currentLabel.textOptions.fill = seriesType._applySaturation(this, pointColor);
                        }
                    }
                }
            }
        },

        //to reposition the outside labels in column type series 

        _positionOutsideLabels: function (currentLabel, points, k, type) {

            var prevLabel = points[k];
            var padding = 5;
            if (k == 0) {
				var collide = this.isCollide(prevLabel, currentLabel);			
                if (type && (type == "column" || type == "stackingcolumn" || type == "rangecolumn" || type == "waterfall")) {
                    if (this.model.outsideLabels.length > 0 && currentLabel.x == this.model.outsideLabels[this.model.outsideLabels.length - 1].x)
                        currentLabel.textOptions.y = currentLabel.yPos = this.model.outsideLabels[this.model.outsideLabels.length - 1].yPos - collide.height;
                    else {
                        for (k = 0; k < this.firstPoints.length; k++) {
                            if (currentLabel.x == this.firstPoints[k].x && collide.state)
                                currentLabel.textOptions.y = currentLabel.yPos = this.firstPoints[k].yPos - collide.height;
							else if(points.length > 1 && k < (points.length - 1))
								currentLabel.textOptions.y = currentLabel.yPos = points[k+1].yPos;
                        }
                    }
                    currentLabel.textOptions.y = currentLabel.textOptions.y + padding + currentLabel.margin.top / 2 - currentLabel.margin.bottom / 2;
                }
                else
                    currentLabel.textOptions.x = currentLabel.xPos = this.model.outsideLabels.length > 0 ? this.model.outsideLabels[this.model.outsideLabels.length - 1].xPos : points[0].xPos + prevLabel.width / 2 + currentLabel.width / 2 + padding;
            }
            var collide = this.isCollide(prevLabel, currentLabel);
            if (collide.state) {
                if (type == "column" || type == "stackingcolumn" || type == "rangecolumn" || type == "waterfall") {
                    currentLabel.textOptions.y = currentLabel.yPos = currentLabel.yPos - collide.height - padding;
                    currentLabel.textOptions.y = currentLabel.textOptions.y + padding + currentLabel.margin.top / 2 - currentLabel.margin.bottom / 2;
                }
                else
                    currentLabel.textOptions.x = currentLabel.xPos = currentLabel.xPos + prevLabel.width / 2 + currentLabel.width / 2 + padding;
            }

        },

        // method to comapare data labels and place without collision
        compareDataLabels: function (i, points, count, processCount) {
            var length = this.model.allPoints.length, areaBounds = this.model.m_AreaBounds, isOutside;
            var j, padding, prevLabel, currentLabel, collide, checkCollide, type, isColumn;
            var posObj = this.posObj; this.breakLoop = false;
            for (j = 0; j < length; j++) {
                type = this.model.series[this.model.allPoints[j].seriesIndex].type.toLowerCase();
                prevLabel = this.model.allPoints[j];
                currentLabel = this.model.allPoints[length - 1];
                this.currentCollideLabel = prevLabel;
                padding = 10;
                collide = this.isCollide(prevLabel, currentLabel, j);
                if (collide.state || collide.marker) {
                    this.connectorFlag = true;
                    switch (count) {
                        case 0:                        // top
                            if (this.processCount > 1) this.resetValues(currentLabel);
                            if (!collide.marker) {
                                if (!sf.util.isNullOrUndefined(this.prevLabel)) {
                                    checkCollide = this.isCollide(this.prevLabel, currentLabel);
                                    if (!checkCollide.state) { this.prevLabel = prevLabel; this.processCount = 1; };
                                } else {
                                    this.prevLabel = prevLabel;
                                    this.processCount = 1;
                                }
                            }
                            else {
                                this.prevLabel = collide.markerRegion;
                                this.processCount = 1;
                            }
                            // right
                            this.resetValues(currentLabel);
                            if (processCount > 1 && posObj.right[this.processCount - 2]) {
                                prevLabel = posObj.right[this.processCount - 2];
                                currentLabel.textOptions.x = currentLabel.xPos = prevLabel.xPos + (prevLabel.width / 2 + currentLabel.width / 2 + padding);
                            }
                            else
                                currentLabel.textOptions.x = currentLabel.xPos = this.prevLabel.xPos + (this.prevLabel.width / 2 + currentLabel.width / 2 + padding);

                            count += 1;
                            currentLabel.position = "right";
                            if (this.breakLoop)
                                break;
                            else {
                                isOutside = this.checkOutsideLabels(this.model, currentLabel, areaBounds);
                                if (!isOutside) {
                                    this.compareDataLabels(i, points, count, this.processCount);
                                    break;
                                }
                            }
                        case 1:
                            // right bottom
                            this.resetValues(currentLabel);
                            currentLabel.textOptions.x = currentLabel.xPos = this.prevLabel.xPos + this.prevLabel.width / 2 + currentLabel.width / 2 + padding;
                            if (processCount > 1 && posObj.rightBottom[this.processCount - 2]) {
                                prevLabel = posObj.rightBottom[this.processCount - 2];
                                currentLabel.textOptions.y = currentLabel.yPos = prevLabel.yPos + this.canvasY + prevLabel.height + padding;
                            }
                            else
                                currentLabel.textOptions.y = currentLabel.yPos = currentLabel.location.Y + this.canvasY + currentLabel.height + padding / 2;
                            currentLabel.textOptions.y = currentLabel.textOptions.y + padding / 2 + currentLabel.margin.top / 2 - currentLabel.margin.bottom / 2;
                            currentLabel.position = "rightBottom";
                            count += 1;
                            if (this.breakLoop)
                                break;
                            else {
                                isOutside = this.checkOutsideLabels(this.model, currentLabel, areaBounds);
                                if (!isOutside) {
                                    this.compareDataLabels(i, points, count, this.processCount);
                                    break;
                                }
                            }
                        case 2:

                            // bottom
                            this.resetValues(currentLabel);
                            currentLabel.textOptions.y = currentLabel.yPos = currentLabel.location.Y + this.canvasY + currentLabel.height + padding / 2;
                            if (processCount > 1 && posObj.bottom[this.processCount - 2]) {
                                prevLabel = posObj.bottom[this.processCount - 2];
                                currentLabel.textOptions.y = currentLabel.yPos = prevLabel.yPos + currentLabel.height + padding;
                            }
                            else
                                currentLabel.textOptions.y = currentLabel.yPos = currentLabel.location.Y + this.canvasY + currentLabel.height + padding / 2;
                            currentLabel.textOptions.y = currentLabel.textOptions.y + padding / 2 + currentLabel.margin.top / 2 - currentLabel.margin.bottom / 2;
                            currentLabel.position = "bottom";
                            count += 1;
                            if (this.breakLoop)
                                break;
                            else {
                                isOutside = this.checkOutsideLabels(this.model, currentLabel, areaBounds);
                                if (!isOutside) {
                                    this.compareDataLabels(i, points, count, this.processCount);
                                    break;
                                }
                            }
                        case 3:
                            // left bottom
                            this.resetValues(currentLabel);
                            currentLabel.textOptions.x = currentLabel.xPos = this.prevLabel.xPos - this.prevLabel.width / 2 - currentLabel.width / 2 - padding;
                            if (processCount > 1 && posObj.leftBottom[this.processCount - 2]) {
                                prevLabel = posObj.leftBottom[this.processCount - 2];
                                currentLabel.textOptions.y = currentLabel.yPos = prevLabel.yPos + this.canvasY + prevLabel.height + padding;
                            }
                            else
                                currentLabel.textOptions.y = currentLabel.yPos = currentLabel.location.Y + this.canvasY + currentLabel.height + padding / 2;
                            currentLabel.textOptions.y = currentLabel.textOptions.y + padding / 2 + currentLabel.margin.top / 2 - currentLabel.margin.bottom / 2;
                            currentLabel.position = "leftBottom";
                            count += 1;
                            if (this.breakLoop)
                                break;
                            else {
                                isOutside = this.checkOutsideLabels(this.model, currentLabel, areaBounds);
                                if (!isOutside) {
                                    this.compareDataLabels(i, points, count, this.processCount);
                                    break;
                                }
                            }
                        case 4:
                            // left
                            this.resetValues(currentLabel);
                            if (processCount > 1 && posObj.left[this.processCount - 2]) {
                                prevLabel = posObj.left[this.processCount - 2];
                                currentLabel.textOptions.x = currentLabel.xPos = (prevLabel.xPos - prevLabel.width / 2 - currentLabel.width / 2 - padding);
                            }
                            else
                                currentLabel.textOptions.x = currentLabel.xPos = (this.prevLabel.xPos - this.prevLabel.width / 2 - currentLabel.width / 2 - padding);

                            currentLabel.position = "left";
                            count += 1;
                            if (this.breakLoop)
                                break;
                            else {
                                isOutside = this.checkOutsideLabels(this.model, currentLabel, areaBounds);
                                if (!isOutside) {
                                    this.compareDataLabels(i, points, count, this.processCount);
                                    break;
                                }
                            }
                        case 5:
                            // left top
                            this.resetValues(currentLabel);
                            currentLabel.textOptions.x = currentLabel.xPos = this.prevLabel.xPos - this.prevLabel.width / 2 - currentLabel.width / 2 - padding;
                            if (processCount > 1 && posObj.leftTop[this.processCount - 2]) {
                                prevLabel = posObj.leftTop[this.processCount - 2];
                                currentLabel.textOptions.y = currentLabel.yPos = (prevLabel.yPos) - (currentLabel.height + padding);
                            }
                            else
                                currentLabel.textOptions.y = currentLabel.yPos = this.prevLabel.yPos - currentLabel.height - padding;
                            currentLabel.textOptions.y = currentLabel.textOptions.y + padding / 2 + currentLabel.margin.top / 2 - currentLabel.margin.bottom / 2;
                            currentLabel.position = "leftTop";
                            count += 1;
                            if (this.breakLoop)
                                break;
                            else {
                                isOutside = this.checkOutsideLabels(this.model, currentLabel, areaBounds);
                                if (!isOutside) {
                                    this.compareDataLabels(i, points, count, this.processCount);
                                    break;
                                }
                            }
                        case 6:
                            //top

                            this.resetValues(currentLabel);
                            if (processCount > 1 && posObj.top[processCount - 2]) {
                                prevLabel = posObj.top[processCount - 2];
                                currentLabel.textOptions.y = currentLabel.yPos = (prevLabel.yPos) - (currentLabel.height + padding);
                            }
                            else
                                currentLabel.textOptions.y = currentLabel.yPos = (this.prevLabel.yPos) - (this.processCount * (currentLabel.height + padding));
                            currentLabel.textOptions.y = currentLabel.textOptions.y + padding / 2 + currentLabel.margin.top / 2 - currentLabel.margin.bottom / 2;
                            count += 1;
                            currentLabel.position = "top";
                            if (this.breakLoop)
                                break;
                            else {
                                isOutside = this.checkOutsideLabels(this.model, currentLabel, areaBounds);
                                if (!isOutside) {
                                    this.compareDataLabels(i, points, count, this.processCount);
                                    break;
                                }
                            }
                        case 7:
                            // right top
                            this.resetValues(currentLabel);
                            currentLabel.textOptions.x = currentLabel.xPos = this.prevLabel.xPos + this.prevLabel.width / 2 + currentLabel.width / 2 + padding;
                            if (processCount > 1 && posObj.rightTop[this.processCount - 2]) {
                                prevLabel = posObj.rightTop[this.processCount - 2];
                                currentLabel.textOptions.y = currentLabel.yPos = prevLabel.yPos - currentLabel.height - padding;
                            }
                            else
                                currentLabel.textOptions.y = currentLabel.yPos = this.prevLabel.yPos - currentLabel.height - padding;
                            currentLabel.textOptions.y = currentLabel.textOptions.y + padding / 2 + currentLabel.margin.top / 2 - currentLabel.margin.bottom / 2;
                            currentLabel.position = "rightTop";
                            count += 1;
                            if (this.breakLoop)
                                break;
                            else {
                                isOutside = this.checkOutsideLabels(this.model, currentLabel, areaBounds);
                                if (!isOutside) {
                                    this.compareDataLabels(i, points, count, this.processCount);
                                    break;
                                }
                            }
                        case 8:

                            count = 0;
                            this.processCount += 1;
                            if (i == this.processCount)
                                count = 9;
                            else {
                                isOutside = this.checkOutsideLabels(this.model, currentLabel, areaBounds);
                                if (!isOutside) {
                                    this.compareDataLabels(i, points, count, this.processCount);
                                    break;
                                }
                            }
                        case 9:
                            // to skip the labelplacement when reaching outside the chart Area
                            if (i == this.processCount || this.processCount > length) {
                                this.processCount -= 1;
                                count = count < 0 || count == 8 ? 0 : count - 1;
                                this.breakLoop = true;
                            }
                    }
                }
            }
        },

        checkOutsideLabels: function (model, currentPoint, areaBounds) {
            var isCanvas = model.enableCanvasRendering, isTemplate = currentPoint.dataLabeltemplate, height, width, currentPointXPos, currentPointYPos;
            if (model.series[currentPoint.seriesIndex].marker.dataLabel.showEdgeLabels) {
                currentPointXPos = isCanvas ? currentPoint.xPos - this.canvasX : currentPoint.xPos;
                currentPointYPos = isCanvas ? currentPoint.yPos - this.canvasY : currentPoint.yPos;
                height = isTemplate ? areaBounds.Height + areaBounds.Y : areaBounds.Height;
                width = isTemplate ? areaBounds.Width + areaBounds.X : areaBounds.width;
                if ((currentPointXPos - currentPoint.width / 2 < 0) || (currentPointXPos + currentPoint.width / 2 > width) ||
                    (currentPointYPos + currentPoint.height / 2 > height) || (currentPointYPos - currentPoint.height / 2 < 0))
                    return true;
            }
        },

        //to draw connector lines for pieofpie series
        drawPieofPieConnectors: function (size, series) {
            //if (series.connectorLine.width > 0) {
            var visibility = (series.enableAnimation && !series._animatedSeries) ? 'hidden' : 'visible';
            if (!this.model.enableCanvasRendering) {
                if (!this.gConnectorLinesGroup)
                    this.gConnectorLinesGroup = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_connectorLineGroup', 'visibility': visibility });
                else (this.gConnectorLinesGroup.childNodes.length > 0)
                $(this.gConnectorLinesGroup.childNodes).remove();
            }
            var radius = [], startX = [], startY = [], loc = [],
                chartStartAngle = -.5 * Math.PI, coefficient, pieCollections;
            for (var j = 0; j < 2; j++) {
                pieCollections = series.pieCollections[j];
                coefficient = j == 0 ? series.pieCoefficient : series.pieOfPieCoefficient;
                radius[j] = 0.25 * coefficient * Math.min(size.width, size.height);
                startX[j] = this.model.circleCenterX[j];
                startX[j] = (j == 0) ? startX[j] + this.model.pieGapWidth / 2 : startX[j] - this.model.pieGapWidth / 2;
                startY[j] = this.model.circleCenterY[j];
                if (pieCollections[0].start > 0 && pieCollections[0].end < Math.PI && j == 0) {
                    var startAngle = pieCollections[0].start + chartStartAngle,
                        endAngle = pieCollections[0].end + chartStartAngle - 0.000001;
                    var x1 = startX[j] + radius[j] * Math.cos(startAngle),
                        y1 = startY[j] + radius[j] * Math.sin(startAngle),
                        x2 = startX[j] + radius[j] * Math.cos(endAngle),
                        y2 = startY[j] + radius[j] * Math.sin(endAngle);
                }
                else {
                    x1 = startX[j] + radius[j] * Math.cos(chartStartAngle),
                        y1 = startY[j] + radius[j] * Math.sin(chartStartAngle),
                        x2 = x1,
                        y2 = y1 + radius[j] * 2;
                }
                loc.push({ X1: x1, Y1: y1, X2: x2, Y2: y2 });
            }
            var pieConnectorLines = series.connectorLine;
            for (var k = 0; k < 2; k++) {
                var lineOptions = {
                    'id': this.svgObject.id + '_connectorLine' + k,
                    'x1': k == 0 ? loc[k].X1 : loc[k - 1].X2,
                    'y1': k == 0 ? loc[k].Y1 : loc[k - 1].Y2,
                    'x2': k == 0 ? loc[k + 1].X1 : loc[k].X2,
                    'y2': k == 0 ? loc[k + 1].Y1 : loc[k].Y2,
                    'stroke': pieConnectorLines.color,
                    'stroke-width': pieConnectorLines.width,
                    'opacity': pieConnectorLines.opacity,
                    'stroke-dasharray': pieConnectorLines.dashArray
                };
                this.svgRenderer.drawLine(lineOptions, this.gConnectorLinesGroup);
            }
            this.svgRenderer.append(this.gConnectorLinesGroup, this.gSeriesEle);
        },
        // method to draw connector lines for data labels in cartesian axis
        drawConnectorLines: function (seriesIndex, index, currentPoint) {
            var bottom = false;
            var drawConnectorLine = true;
            var xPos = currentPoint.xPos;
            var yPos = currentPoint.yPos;
            var areaBounds = this.model.m_AreaBounds;
            var dataLabel = this.model.series[seriesIndex].marker.dataLabel;
            var location = currentPoint.location ? currentPoint.location : currentPoint.symbolLocation;
            if (location.Y > currentPoint.textOptions.y)
                var endY = (currentPoint.textOptions.y);                         // top
            else {
                bottom = true
                endY = (currentPoint.textOptions.y - currentPoint.height / 2);  // bottom
            }
            if (currentPoint.dataLabeltemplate) {                               // for template
                endY = currentPoint.yPos - this.model.m_AreaBounds.Y + currentPoint.height;
                currentPoint.textOptions.x = currentPoint.textOptions.x - this.model.m_AreaBounds.X + currentPoint.width / 4 + this.canvasX;
            } else if ((xPos > areaBounds.Width || (xPos + currentPoint.width) < 0 ||
                yPos - currentPoint.height > areaBounds.Height || yPos + currentPoint.height < 0) && !dataLabel.showEdgeLabels)
                drawConnectorLine = false;
            if (drawConnectorLine) {
                var connectorDirection = "M" + " " + (location.X + this.canvasX) + " " + (location.Y + this.canvasY) + " " + "L" + " " + (currentPoint.textOptions.x) + " " + (endY);
                var connectorLineValues = this.model.series[seriesIndex].marker.dataLabel.connectorLine;
                var stroke = !sf.util.isNullOrUndefined(connectorLineValues.color) ? connectorLineValues.color : this.model.series[seriesIndex].fill;
                var connectorOptions = {
                    'id': this.svgObject.id + "_dataLabelConnectorLine_series" + seriesIndex + "_" + index,
                    'stroke': stroke,
                    'stroke-width': connectorLineValues.width,
                    'd': connectorDirection
                };
                this.model.series[seriesIndex].connectorLines = true;
                this.svgRenderer.drawPath(connectorOptions, this.gConnectorEle[seriesIndex]);
            }
        },

        // to reset the data label values back 
        resetValues: function (currentPoint) {
            currentPoint.textOptions.y = currentPoint.dataLabel.textY;
            currentPoint.yPos = currentPoint.dataLabel.y;
            currentPoint.textOptions.x = currentPoint.dataLabel.textX;
            currentPoint.xPos = currentPoint.dataLabel.x
        },

        // to detect collision
        isCollide: function (a, b, j, contrastColor, chart, angle) {
            var width = 0;
            var height = 0;
            var state = false, markerState = false, aVal, areaBounds, aBounds, rectLeft, rectRight, rectTop, rectBottom;
            if (contrastColor) {
                aVal = a.Region.Bounds,
                    areaBounds = chart.model.m_AreaBounds;
                aBounds = {
                    "X": aVal.X - areaBounds.X,
                    "Y": aVal.Y - areaBounds.Y,
                    "Width": aVal.Width,
                    "Height": aVal.Height
                };
                if (b.symbolName != "None") {
                    rectLeft = b.xPos;
                    rectRight = b.xPos + b.width;
                    rectTop = b.yPos - b.height / 2;
                    rectBottom = b.yPos + b.height / 2;
                }
                else {
                    rectLeft = b.textOptions.x - b.width / 2;
                    rectRight = b.textOptions.x + b.width / 2;
                    rectTop = b.textOptions.y - ((b.textOptions.angle == 90 || b.textOptions.angle == -90) ? b.height / 2 : b.height);
                    rectBottom = b.textOptions.y + ((b.textOptions.angle == 90 || b.textOptions.angle == -90) ? b.height / 2 : 0);
                }
                state = ((aBounds.X < rectRight) && ((aBounds.X + aBounds.Width) > rectLeft) &&
                    (aBounds.Y < rectBottom) && ((aBounds.Y + aBounds.Height) > rectTop));
            }
            else {
                var borderWidth = a.seriesIndex ? this.model.series[a.seriesIndex].marker.dataLabel.border.width : 0;
                borderWidth += b.seriesIndex ? this.model.series[b.seriesIndex].marker.dataLabel.border.width : 0;
                var series = this.model.series;
                var firstSeries = series[a.seriesIndex];
                var secondSeries = series[b.seriesIndex];
                var aXPos = a.xPos, aYPos = a.yPos, bXPos = b.xPos, bYPos = b.yPos;
                a.xPos += firstSeries.xAxis.x, a.yPos += firstSeries.yAxis.y,
                b.xPos += secondSeries.xAxis.x, b.yPos += secondSeries.yAxis.y;				
				var aHeight = a.height, aWidth = a.width, bHeight = b.height, bWidth = b.width;
				if(angle)
				{	
					var degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;
					if(degree == 90 || degree == -90)
					{ 
						aHeight = a.width; 
						aWidth = a.height; 
						bHeight = b.width; 
						bWidth = b.height;
					}
				}
                if (a != b) {					
                    state = !(                    // to compare data labels
                        ((a.yPos + aHeight) < (b.yPos)) ||
                        (a.yPos > (b.yPos + bHeight)) ||
                        ((a.xPos + aWidth / 2 + borderWidth) <= b.xPos - bWidth / 2) ||
                        (a.xPos - aWidth / 2 >= (b.xPos + bWidth / 2)));
                    if (state) {
                        height = (a.yPos + aHeight) - b.yPos;
                        width = (a.xPos + aWidth) - b.xPos;
                    }
                    a.xPos = aXPos, a.yPos = aYPos;
                }
                if (!state) {
                    for (var f = 0; f < this.model.markerRegion.length; f++) {
                        a = this.model.markerRegion[f];
                        firstSeries = series[a.seriesIndex];
                        aXPos = a.xPos, aYPos = a.yPos;
                        a.xPos += firstSeries.xAxis.x, b.yPos += firstSeries.yAxis.y;
                        markerState = !(                // to compare data label and marker
                            ((a.yPos + aHeight) < (b.yPos - bHeight / 2)) ||
                            (a.yPos > (b.yPos + bHeight)) ||
                            ((a.xPos + aWidth) < b.xPos) ||
                            (a.xPos > (b.xPos + bWidth)));
                        if (markerState)
                            break;
                    }
                }

                a.xPos = aXPos, a.yPos = aYPos;
                b.xPos = bXPos, b.yPos = bYPos;
                // to hide the partially visible data labels
            }


            return { state: state, marker: markerState, markerRegion: a, width: width, height: height };
        },

        drawAccDisplayText: function (series, options, seriesIndex) {
            // method to draw text 
            var chartObj = this;
            var pointsLength = options._visiblePoints.length;
            chartObj.firstStartAngle = [];
            var type = options.type.toLowerCase();
            if ((type != "pyramid" && type != "funnel" && type != "pieofpie") && (options.leftsidePoints.length > 0 || options.rightsidePoints.length > 0)) {
                var rightsidePointsLength = options.rightsidePoints.length;
                var leftsidePointsLength = options.leftsidePoints.length;

                for (var i = 0; i < rightsidePointsLength; i++) {
                    options.rightsidePoints[i].index = i;
                    series.drawDataLabelAcc(chartObj, options, options.rightsidePoints[i].pointIndex, options.rightsidePoints[i], seriesIndex)
                }
                for (var j = leftsidePointsLength - 1; j >= 0; j--) {
                    options.leftsidePoints[j].index = j;
                    series.drawDataLabelAcc(chartObj, options, options.leftsidePoints[j].pointIndex, options.leftsidePoints[j], seriesIndex)
                }
            }
            else {
                for (var i = 0; i < pointsLength; i++) {
                    options._visiblePoints[i].index = i;
                    var pointIndex = type == "pieofpie" ? options._visiblePoints[i].actualIndex : i;
					if (options._visiblePoints[i].start != options._visiblePoints[i].startAngle)
                        options._visiblePoints[i].startAngle = options._visiblePoints[i].start;
                    if (isNaN(options._visiblePoints[i].startAngle) && options.type.toLowerCase() == "pie" && options.type.toLowerCase == "pieofpie") continue;
                    series.drawDataLabelAcc(chartObj, options, pointIndex, options._visiblePoints[i], seriesIndex, options.collectionIndex)
                }
            }
            if (options.type.toLowerCase() == "pyramid" || options.type.toLowerCase() == "funnel") {
                this.svgRenderer.append(this.gConnectorEle, this.gSeriesEle);

                this.svgRenderer.append(this.gSymbolGroupEle, this.gSeriesEle);

                this.svgRenderer.append(this.gDataLabelEle, this.gSeriesEle);

                this.svgRenderer.append(this.gSeriesTextEle, this.gSeriesEle);


                this.svgRenderer.append(this.gSeriesEle, this.svgObject);

                if (!this.vmlRendering)
                    this.svgRenderer.append(this.svgObject, this.element)

            }
        },

        _processOData: function (series) {
            var chart = this, type = series.type.toLowerCase();
            var queryPromise = series.dataSource.executeQuery(series.query);
            queryPromise.done(function (e) {
                chart._processJsonData(e.result, series);
                series.visibility = 'visible';
                $(chart.svgObject).empty();
                $(chart.legendSvgContainer).empty();
                if (chart.model.enableCanvasRendering) {
                    chart.svgRenderer.ctx.clearRect(0, 0, chart.svgObject.width, chart.svgObject.height);
                    $("#canvas_trackSymbol").remove();
                }

                var redrawChart = true;
                var dec = (type != "pie" || type != "doughnut") ? 0 : chart.model.series.length - 1
                for (var i = dec, cond; cond = (type != "pie" || type != "doughnut") ? i < chart.model.series.length : i >= 0; (type != "pie" || type != "doughnut") ? i++ : i--) {
                    if (chart.model.series[i].dataSource) {
                        if (chart.model.series[i].visibility == 'hidden') {
                            redrawChart = false;
                            break;
                        }
                    }
                }
                if (redrawChart) {
                    chart.draw();
                }
            });
            queryPromise.fail(function (e) {
                series.visibility = 'visible';
                $(chart.svgObject).empty();
                $(chart.legendSvgContainer).empty();
                var redrawChart = true;
                for (var i = 0; i < chart.model.series.length; i++)
                    if (chart.model.series[i].dataSource) {
                        if (chart.model.series[i].visibility == 'hidden') {
                            redrawChart = false;
                            break;
                        }
                    }
                if (redrawChart) {
                    chart.draw();
                }
            });
        },
        _findDatatype: function (series, chart) {
            var isDate;
            if (series.xAxisName == null)
                isDate = chart.model.primaryXAxis.valueType != null && chart.model.primaryXAxis.valueType.toLowerCase() == "datetime" ? true : false;
            else {
                for (var i = 0; i < chart.model._axes.length; i++) {
                    var axis = chart.model._axes[i];
                    if (axis.name == series.xAxisName && axis.valueType != null && axis.valueType.toLowerCase() == "datetime")
                        isDate = true;
                    else
                        isDate = false;
                }
            }
            return isDate;
        },
        _processJsonData: function (jsonObj, series) {

            var xName = series.xName,
                yNames = series.yName,
                colorMap = series.pointColorMappingName,
                textMap = series.marker && series.marker.dataLabel && series.marker.dataLabel.textMappingName,
                type = series.type.toLowerCase(),
                jsonLength = !!document.createElementNS && !!document.createElementNS('http://www.w3.org/2000/svg', "svg") ? jsonObj.length : jsonObj[jsonObj.length - 1] === undefined ? jsonObj.length - 1 : jsonObj.length,
                yLength = yNames.length,
                isBubble = type == 'bubble',
                checkString = jsonObj.length && (!!jsonObj[0][xName].indexOf || (!series._hiloTypes ? !!(jsonObj[0][yNames] == 0 ? 0 : jsonObj[0][yNames] || jsonObj[0][series.size] || 0).indexOf : (jsonObj[0][series.high] && jsonObj[0][series.high].indexOf))),
                isDate = checkString && jsonObj[0][xName].indexOf && (jsonObj[0][xName].indexOf("/Date(") != -1),
                point, m = 0, x, y,
                hiddenIndex = this.model._hiddenPointIndex;
			var points = $.extend(true, [], series.points);
            series.points = new Array(jsonLength);

            if (!checkString) {
                while (m < jsonLength) {
                    x = jsonObj[m][xName];
                    if (!series._hiloTypes)
                        y = typeof jsonObj[m][yNames] == "string" ? parseFloat(jsonObj[m][yNames]) : jsonObj[m][yNames];
                    series.points[m++] = { x: x, xValue: x, y: y, YValues: [y] };
                }
            }
            else if (type != "boxandwhisker")
                this._processStringData(jsonObj, series, xName, yNames, isDate, jsonLength, points);

            //Using separate function for boxandwhisker series
            if (type == "boxandwhisker")
                this._processBoxandWhiskerData(jsonObj, series, xName, yNames, isDate);

            //Using separate functions for bubble and hilo type series improves the performance a lot
            (isBubble || colorMap.length > 0 || textMap.length > 0 || hiddenIndex.length > 0) && this._processBubbleSize(jsonObj, series, checkString, colorMap, textMap, hiddenIndex, isBubble, jsonLength);

            (series._hiloTypes) && this._processHiLoValues(jsonObj, series, checkString, type, jsonLength);
            return 0;
        },

        _processBoxandWhiskerData: function (jsonObj, series, xName, yName, isDate) {
            var m = 0, jsonLength = jsonObj.length, x, y,
                isDateString = jsonObj[0][xName].indexOf && jsonObj[0][xName].indexOf("/Date(") != -1;
            while (m < jsonLength) {
                x = jsonObj[m][xName];
                isDate && (x = new Date(isDateString ? parseInt(x.substr(6)) : x));
                y = jsonObj[m][yName];
                series.points[m++] = { x: x, xValue: x, y: y, YValues: [y] };
            }
        },

        _processStringData: function (jsonObj, series, xName, yName, isDate, jsonLength, points) {
            var m = 0, x, y,
                isDateString = jsonObj[0][xName].indexOf && jsonObj[0][xName].indexOf("/Date(") != -1;
			if(points.length && points.length == jsonLength && series.dataSource instanceof sf.DataManager){					
				while (m < points.length) {
					x = points[m].x;
					y = points[m].y;
					series.points[m++] = { x: x, xValue: x, y: y, YValues: [y] };
					if(!sf.isNullOrUndefined(points[m-1].fill))
						series.points[m-1].fill = points[m-1].fill;
				}
			}
            else {
				while (m < jsonLength) {
					x = jsonObj[m][xName];
					isDate && !(x instanceof Date) && (x = new Date(isDateString ? parseInt(x.substr(6)) : x));
					y = parseFloat(jsonObj[m][yName]);
					series.points[m++] = { x: x, xValue: x, y: y, YValues: [y] };
				}
			}
        },

        _processBubbleSize: function (jsonObj, series, checkString, colorMap, textMap, hiddenIndex, isBubble, jsonLength) {
            var point, m = 0;
            for (; m < jsonLength; m++) {
                point = series.points[m];
                point.YValues[0] = checkString ? parseFloat(jsonObj[m][series.yName]) : jsonObj[m][series.yName];
                isBubble && (point.size = point.YValues[1] = checkString ? parseFloat(jsonObj[m][series.size]) : jsonObj[m][series.size]);
                (colorMap.length > 0) && (point.fill = jsonObj[m][colorMap]);
                (textMap.length > 0) && (point.text = jsonObj[m][textMap]);
                (hiddenIndex.length > 0 && m == hiddenIndex[m]) && (point.visibility = "hidden");
            }
        },
        _processHiLoValues: function (jsonObj, series, checkString, type, jsonLength) {
            var point, obj, m = 0;
            for (; m < jsonLength; m++) {
                point = series.points[m];
                obj = jsonObj[m];
                point.y = point.high = point.YValues[0] = checkString ? (this.tryParseFloat(obj[series.high])) : obj[series.high];
                point.low = point.YValues[1] = checkString ? this.tryParseFloat(obj[series.low]) : obj[series.low];
                if (type != 'hilo' && type != 'rangecolumn' && type != 'waterfall') {
                    point.open = point.YValues[2] = checkString ? this.tryParseFloat(obj[series.open]) : obj[series.open];
                    point.close = point.YValues[3] = checkString ? this.tryParseFloat(obj[series.close]) : obj[series.close];
                    if (series.volume)
                        point.volume = point.YValues[4] = checkString ? this.tryParseFloat(obj[series.volume]) : obj[series.volume];
                }
            }
        },
        tryParseFloat: function (str) {
            return (str && str.length > 0) ? parseFloat(str) : str;
        },
        bindTo: function (excludeDataUpdate) {
            var model = this.model,
                seriesCollection = model.series;
            $("#" + this.svgObject.id + '_CrosshairVertical').remove();
            $("#" + this.svgObject.id + '_CrosshairHorizontal').remove();
            if ($.finish) {
                $(".ejTooltip" + this._id).finish();
                $(".tooltipDiv" + this._id).finish();
            }
            else {
                $(".ejTooltip" + this._id).stop(true, true);
                $(".tooltipDiv" + this._id).stop(true, true);
            }
            $(document).find('[id*="_TrackToolTip"]').remove();// fixed for mobile issue
            $('#template_group_' + this._id).remove();
			//Create id to chart elements, if the chart element don't have id
			if(this.isChartElemId)
				this.createElementsId();


            model.primaryXAxis._valueType = null;
            model.primaryXAxis.position = null;
            model.primaryYAxis._valueType = null;
            model.primaryYAxis.position = null;
            model.requireInvertedAxes = false;
            model._hiddenPointIndex = [];
            var seriesLength = seriesCollection.length,
                axesLength = model.axes.length,
                axis;
            for (var i = 0; i < axesLength; i++) {
                axis = model.axes[i];
                axis._valueType = null;
                axis.position = null;
            }
            if (model._axes) {
                axesLength = model._axes.length;
                for (var j = 0; j < axesLength; j++) {
                    axis = model._axes[j];
                    axis._valueType = null;
                    axis.position = null;
                    axis.zoomFactor = (axis._pointsLength && axis._pointsLength != axis.scrollbarSettings.pointsLength) ? 1 : axis.zoomFactor;
                }
            }
            for (var i = 0; i < seriesLength; i++) {
                var series = seriesCollection[i];
                var mappingYNames = ["y", "high", "low", "open", "close"];
                if (!(sf.isNullOrUndefined(series.points))) {
                    for (var j = 0; j < series.points.length; j++) {
                        mappingYNames.map(function (name, index) {
                            var value = series.points[j][name];
                            if (!sf.isNullOrUndefined(value)) series.points[j][name] = (typeof (value) == "string") ? parseFloat(value) : value;
                        });
                    }
                }
                series.position = null;
                if (series.fill && this.model.seriesColors && series.fill != this.model.seriesColors[i])
                    seriesCollection[i].isFill = true;
            }
            if (model.AreaType && model.AreaType == "none") {
                var series = seriesCollection[0];
                var point;
                for (var i = 0; series.points && i < series.points.length; i++) {
                    point = series.points[i]
                    //point._visibility = point._visibility ? point._visibility : null;
                    if (point._visibility == "hidden" && model.AreaType == "none" && seriesCollection.length == 1)
                        this.model._hiddenPointIndex[i] = i;
                    point.isFill = (point.fill && model.pointColors && point.fill != model.pointColors[i]) || point.isFill;
                    point.fill = !point.isFill ? null : point.fill;
                }
            }
            if (model.enable3D)
                sf.Ej3DRender.transform = null;
            if (seriesCollection) {
                //var series = seriesCollection;
                this.setModelProperties(excludeDataUpdate);
                if (!excludeDataUpdate) {
                    for (var i = 0; i < seriesCollection.length; i++) {
                        var series = seriesCollection[i];
                        if (series.visibility == null || series.visibility == undefined) {
                            series.visibility = 'visible';
                        }
                        if (series.type) series._hiloTypes = series.type.toLowerCase() == "polar" || series.type.toLowerCase() == "radar" ? sf.seriesTypes[series.drawType.toLowerCase()].prototype.hiloTypes : sf.seriesTypes[series.type.toLowerCase()].prototype.hiloTypes;
                        if (!(series.points))
                            series.points = [];
                        if (series.dataSource) {
                            if (series.dataSource instanceof sf.DataManager) {
                                series.visibility = 'hidden';
                                if (sf.isNullOrUndefined(series.query) || !(series.query instanceof sf.Query))
                                    series.query = sf.Query();
                                this._processOData(series);
                            } else if (series.dataSource.length > 0) {
                                if (typeof series.dataSource === 'string' || series.dataSource.toLowerCase)
                                    series.dataSource = JSON.parse(series.dataSource.replace(/'''/g, "\""));
                                this._processJsonData(series.dataSource, series);
                            }
                        }
                    }
                }
                if ($(this.svgObject).width() > 0)
                    this.draw(excludeDataUpdate);
            }



        },

        _createChartId: function () {
            var exsistId = false, count = 0;
            var className = $(this.element)[0].className.split(" ")[0];
            do {
                if (!$("#" + className + "_" + count).length) {
					$(this).attr("_id", className + "_" + count);
					$(this.element).attr('id', className + "_" + count);
					exsistId = true;
                }
                count++;
            } while (!exsistId);
			this.isChartElemId = true;
        },
		
		createElementsId: function () {
			this.legendContainer.attr('id', "legend_" + this._id);
			this.scrollerContainer.attr('id', "legend_Scroller" + this._id);
			this.chartContainer.attr('id', "chartContainer_" + this._id);
			this.axisScroll.attr('id', "axisScrollbar_" + this._id);
			$(this.svgObject).attr('id', this._id + (this.model.enableCanvasRendering ? '_canvas' : '_svg'));
		},

        calculateHeight: function (chart) {              // height calculation
            var $svgObj = $(chart.svgObject);
            var chartHeight = chart.model.size.height;
            var containerHeight = $(chart.element).height();
            var height = (containerHeight / 100) * parseInt(chartHeight);
            $svgObj.height(height);
            return height;
        },

        calculateWidth: function (chart) {               // width calculation
            var $svgObj = $(chart.svgObject);
            var chartWidth = chart.model.size.width;
            var containerWidth = $(chart.element).width();
            var width = (containerWidth / 100) * parseInt(chartWidth);
            $svgObj.width(width);
            return width;
        },

        // store the element class logic perform here
        selectedStyle: function (chart) {
            var selected = $('#' + chart._id).find('[class*="Selection"]');
            var selection = [];
            for (var i = 0; i < selected.length; i++) {
                selection[i] = [];
                selection[i].id = selected[i].id;
                selection[i].className = $('#' + selection[i].id).attr('class');
            }
            if ($('[id $= Def ]').length > 0) {
                selection.pattern = $('[id $= Def ]');
            }

            return selection;
        },

        chartResize: function () {
            var chart = this;
            var $svgObj = $(chart.svgObject);
            var selection = this.selectedStyle(chart);
            this.removeMultiRect();
            this._chartResize = true;
            if (this.model.enableCanvasRendering) {
                $('[id*=' + this._id + '_Selection_' + ']').remove();
                $("#canvas_trackSymbol").remove();
                var ctx = chart.svgObject.getContext("2d");
                ctx.clearRect(0, 0, this.svgRenderer.svgObj.width, this.svgRenderer.svgObj.height);

                if (typeof chart.model.size.width == "string" && chart.model.size.width.indexOf("%") != -1) {           // to set width 
                    var width = chart.calculateWidth(chart);
                    this.svgRenderer.svgObj.width = width;
                }
                else
                    this.svgRenderer.svgObj.width = $("#" + this._id).width();

                if (typeof chart.model.size.height == "string" && chart.model.size.height.indexOf("%") != -1) {          // to set height
                    var height = chart.calculateHeight(chart);
                    this.svgRenderer.svgObj.height = height;
                }
                else
                    this.svgRenderer.svgObj.height = sf.util.isNullOrUndefined(this.model.size.height) ? "450" : parseInt($(chart.element).height());


            }
            if (this.resizeTO) clearTimeout(this.resizeTO);
            this.resizeTO = setTimeout(function () {
                if (!sf.util.isNullOrUndefined(chart.model)) {
                    if (typeof chart.model.size.width == "string" && chart.model.size.width.indexOf("%") != -1) {
                        chart.calculateWidth(chart);
                    }
                    else
                        $svgObj.width($(chart.element).width());

                    if (typeof chart.model.size.height == "string" && chart.model.size.height.indexOf("%") != -1) {
                        chart.calculateHeight(chart);
                    }
                    else
                        $svgObj.height(chart.model.size.height);
                    if ($(chart.svgObject).width() > 0) {
                        $(chart.svgObject).empty();
                        $(chart.legendSvgContainer).empty();
                        $('#template_group_' + chart._id).remove();
                        $("#annotation_group_" + chart._id).remove();       //to remove annotation from DOM on resize
                        chart.disableAnimation();
                        for (var j = 0; j < chart.model.series.length; j++)
                            chart.model.series[j].regionAdded = false;
                        chart.draw();
                        for (var i = 0; i < selection.length; i++) {
                            $('#' + selection[i].id).attr('class', selection[i].className);
                        }
                        if (selection.pattern)
                            chart.svgRenderer.append(selection.pattern, chart.svgObject);
                        if (chart.zoomed && !chart.vmlRendering)
                            chart._enableZoomingButtons();
                        chart.enableAnimation();
                    }
                }
            }, 500);

        },
        isDevice: function () {
            return (/mobile|tablet|android|kindle/i.test(navigator.userAgent.toLowerCase()));
            // comment above line temporary. Due to the below code event wont bind for tablet device
            //  return (/mobile|android|kindle/i.test(navigator.userAgent.toLowerCase()));
        },

        //To check whether the device is Windows
        isWindows: function () {
            if (!sf.getBooleanVal($('head'), 'data-sf-android') && !sf.getBooleanVal($('head'), 'data-sf-ios') && !sf.getBooleanVal($('head'), 'data-sf-ios7') && !sf.getBooleanVal($('head'), 'data-sf-flat'))
                return this._windows();
        },

        _windows: function () {
            return (/trident|windows phone/i.test(navigator.userAgent.toLowerCase())) || (sf.getBooleanVal($('head'), 'data-sf-windows', false) === true);
        },

        bindResizeEvents: function () {
            if (this.model._resizeEventRegistered)
                return 0;
            if (sf.isTouchDevice() && this._isOrientationSupported())
                this._on($(window), "orientationchange", this.chartResize);
            else
                this._on($(window), "resize", this.chartResize);
            this.model._resizeEventRegistered = true;
        },
        removeResizeEvents: function () {
            if (this.model._resizeEventRegistered) {
                if (sf.isTouchDevice() && this._isOrientationSupported())
                    this._off($(window), "orientationchange", this.chartResize);
                else
                    this._off($(window), "resize", this.chartResize);
                this.model._resizeEventRegistered = false;
            }
        },
        _isOrientationSupported: function () {
            return ("orientation" in window && "onorientationchange" in window);
        },

        _getElemCoords: function(elem) { // crossbrowser version
            var box = elem.getBoundingClientRect();                       
            var body = document.body;            
            var docEl = document.documentElement;
            var scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
            var scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;
            var clientTop = docEl.clientTop || body.clientTop || 0;
            var clientLeft = docEl.clientLeft || body.clientLeft || 0;
            var top = box.top + scrollTop - clientTop;
            var left = box.left + scrollLeft - clientLeft;
            return { top: Math.round(top), left: Math.round(left) };
        },
        _calculatePinchZoomPosition: function (e) {
            var areaBounds = $.extend(true, {}, this.model.m_AreaBounds), zoomPosition, axes = this.model._axes, axis,
                event = (e.originalEvent.touches && e.originalEvent.touches.length > 0 ? e.originalEvent.touches[0] : e.originalEvent),
                pageX = event.pageX, pageY = event.pageY, panTouch = this.previousPanTouch, pinchPan,
                orientation, offset, j = 0, length = axes.length;
			var trans = this.getScaleValues(this);
		    var areaBoundsX = areaBounds.X * trans.x,
				areaBoundsY = areaBounds.Y * trans.y,
				areaBoundsWidth = areaBounds.Width * trans.x,
				areaBoundsHeight = areaBounds.Height * trans.y;
			var chartEle = document.getElementById(this.element[0].id);
			//areaBoundsX = areaBoundsX + chartEle.offsetParent.offsetLeft;
			//areaBoundsY = areaBoundsY + chartEle.offsetParent.offsetTop;	
            var coords = this._getElemCoords(chartEle);
            areaBoundsX = areaBoundsX + coords.left;
            areaBoundsY = areaBoundsY + coords.top;					
            if (pageX > areaBoundsX  && pageX < areaBoundsX + areaBoundsWidth && pageY > areaBoundsY && pageY < areaBoundsY + areaBoundsHeight) {
                if (!panTouch)
                    panTouch = this.previousPanTouch = { pageX: pageX, pageY: pageY };

                if (sf.isTouchDevice() || this.model.zooming.enableDeferredZoom) {
                    this.oPreviousCoords = { x: this.previousPanTouch.pageX, y: this.previousPanTouch.pageY };
                    return this.chartMouseMove(e); //Deferred panning for slow devices
                }

                for (; j < length; j++) {
                    axis = axes[j];
                    orientation = axis.orientation.toLowerCase() == "horizontal";
                    offset = orientation ? ((panTouch.pageX - pageX) / axis.width * axis.zoomFactor) : ((panTouch.pageY - pageY) / axis.height * axis.zoomFactor);
                    zoomPosition = axis.zoomPosition;
                    axis.zoomPosition = this._ensureValueInMinMax(orientation ? zoomPosition + offset : zoomPosition - offset, 0, 1 - axis.zoomFactor);
                    pinchPan = pinchPan || (zoomPosition != axis.zoomPosition);
                }
                this.previousPanTouch = { pageX: pageX, pageY: pageY };
                if (pinchPan && !this.chartUpdating) {
                    this.redraw(true, pinchPan, e.target);
                    this._enableZoomingButtons();
                }
            }

        },
        _calculateTouchDistance: function (previous, current) {
            var result = [], j = 0, length = current.length;

            for (; j < length; j++) {
                if (previous[j] == null)
                    previous[j] = current[j];
                result[j] = {};
                if (j > 0) {
                    result[j].scaleX = ((previous[0].pageX != previous[1].pageX) && ((current[0].pageX - current[1].pageX) / (previous[0].pageX - previous[1].pageX)));
                    result[j].scaleY = ((previous[0].pageY != previous[1].pageY) && ((current[0].pageY - current[1].pageY) / (previous[0].pageY - previous[1].pageY)));
                    result[j].center = { x: (previous[0].pageX + current[0].pageX) / 2, y: (previous[1].pageY + current[1].pageY) / 2 };
                }
            }
            return result;
        },
        _ensureValueInMinMax: function (valueToCheck, minValue, maxValue) {
            return valueToCheck < minValue ? minValue : (valueToCheck > maxValue ? maxValue : valueToCheck);
        },
        _calculatePinchZoomFactor: function (scale, orientation, target) {
            var model = this.model, axes = model._axes, zoomedOut = true, zoomed, currentScale, origin, cumulativeScale,
                axisScale, axis, factor, zoomFactor, zoomPosition, areaBounds = $.extend(true, {}, model.m_AreaBounds),
                prevScale, scaleLimit = 10000, i = 0, length = axes.length;

            orientation = (orientation == 'x' ? 'horizontal' : (orientation == 'y' ? 'vertical' : null));
			var trans = this.getScaleValues(this);
		    var areaBoundsX = areaBounds.X * trans.x,
				areaBoundsY = areaBounds.Y * trans.y,
				areaBoundsWidth = areaBounds.Width * trans.x,
				areaBoundsHeight = areaBounds.Height * trans.y;
            if (this.previousScale != null) {
                for (; i < length; i++) {
                    if (!orientation || axes[i].orientation === orientation) {
                        axis = axes[i];
                        currentScale = axis.orientation == 'horizontal' ? scale[1].scaleX : scale[1].scaleY;
                        if (!currentScale)
                            break;
                        prevScale = axis.orientation == 'horizontal' ? this.previousScale[1].scaleX : this.previousScale[1].scaleY;
                        zoomFactor = axis.zoomFactor;
                        zoomPosition = axis.zoomPosition;
                        axisScale = this._ensureValueInMinMax(1 / axis.zoomFactor, 1, scaleLimit);
                        cumulativeScale = this._ensureValueInMinMax(axisScale + (axisScale * (currentScale - prevScale) / prevScale), 1, scaleLimit);
                        origin = (axis.orientation == 'horizontal' ? (scale[1].center.x / areaBoundsWidth) : (1 - scale[1].center.y / areaBoundsHeight));
                        axis.zoomFactor = this._ensureValueInMinMax(1 / cumulativeScale, 1 / scaleLimit, 1);
                        axis.zoomPosition = this._ensureValueInMinMax(zoomPosition + (zoomFactor - axis.zoomFactor) * origin, 0, 1 - axis.zoomFactor);
                        zoomed = zoomed || (zoomFactor != axis.zoomFactor);
                        zoomedOut = zoomedOut && (axis.zoomFactor == 1);
                    }
                }
                if (zoomed && !zoomedOut && !this.chartUpdating) {
                    this.zoomed = true;
                    this.redraw(true, true, target);
                    this._enableZoomingButtons();
                }
                else if (zoomedOut && this.zoomed && !this.chartUpdating) {
                    this.redraw(true, true, target);
                    this.zoomed = false;
                    this._removeZoomkit();
                }
            }
            this.previousScale = scale;
        },
        _addTouchPointer: function (touches, e, overwrite, j) {
            for (j = touches.length; j--;)
                if (e.pointerId == touches[j].pointerId) {
                    if (overwrite) touches[j] = e;
                    return 0;
                }
            touches.push(e);
        },
        _removeTouchPointer: function (touches, e, j) {
            for (j = touches && touches.length; j--;)
                if (e.pointerId == touches[j].pointerId) {
                    touches.splice(j, 1);
                    return 0;
                }
        },
        _copyTouches: function (touches) {
            var target = [], i = 0, length = touches.length;
            for (; i < length; i++)
                target[i] = { pageX: touches[i].pageX, pageY: touches[i].pageY };
            return target;
        },
        _initEventParams: function () {
            return { touches: [], movements: [] };
        },
        _pointerPinchStart: function (e) {
            var event = e.originalEvent, targetId, model = this.model, bounds = $.extend(true, {}, model.m_AreaBounds), eventObj, elementOffset = $(this.element).offset(),
                params = this.eventParams || (this.eventParams = this._initEventParams()),
                x = (event.pageX || event.changedTouches[0].pageX) - elementOffset.left, y = (event.pageY || event.changedTouches[0].pageY) - elementOffset.top;
				// to check transform 
			var trans = this.getScaleValues(this);
			var m_AreaBoundsX = bounds.X * trans.x,
				m_AreaBoundsY = bounds.Y * trans.y,
				m_AreaBoundsWidth = bounds.Width * trans.x,
				m_AreaBoundsHeight = bounds.Height * trans.y;
            if (this.model.selectionEnable) {
                this.cancelEvent(e);
                event.preventDefault();
            }

            if (!model.enable3D && model.AreaType == 'cartesianaxes' && event.pointerType != 'mouse' && event.pointerType != 4 && model.zooming.enable && model.zooming.enablePinching && (event.touches || event.pointerId)) {
                targetId = e.target.id;
                if (targetId.indexOf("ResetZoom") != -1)
                    this.resetZoom(e);
                else if (targetId.indexOf("panIcon") != -1)
                    this.startPan(e);
                else if (targetId.indexOf("ZoomIcon") != -1)
                    this.startZoom(e);
                else if (targetId.indexOf("ZoomOut") != -1 || targetId.indexOf("ZoomIn") != -1)
                    this.startZoomInOut(e);
                else if (x > m_AreaBoundsX && x < m_AreaBoundsX + m_AreaBoundsWidth && y > m_AreaBoundsY && y < m_AreaBoundsY + m_AreaBoundsHeight) {
                    event.touches ? (params.touches = this._copyTouches(event.touches)) : this._addTouchPointer(params.touches, { pageX: x, pageY: y, pointerId: event.pointerId });
                    if (params.touches.length < 2)
                        this.chartMouseDown(e);
                }
                else
                    this.chartMouseDown(e);
            }
            else
                this.chartMouseDown(e);
        },
        _removeInteractions: function () {
            $("[id*=_TrackSymbol]").remove();
            this._removeTrackBall();
            this._removeHighlight();
            $("#" + this.svgObject.id + "_TrackToolTip").hide();
            $("#" + this._id + "_tooltip").remove();
        },
        _pinchGestureMove: function (e) {
            var event = e.originalEvent.changedTouches[0], touches = e.originalEvent.touches, model = this.model, elementOffset = $(this.element).offset(),
                areaBounds = model.m_AreaBounds, x = event.pageX - elementOffset.left, y = event.pageY - elementOffset.top;

            this.eventParams = this.eventParams || this._initEventParams(model, event);
            if (!model.enable3D && model.AreaType == 'cartesianaxes' && event.pointerType != 'mouse' && event.pointerType != 4 && model.zooming.enable && model.zooming.enablePinching && touches) {
                if (x > areaBounds.X && x < areaBounds.X + areaBounds.Width && y > areaBounds.Y && y < areaBounds.Y + areaBounds.Height) {
                    this._removeInteractions();
                    if (touches.length > 1)
                        this._calculatePinchZoomFactor(this._calculateTouchDistance(this.eventParams.touches, touches), model.zooming.type, e.target);
                    else
	                (this.doPan || this.panning) ? this._calculatePinchZoomPosition(e) : this.chartMouseMove(e);
                }
                else
                    this.chartMouseMove(e);
            } else
                this.chartMouseMove(e);
        },
        _pointerPinchMove: function (e) {
            var areaBounds, touches, j = 0, event = e.originalEvent, elementOffset = $(this.element).offset(), x = event.pageX - elementOffset.left, y = event.pageY - elementOffset.top,
                model = this.model, params = this.eventParams || this._initEventParams(model, event), startTouches = params.touches, previous = this.previousPointerMove,
                length = startTouches.length, touches = params.movements;

			var trans = this.getScaleValues(this);
            if (previous != null && previous.pageX == event.pagex && previous.pageY == event.pageY && previous.pointerId == e.pointerId)
                return false;
            if (!model.enable3D && model.AreaType == 'cartesianaxes' && event.pointerType != 'mouse' && event.pointerType != 4 && model.zooming.enable && model.zooming.enablePinching) {
                areaBounds = $.extend(true, {}, model.m_AreaBounds);
				var m_AreaBoundsX = areaBounds.X * trans.x,
				m_AreaBoundsY = areaBounds.Y * trans.y,
				m_AreaBoundsWidth = areaBounds.Width * trans.x,
				m_AreaBoundsHeight = areaBounds.Height * trans.y;
                if (x > m_AreaBoundsX && x < m_AreaBoundsX + m_AreaBoundsWidth && y > m_AreaBoundsY && y < m_AreaBoundsY + m_AreaBoundsHeight) {
                    this._addTouchPointer(startTouches, { pageX: x, pageY: y, pointerId: event.pointerId });
                    if (startTouches && startTouches.length > 1) {
                        for (; j < length; j++)
                            this._addTouchPointer(touches, startTouches[j], false);
                        this._addTouchPointer(touches, { pageX: x, pageY: y, pointerId: event.pointerId }, true);
                        if (!((touches[0].pageX == startTouches[0].pageX) && (touches[1].pageX == startTouches[1].pageX) && (touches[0].pageY == startTouches[0].pageY) && (touches[1].pageY == touches[1].pageY)))
                            this._calculatePinchZoomFactor(this._calculateTouchDistance(startTouches, touches), this.model.zooming.type, e.target);
                    }
                    else
	                (this.doPan || this.panning) ? this._calculatePinchZoomPosition(e) : this.chartMouseMove(e);
                }
                else {
                    startTouches.length > 0 && this._removeTouchPointer(startTouches, e);
                    touches.length > 0 && this._removeTouchPointer(touches, e);
                    this.chartMouseMove(e);
                }
                this.previousPointerMove = { pageX: x, pageY: y, pointerId: event.pointerId };
            }
            else
                this.chartMouseMove(e);
        },
        _pointerPinchEnd: function (e) {
            var model = this.model, event = e.originalEvent, params = this.eventParams || (this.eventParams = this._initEventParams(model, event)),
                mouseLeave = (event.type.indexOf("leave") != -1 || event.type.indexOf("out") != -1 || event.type.indexOf("Out") != -1);
            if (!model.enable3D && model.AreaType == 'cartesianaxes' && event.pointerType != 'mouse' && event.pointerType != 4 && model.zooming.enable && model.zooming.enablePinching && (event.touches || event.pointerId)) {
                if (this.continuePinching != null)
                    this.svgObject.removeChild(this.svgObject.firstChild);
                this.continuePinching = this.previousPanTouch = this.previousScale = null;
                if (event.touches) {
                    this.eventParams = null;
                    this.chartMouseUp(e);
                    mouseLeave && this.chartMouseLeave(e);
                }
                else {
                    this._removeTouchPointer(params.touches, { pointerId: event.pointerId });
                    if (params.movements.length > 0)
                        this._removeTouchPointer(params.movements, { pointerId: event.pointerId });
                    if (params.touches.length == 0) {
                        this.chartMouseUp(e);
                        mouseLeave && this.chartMouseLeave(e);
                        this.eventParams = null;
                    }
                }
            }
            else {
                this.chartMouseUp(e);
                mouseLeave && this.chartMouseLeave(e); //Trigger mouse leave event
            }
        },
        _appendStyle: function (selector) {
            var css = '#' + selector + '.e-canvas * {touch-action:none; -ms-touch-action:none}',
                head = document.head || document.body,
                style = document.createElement('style');

            style.type = 'text/css';
            style.appendChild(document.createTextNode(css));
            head.appendChild(style);
        },
        bindEvents: function () {

            var matched = jQuery.uaMatch(navigator.userAgent),
                browserInfo = sf.EjSvgRender.utils.browserInfo(),
                isPointer = browserInfo.isMSPointerEnabled,
                isIE11Pointer = browserInfo.pointerEnabled,
                touchStartEvent = isPointer ? (isIE11Pointer ? "pointerdown" : "MSPointerDown") : "touchstart mousedown",
                touchStopEvent = isPointer ? (isIE11Pointer ? "pointerup" : "MSPointerUp") : "touchend mouseup",
                touchMoveEvent = isPointer ? (isIE11Pointer ? "pointermove" : "MSPointerMove") : "touchmove mousemove",
                touchCancelEvent = isPointer ? (isIE11Pointer ? "pointerleave" : "MSPointerOut") : "touchleave mouseleave";
            this.model.browserInfo = browserInfo;

            if ((window.navigator.maxTouchPoints > 1 && window.PointerEvent) || window.PointerEventsPolyfill) { //For IE11 and IE devices that supports pointer events
                this._on(this.element, "pointerup pointerleave", this._pointerPinchEnd);
                this._on(this.element, "pointerdown", this._pointerPinchStart);
                this._on(this.element, "pointermove", this._pointerPinchMove);
                this._appendStyle(this.element[0].id);
            }
            else if (window.TouchEvent)//For chrome, safari and android
            {
                this._on(this.element, "touchstart", this._pointerPinchStart);
                this._on(this.element, "touchmove", this._pinchGestureMove);
                this._on(this.element, "touchend", this._pointerPinchEnd);
                this._on($(this.element), "mousedown", this.chartMouseDown);
                this._on($(this.element), "mousemove", this.chartMouseMove);
                this._on(this.element, 'mouseleave', this.chartMouseLeave);
                this._on($(document), "mouseup", this.chartMouseUp);
                this._appendStyle(this.element[0].id);
            }
            else if (window.navigator.msMaxTouchPoints && window.navigator.msPointerEnabled) { //For IE10
                this._on(this.element, "MSPointerUp", this._pointerPinchEnd);
                this._on(this.element, "mouseleave", this.chartMouseLeave);
                this._on(this.element, "MSPointerDown", this._pointerPinchStart);
                this._on(this.element, "MSPointerMove", this._pointerPinchMove);
                this._appendStyle(this.element[0].id);
            }
            else {
                this._on(this.element, touchMoveEvent, this.chartMouseMove);
                this._on(this.element, touchCancelEvent, this.chartMouseLeave);
                this._on($(document), touchStopEvent, this.chartMouseUp);
                this._on($(this.element), touchStartEvent, this.chartMouseDown);
            }
            this._isSafari = !!navigator.userAgent.match(/Version\/[\d\.]+.*Safari/);
            if ((this.isDevice() && this._isSafari) != true)
                this._on($(this.element), "click", this.chartMouseClick);
            this._on($(this.element), "contextmenu", this.chartRightClick);
            this._on($(this.element), "dblclick", this.chartMouseDoubleClick);


            if (this.model.canResize || this.model.isResponsive) {
                this.bindResizeEvents();
            }
            var touchAction = this.model.zooming.enable || this.model.commonSeriesOptions.dragSettings.enable ? 'none' : 'pan-y';

            $(this.element).css({ 'ms-touch-action': touchAction, 'touch-action': touchAction, 'content-zooming': 'none' }); //disable browser touch action   
            // $(this.svgObject).css({ 'ms-touch-action': 'none', 'touch-action': 'none', 'content-zooming': 'none' });
            $(this.element).css({
                "-webkit-touch-callout": "none", /* iOS Safari */
                "-webkit-user-select": "none",  /* Chrome/Safari/Opera */
                "-moz-user-select": "none",     /* Firefox */
                "-ms-user-select": "none",     /* Internet Explorer/Edge */
                "user-select": "none"
            });
            var eventName = matched.browser.toLowerCase() == "mozilla" ? (isIE11Pointer ? "mousewheel" : "DOMMouseScroll") : "mousewheel";
            this._on(this.element, eventName, this.chartMouseWheel);
			this._isEventsBinded = true;

        },

        calZoomFactors: function (cumulativeScale, origin, currentZoomFactor, currentZoomPos) {
            var calcZoomFactorVal, calcZoomPosition;
            if (cumulativeScale == 1) {
                calcZoomFactorVal = 1;
                calcZoomPosition = 0;
            } else {
                calcZoomFactorVal = sf.EjSvgRender.utils._minMax(1 / cumulativeScale, 0, 1);
                calcZoomPosition = currentZoomPos + ((currentZoomFactor - calcZoomFactorVal) * origin);
            }
            return { zoomMFactor: calcZoomFactorVal, zoomMPosition: calcZoomPosition };
        },
        doMouseWheelZoom: function (cumulativeScale, origin, axis) {
            if (cumulativeScale >= 1) {
                var calZoomVal = this.calZoomFactors(cumulativeScale, origin, axis.zoomFactor, axis.zoomPosition);
                //calcZoomPos = Math.Round(calcZoomPos, 2);
                if (axis.zoomPosition != calZoomVal.zoomMPosition || axis.zoomFactor != calZoomVal.zoomMFactor) {
                    this.zoomed = true;
                    axis.zoomPosition = calZoomVal.zoomMPosition;
                    axis.zoomFactor = (calZoomVal.zoomMPosition + calZoomVal.zoomMFactor) > 1 ? (1 - calZoomVal.zoomMPosition) : calZoomVal.zoomMFactor;
                    return true;
                }
            }

            return false;

        },
        enableAnimation: function () {
            for (var m = 0; m < this.model.series.length; m++) {
                var series = this.model.series[m];
                series.enableAnimation = this.serAnimation[m];
            }
        },
        disableAnimation: function () {
            var chart = this;
            for (var m = 0; m < chart.model.series.length; m++)
                chart.model.series[m].enableAnimation = false;
            for (var k = 0; k < chart.model.indicators.length; k++)
                chart.model.indicators[k].enableAnimation = false;
        },
        _removeTrackBall: function () {
            var id = "#" + this.svgObject.id;
            $("#" + this.svgObject.id + "_trackSymbol").remove();
            $(document).find("#measureTex").remove();
            if (this.chartCross.visible) {
                // Visibility is set to hidden
                var element = $(this.svgObject).find(id + "_AxisCrossToolTip");
                this.svgRenderer._setAttr($(element), { "visibility": 'hidden' });
                element = $(this.svgObject).find(id + "_CrosshairVertical");
                this.svgRenderer._setAttr($(element), { "d": 'M 0 0' });
                element = $(this.svgObject).find(id + "_CrosshairHorizontal");
                this.svgRenderer._setAttr($(element), { "d": 'M 0 0' });

                element = $(this.svgObject).find(id + "_TrackAxisToolTip");
                this.svgRenderer._setAttr($(element), { "visibility": 'hidden' });
                element = $(this.svgObject).find(id + "_Tracker");
                this.svgRenderer._setAttr($(element), { "d": 'M 0 0' });
                element = $(this.svgObject).find('[id*="_TrackToolTip"]');
                this.svgRenderer._setAttr($(element), { "visibility": 'hidden' });
                element = $(this.svgObject).find('[id*="_TrackToolTip"]').children();
                this.svgRenderer._setAttr($(element), { "visibility": 'hidden' });
                $(element).css('visibility', 'hidden');
                element = $(this.svgObject).find('[id*="_trackSymbol_"]');
                this.svgRenderer._setAttr($(element), { "visibility": 'hidden' });
                $(document).find('[id*="_TrackToolTipTemplate_"]').attr("visibility", "hidden");
                $(document).find('[id*="_TrackToolTipTemplate_"]').css("display", "none");
                $(id + "_CrosshairVertical").css("display", "none");
                $(id + "_CrosshairHorizontal").css("display", "none");
                $("#" + this._id).find('[id*="canvas_AxisToolTipRect"]').css("visibility", "hidden");
                $("#" + this._id).find('[id*="canvas_Tracker"]').remove();
                $("#" + this._id).find('[id*="canvas_trackSymbol"]').css("visibility", "hidden");
                $("#" + this._id).find('[id*="_gTooltip_"]').remove();
                $("#secondCanvas").remove();
                $(document).find('[id*="TrackGroupToolTipTemplate"]').remove();
                $(document).find('[id*="_TrackToolTipTemplate_"]').remove();
                $("#" + this._id).find('[id*="_trackball_grouping_tooltip"]').remove();
            }

        },
        enableTrackBall: function () {
            this.model.crosshair.visible = this.chartCross.visible;
            this.model.crosshair.type = this.chartCross.mArea;
        },
        disableTrackBall: function () {

            this.model.crosshair.visible = false;

            this._removeTrackBall();
        },
        _enableZoomingButtons: function () {
            var svgObjectId = this.svgObject.id;
            if (this.model.AreaType != 'cartesianaxes') {
                $("#" + svgObjectId + "_ResetZoom").remove();
                $("#" + svgObjectId + "_PanBtn").remove();
                $("#" + svgObjectId + "_ZoomBtn").remove();
                $("#" + svgObjectId + "_ZoomInBtn").remove();
                $("#" + svgObjectId + "_ZoomOutBtn").remove();
            }
            if (this.model.AreaType == 'cartesianaxes') {
                //Remove zoom buttons before adding them
                this._removeZoomkit();
                var isRTL = this.model.zooming.isReversed;
                if (!this.toolbarItems)
                {
                    this.toolbarItems = $.extend(true, [],  this.model.zooming.toolbarItems);
                    this.toolbarItems.reverse();
                }
                var toolbar = isRTL ? this.toolbarItems : this.model.zooming.toolbarItems;
                var length = toolbar.length;
                var currentItem, index;
                for (var i = length - 1; i >= 0; i--) {
                    currentItem = toolbar[i];
                    index = length - i;
                    switch (currentItem) {
                        case "reset":
                            this.resetZoomButton(index);
                            break;
                        case "pan":
                            this.panButton(index);
                            break;
                        case "zoom":
                        case "zoomIn":
                        case "zoomOut":
                            this.zoomButton(index, currentItem);
                            break;
                        default:
                            length = length - 1;
                            break;
                    }
                }
            }
        },
        chartMouseWheel: function (e) {
            $("#" + this.svgObject.id + "_TrackToolTip").hide(); // fixed tooltip mouse wheel issue
            $(document).find('[id*="TrackGroupToolTipTemplate"]').remove();
            $(document).find('[id*="_TrackToolTipTemplate_"]').remove();
            $(this.svgObject).find('[id*="_trackSymbol_"]').remove();
            if (this.model.zooming.enableMouseWheel && this.model.AreaType == "cartesianaxes" && !this.model.enable3D && !this.vmlRendering && sf.util.isNullOrUndefined(this.model.isLazyZooming)) {
                var chart = this;
                var chartZoomed;
                this.zoomed = false;
                var canUpdate = false;
                var id = "#" + chart.svgObject.id;
                var matched = jQuery.uaMatch(navigator.userAgent);
                var isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
                var wheelDelta = e.originalEvent.wheelDelta;
                var direction = matched.browser.toLowerCase() == "mozilla" ? ((isIE11 ? ((wheelDelta / 120) > 0 ? 1 : -1) : -(e.originalEvent.detail) / 3 > 0 ? 1 : -1)) : ((wheelDelta / 120) > 0 ? 1 : -1);
                for (var i = 0; i < this.model._axes.length; i++) {
                    var axis = this.model._axes[i];
                    if ((axis.orientation.toLowerCase() == "vertical" && (chart.model.zooming.type.toLowerCase() == "y" || chart.model.zooming.type.trim().toLowerCase() == "x,y")) || (axis.orientation.toLowerCase() == "horizontal" && (chart.model.zooming.type.toLowerCase() == "x" || chart.model.zooming.type.trim().toLowerCase() == "x,y"))) {

                        var currentScale = Math.max(1 / sf.EjSvgRender.utils._minMax(axis.zoomFactor, 0, 1), 1);
                        var cumulativeScale = Math.max(currentScale + (0.25 * direction), 1);
                        canUpdate = canUpdate | chart.doMouseWheelZoom(cumulativeScale, 0.5, axis);
                    }
                    if (axis.zoomFactor != 1 && axis.zoomPosition != 0)
                        chartZoomed = true;
					this.resetZooming = axis.zoomFactor == 1 && axis.zoomPosition == 0;
                }
                this._updateScroll();
                this.disableAnimation();

                this.disableTrackBall();
                if (canUpdate) {
                    this.model.legendCollapsed = false;
                    this.zoomed = true;
                    chart.redraw(true);
                }
                this.model._chartAreaZoom = true;
                this._enableZoomingButtons();
                this.mouseWheelCoords = { x: e.originalEvent.pageX, y: e.originalEvent.pageY };
                if (!chartZoomed) {
                    $(id + '_ResetZoom').remove();
                    $(id + '_PanBtn').remove();
                    $(id + '_ZoomBtn').remove();
                    $(id + '_ZoomInBtn').remove();
                    $(id + '_ZoomOutBtn').remove();
                    this.enableAnimation();
                    this.panning = false;
                }
                var matched = jQuery.uaMatch(navigator.userAgent);
                if (e.preventDefault && matched.browser == 'chrome' && this.model.zooming.enable)
                    e.preventDefault();
                e.returnValue = false;
            }

            $(".tooltipDiv" + this._id).remove();

        },

        getAxisMultiLevelLabelsData: function (evt) {
            var mouseMoveCords = this.calMousePosition(evt),
                grpLabelsLength = this.model.multiLevelLabelRegions.length,
                ele, x, y, height, width, i, data;
            this.mousemoveX = mouseMoveCords.X;
            this.mousemoveY = mouseMoveCords.Y;
            for (i = 0; i < grpLabelsLength; i++) {
                ele = this.model.multiLevelLabelRegions[i];
                x = ele.bounds.x;
                y = ele.bounds.y;
                height = ele.bounds.height;
                width = ele.bounds.width;
                if ((this.mousemoveX >= x) && (this.mousemoveX <= x + width) && (this.mousemoveY <= y + height) && (this.mousemoveY >= y)) {
                    data = { location: { x: this.mousemoveX, y: this.mousemoveY }, axis: this.model._axes[ele.axisIndex], multiLevelLabel: ele.multiLevelLabel };
                    return data;
                }
            }
        },

        getAxisLabelData: function (evt) {

            var mouseMoveCords = this.calMousePosition(evt),
                targetid = evt.target.id,
                region,
                x,
                y,
                width,
                height,
                data,
                labelsLength,
                axisVisible,
                axesLength = this.model._axes.length;
            this.mousemoveX = mouseMoveCords.X;
            this.mousemoveY = mouseMoveCords.Y;
            if (this.model.AreaType == 'cartesianaxes' || this.model.AreaType == 'polaraxes') {
                if (!this.model.enable3D) {
                    for (var j = 0; j < axesLength; j++) {
                        labelsLength = this.model._axes[j].visibleLabels.length;
                        axisVisible = this.model._axes[j].visible;
                        if (axisVisible)
                            for (var k = 0; k < labelsLength; k++) {

                                region = this.model._axes[j].visibleLabels[k].region;
                                if (!sf.util.isNullOrUndefined(region)) {
                                    x = region.bounds.x;
                                    y = region.bounds.y;
                                    width = region.bounds.width;
                                    height = region.bounds.height;
                                    x = (this.vmlRendering && (targetid.indexOf("_YLabel_") >= 0)) ? (this.model._axes[j].opposedPosition) ? x : x + width : x;
                                    if ((this.mousemoveX >= x) && (this.mousemoveX <= x + width)) {
                                        if ((this.vmlRendering) ? ((this.mousemoveY <= y + height) && (this.mousemoveY >= y)) : (this.mousemoveY >= y - height) && (this.mousemoveY <= y)) {
                                            data = { location: { x: this.mousemoveX, y: this.mousemoveY }, index: k, axis: this.model._axes[j], text: region.labelText };
                                            return data;
                                        }
                                    }
                                }

                            }
                    }
                }
                else {
                    if (targetid.indexOf("horizontal") >= 0 || targetid.indexOf("vertical") >= 0) {
                        for (var j = 0; j < axesLength; j++) {
                            labelsLength = this.model._axes[j].visibleLabels.length;
                            for (var k = 0; k < labelsLength; k++) {

                                if (targetid == this.svgObject.id + this.model._axes[j].orientation + k) {
                                    data = { location: { x: this.mousemoveX, y: this.mousemoveY }, index: k, axis: this.model._axes[j], text: this.model._axes[j].visibleLabels[k].Text };
                                    return data;

                                }
                            }
                        }
                    }
                }
            }
        },
        getLegendData: function (evt) {
            var mouseMoveCords = this.calMousePosition(evt);
            var vScrollerWidth = 18;
            var isRTL = this.model.legend.isReversed;           
            mouseMoveCords.X = isRTL && ($("#legend_" + this._id).find('[class*="e-vscrollbar"]').length || $("#legend_" + this._id)[0].style.overflowY == "scroll") ? mouseMoveCords.X - vScrollerWidth : mouseMoveCords.X;
            mouseMoveCords.X -= parseFloat($(this.element).css("padding-left"));
            mouseMoveCords.Y -= parseFloat($(this.element).css("padding-top"));
            var isEjScroll = this.model.legend._ejScroller;
            var scrolltop = 0;
            var scrollleft = 0;
            scrolltop = isEjScroll ? $("#legend_" + this._id).ejScroller('instance').model.scrollTop : $("#legend_" + this._id).scrollTop();
            scrollleft = isEjScroll ? $("#legend_" + this._id).ejScroller('instance').model.scrollLeft : $("#legend_" + this._id).scrollLeft();
            if (isRTL && isEjScroll) {
                    if (scrollleft == 0)
                        scrollleft = $("#legend_" + this._id).ejScroller('instance')._rtlScrollLeftValue;
                    else if ($("#legend_" + this._id).ejScroller('instance').model.scrollLeft == $("#legend_" + this._id).ejScroller('instance')._rtlScrollLeftValue)
                        scrollleft = 0;
                    else
                        scrollleft = $("#legend_" + this._id).ejScroller('instance')._rtlScrollLeftValue - $("#legend_" + this._id).ejScroller('instance').model.scrollLeft;         
            }
            this.scrolltop = scrolltop ? scrolltop : 0;
            this.scrollleft = scrollleft ? scrollleft : 0;
            this.mousemoveX = mouseMoveCords.X + scrollleft;
            this.mousemoveY = mouseMoveCords.Y + scrolltop;
            var targetId = evt.target.id;

            {
                var currentX = this.mousemoveX;
                var currentY = this.mousemoveY;
                var chartId = this._id;
                var region;
                if ((!sf.util.isNullOrUndefined(targetId) && this.svgRenderer._getAttrVal($(evt.target).parents(':eq(1)'), 'id') == this.svgObject.id + '_Legend') || (this.model.enableCanvasRendering && targetId == "legend_" + chartId + "_canvas") || (this.vmlRendering)) {
                    $.each(this.model.legendRegion, function (index, regionItem) {

                        if ((currentX >= regionItem.Bounds.LegendBound.X + regionItem.Bounds.ItemBound.X) && (currentX <= regionItem.Bounds.LegendBound.X + regionItem.Bounds.ItemBound.X + regionItem.Bounds.ItemBound._Width)) {
                            if ((currentY >= regionItem.Bounds.LegendBound.Y + regionItem.Bounds.ItemBound.Y - (regionItem.Bounds.ItemBound.Height / 4)) && (currentY <= regionItem.Bounds.LegendBound.Y + regionItem.Bounds.ItemBound.Y + regionItem.Bounds.ItemBound.Height)) {
                                region = regionItem;
                                $("#legend_" + chartId + "_canvas").css("cursor", "pointer");
                            } else
                                $("#legend_" + chartId + "_canvas").css("cursor", "default");
                        }
                    });
                    if (!sf.util.isNullOrUndefined(region)) {
                        return { legendItem: region, series: this.model._visibleSeries[region.LegendItem.SeriesIndex] };
                    }
                }

            }
            return false;
        },

        get3DSeriesPoint: function (evt) {
            var currentX = this.mousemoveX;
            var currentY = this.mousemoveY;
            var x = (this.model.AreaType == 'polaraxes') ? 0 : this.model.m_AreaBounds.X;
            var y = (this.model.AreaType == 'polaraxes') ? 0 : this.model.m_AreaBounds.Y;
            var width = (this.model.AreaType == 'polaraxes') ? $(this.svgObject).width() : this.model.m_AreaBounds.Width;
            var height = (this.model.AreaType == 'polaraxes') ? $(this.svgObject).height() : this.model.m_AreaBounds.Height;
            var index, pointIndex, seriesIndex, region;
            if (currentX > x && currentX < (x + width) && currentY > y && currentY < (y + height)) {
                var nodeName = $(evt.target)[0].nodeName;
                if ((nodeName == "path" || nodeName == "shape") && $(evt.target)[0].id.indexOf("Region") > 1) {
                    index = $(evt.target)[0].id.match(/(\d+)/g);
                    pointIndex = parseInt(index[index.length - 1]);
                    seriesIndex = parseInt(index[index.length - 2]);
                    var regionValue = {};
                    regionValue.Region = {};
                    regionValue.Region.PointIndex = pointIndex;
                    regionValue.SeriesIndex = seriesIndex;
                    var pointData = {};
                    pointData.pointIndex = pointIndex;
                    region = { region: regionValue, pointData: pointData, location: { x: currentX, y: currentY } };
                    return region;
                }
            }
        },

        GetSeriesPoint: function (evt) {
            var mouseX;
            var mouseY;
            var currentX = this.mousemoveX;
            var currentY = this.mousemoveY;
            var region, pointIndex;
            var chartObj = this;
            var indicators = chartObj.model.indicators;
            var seriesCollection = chartObj.model._visibleSeries;
            for (var j = 0; j < indicators.length && indicators[j].segment; j++) {
                seriesCollection = seriesCollection.concat(indicators[j].segment);
            }
            if (chartObj.model.enable3D) {
                return this.get3DSeriesPoint(evt);
            }
            var x = (this.model.AreaType == 'polaraxes') ? 0 : this.model.m_AreaBounds.X;
            var y = (this.model.AreaType == 'polaraxes') ? 0 : this.model.m_AreaBounds.Y;
            var width = (this.model.AreaType == 'polaraxes') ? $(this.svgObject).width() : this.model.m_AreaBounds.Width;
            var height = (this.model.AreaType == 'polaraxes') ? $(this.svgObject).height() : this.model.m_AreaBounds.Height;

            if ((this.model.AreaType == 'cartesianaxes' || this.model.AreaType == 'polaraxes')) {

                if (currentX > x && currentX < (x + width) && currentY > y && currentY < (y + height)) {
                    $.each(this.model.chartRegions, function (index, regionItem) {
                        if (!sf.util.isNullOrUndefined(regionItem.SeriesIndex)) {
                            var currentSer = seriesCollection[regionItem.SeriesIndex];
                            if (chartObj.model.AreaType == "polaraxes" && currentSer.drawType.toLowerCase() == 'column' && evt.target || (currentSer.drawType.toLowerCase() == 'rangecolumn')) {
                                if (chartObj.model.enableCanvasRendering) {
                                    if (currentSer.type.toLowerCase() == "polar") {
                                        var bounds = regionItem.Region.Bounds;
                                        var chartStartAngle = -.5 * Math.PI;
                                        var innerRadius = bounds.innerRadius || bounds.DRadius;
                                        var fromCenterX;
                                        var fromCenterY;
                                        fromCenterX = (currentX) - (bounds.CenterX);
                                        fromCenterY = (currentY) - (bounds.CenterY);
                                        var series = chartObj.model._visibleSeries[regionItem.SeriesIndex];
                                        var startAngle = series.startAngle;
                                        var endAngle = series.endAngle;

                                        var arcAngle = (startAngle) ? 2 * Math.PI * (chartObj.model.itemCurrentXPos < 0 ? 1 + chartObj.model.itemCurrentXPos : chartObj.model.itemCurrentXPos) : 0;
                                        var clickAngle = (Math.atan2(fromCenterY, fromCenterX) - chartStartAngle - arcAngle) % (2 * Math.PI);
                                        if (clickAngle < 0 && bounds.PointIndex != 0) clickAngle = 2 * Math.PI + clickAngle;

                                        var pointStartAngle = parseFloat(bounds.StartAngle.toFixed(14));
                                        var pointEndAngle = parseFloat(bounds.EndAngle.toFixed(14));
                                        pointStartAngle -= arcAngle;
                                        pointEndAngle -= arcAngle;

                                        if (clickAngle >= pointStartAngle && clickAngle <= pointEndAngle) {
                                            index = bounds.PointIndex;
                                            distanceFromCenter = Math.sqrt(Math.pow(Math.abs(fromCenterX), 2) + Math.pow(Math.abs(fromCenterY), 2));
                                            if (distanceFromCenter <= bounds.Radius && distanceFromCenter > innerRadius) {
                                                var pointRegion = { Region: { PointIndex: index }, SeriesIndex: regionItem.SeriesIndex, type: regionItem.type };
                                                region = pointRegion;
                                            }
                                        }
                                    } else if (currentSer.type.toLowerCase() == "radar") {
                                        var bounds = regionItem.Region.Bounds;
                                        if (bounds.Line1) {
                                            line1 = bounds.Line1;
                                            line2 = bounds.Line2;
                                            line3 = bounds.Line3;
                                            line4 = bounds.Line4;
                                            var polygon = [
                                                { x: line1.x, y: line1.y },
                                                { x: line2.x, y: line2.y },
                                                { x: line3.x, y: line3.y },
                                            ];
                                            var currentPoint = { x: currentX, y: currentY };
                                            var point = false;
                                            if (currentSer.drawType.toLowerCase() == 'column') {
                                                for (var p = false, i = -1, l = polygon.length, j = l - 1; ++i < l; j = i)
                                                    ((polygon[i].y <= currentPoint.y && currentPoint.y < polygon[j].y) || (polygon[j].y <= currentPoint.y && currentPoint.y < polygon[i].y))
                                                        && (currentPoint.x < (polygon[j].x - polygon[i].x) * (currentPoint.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)
                                                        && (p = !p);
                                            }
                                            else {
                                                var polygon1 = [
                                                    { x: line1.x, y: line1.y },
                                                    { x: line2.x, y: line2.y },
                                                    { x: line3.x, y: line3.y },
                                                    { x: line4.x, y: line4.y }
                                                ];
                                                var i = 0; j = 2;
                                                for (var p = false, q = 0; q < polygon1.length; q++) {
                                                    ((polygon1[i].y <= currentPoint.y && currentPoint.y < polygon1[j].y) || (polygon1[j].y <= currentPoint.y && currentPoint.y < polygon1[i].y))
                                                        && (currentPoint.x < (polygon1[j].x - polygon1[i].x) * (currentPoint.y - polygon1[i].y) / (polygon1[j].y - polygon1[i].y) + polygon1[i].x)
                                                        && (p = !p);
                                                    var k;
                                                    k = i;
                                                    i = j;
                                                    j = ++k;
                                                    if (q == 2)
                                                        j = 0;
                                                }
                                            }
                                            point = p;
                                            if (point) {
                                                index = bounds.PointIndex;
                                                var pointRegion = { Region: { PointIndex: index }, SeriesIndex: regionItem.SeriesIndex, type: regionItem.type };
                                                region = pointRegion;
                                            }
                                        }
                                    }
                                }
                                else {
                                    var nodeName = $(evt.target)[0].nodeName;
                                    if ((nodeName == "path" || nodeName == "shape") && $($(evt.target).parent())[0].id == chartObj.svgObject.id + '_SeriesGroup' + '_' + regionItem.SeriesIndex) {
                                        index = $(evt.target)[0].id.match(/(\d+)/g);
                                        pointIndex = parseInt(index[index.length - 1]);
                                        regionItem = { Region: { PointIndex: pointIndex }, SeriesIndex: regionItem.SeriesIndex, type: regionItem.type };
                                        region = regionItem;
                                        return false;
                                    }
                                }
                            }
                            else {
                                if ((((currentX >= regionItem.Region.Bounds.X) && (currentX <= (regionItem.Region.Bounds.X + (regionItem.Region.Bounds.Width))))) && ((currentY > regionItem.Region.Bounds.Y) && (currentY < (regionItem.Region.Bounds.Y) + (regionItem.Region.Bounds.Height)))) {
                                    region = regionItem;
                                }
                            }
                        }
                        else {
                            regionValue = chartObj.model.chartRegions;
                            var pointData = {};
                            var areaValue;
                            if (!regionItem.isStripLine) {
                                var regionLength = regionItem.length;
                                var requireInvertedAxes = chartObj.model.requireInvertedAxes;
                                var axisName = (!requireInvertedAxes) ? chartObj.model.series[regionItem[regionLength - 1].SeriesIndex]._yAxisName : chartObj.model.series[regionItem[regionLength - 1].SeriesIndex]._xAxisName;
                                for (var k = 0; k < chartObj.model._axes.length; k++) {
                                    if (axisName == chartObj.model._axes[k].name) {
                                        areaValue = chartObj.model._axes[k];
                                        break;
                                    }
                                }
                                for (var i = 0; i < regionValue.length; i++) {
                                    for (var j = 0; j < regionValue[i].length; j++) {
                                        var polygon = [],
                                            line1 = regionValue[i][j].region;
                                        if (line1[0]) polygon.push({ x: line1[0].X + areaValue.x, y: line1[0].Y + areaValue.y });
                                        if (line1[1]) polygon.push({ x: line1[1].X + areaValue.x, y: line1[1].Y + areaValue.y });
                                        if (line1[2]) polygon.push({ x: line1[2].X + areaValue.x, y: line1[2].Y + areaValue.y });
                                        if (line1[3]) polygon.push({ x: line1[3].X + areaValue.x, y: line1[3].Y + areaValue.y });

                                        var currentPoint = { x: currentX, y: currentY };
                                        var point = chartObj.isPointInPolygon(polygon, currentPoint);
                                        if (point)
                                            region = regionValue[i][j];
                                    }

                                }
                            }
                        }
                    });
                }
                if (region) {
                    return { region: region, location: { x: currentX, y: currentY } };
                }
            }

            else {
                var chartObj = this;
                var distanceFromCenter, index;
                var regionValue;
                var chartRegions = chartObj.model.chartRegions;
                if (chartRegions.length > 0 && (chartRegions[0].Series.type.toLowerCase() == "pyramid" || chartRegions[0].Series.type.toLowerCase() == "funnel")) {
                    var nodeName = $(evt.target)[0].nodeName;
                    if ((nodeName == "path" || nodeName == "shape") && $($(evt.target).parent())[0].id == chartObj.svgObject.id + '_SeriesGroup' + '_' + chartRegions[0].SeriesIndex) {
                        regionValue = chartObj.model.chartRegions[0];
                        index = $(evt.target)[0].id.match(/(\d+)/g);
                        index = parseInt(index[index.length - 1]);
                        regionValue.Region.PointIndex = index;
                        var pointData = {};
                        pointData.pointIndex = index;
                        region = { region: regionValue, pointData: pointData, location: { x: currentX, y: currentY } };
                        return region;
                    }
                    else {
                        regionValue = chartRegions[0];
                        var pyrX = this.pyrX;
                        var pyrY = this.pyrY;
                        var pointData = {};
                        var polygon, line1, line2, line3, line4, line5, line6;
                        for (var j = 0; j < regionValue.Region.length; j++) {
                            line1 = regionValue.Region[j].Line1;
                            line2 = regionValue.Region[j].Line2;
                            line3 = regionValue.Region[j].Line3;
                            line4 = regionValue.Region[j].Line4;
                            if (chartRegions[0].Series.type.toLowerCase() == "pyramid")
                                polygon = [
                                    { x: line1.x + pyrX, y: line1.y + pyrY },
                                    { x: line2.x + pyrX, y: line2.y + pyrY },
                                    { x: line3.x + pyrX, y: line3.y + pyrY },
                                    { x: line4.x + pyrX, y: line4.y + pyrY }
                                ];
                            else {
                                line5 = regionValue.Region[j].Line5;
                                line6 = regionValue.Region[j].Line6;
                                polygon = [
                                    { x: line1.x + pyrX, y: line1.y + pyrY },
                                    { x: line2.x + pyrX, y: line2.y + pyrY },
                                    { x: line3.x + pyrX, y: line3.y + pyrY },
                                    { x: line4.x + pyrX, y: line4.y + pyrY },
                                    { x: line5.x + pyrX, y: line5.y + pyrY },
                                    { x: line6.x + pyrX, y: line6.y + pyrY }
                                ];
                            }

                            var currentPoint = { x: currentX, y: currentY };
                            var point = this.isPointInPolygon(polygon, currentPoint);
                            if (point) {
                                pointData.pointIndex = regionValue.Region[j].PointIndex;
                                regionValue.Region.PointIndex = pointData.pointIndex;
                                region = { region: regionValue, pointData: pointData, location: { x: currentX, y: currentY } };
                                return region;
                            }

                        }
                    }
                }

                else {
                    // ReSharper disable DuplicatingLocalDeclaration
                    $.each(chartObj.model.chartRegions, function (regionIndex, regionValue) {
                        // ReSharper restore DuplicatingLocalDeclaration
                        var chartStartAngle = -.5 * Math.PI;
                        var seriesData = regionValue.SeriesData,
                            regionData = regionValue.Region,
                            innerRadius = (chartObj.model._visibleSeries[regionValue.SeriesIndex].type.toLowerCase() == 'doughnut') ? seriesData.DRadius : 0;
                        var fromCenterX;
                        var fromCenterY;
                        fromCenterX = (currentX) - (seriesData.CenterX);
                        fromCenterY = (currentY) - (seriesData.CenterY);
                        var series = chartObj.model._visibleSeries[regionValue.SeriesIndex];
                        var startAngle = series.startAngle;
                        var endAngle = series.endAngle;
                        startAngle = startAngle < 0 ? startAngle + 360 : startAngle;
                        endAngle = endAngle < 0 ? endAngle + 360 : endAngle;
                        var totalDegree = (series.endAngle - series.startAngle);
                        //Anticlockwise pie and doughnut
                        if (totalDegree < 0) {
                            endAngle = endAngle / 360;
                            var arcAngle = (endAngle) ? 2 * Math.PI * (endAngle < 0 ? 1 + endAngle : endAngle) : 0;
                            var clickAngle = (Math.atan2(fromCenterY, fromCenterX) - chartStartAngle - arcAngle) % (2 * Math.PI);;
                            if (clickAngle < 0) clickAngle = 2 * Math.PI + clickAngle;

                            pointData = [];
                            for (var i = 0; i < regionData.length; i++) {
                                var pointStartAngle = parseFloat(regionData[i].StartAngle.toFixed(14));
                                var pointEndAngle = parseFloat(regionData[i].EndAngle.toFixed(14));
                                pointStartAngle = pointStartAngle < 0 ? 2 * Math.PI + pointStartAngle : pointStartAngle;
                                pointEndAngle = pointEndAngle < 0 ? 2 * Math.PI + pointEndAngle : pointEndAngle;
                                pointStartAngle -= arcAngle;
                                pointEndAngle -= arcAngle;
                                pointStartAngle = parseFloat(pointStartAngle.toFixed(14));
                                pointEndAngle = parseFloat(pointEndAngle.toFixed(14));
                                if (series.startAngle >= 0 && series.endAngle <= 0) {
                                    pointStartAngle = pointStartAngle <= 0 ? 2 * Math.PI + pointStartAngle : pointStartAngle;
                                    pointEndAngle = pointEndAngle < 0 ? 2 * Math.PI + pointEndAngle : pointEndAngle;
                                }
                                if (clickAngle <= pointStartAngle && clickAngle >= pointEndAngle) {
                                    pointData.push(regionData[i]);
                                    break;
                                }
                            }
                        }  //Clockwise pie,pieofpie and doughnut
                        else {
                            var arcAngle = (startAngle) ? 2 * Math.PI * (chartObj.model.itemCurrentXPos < 0 ? 1 + chartObj.model.itemCurrentXPos : chartObj.model.itemCurrentXPos) : 0;
                            var clickAngle = (Math.atan2(fromCenterY, fromCenterX) - chartStartAngle - arcAngle) % (2 * Math.PI);
                            if (clickAngle < 0) clickAngle = chartObj.model._isPieOfPie ? clickAngle : 2 * Math.PI + clickAngle;
                            pointData = [];
                            for (var i = 0; i < regionData.length; i++) {
                                var pointStartAngle = parseFloat(regionData[i].StartAngle.toFixed(14));
                                var pointEndAngle = parseFloat(regionData[i].EndAngle.toFixed(14));
                                pointStartAngle = pointStartAngle < 0 ? (chartObj.model._isPieOfPie ? pointStartAngle : 2 * Math.PI + pointStartAngle) : pointStartAngle;
                                pointEndAngle = pointEndAngle < 0 ? 2 * Math.PI + pointEndAngle : pointEndAngle;
                                pointStartAngle -= arcAngle;
                                pointEndAngle -= arcAngle;
                                pointStartAngle = parseFloat(pointStartAngle.toFixed(14));
                                pointEndAngle = parseFloat(pointEndAngle.toFixed(14));
                                if (series.startAngle < 0 && (series.endAngle > -1 || series.endAngle == null)) {
                                    pointStartAngle = pointStartAngle < 0 ? 2 * Math.PI + pointStartAngle : pointStartAngle;
                                    pointEndAngle = pointEndAngle <= 0 ? 2 * Math.PI + pointEndAngle : pointEndAngle;
                                }
                                if (clickAngle + 2 * Math.PI < pointEndAngle && series.type == "pieofpie")
                                    clickAngle = clickAngle + 2 * Math.PI;
                                if (clickAngle >= pointStartAngle && clickAngle <= pointEndAngle) {
                                    pointData.push(regionData[i]);
                                    break;
                                }
                            }
                        }
                        if (pointData.length > 0) {
                            var isExploded = (series.explodeAll || (series.explodeIndex == pointData[0].PointIndex));
                            if (isExploded) {

                                var fromCenterX1 = currentX - pointData[0].StartX;
                                var fromCenterY1 = currentY - pointData[0].StartY;

                                if (pointData.length > 0) {

                                    distanceFromCenter = Math.sqrt(Math.pow(Math.abs(fromCenterX1), 2) + Math.pow(Math.abs(fromCenterY1), 2));
                                    if (distanceFromCenter <= seriesData.Radius && distanceFromCenter > innerRadius) {
                                        regionData.PointIndex = pointData[0].PointIndex;
                                        regionData.Index = pointData[0].Index;
                                        regionData.SeriesIndex = pointData[0].SeriesIndex;
                                        region = { region: regionValue, pointData: pointData, location: { x: currentX, y: currentY } };
                                    }
                                }
                            }
                            else {
                                distanceFromCenter = Math.sqrt(Math.pow(Math.abs(fromCenterX), 2) + Math.pow(Math.abs(fromCenterY), 2));
                                if (distanceFromCenter <= seriesData.Radius && distanceFromCenter > innerRadius) {
                                    regionData.PointIndex = pointData[0].PointIndex;
                                    regionData.Index = pointData[0].Index;
                                    regionData.SeriesIndex = pointData[0].SeriesIndex;
                                    region = { region: regionValue, pointData: pointData, location: { x: currentX, y: currentY } };
                                }
                            }
                        }

                    });

                    return region;
                }
            }
        },
        isPointInPolygon: function (polygon, point) {
            for (var p = false, i = -1, l = polygon.length, j = l - 1; ++i < l; j = i)
                ((polygon[i].y <= point.y && point.y < polygon[j].y) || (polygon[j].y <= point.y && point.y < polygon[i].y))
                    && (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)
                    && (p = !p);
            return p;
        },
        mousePosition: function (evt) {
            if (!sf.util.isNullOrUndefined(evt.pageX) && evt.pageX > 0)
                return { x: evt.pageX, y: evt.pageY };
            else if (evt.originalEvent && !sf.util.isNullOrUndefined(evt.originalEvent.pageX) && evt.originalEvent.pageX > 0)
                return { x: evt.originalEvent.pageX, y: evt.originalEvent.pageY };
            else if (evt.originalEvent && evt.originalEvent.changedTouches != undefined) {
                if (!sf.util.isNullOrUndefined(evt.originalEvent.changedTouches[0].pageX) && evt.originalEvent.changedTouches[0].pageX > 0)
                    return { x: evt.originalEvent.changedTouches[0].pageX, y: evt.originalEvent.changedTouches[0].pageY };
            }
            else
                return { x: 0, y: 0 };

        },


        calMousePosition: function (e) {
            var matched = jQuery.uaMatch(navigator.userAgent);
            var mouseposition = this.mousePosition(e);
            e.pageX = mouseposition.x;
            e.pageY = mouseposition.y;
            var mouseX, mouseY;
            var browser = matched.browser.toLowerCase();
            mouseX = (e.pageX) - $(this.svgObject).offset().left;
            mouseY = (e.pageY) - $(this.svgObject).offset().top;


            return { X: mouseX, Y: mouseY };

        },

        calTouchPosition: function (e) {
            var matched = jQuery.uaMatch(navigator.userAgent);
            var mouseX, mouseY;

            if (matched.browser.toLowerCase() == "mozilla" || matched.browser.toLowerCase() == "webkit") {
                var touch = e.originalEvent.touches[0];
                mouseX = (touch.pageX) - $(this.svgObject).parent().offset().left;
                mouseY = (touch.pageY) - $(this.svgObject).parent().offset().top;
                this.leftPadding = $(this.svgObject).offset().left;
                this.grabPadding = 0;
            } else if (matched.browser.toLowerCase() == "msie") {

                mouseX = (e.originalEvent.pageX) - $(this.svgObject).offset().left;
                mouseY = (e.originalEvent.pageY) - $(this.svgObject).offset().top;
                this.leftPadding = $(this.svgObject).offset().left;
            }
            else {
                var touch = e.originalEvent.touches[0];
                mouseX = (touch.pageX) - $(this.svgObject).offset().left;
                mouseY = (touch.pageY) - $(this.svgObject).offset().top;
                this.leftPadding = $(this.svgObject).offset().left;
            }

            return { X: mouseX, Y: mouseY };

        },

        cancelEvent: function (e) {
            e.stopPropagation();
            var matched = jQuery.uaMatch(navigator.userAgent);
            if (matched.browser == 'chrome' && (this.model.zooming.enable || this.model.crosshair.visible)) {
                e.preventDefault();
            }
            if (this.model.enable3D) {
                e.preventDefault();
                e.stopPropagation();
            }
            e.returnValue = false;
            e.cancelBubble = true;
            return false;
        },
        resetZoom: function () {
            var chartobj = this;
            var id = "#" + this.svgObject.id;
            $(".tooltipDiv" + this._id).remove(); //To remove tooltip template
            $(".zoom" + this._id).remove();
            if (chartobj.zoomed) {
                $.each(this.model._axes, function (index, axis) {
                    axis.zoomed = false;
                    axis.zoomFactor = 1;
                    axis.zoomPosition = 0;
                });
                //Reset primary axis zoomFactor and zoomPosition
                chartobj.model.primaryXAxis.zoomFactor = 1;
                chartobj.model.primaryYAxis.zoomFactor = 1;
                chartobj.model.primaryXAxis.zoomPosition = 0;
                chartobj.model.primaryYAxis.zoomPosition = 0;
                $("#" + chartobj._id + "_canvas").css({ "cursor": "default" });
                $(id + "_ResetZoom").remove();
                $(id + "_PanBtn").remove();
                $(id + "_ZoomBtn").remove();
                $(id + "_ZoomInBtn").remove();
                $(id + "_ZoomOutBtn").remove();
                chartobj.zoomed = false;
                chartobj.zooming = false;
                chartobj.panning = false;
                chartobj.model._chartAreaZoom = false;
                chartobj.resetZooming = true;
                chartobj.enableTrackBall();
                //No need for data update during reset zoom
                chartobj.redraw(true);
                chartobj.enableAnimation();
                chartobj.svgRenderer._setAttr($(chartobj.svgObject).find(id + "_XAxis," + id + "_ChartArea," + id + "_YAxis," + id + "_SeriesCollection"), { "cursor": "default" });
            }
        },
        startZoomInOut: function (currentEle) {
            var currentItem = currentEle.target.id.indexOf("ZoomIn") > -1 ? "zoomIn" : "zoomOut";
            this.drag = false;
            this.zoomed = true;
            var type = this.model.zooming.type.toLowerCase();
            var zoomValue = currentItem == "zoomIn" ? 0.2 : -0.2;
            var zoomedOut = true;
            var axis, previousZoomFactor, previousZoomPosition, selectedData;
            for (var k = 0; k < this.model._axes.length; k++) {
                axis = this.model._axes[k];
                previousZoomFactor = axis.zoomFactor;
                previousZoomPosition = axis.zoomPosition;
                if (axis.orientation.toLowerCase() == "horizontal") {
                    axis.zoomFactor = type != "y" ? previousZoomFactor - zoomValue : axis.zoomFactor;
                    axis.zoomPosition = type != "y" ? previousZoomPosition + zoomValue : axis.zoomPosition;
                } else {
                    axis.zoomFactor = type != "x" ? previousZoomFactor - zoomValue : axis.zoomFactor;
                    axis.zoomPosition = type != "x" ? previousZoomPosition + zoomValue : axis.zoomPosition;
                }
                if (parseFloat(axis.zoomFactor.toFixed(3)) <= 0.001) {
                    axis.zoomFactor = previousZoomFactor;
                    axis.zoomPosition = previousZoomPosition;
                }
                if (parseFloat(axis.zoomFactor.toFixed(3)) >= 1) {
                    axis.zoomFactor = 1;
                    axis.zoomPosition = 0;
                }
                zoomedOut = zoomedOut && (axis.zoomFactor == 1);
				this.resetZooming = axis.zoomFactor == 1 && axis.zoomPosition == 0;
            }
            selectedData = this._getZoomedData(this);
            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = {};
            commonEventArgs.data.series = selectedData;
            this._trigger("zoomed", commonEventArgs);
            this._updateScroll();
            this.redraw(true);
            if (zoomedOut) {
                this._removeZoomkit();
                this.resetZooming = true;
                this.zoomed = this.panning = false;
                this.model._chartAreaZoom = false
            }
            else
                this._enableZoomingButtons();
        },
        startZoom: function () {
            var chartObj = this;
            var id = "#" + this.svgObject.id;
            $(".tooltipDiv" + this._id).remove(); //To remove tooltip template
            var iconColor = this.model.theme.toLowerCase().indexOf("dark") >= 0 ? "#000000" : " #FFFFFF";
            chartObj.svgRenderer._setAttr($(id + '_ZoomBtn'), { 'selected': 'true' });
            chartObj.svgRenderer._setAttr($(id + '_ZoomPath'), { "fill": "#14B9FF" });
            chartObj.svgRenderer._setAttr($(id + '_ZoomIcon'), { "fill": '#FFFFFF' });
            chartObj.svgRenderer._setAttr($(id + '_PanPath'), { "fill": '#B7B7B7' });
            chartObj.svgRenderer._setAttr($(id + '_panIcon'), { "fill": iconColor });
            $(id + "_ZoomBtn").css({ "border-color": "#14B9FF", "background-color": "#14B9FF" });
            $(id + "_PanBtn").css({ "border-color": "#B7B7B7", "background-color": "#B7B7B7" });
            $("#" + chartObj._id + "_canvas").css({ "cursor": "default" });
            this._cursorToDefault();
            chartObj.panning = false;
            chartObj.enableTrackBall();
        },
        startPan: function () {
            var chartObj = this;
            var id = "#" + this.svgObject.id;
            $(".tooltipDiv" + this._id).remove(); //To remove tooltip template
            var iconColor = this.model.theme.toLowerCase().indexOf("dark") >= 0 ? "#000000" : " #FFFFFF";
            chartObj.svgRenderer._setAttr($(id + '_ZoomBtn'), { 'selected': 'false' });
            chartObj.svgRenderer._setAttr($(id + '_PanBtn'), { 'selected': 'true' });
            chartObj.svgRenderer._setAttr($(id + '_ZoomPath'), { "fill": "#B7B7B7" });
            chartObj.svgRenderer._setAttr($(id + '_ZoomIcon'), { "fill": iconColor });
            chartObj.svgRenderer._setAttr($(id + '_PanPath'), { "fill": '#14B9FF' });
            chartObj.svgRenderer._setAttr($(id + '_panIcon'), { "fill": '#FFFFFF' });
            $(id + "_ZoomBtn").css({ "border-color": "#B7B7B7", "background-color": "#B7B7B7" });
            $(id + "_PanBtn").css({ "border-color": "#14B9FF", "background-color": "#14B9FF" });
            $("#" + chartObj._id + "_canvas").css({ "cursor": "pointer" });
            this._cursorToPointer();
            chartObj.panning = true;
            chartObj.disableTrackBall();

        },
        zoomButton: function (index, currentItem) {
            if (currentItem == "zoom")
                var currentItemId = "_Zoom";
            else if (currentItem == "zoomIn")
                currentItemId = "_ZoomIn";
            else
                currentItemId = "_ZoomOut";

            var padding = index * 5 + 5, chartOffset = { left: 0, top: 0 };
            var transX = this.model.m_AreaBounds.X + (this.model.m_AreaBounds.Width - (index * 32) - padding); //32 path bouding box for pan,reset, zoom button 
            var transY = (this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height) + (this.model.elementSpacing - (this.model.m_AreaBounds.Height));
            var iconColor = this.model.theme.toLowerCase().indexOf("dark") >= 0 ? "#000000" : " #FFFFFF";

            var pathOptions = {
                'id': this.svgObject.id + currentItemId + 'Path',
                'd': "M32,27c0,2.75-2.25,5-5,5H5c-2.75,0-5-2.25-5-5V5c0-2.75,2.25-5,5-5h22c2.75,0,5,2.25,5,5V27z",
                'fill': this.panning || currentItem == "zoomIn" || currentItem == "zoomOut" ? '#b7b7b7' : '#14B9FF',
                'zoomId': this._id + currentItemId + "Btn",
                'width': 26,
                'height': 26,
                'left': transX + chartOffset.left,
                'top': transY + chartOffset.top,
                'iconColor': iconColor
            };

            sf.EjCanvasRender.prototype.zoomButton(pathOptions, currentItem, this);
            if (currentItem == "zoom")
                this._on($("#" + this.svgObject.id + currentItemId + "Btn"), "touchstart click", this.startZoom);
            else
                this._on($("#" + this.svgObject.id + currentItemId + "Btn"), "touchstart click", this.startZoomInOut);
        },
        panButton: function (index) {
            var padding = index * 5 + 5, chartOffset = { left: 0, top: 0 };
            var transX = this.model.m_AreaBounds.X + (this.model.m_AreaBounds.Width - (index * 32) - padding); //32 path bounding box for pan and resetzoom button
            var transY = (this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height) + (this.model.elementSpacing - (this.model.m_AreaBounds.Height));
            var iconColor = this.model.theme.toLowerCase().indexOf("dark") >= 0 ? "#000000" : " #FFFFFF";

            var pathOptions = {
                'id': this.svgObject.id + '_PanPath',
                'd': "M 32 27 c 0 2.75 -2.25 5 -5 5 H 5 c -2.75 0 -5 -2.25 -5 -5 V 5 c 0 -2.75 2.25 -5 5 -5 h 22 c 2.75 0 5 2.25 5 5 V 27 Z",
                'fill': !this.panning ? '#b7b7b7' : '#14B9FF',
                'panId': this._id + '_PanBtn',
                'width': 26,
                'height': 26,
                'left': transX + chartOffset.left,
                'top': transY + chartOffset.top,
                'iconColor': iconColor
            };
            sf.EjCanvasRender.prototype.panButton(pathOptions, this);
            this._on($("#" + this.svgObject.id + '_PanBtn'), "touchstart click", this.startPan);
        },
        resetZoomButton: function (index) {
            var padding = index * 5 + 5, chartOffset = { left: 0, top: 0 };
            var transX = this.model.m_AreaBounds.X + (this.model.m_AreaBounds.Width - (index * 32 + padding)); //32 path bouding box
            var transY = (this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height) + (this.model.elementSpacing - (this.model.m_AreaBounds.Height));
            var iconColor = this.model.theme.toLowerCase().indexOf("dark") >= 0 ? "#000000" : " #FFFFFF";
            var options = {
                'id': this.svgObject.id + '_ResetZoomPath',
                'd': "M 32 27 c 0 2.75 -2.25 5 -5 5 H 5 c -2.75 0 -5 -2.25 -5 -5 V 5 c 0 -2.75 2.25 -5 5 -5 h 22 c 2.75 0 5 2.25 5 5 V 27 Z",
                'fill': '#b7b7b7',
                'resetZoomId': this._id + '_ResetZoom',
                'width': 26,
                'height': 26,
                'left': transX + chartOffset.left,
                'top': transY + chartOffset.top,
                'iconColor': iconColor
            };
            sf.EjCanvasRender.prototype.resetZoom(options, this);
            var events = (window.TouchEvent ? "touchstart" : (window.PointerEvent ? "pointerdown" : (window.MSPointerEvent ? "MSPointerDown" : "click"))) + " click";
            this._on($("#" + this.svgObject.id + '_ResetZoom'), events, this.resetZoom);
        },

        doZoom: function (zoomRect, zoomRectWidth, zoomRectHeight) {
            var chart = this, selectedData;
            this.model._chartAreaZoom = true;
            this.scrollDraw = true;
            $(".tooltipDiv" + this._id).remove(); //To remove tooltip template
            if (chart.model.enableCanvasRendering) {
                var zoomArea = $("#" + this.svgObject.id + "_ZoomArea")[0].getClientRects()[0];
                var chartArea = $("#" + this.svgObject.id)[0].getClientRects()[0];
                var zoomX = zoomArea.left - chartArea.left - $(document).scrollLeft();
                var zoomY = zoomArea.top - chartArea.top - $(document).scrollTop();
            } else {
                var zoomX = parseFloat(chart.svgRenderer._getAttrVal($(zoomRect), "x"));
                var zoomY = parseFloat(chart.svgRenderer._getAttrVal($(zoomRect), "y"));
            }
            $("#" + this.svgObject.id + "_ZoomArea").remove();
            this.drag = false;
            this.zoomed = true;
			var trans = this.getScaleValues(chart);
			var areaBounds = $.extend(true, {}, chart.model.m_AreaBounds),
				m_AreaBoundsX = areaBounds.X * trans.x,
				m_AreaBoundsY = areaBounds.Y * trans.y,
				m_AreaBoundsWidth = areaBounds.Width * trans.x,
				m_AreaBoundsHeight = areaBounds.Height * trans.y;
            for (var k = 0; k < this.model._axes.length; k++) {
                var axis = this.model._axes[k];
                var previousZoomFactor = axis.zoomFactor;
                var previousZoomPosition = axis.zoomPosition;
                if (axis.orientation.toLowerCase() == "horizontal") {
                    axis.zoomFactor = chart.model.zooming.type.toLowerCase() != "y"
                        ? previousZoomFactor * (zoomRectWidth / (m_AreaBoundsWidth)) : axis.zoomFactor;
                    axis.zoomPosition = chart.model.zooming.type.toLowerCase() != "y"
                        ? previousZoomPosition + Math.abs((zoomX - m_AreaBoundsX) / (m_AreaBoundsWidth)) * previousZoomFactor : axis.zoomPosition;
                    if (parseFloat(axis.zoomFactor.toFixed(3)) <= 0.001) {
                        axis.zoomFactor = previousZoomFactor;
                        axis.zoomPosition = previousZoomPosition;

                    }
                } else {
                    axis.zoomFactor = chart.model.zooming.type.toLowerCase() != "x"
                        ? previousZoomFactor * zoomRectHeight / m_AreaBoundsHeight : axis.zoomFactor;
                    axis.zoomPosition = chart.model.zooming.type.toLowerCase() != "x"
                        ? previousZoomPosition + (1 - Math.abs((zoomRectHeight + (zoomY - m_AreaBoundsY)) / (m_AreaBoundsHeight))) * previousZoomFactor : axis.zoomPosition;
                    if (parseFloat(axis.zoomFactor.toFixed(3)) <= 0.001) {
                        axis.zoomFactor = previousZoomFactor;
                        axis.zoomPosition = previousZoomPosition;

                    }
                }
            }

            //Getting zoomed region data when zoomedData event fired                    
            selectedData = this._getZoomedData(chart);
            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = {};
            commonEventArgs.data.series = selectedData;
            this._trigger("zoomed", commonEventArgs);

            this.disableAnimation();
            this.model.legendCollapsed = false;
            this.redraw(true);

            this._enableZoomingButtons();
        },
        _getZoomedData: function (chart) {
            //Getting zoomed region data when zoomedData event fired                    
            var series = this.model._visibleSeries;
            var seriesLength = series.length;
            var zoomedData = [];
            var selectedData = [];
            var points = [];
            var type;
            var axisValueType;
            var xVisibleRange;
            var yVisibleRange;
            var pointsLength;
            for (var j = 0; j < seriesLength; j++) {
                if (series[j].visibility == "visible") {
                    points = series[j].points;
                    pointsLength = points.length;
                    type = series[j].type.toLowerCase();
                    axisValueType = new sf.axisTypes[series[j].xAxis._valueType.toLowerCase()]();
                    axisValueType._calculateVisibleRange(series[j].xAxis, chart);
                    axisValueType = new sf.axisTypes[series[j].yAxis._valueType.toLowerCase()]();
                    axisValueType._calculateVisibleRange(series[j].yAxis, chart);
                    xVisibleRange = series[j].xAxis.visibleRange;
                    yVisibleRange = series[j].yAxis.visibleRange;
                    for (var k = 0; k < pointsLength; k++) {
                        if ((xVisibleRange.min <= points[k].xValue && xVisibleRange.max >= points[k].xValue) && (yVisibleRange.min <= points[k].y && yVisibleRange.max >= points[k].y)) {
                            if (series[j]._hiloTypes) {
                                if (type == "rangearea" || type == "rangecolumn" || type == "waterfall" || type == "hilo")
                                    zoomedData.push({ XValue: points[k].x, High: points[k].high, Low: points[k].low });
                                else
                                    zoomedData.push({ XValue: points[k].x, High: points[k].high, Low: points[k].low, Open: points[k].open, Close: points[k].close });
                            }
                            else
                                zoomedData.push({ XValue: points[k].x, YValue: points[k].y });
                        }
                    }
                }
                if (zoomedData.length != 0)
                    selectedData.push({ selectedData: zoomedData });
                zoomedData = [];
            }
            return selectedData;
        },
        _cursorToDefault: function () {
            var id = "#" + this.svgObject.id;
            this.svgRenderer._setAttr($(this.svgObject).find(id + "_XAxis," + id + "_ChartArea," + id + "_YAxis," + id + "_SeriesCollection," + id + "_StriplineBehind," + id + '_StriplineOver'), { "cursor": "default" });
        },
        _cursorToPointer: function () {
            var id = "#" + this.svgObject.id;
            this.svgRenderer._setAttr($(this.svgObject).find(id + "_XAxis," + id + "_ChartArea," + id + "_YAxis," + id + "_SeriesCollection," + id + "_StriplineBehind," + id + '_StriplineOver'), { "cursor": "pointer" });
        },
        //to remove the select region on redraw
        removeMultiRect: function () {
            $(this.parentgEle).empty();
            this.model.selectedDataCollection = [];
        },
        multiSelectDataCalculation: function () {
            var chart = this, selectedData = [], selectedRectIndex = this.selectedRectIndex,
                rectX = this.oldRectX[selectedRectIndex],
                rectY = this.oldRectY[selectedRectIndex],
                rectWidth = this.oldRectWidth[selectedRectIndex],
                rectHeight = this.oldRectHeight[selectedRectIndex],
                selectFactor = 1,
                selectPosition = 0,
                seriesCollection = this.model.series,
                seriesCollectionLength = seriesCollection.length,
                axes = this.multiAxis,
                axesLength = axes.length,
                multiSelectType = this.multiSelectType,
                axis, previousSelectFactor, previousSelectPosition,
                xMin, xMax, yMin, yMax,
                visiblePoints, type, baseRange,
                start, end, isEmpty, xOriginalVisibleRange, yOriginalVisibleRange,
                areaType = this.model.AreaType.toLowerCase(),
                xValue, y, isInversed, stackYValue,
                isTransposed, selectionSettings, series;
            for (var i = 0; i < seriesCollectionLength; i++) {
                series = seriesCollection[i];
                xOriginalVisibleRange = series.xAxis.visibleRange;
                yOriginalVisibleRange = series.yAxis.visibleRange;
                var xAxisName = axes.some((function (val) {
                    return val.name.toLowerCase() == series._xAxisName.toLowerCase();
                }));
                var yAxisName = axes.some((function (val) {
                    return val.name.toLowerCase() == series._yAxisName.toLowerCase();
                }));

                selectionSettings = series.selectionSettings;
                if ((xAxisName && yAxisName) && series.visibility.toLowerCase() == 'visible') {
                    for (var k = 0; k < axesLength; k++) {
                        axis = axes[k];
                        previousSelectFactor = selectFactor;
                        previousSelectPosition = selectPosition;
                        if (axis.orientation.toLowerCase() == "horizontal") {
                            this.selectFactor = selectionSettings.rangeType.toLowerCase() != "y"
                                ? previousSelectFactor * (rectWidth / (this.multiAxis[k].width)) : selectFactor;
                            this.selectPosition = selectionSettings.rangeType.toLowerCase() != "y"
                                ? previousSelectPosition + Math.abs((rectX - this.multiAxis[k].x) / (this.multiAxis[k].width)) * previousSelectFactor : selectPosition;
                            if (parseFloat(selectFactor.toFixed(3)) <= 0.001) {
                                this.selectFactor = previousSelectFactor;
                                this.selectPosition = previousSelectPosition;
                            }
                        }
                        else {
                            this.selectFactor = selectionSettings.rangeType.toLowerCase() != "x"
                                ? previousSelectFactor * rectHeight / this.multiAxis[k].height : selectFactor;
                            this.selectPosition = selectionSettings.rangeType.toLowerCase() != "x"
                                ? previousSelectPosition + (1 - Math.abs((rectHeight + (rectY - this.multiAxis[k].y)) / (this.multiAxis[k].height))) * previousSelectFactor : selectPosition;
                            if (parseFloat(selectFactor.toFixed(3)) <= 0.001) {
                                this.selectFactor = previousSelectFactor;
                                this.selectPosition = previousSelectPosition;
                            }
                        }
                        axis.visibleRange = $.extend(true, {}, axis.actualRange);
                        if (this.selectFactor < 1 || this.selectPosition > 0) {
                            if (axis.valueType == "logarithmic") baseRange = axis.visibleRange;
                            else baseRange = axis.actualRange;
                            this.selectFactor = this.selectFactor > 1 ? 1 : (this.selectFactor < 0 ? 0 : this.selectFactor);
                            this.selectPosition = this.selectPosition < 0 ? 0 : (this.selectPosition > 1 ? 1 : this.selectPosition);
                            if (axis.isInversed) {
                                start = axis.actualRange.max - this.selectPosition * axis.actualRange.delta;
                                end = start - this.selectFactor * axis.actualRange.delta;
                                isInversed = true;
                            }
                            else {
                                start = axis.actualRange.min + this.selectPosition * axis.actualRange.delta;
                                end = start + this.selectFactor * axis.actualRange.delta;
                            }
                            if (start < baseRange.min) {
                                end = end + (baseRange.min - start);
                                start = baseRange.min;
                            }
                            if (end > baseRange.max) {
                                start = start - (end - baseRange.max);
                                end = baseRange.max;
                            }
                            if (axis.valueType == "logarithmic") {
                                start = Math.pow(10, start);
                                end = Math.pow(10, end);
                            }
                            axis.visibleRange.min = Math.min(start, end);
                            axis.visibleRange.max = Math.max(start, end);
                        }
                    }
                    visiblePoints = series._visiblePoints;
                    type = series.type.toLowerCase(), isTransposed = series.isTransposed;
                    xMin = series.xAxis.visibleRange.min; xMax = series.xAxis.visibleRange.max;
                    yMin = series.yAxis.visibleRange.min; yMax = series.yAxis.visibleRange.max;
                    if (sf.util.isNullOrUndefined(selectedData)) selectedData = [];
                    if (series.selectionSettings.enable) {
                        switch (multiSelectType) {
                            case 'x':
                                for (var k = 0; k < visiblePoints.length; k++) {
                                    visiblePoints[k].seriesIndex = i;
                                    isEmpty = visiblePoints[k].isEmpty;
                                    xValue = visiblePoints[k].xValue;
                                    y = visiblePoints[k].y;
                                    if (series.xAxis.isInversed || series.yAxis.isInversed) {
                                        if (type.indexOf('bar') >= 0) {
                                            if (type.indexOf('stacking') >= 0) {
                                                stackYValue = series.stackedValue.EndValues[k];
                                                if (!isEmpty && yMax >= stackYValue && yMin <= stackYValue)
                                                    selectedData.push(visiblePoints[k]);
                                            }
                                            else {
                                                if (type == 'waterfall' && !isEmpty && yMax >= visiblePoints[k].YValues[0] && yMin <= visiblePoints[k].YValues[0])
                                                    selectedData.push(visiblePoints[k]);
                                                else if (!isEmpty && yMax >= y && yMin <= y)
                                                    selectedData.push(visiblePoints[k]);
                                            }
                                        }
                                        else {
                                            if (!isEmpty && xMax >= xValue && xMin <= xValue)
                                                selectedData.push(visiblePoints[k]);
                                        }
                                    }
                                    else {
                                        if (isTransposed && (type.indexOf('bar') >= 0)) {
                                            if (!isEmpty && xMin <= xValue && xMax >= xValue)
                                                selectedData.push(visiblePoints[k]);
                                        }
                                        else if ((type.indexOf('bar') >= 0) || ((series.isTransposed) && (!(type.indexOf('bar') >= 0)))) {
                                            if (type.indexOf('stacking') >= 0) {
                                                stackYValue = series.stackedValue.EndValues[k];
                                                if (!isEmpty && yMin <= stackYValue && yMax >= stackYValue)
                                                    selectedData.push(visiblePoints[k]);
                                            }
                                            else {
                                                if (type == 'waterfall' && !isEmpty && yMin <= visiblePoints[k].YValues[0] && yMax >= visiblePoints[k].YValues[0])
                                                    selectedData.push(visiblePoints[k]);
                                                else if (!isEmpty && yMin <= y && yMax >= y)
                                                    selectedData.push(visiblePoints[k]);
                                            }
                                        }
                                        else {
                                            if (!isEmpty && Math.round(xMin) <= xValue && xMax >= xValue)
                                                selectedData.push(visiblePoints[k]);
                                        }
                                    }
                                }
                                break;
                            case 'y':
                                for (var k = 0; k < visiblePoints.length; k++) {
                                    visiblePoints[k].seriesIndex = i;
                                    isEmpty = visiblePoints[k].isEmpty;
                                    xValue = visiblePoints[k].xValue;
                                    y = visiblePoints[k].y;
                                    if (series.xAxis.isInversed || series.yAxis.isInversed) {
                                        if (type.indexOf('bar') >= 0) {
                                            if (!isEmpty && xMax >= xValue && xMin <= xValue)
                                                selectedData.push(visiblePoints[k]);
                                        }
                                        else {
                                            if (type.indexOf('stacking') >= 0) {
                                                stackYValue = series.stackedValue.EndValues[k];
                                                if (!isEmpty && yMin <= stackYValue && yMax >= stackYValue)
                                                    selectedData.push(visiblePoints[k]);
                                            }
                                            else {
                                                if (type == 'waterfall' && !isEmpty && yMax >= visiblePoints[k].YValues[0] && yMin <= visiblePoints[k].YValues[0])
                                                    selectedData.push(visiblePoints[k]);
                                                else if (!isEmpty && yMax >= y && yMin <= y)
                                                    selectedData.push(visiblePoints[k]);
                                            }
                                        }
                                    }
                                    else {
                                        if (isTransposed && (type.indexOf('bar') >= 0)) {
                                            if (type.indexOf('stacking') >= 0) {
                                                stackYValue = series.stackedValue.EndValues[k];
                                                if (!isEmpty && yMin <= stackYValue && yMax >= stackYValue)
                                                    selectedData.push(visiblePoints[k]);
                                            }
                                            else {
                                                if (type == 'waterfall' && !isEmpty && yMin <= visiblePoints[k].YValues[0] && yMax >= visiblePoints[k].YValues[0])
                                                    selectedData.push(visiblePoints[k]);
                                                else if (!isEmpty && yMin <= y && yMax >= y)
                                                    selectedData.push(visiblePoints[k]);
                                            }
                                        }
                                        else if ((type.indexOf('bar') >= 0) || ((series.isTransposed) && (!(type.indexOf('bar') >= 0)))) {
                                            if (!isEmpty && xMin <= xValue && xMax >= xValue)
                                                selectedData.push(visiblePoints[k]);
                                        }
                                        else {
                                            if (type.indexOf('stacking') >= 0) {
                                                stackYValue = series.stackedValue.EndValues[k];
                                                if (!isEmpty && yMin <= stackYValue && yMax >= stackYValue)
                                                    selectedData.push(visiblePoints[k]);
                                            }
                                            else {
                                                if (type == 'waterfall' && !isEmpty && yMin <= visiblePoints[k].YValues[0] && yMax >= visiblePoints[k].YValues[0])
                                                    selectedData.push(visiblePoints[k]);
                                                else if (!isEmpty && yMin <= y && yMax >= y)
                                                    selectedData.push(visiblePoints[k]);
                                            }
                                        }
                                    }
                                }
                                break;
                            case 'xy':
                                for (var k = 0; k < visiblePoints.length; k++) {
                                    visiblePoints[k].seriesIndex = i;
                                    isEmpty = visiblePoints[k].isEmpty;
                                    xValue = visiblePoints[k].xValue;
                                    y = visiblePoints[k].y;
                                    if (type.indexOf('stacking') >= 0) {
                                        stackYValue = series.stackedValue.EndValues[k];
                                        if (!isEmpty && xMax >= xValue && xMin <= xValue && yMin <= stackYValue && yMax >= stackYValue)
                                            selectedData.push(visiblePoints[k]);
                                    }
                                    else {
                                        if (type == 'waterfall' && !isEmpty && xMax >= xValue && xMin <= xValue && yMin <= visiblePoints[k].YValues[0] && yMax >= visiblePoints[k].YValues[0])
                                            selectedData.push(visiblePoints[k]);
                                        else if (!isEmpty && xMax >= xValue && Math.round(xMin) <= xValue && yMin <= y && yMax >= y)
                                            selectedData.push(visiblePoints[k]);
                                    }
                                }
                                break;
                        }
                    }
                }
                series.xAxis.visibleRange = xOriginalVisibleRange;
                series.yAxis.visibleRange = yOriginalVisibleRange;
            }
            var currentIndex = this.currentIndex;
            if (sf.util.isNullOrUndefined(this.model.selectedDataCollection) || $("#" + this.svgObject.id + "_rectSelectionGroup").length == 0)
                this.model.selectedDataCollection = [];
            if (this.removeRect) this.model.selectedDataCollection.splice(currentIndex, 1);
            else if (this.rectPan || this.resize) {
                this.model.selectedDataCollection[currentIndex] = 0;
                this.model.selectedDataCollection[currentIndex] = selectedData;
            }
            else this.model.selectedDataCollection[this.model.selectedDataCollection.length] = selectedData;
            //trigger rangeSelected event to get the selected region's data
            var commonloadEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonloadEventArgs.data = {};
            commonloadEventArgs.data.selectedData = selectedData;
            commonloadEventArgs.data.selectedDataCollection = this.model.selectedDataCollection;
            this._trigger("rangeSelected", commonloadEventArgs);
        },
        multiSelectMouseUp: function (evt) {
            if (this._isMultiSelect && (this.multiSelectMode == 'range')) {
                var selectRectWidth, selectRectHeight, selectRectX, selectRectY, cx, cy, index,
                    containerSvg = this.svgObject.id, selectedRectIndex = this.selectedRectIndex,
                    selectRectId = "#" + containerSvg + "_selectRect",
                    selectRectWidth = parseInt($(selectRectId + selectedRectIndex).attr("width")),
                    selectRectHeight = parseInt($(selectRectId + selectedRectIndex).attr("height")),
                    selectRectX = parseInt($(selectRectId + selectedRectIndex).attr("x")),
                    selectRectY = parseInt($(selectRectId + selectedRectIndex).attr("y"));
                if ((this.multiSelectDraw || !this.removeRect || !this.resize || !this.rectPan) && (selectRectWidth > 0 && selectRectHeight > 0)) {
                    var rightRectOptions = {
                        'id': containerSvg + '_resize_rightRect' + selectedRectIndex,
                        'x': selectRectX + selectRectWidth - 5,
                        'y': selectRectY + 10,
                        'width': 10,
                        'height': selectRectHeight - 20 > 0 ? selectRectHeight - 20 : 0,
                        'fill': "transparent",
                        'stroke': "transparent",
                        'stroke-width': 2,
                        'cursor': 'e-resize'
                    };
                    this.svgRenderer.drawRect(rightRectOptions, this.gEle);
                    var bottomRectOptions = {
                        'id': containerSvg + '_resize_bottomRect' + selectedRectIndex,
                        'x': selectRectX,
                        'y': selectRectY + selectRectHeight - 5,
                        'width': selectRectWidth - 10 > 0 ? selectRectWidth - 10 : 0,
                        'height': 10,
                        'fill': "transparent",
                        'stroke': "transparent",
                        'stroke-width': 2,
                        'cursor': 's-resize'
                    };
                    this.svgRenderer.drawRect(bottomRectOptions, this.gEle);
                    var leftRectOptions = {
                        'id': containerSvg + '_resize_leftRect' + selectedRectIndex,
                        'x': selectRectX - 5,
                        'y': selectRectY,
                        'width': 10,
                        'height': selectRectHeight,
                        'fill': "transparent",
                        'stroke': "transparent",
                        'stroke-width': 2,
                        'cursor': 'w-resize'
                    };
                    this.svgRenderer.drawRect(leftRectOptions, this.gEle);
                    var topRectOptions = {
                        'id': containerSvg + '_resize_topRect' + selectedRectIndex,
                        'x': selectRectX,
                        'y': selectRectY - 5,
                        'width': selectRectWidth - 10 > 0 ? selectRectWidth - 10 : 0,
                        'height': 10,
                        'fill': "transparent",
                        'stroke': "transparent",
                        'stroke-width': 2,
                        'cursor': 'n-resize'
                    };
                    this.svgRenderer.drawRect(topRectOptions, this.gEle);
                    var bottomRightCornerCircleOptions = {
                        'id': containerSvg + '_resize_bottomRightCornerCircle' + selectedRectIndex,
                        'cx': selectRectX + selectRectWidth,
                        'cy': selectRectY + selectRectHeight,
                        'r': 10,
                        'fill': "transparent",
                        'stroke': "transparent",
                        'stroke-width': 2,
                        'cursor': 'se-resize'
                    };
                    this.svgRenderer.drawCircle(bottomRightCornerCircleOptions, this.gEle);
                    var topRightCornerCircleOptions = {
                        'id': containerSvg + '_closeTopRightCornerCircle' + selectedRectIndex,
                        'cx': selectRectX + selectRectWidth,
                        'cy': selectRectY,
                        'r': 10,
                        'fill': "white",
                        'stroke': "#2988d6",
                        'stroke-width': 2,
                        'cursor': 'pointer'
                    };
                    this.svgRenderer.drawCircle(topRightCornerCircleOptions, this.gEle);
                    var closingPathOptions = {
                        'id': containerSvg + '_closePath' + selectedRectIndex,
                        'x1': selectRectX + selectRectWidth - 4,
                        'y1': selectRectY - 4,
                        'x2': selectRectX + selectRectWidth + 4,
                        'y2': selectRectY + 4,
                        'stroke': "#2988d6",
                        'stroke-width': 2,
                        'cursor': 'pointer'
                    };
                    this.svgRenderer.drawLine(closingPathOptions, this.gEle);
                    var closingPathOppositeOptions = {
                        'id': containerSvg + '_closePathOpposite' + selectedRectIndex,
                        'x1': selectRectX + selectRectWidth + 4,
                        'y1': selectRectY - 4,
                        'x2': selectRectX + selectRectWidth - 4,
                        'y2': selectRectY + 4,
                        'stroke': "#2988d6",
                        'stroke-width': 2,
                        'cursor': 'pointer'
                    };
                    this.svgRenderer.drawLine(closingPathOppositeOptions, this.gEle);
                    cx = [16, 10, 4, 10, 4, 4];
                    cy = [4, 4, 4, 10, 10, 16];
                    index = ["a", "b", "c", "d", "e", "f"];
                    for (var t = 0; t < 6; t++) {
                        var gripOptions = {
                            'id': containerSvg + '_gripCircle_' + index[t] + selectedRectIndex,
                            'cx': selectRectX + selectRectWidth - cx[t],
                            'cy': selectRectY + selectRectHeight - cy[t],
                            'r': 0.4,
                            'stroke': "#5B5B5B",
                            'stroke-width': 2,
                        }
                        this.svgRenderer.drawCircle(gripOptions, this.gripCollection);
                    }
                    if ((this.gripCollection != null))
                        $(this.gripCollection).appendTo(this.gEle);
                    $("#" + containerSvg + "_gripCollection" + selectedRectIndex).css({ 'visibility': 'hidden' });
                }
                if (sf.util.isNullOrUndefined(this.oldRectX)) {
                    this.oldRectX = []; this.oldRectY = []; this.oldRectWidth = []; this.oldRectHeight = [];
                    this.oldReRightRectX = []; this.oldReTopRectY = []; this.oldReBottomRectY = [];
                }
                this.oldRectX[selectedRectIndex] = parseInt($(selectRectId + selectedRectIndex).attr('x'));
                this.oldRectY[selectedRectIndex] = parseInt($(selectRectId + selectedRectIndex).attr('y'));
                this.oldRectWidth[selectedRectIndex] = parseInt($(selectRectId + selectedRectIndex).attr('width'));
                this.oldRectHeight[selectedRectIndex] = parseInt($(selectRectId + selectedRectIndex).attr('height'));
                this.oldReRightRectX[selectedRectIndex] = parseInt($("#" + containerSvg + "_resize_rightRect" + selectedRectIndex).attr('x'));
                this.oldReTopRectY[selectedRectIndex] = parseInt($("#" + containerSvg + "_resize_topRect" + selectedRectIndex).attr('y'));
                this.oldReBottomRectY[selectedRectIndex] = parseInt($("#" + containerSvg + "_resize_bottomRect" + selectedRectIndex).attr('y'));
                this.oldMultiSelectType = this.multiSelectType;
                if (this.resize || this.rectPan) {
                    //to remove the grip after resizing at the bottom right corner
                    if (this.resize)
                        $("#" + this.svgObject.id + "_gripCollection" + selectedRectIndex).attr({ 'transform': "" });
                    $("#" + containerSvg + "_closeTopRightCornerCircle" + selectedRectIndex).css({ 'display': 'inline' });
                    $("#" + containerSvg + "_closePath" + selectedRectIndex).css({ 'display': 'inline' });
                    $("#" + containerSvg + "_closePathOpposite" + selectedRectIndex).css({ 'display': 'inline' });
                    $("#" + containerSvg + '_resize_rightRect' + selectedRectIndex).css({ 'cursor': 'e-resize' });
                    $("#" + containerSvg + '_resize_leftRect' + selectedRectIndex).css({ 'cursor': 'w-resize' });
                    $("#" + containerSvg + '_resize_bottomRect' + selectedRectIndex).css({ 'cursor': 's-resize' });
                    $("#" + containerSvg + '_resize_topRect' + selectedRectIndex).css({ 'cursor': 'n-resize' });
                }
                this.drag = false;
                if (this.removeRect) {
                    $("#" + containerSvg + "_selectedRectGroup" + selectedRectIndex).remove();
                    if (this.parentgEle.childNodes.length <= 0) $(this.parentgEle).remove();
                }
                if ((this.multiSelectDraw || this.removeRect || this.resize || this.rectPan) && (selectRectWidth > 0 && selectRectHeight > 0)) {
                    this.multiSelectDraw = false;
                    this.multiSelectDataCalculation(evt);
                }
                if (this.resize) this.resize = false;
                if (this.rectPan) this.rectPan = false;
                this.removeRect = false;
                this.enableTrackBall();
            }
        },
        chartMouseUp: function (evt) {
            if (this.isTouch(evt)) {
                this.model.touchCross = false;
                this.chartMouseUpTouch(evt);
            }
            if (!this.currentPageX && this.panning) {
                var mouseDownCords = this.calMousePosition(evt);
                this.currentPageX = mouseDownCords.X;
                this.currentPageY = mouseDownCords.Y;
            }

            var chart = this;
            var model = this.model;
            this.mousedownPointX = this.mousedownPointY = null;
            $("[id*=" + "_PreviewSeries" + "]").remove();
            $("[id*=" + "_Marker" + "]").remove();
            if (chart.dragPoint) {
                var i = this.dragIndex.seriesIndex,
                    chartSeries = model._visibleSeries[i];
                if (!this.model.enableCanvasRendering) {
                    if (this.gPreviewSeriesGroupEle) {
                        $(this.svgObject).find("#" + this.svgObject.id + "_PreviewSeriesGroup_" + i).remove();
                        if (this.gPreviewSeriesGroupEle.childNodes.length > 0)
                            this.gPreviewSeriesGroupEle.removeChild(this.gPreviewSeriesGroupEle.childNodes[0]);
                    }
                }
                var commonDragEventArgs, valAxis, srIndex, ptIndex;
                this.dragPoint = chartSeries.dragPoint = false;
                var draggedPoints = this._getDraggedPoint(chartSeries, this.mousemoveX, this.mousemoveY),
                    xPoint = draggedPoints.X,
                    yPoint = draggedPoints.Y;
                srIndex = chartSeries.data.seriesIndex,
                    ptIndex = chartSeries.data.pointIndex;

                var oldValue = { X: this.commonDragEventArgs.data.oldValue.X, Y: this.commonDragEventArgs.data.oldValue.Y },
                    newValue = { X: xPoint, Y: yPoint };
                commonDragEventArgs = $.extend({}, this.commonDragEventArgs);
                commonDragEventArgs.data = { series: chartSeries, seriesIndex: srIndex, pointIndex: ptIndex, oldValue: oldValue, newValue: newValue };
                this._trigger("dragEnd", commonDragEventArgs);
                chart.commonDragEventArgs = commonDragEventArgs;
                chart._changeDraggingPoints(chartSeries, ptIndex, commonDragEventArgs.data.newValue.X, commonDragEventArgs.data.newValue.Y);
                chartSeries.region = null;
                this.redraw();		// to redraw the chart after changing the points  
            }
            if (this.multiSelectAreaType == 'cartesianaxes' && (!model.zooming.enable) && (!model.enableCanvasRendering))
                this.multiSelectMouseUp(evt);
            var chart = this;
            if (model.zooming.enable && model.AreaType == "cartesianaxes") {
                var zoomRect = $("#" + this.svgObject.id + "_ZoomArea");
                if (zoomRect[0]) {
                    if (model.enableCanvasRendering) {
                        var zoomArea = zoomRect[0].getClientRects()[0];
                        var zoomRectWidth = zoomArea.width;
                        var zoomRectHeight = zoomArea.height;
                    } else {
                        var $zoomRect = $(zoomRect);
                        var zoomRectWidth = parseFloat(this.svgRenderer._getAttrVal($zoomRect, "width"));
                        var zoomRectHeight = parseFloat(this.svgRenderer._getAttrVal($zoomRect, "height"));
                    }
                }
                if (zoomRectWidth > 0 && zoomRectHeight > 0) {
                    chart.doZoom(zoomRect, zoomRectWidth, zoomRectHeight);
                }
                else
                    this.drag = false;
                if (!chart.panning)
                    this.enableTrackBall();
            }
            // Panning is done on mouse up for other devices and when deferredZoom is set to true
            var id = this.svgObject.id;
            var parentId = sf.util.isNullOrUndefined(evt.target.parentNode) ? "" : evt.target.parentNode.id;

            //condition to find the buttons
            if (parentId == id + "_ResetZoom" || parentId == id + '_ZoomBtn' || evt.target.id == id + "_ResetZoom" || evt.target.id == id + '_ZoomBtn') {
                this.panning = false;
                this.model._chartAreaZoom = false;
            }

            //Panning for other devices
            if ((sf.isTouchDevice() || model.zooming.enableDeferredZoom) && this.panning && this.doPan && model.AreaType == "cartesianaxes") {
                var oDelta, panStartEventArgs, panEndEventArgs, $proxy;
                oDelta = {
                    'x': this.oPreviousCoords.x - this.currentPageX,
                    'y': this.oPreviousCoords.y - this.currentPageY
                };

                this.oPreviousCoords = {
                    'x': this.currentPageX,
                    'y': this.currentPageY
                };
                $.each(model._axes, function (index, axis) {
                    var currentScale = Math.max(1 / sf.EjSvgRender.utils._minMax(axis.zoomFactor, 0, 1), 1);
                    chart.translate(axis, (oDelta.x), (oDelta.y), currentScale);
                });
                this.model.legendCollapsed = false;
                panEndEventArgs = panStartEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs),
                    $proxy = this;

                panStartEventArgs.data = { model: this.model };
                this._trigger("panStart", panStartEventArgs);

                //setTimeout is necessary to show waiting popup
                window.setTimeout(function () {
                    $proxy.redraw(true, true, evt.target); //to avoid touch event termination in mobiles / deferred pan           
                    $proxy._cursorToPointer();
                    $proxy._enableZoomingButtons();
                    panEndEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                    panEndEventArgs.data = { model: $proxy.model };
                    $proxy._trigger("panEnd", panEndEventArgs);
                }, 10);
            }

            if (this.doPan)
                this.doPan = false;

            this.rotateActivate = false;
        },
        multiSelectMouseDown: function (evt) {
            this.multiSelectAreaType = this.model.AreaType.toLowerCase();
            var model = this.model, chartX = model.m_AreaBounds.X, chartWidth = model.m_AreaBounds.Width,
                chartY = model.m_AreaBounds.Y, chartHeight = model.m_AreaBounds.Height, mouseDownCords = this.calMousePosition(evt);
            //to check whether the click is made within the chart area
            if (this.multiSelectAreaType == 'cartesianaxes' && (!model.zooming.enable) && (!model.enableCanvasRendering)
                && mouseDownCords.X >= chartX && mouseDownCords.X < (chartX + chartWidth) && mouseDownCords.Y < (chartY + chartHeight) && mouseDownCords.Y >= chartY) {
                var seriesCollection = this.model.series,
                    seriesCollectionLength = seriesCollection.length,
                    id, mouseDownCords, matchStr,
                    containerSvg = this.svgObject.id,
                    selectMode = seriesCollection.some((function (val) {
                        return val.selectionSettings.mode.toLowerCase() == 'range';
                    }));
                this._isMultiSelect = seriesCollection.some((function (val) {
                    return val.selectionSettings.enable == true && val.selectionSettings.mode.toLowerCase() == "range";
                }));
                if (selectMode) this.multiSelectMode = 'range';
                for (var i = 0; i < seriesCollectionLength; i++) {
                    if ((seriesCollection[i].selectionSettings.enable == true) && (seriesCollection[i].selectionSettings.mode.toLowerCase() == 'range'))
                        this.multiSelectType = seriesCollection[i].selectionSettings.rangeType.toLowerCase();
                }
                if (this._isMultiSelect && this.multiSelectMode == 'range') {
                    this.disableTrackBall();
                    mouseDownCords = this.calMousePosition(evt);
                    this.mouseDownX = mouseDownCords.X;
                    this.mouseDownY = mouseDownCords.Y;
                    this.drag = true;
                    if (($(this.parentgEle).find("g").length < 1))
                        this.selectedRectIndex = 0;
                    else {
                        id = $(this.parentgEle).find("g").last().attr("id");
                        matchStr = containerSvg + "_gripCollection";
                        id = parseInt(id.substr(matchStr.length));
                        this.selectedRectIndex = id + 1;
                    }
                    if ($(this.parentgEle).find("g").length == 0) {
                        this.parentgEle = this.svgRenderer.createGroup({ 'id': containerSvg + '_rectSelectionGroup' });
                    }
                    this.gEle = this.svgRenderer.createGroup({ 'id': containerSvg + '_selectedRectGroup' + this.selectedRectIndex });
                    if ($(this.gripCollection).find("g").length == 0)
                        this.gripCollection = this.svgRenderer.createGroup({ 'id': containerSvg + '_gripCollection' + this.selectedRectIndex });
                    if (evt.target.id.indexOf("resize") >= 0) {
                        id = evt.target.id.split("resize")[1].match(/\d+/)[0];
                        this.selectedRectIndex = eval(id);
                    }
                    if (evt.target.id.indexOf("close") >= 0) {
                        id = evt.target.id.split("close")[1].match(/\d+/)[0];
                        this.selectedRectIndex = eval(id);
                    }
                    if ((evt.target.id.indexOf(this.svgObject.id + "_selectRect") >= 0)) {
                        matchStr = this.svgObject.id + "_selectRect";
                        this.selectedRectIndex = parseInt(evt.target.id.substr(matchStr.length));
                    }
                    this.currentIndex = $(evt.target.parentNode).index();
                    var axes = this.model._axes,
                        axesLength = axes.length, axis,
                        mouseMoveCords = this.calMousePosition(evt),
                        mouseMoveX = mouseMoveCords.X,
                        mouseMoveY = mouseMoveCords.Y;
                    this.multiAxis = []
                    for (var k = 0; k < axesLength; k++) {
                        axis = axes[k];
                        if ((mouseMoveX > axis.Location.X1) && (mouseMoveX < axis.Location.X2))
                            this.multiAxis.push(axis);
                        if ((mouseMoveY < axis.Location.Y1) && (mouseMoveY > axis.Location.Y2))
                            this.multiAxis.push(axis);
                    }
                }
            }
        },
        //Triggers while start dragging column or bar points
        _grab: function (chartSeries, chartObj, srIndex, ptIndex, point) {
            var commonDragEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonDragEventArgs.data = { seriesIndex: srIndex, pointIndex: ptIndex, currentPoint: point };
            chartObj._trigger("dragStart", commonDragEventArgs);
            chartSeries.data = commonDragEventArgs.data;
            this.commonDragEventArgs = commonDragEventArgs;
            this.mousedownPointX = this.mousedownPointY = null;
        },
        _enableDragging: function (chartSeries, seriesIndex, e) {
            var chartObj = this, closestXyPoint, data,
                type = chartSeries.type.toLowerCase(),
                areaType = chartObj.model.AreaType,
                visibility = chartSeries.visibility.toLowerCase();
            if (this.mousedownPointX && this.mousedownPointY && areaType == "cartesianaxes" && !this.model.enable3D && visibility == 'visible' && (type == "line" || type == "spline" || type == "area" ||
                type == "stepline" || type == "steparea" || type == "splinearea" || type == "column" || type == "bar" || type == "bubble" || type == "scatter")) {
                var serY = [], serX = [];
                closestXyPoint = this.getClosesPointXY(serX, serY, chartSeries, this.mousedownPointX, this.mousedownPointY, e);
                this.mousemoveX = this.mousedownPointX;
                this.mousemoveY = this.mousedownPointY;
                data = this.GetSeriesPoint(e);
                if (!sf.util.isNullOrUndefined(closestXyPoint.point)) {
                    this.dragPoint = chartSeries.dragPoint = true;
                    closestXyPoint.seriesIndex = seriesIndex;
                    chartSeries.pointData = closestXyPoint;
                    var point = { xValue: closestXyPoint.point.xValue, yValue: closestXyPoint.point.YValues };
                    chartObj._grab(chartSeries, chartObj, seriesIndex, closestXyPoint.index, point);
                    this.dragIndex = { pointIndex: closestXyPoint.index, seriesIndex: seriesIndex };
                }
                if (!sf.util.isNullOrUndefined(data)) {
                    var region = data.region;
                    if (seriesIndex == region.SeriesIndex) {
                        chartSeries.region = data.region;
                        this.dragPoint = chartSeries.dragPoint = true;
                        var xVal = chartSeries._visiblePoints[region.Region.PointIndex].xValue,
                            yVal = chartSeries._visiblePoints[region.Region.PointIndex].YValues,
                            point = { xValue: xVal, yValue: yVal };
                        chartObj._grab(chartSeries, chartObj, region.SeriesIndex, region.Region.PointIndex, point);
                        this.dragIndex = { pointIndex: region.Region.PointIndex, seriesIndex: region.SeriesIndex };
                    }
                }
            }
        },
        chartMouseDown: function (e) {

            //this.cancelEvent(e);   

            var model = this.model,
                matchStr = this._id + '_scrollbar' + '_',
                parentNodeId = (e.target.parentNode && e.target.parentNode.id) ? e.target.parentNode.id : '',
                selectionIndex = parentNodeId.indexOf(matchStr) > -1 ? parseInt(parentNodeId.substr(matchStr.length)) : NaN,
                isZoom = this.isZoomButtonHovered(e.target),
                axes = model._axes,
                chart = this, id,
                mouseDownCords = this.calMousePosition(e),
                browserInfo = this.model.browserInfo;
            this.mousedownPointX = mouseDownCords.X;
            this.mousedownPointY = mouseDownCords.Y;
            if ("which" in e)  // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
                this.chartRightClick = e.which == 3;
            else if ("button" in e)  // IE, Opera 
                this.chartRightClick = e.button == 2;
            if (!isNaN(selectionIndex) && !sf.util.isNullOrUndefined(selectionIndex))
                axes[selectionIndex].previousRange = $.extend(true, {}, model._axes[selectionIndex].visibleRange);

            this.mousemoveX = this.mouseDownX = mouseDownCords.X;
            this.mousemoveY = this.mouseDownY = mouseDownCords.Y;
            if (this.isTouch(e)) {
                this.model.event = e;
                this.model.touchCross = true;
                //this.cancelEvent(e);  
                if ($.finish)
                    $(this.model.trackerElement).finish();
                else
                    $(this.model.trackerElement).stop(true, true);
                this.model.tapNum = this.model.tapNum || 0;
                if (!isZoom)
                    this.doubleTap(e);
                if (chart.model.crosshair.visible && !isZoom) {
                    var timer = setTimeout(function () {
                        var zoom = $("#" + chart.svgObject.id).find("#" + chart.svgObject.id + '_ZoomArea'),
                            padding = chart.model.elementSpacing / 2,
                            pointer = chart.getEvent(chart.model.event), currX = pointer.pageX,
                            currY = pointer.pageY;
                        if (chart.model.touchCross && !chart.panning && Math.abs(currX - chart.model.cachedX) < padding && Math.abs(currY - chart.model.cachedY) < padding && (zoom.length == 0 || (parseFloat($(zoom).attr("width")) == 0 || parseFloat($(zoom).attr("height")) == 0))) {
                            chart.chartInteractiveBehavior(e);
                            chart.model.crosshairMoved = true;
                            chart.drag = false;
                        }


                    }, 500);

                }

            }

            if (this.model.enable3D && this.model.enableRotation)
                this.rotateActivate = true;

            if (!this.svgRenderer.vmlNamespace) {
                this.oPreviousCoords = {};
                if (e.target.id.indexOf("resize") >= 0) {
                    id = e.target.id.split("resize")[1].match(/\d+/)[0];
                    this.selectedRectIndex = eval(id);
                    this.multiSelectMouseDownId = e.target.id;
                    this.resize = true;
                }
                if (e.target.id.indexOf("close") >= 0) {
                    id = e.target.id.split("close")[1].match(/\d+/)[0];
                    this.selectedRectIndex = eval(id);
                    this.removeRect = true;
                }
                if ((e.target.id.indexOf(this.svgObject.id + "_selectRect") >= 0)) {
                    matchStr = this.svgObject.id + "_selectRect";
                    this.selectedRectIndex = parseInt(e.target.id.substr(matchStr.length));
                }
                if (e.target.id == this.svgObject.id + '_selectRect' + this.selectedRectIndex) {
                    this.rectPan = true;
                    this.PreviousCoords = {
                        'X': e.pageX, 'Y': e.pageY
                    }
                }
                if (!this.isTouch(e))
                    this.multiSelectMouseDown(e);
				var trans = this.getScaleValues(this);
				var areaBounds = $.extend(true, {}, this.model.m_AreaBounds),
					m_AreaBoundsX = areaBounds.X * trans.x,
					m_AreaBoundsY = areaBounds.Y * trans.y,
					m_AreaBoundsWidth = areaBounds.Width * trans.x,
					m_AreaBoundsHeight = areaBounds.Height * trans.y;
                var parent = this.svgRenderer._getAttrVal($(e.target).parent(), "id");
                var isZoomToolkit = parent != this.svgObject.id + "_ZoomBtn" && parent != this.svgObject.id + "_ZoomInBtn" && parent != this.svgObject.id + "_ZoomOutBtn" && parent != this.svgObject.id + "_ResetZoom" && parent != this.svgObject.id + "_PanBtn";
                if (isZoomToolkit && this.model.zooming.enable && !this.model.isLazyZooming && !(this.panning) && this.model.AreaType == "cartesianaxes") {

                    if (this.mouseDownX >= m_AreaBoundsX && this.mouseDownX < (m_AreaBoundsX + m_AreaBoundsWidth) && this.mouseDownY < (m_AreaBoundsY + m_AreaBoundsHeight) && this.mouseDownY >= m_AreaBoundsY && !this.isTouch(e)) {
                        if (isNaN(selectionIndex) || sf.util.isNullOrUndefined(selectionIndex))
                            this.drag = true;
                        this.disableTrackBall();
                    }


                }
                else if (isZoomToolkit && this.panning || $(e.target)[0].className == "e-hhandle e-box") {
                    var mousePanCords = this.calMousePosition(e);
                    this.mousePanX = mousePanCords.X;
                    this.mousePanY = mousePanCords.Y;
                    if (this.mousePanX >= m_AreaBoundsX && this.mousePanX < (m_AreaBoundsX + m_AreaBoundsWidth) && this.mousePanY < (m_AreaBoundsY + m_AreaBoundsHeight + 18) && this.mousePanY >= m_AreaBoundsY) {
                        this.doPan = true;

                    }
                }
                if (this.rotateActivate || this.doPan)
                    this.oPreviousCoords = {
                        'x': e.pageX,
                        'y': e.pageY
                    };
            }

        },
        chartMouseLeave: function (evt) {

            this.cancelEvent(evt);

            if (!this.isTouch(evt)) {
                // Changes the visibility to hidden

                $("[id*=" + "_TrackSymbol" + "]").remove();

                this._removeHighlight();

                this._removeTrackBall();

                $("#" + this.svgObject.id + "_TrackToolTip").hide();

                $("#" + this._id + "_tooltip").remove();
                if (($(".tooltipDiv" + this._id).hasClass(this.svgObject.id)))
                    $(".tooltipDiv" + this._id).remove();
            }



            // chartMouseLeave event           
            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY }, size: { height: this.model.svgHeight, width: this.model.svgWidth }, id: evt.target.id, pageX: evt.pageX, pageY: evt.pageY };
            this._trigger("chartMouseLeave", commonEventArgs);

        },


        _doClick: function (evt) {
            this.drag = false;
            if (!this.model.crosshairMoved)
                this._removeHighlight();
            if (!this.model.selectedDataPointIndexes)
                this.model.selectedDataPointIndexes = [];
            this.model.clusterPoints = [];
            this.model._isStateChaged = false;
            var seriesIndex, pointIndex, seriesLength, chartSeries, data, pointer = this.getEvent(evt),
                currX = pointer.pageX,
                currY = pointer.pageY,
                padding = 10,
                targetId = evt.target.id,
                svgObjectId = this.svgObject.id,
                seriesCollection = this.model._visibleSeries,
                isZoom = this.isZoomButtonHovered(evt.target),
                targetid = evt.target.id, name;

            //Set current seriesCollection Selection type for selection state maintains            
            seriesLength = seriesCollection.length;
            var isMultiSelection, mode, commonEventArgs, text, getIndex;
            data = this.GetSeriesPoint(evt);
            if (data) {
                seriesIndex = data.region.SeriesIndex;
                pointIndex = data.region.Region.PointIndex;
            } else {
                //Getting SeriesIndex and PointIndex for Path element type series when marker and dataLabels visible
                if (this.model.selectionEnable) {
                    if (!this.model.enable3D && !(evt.target.id.indexOf('LegendItem') != -1) && this.model.AreaType != 'none') {
                        text = evt.target.id;
                        getIndex = text.match(/(\d+)/g);
                        if (getIndex && (text.indexOf('symbol') != -1 || text.indexOf('Series') != -1) && !(text.indexOf('Text') != -1)) {
                            seriesIndex = parseInt(getIndex[0]);
                            pointIndex = isNaN(parseInt(getIndex[1])) ? 0 : parseInt(getIndex[1]);
                        } else if (getIndex && (text.indexOf('Text') != -1 || text.indexOf('dataLabel') != -1)) {
                            seriesIndex = parseInt(getIndex[0].charAt(1));
                            pointIndex = isNaN(parseInt(getIndex[0].charAt(0))) ? parseInt(getIndex[0].charAt(1)) : parseInt(getIndex[0].charAt(0));
                        }
                    }
                }
            }
            if (!isZoom || this.model.enableCanvasRendering) {
                for (var i = 0; i < this.model._visibleSeries.length; i++) {
                    chartSeries = this.model._visibleSeries[i];
                    var type = chartSeries.type.toLowerCase();
                    if (this.model.AreaType == "cartesianaxes" && chartSeries.visibility.toLowerCase() == 'visible' && type !== "scatter" && type !== "bubble" && type !== "column" && type.indexOf("bar") == -1 && type !== "stackingcolumn" && type !== "stackingcolumn100" && !chartSeries._hiloTypes) {
                        var serY = [];
                        var serX = [];
                        var location = null;
                        var mouseMoveCords = this.calMousePosition(evt);
                        this.mousemoveX = mouseMoveCords.X;
                        this.mousemoveY = mouseMoveCords.Y;
                        var closestXyPoint = this.getClosesPointXY(serX, serY, chartSeries, this.mousemoveX, this.mousemoveY, evt);
                        if (!sf.util.isNullOrUndefined(closestXyPoint.point)) {
                            seriesIndex = i;
                            pointIndex = closestXyPoint.index;
                            var commonPointEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                            commonPointEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY }, region: { SeriesIndex: i, Region: { PointIndex: closestXyPoint.index } } };
                            this._trigger("pointRegionClick", commonPointEventArgs);
                        }
                    }
                }
                if (data && (!isZoom || this.model.enableCanvasRendering)) {
                    commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                    commonEventArgs.data = data;
                    this._trigger("pointRegionClick", commonEventArgs);
                }
            }

            if (this.model.AreaType == "none" && this.model.enable3D && $(evt.target)[0].nodeName == "path" && (!this.isTouch(evt) || (Math.abs(currX - this.model.cachedX) < padding && Math.abs(currY - this.model.cachedY) < padding))) {
                index = $(evt.target)[0].id.match(/(\d+)/g);
                seriesIndex = parseInt(index[index.length - 2]);
                pointIndex = parseInt(index[index.length - 1]);
                var currentexplodeindex = this.model._visibleSeries[seriesIndex].explodeIndex;
                var actualIndex = this.model._visibleSeries[seriesIndex]._visiblePoints[pointIndex].actualIndex;
                if (currentexplodeindex == actualIndex)
                    this.model._visibleSeries[seriesIndex].explodeIndex = null;
                else
                    this.model._visibleSeries[seriesIndex].explodeIndex = actualIndex;
                if (!this.vmlRendering && !this.model.enableCanvasRendering)
                    var selection = this.selectedStyle(this);
                $(this.svgObject).empty();
                $(this.legendSvgContainer).empty();
                this.draw();
                if (this.model.AreaType == 'none') {
                    this.model._isStateChaged = false;
                    var className, elementsLenth,
                        styleLength = selection.length,
                        pathId = "_Region_Series_" + seriesIndex + "_Point_" + pointIndex,
                        gElement = $(this.svgObject).find('[id$=' + pathId + '],[id*=' + pathId + 'back],[id*=' + pathId + 'front]'),
                        elementsLength = gElement.length;
                    for (var k = 0; k < styleLength; k++) {
                        for (var i = 0; i < elementsLength; i++) {
                            if (selection[k].id == gElement[i].id) {
                                className = selection[k].className;
                                if (className.indexOf('SelectionStyle') < 0 && (className.indexOf('Selection' + name + 'Style') < 0)) {
                                    $("[id=" + gElement[i].id + "]").attr('class', className);
                                }
                            }
                        }
                    }
                    if (selection.pattern)
                        this.svgRenderer.append(selection.pattern, this.svgObject);
                }
                else {
                    $('[id*=' + this.svgObject.id + '_LegendItemShape],[id*=_Region_Series_]').each(function () {
                        $(this).attr('class', '');
                    });
                }
            }
            var legenddata = this.getLegendData(evt);
            if (legenddata) {
                $('#template_group_' + this._id).remove();
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = legenddata;
                this._trigger("legendItemClick", commonEventArgs);
                var seriesIndex = legenddata.legendItem.LegendItem.SeriesIndex;
                // legend selection logic perform here
                if (!this.model.legend.toggleSeriesVisibility && legenddata.series.selectionSettings.enable) {
                    this.model._isStateChaged = false;
                    this.legendSelection(this, legenddata, evt, data);
                }
                if (!commonEventArgs.cancel && this.model.legend.toggleSeriesVisibility) {
                    $('[id*=' + this._id + '_Selection_' + ']').remove();
                    var length = this.model._visibleSeries.length;
                    if (this.model.AreaType != "none" || this.model.AreaType == "none" && type != 'pieofpie' && type != 'pyramid' && type != 'funnel' && length > 1) {
                        var seriesIndex = legenddata.legendItem.LegendItem.SeriesIndex;
                        var trendlineIndex = legenddata.legendItem.LegendItem.TrendLineIndex;
                        if (sf.util.isNullOrUndefined(trendlineIndex)) {
                            legenddata.series.visibility = legenddata.series.visibility.toLowerCase() === 'visible' ? 'hidden' : 'visible';
                            this.model.series[seriesIndex].visibility = legenddata.series.visibility;
                            if (this._notifyArrayChange)
                                this._notifyArrayChange("series[" + seriesIndex + "]visibility", legenddata.series.visibility);
                        } else {
                            var trendlineVisible = legenddata.series.trendlines[trendlineIndex].visibility.toLowerCase();
                            trendlineVisible = trendlineVisible === 'visible' ? 'hidden' : 'visible';
                            this.model.series[seriesIndex].trendlines[trendlineIndex].visibility = trendlineVisible;
                            if (this._notifyArrayChange)
                                this._notifyArrayChange("series[" + seriesIndex + "].trendlines[" + trendlineIndex + "].visibility", trendlineVisible);
                        }
                    }
                    else {
                        if (this.model._isPieOfPie) {
                            var point = this._getPieOfPiePoint(legenddata.legendItem.LegendItem.ActualIndex, legenddata.series, legenddata)._visibility;
                            var pointIndex = legenddata.legendItem.LegendItem.ActualIndex;
                        }
                        else {
                            var point = legenddata.series.visiblePoints[legenddata.legendItem.LegendItem.PointIndex]._visibility;
                            var pointIndex = legenddata.series.visiblePoints[legenddata.legendItem.LegendItem.PointIndex].actualIndex;
                        }
                        legenddata.series.points[pointIndex]._visibility = point === 'visible' ? 'hidden' : 'visible';
                    }
                    if (this.model.enableCanvasRendering) {
                        /** Canvas Chart image is cleared when click the legend item to show/hide the series**/
                        var chartRect = document.getElementById(this._id).getClientRects()[0];
                        this.svgRenderer.ctx.clearRect(0, 0, chartRect.width, chartRect.height);
                        //Canvas series marker element removed
                        $("#" + this._id).find('[id*="canvas_symbol"]').remove();
                    }
                    $(this.svgObject).empty();
                    $(this.legendSvgContainer).empty();
                    for (var j = 0; j < this.model.series.length; j++)
                        this.model.series[j].regionAdded = false;
                    this.model.legendCollapsed = true;
                    this.disableAnimation();
                    this.draw();
                    this.enableAnimation();
                    if (this.model.AreaType != "none" && this.zoomed)
                        this._enableZoomingButtons();
                }
            }

            //axisLabelClick event
            var axisData = this.getAxisLabelData(evt);
            if (axisData) {
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = axisData;
                this._trigger("axisLabelClick", commonEventArgs);

            }

            // multi level labels click event
            var labelData = this.getAxisMultiLevelLabelsData(evt);
            if (labelData) {
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = labelData;
                this._trigger("multiLevelLabelClick", commonEventArgs);
            }

            //annotationClick event
            if (targetid.indexOf("annotation_") >= 0) {
                var len = targetid.lastIndexOf("_");
                var str = targetid.substr(len + 1, targetid.length);
                var index = parseInt(str);
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY }, contentData: this.model.annotations[index], pageX: evt.pageX, pageY: evt.pageY };
                this._trigger("annotationClick", commonEventArgs);


            }

            //Selection started here
            var isSelectionSetting = !sf.isNullOrUndefined(seriesIndex) ? this.model._visibleSeries[seriesIndex].selectionSettings.enable : false;
            if (!sf.isNullOrUndefined(seriesIndex) && !legenddata && isSelectionSetting && (!this.isTouch(evt) || (!this.model.crosshairMoved && Math.abs(currX - this.model.cachedX) < padding && Math.abs(currY - this.model.cachedY) < padding))) {
                isMultiSelection = seriesCollection[seriesIndex].selectionSettings.type.toLowerCase() == 'multiple' ? true : false;
                mode = seriesCollection[seriesIndex].selectionSettings.mode;
                if (mode.toLowerCase() != 'range')
                    this.segmentSelection(evt, legenddata, seriesIndex, pointIndex, data, seriesCollection);
            }
            this.model.crosshairMoved = false;
            //chartClick event
            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY }, size: { height: this.model.svgHeight, width: this.model.svgWidth }, id: targetid, pageX: evt.pageX, pageY: evt.pageY };
            this._trigger("chartClick", commonEventArgs);

        },

        //Getting targetId when selection state changed by redraw,setmodel
        getTargetId: function (seriesIndex, pointIndex, mode) {
            var getSelectionId,
                type = this.model._visibleSeries[seriesIndex].type.toLowerCase(),
                isAreaType = (type.indexOf("area") != -1 || type.indexOf("line") != -1 || type.indexOf("scatter") != -1 ? true : false) ? true : false;
            if (this.model.enable3D)
                $("[id*=" + '_Region_Series_' + seriesIndex + '_Point_' + pointIndex + "]").each(function () {
                    getSelectionId = this.id;
                });
            else {
                if (mode != 'series' || this.model.AreaType == 'none')
                    !isAreaType ? $("[id$=" + this.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex + "]").each(function () {
                        getSelectionId = this.id;
                    }) : $("[id*=" + this.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex + '_symbol' + "]").each(function () {
                        getSelectionId = this.id;
                    });
                else
                    $("[id*=" + this.svgObject.id + '_Series' + seriesIndex + "]").each(function () {
                        getSelectionId = this.id;
                    });
            }
            return getSelectionId;
        },

        findCanvasSelection: function (seriesIndex, pointIndex, mode) {
            var isSelectionFound;
            if (mode == 'point')
                isSelectionFound = $('#' + this._id + '_Selection_series' + seriesIndex + '_point_' + pointIndex + '_canvas').length;
            else if (mode == 'series')
                isSelectionFound = $('#' + this._id + '_Selection_series' + seriesIndex + '_canvas').length;
            else
                isSelectionFound = $('#' + this._id + '_Selection_Cluster' + '_point_' + pointIndex + '_canvas').length;
            return isSelectionFound == 1 ? true : false;
        },

        //Selection logic started here
        segmentSelection: function (evt, legendData, seriesIndex, pointIndex, data) {
            var seriesCollection = this.model._visibleSeries,
                series = seriesCollection[seriesIndex];

            if (sf.isNullOrUndefined(series)) return 0;
            var selectionSettings = series.selectionSettings,
                isSelectionSettings = selectionSettings.enable,
                isMultiSelection = selectionSettings.type.toLowerCase() == 'multiple' ? true : false,
                mode = selectionSettings.mode,
                isTrackball = false, chart = this,
                targetId, parentNodeId, isSelectionFound, isElement, sIndex, pIndex, data, dataLength, seriesFlag, pointFlag, accPointFlag, clusterFlag, accSeriesClusterFlag, className;
            this.model.isSelected = true;
            //Calculating cluster points
            if (!sf.isNullOrUndefined(pointIndex) && mode == 'cluster') {
                var clusterPoints = [],
                    points, pointsLength,
                    xvalue = seriesCollection[seriesIndex]._visiblePoints[pointIndex].xValue;
                for (var i = 0, len = seriesCollection.length; i < len; i++) {
                    points = seriesCollection[i].points;
                    pointsLength = points.length;
                    for (var j = 0; j < pointsLength; j++)
                        if (xvalue == points[j].xValue && points[j].isEmpty == false && points[j].visible == true)
                            clusterPoints[clusterPoints.length] = { seriesIndex: i, pointIndex: j };
                }
                this.model.clusterPoints = clusterPoints;
            }

            //Get Target and parent node Id's by using seriesIndex and pointIndex
            if (!this.model.enableCanvasRendering) {
                targetId = this.getTargetId(seriesIndex, pointIndex, mode);
                if (targetId) {
                    parentNodeId = $('#' + targetId)[0].parentNode.id;
                    var parentNode = $('#' + parentNodeId)[0];
                    //Checking wether target parent or tracker symbols  present or not
                    if (parentNode != null) {
                        if (parentNodeId) {
                            isElement = (parentNodeId.indexOf(this.svgObject.id + "_TextGroup_") >= 0 || parentNodeId.indexOf(this.svgObject.id + "_symbolGroup") >= 0) ? true : false;
                            if (parentNodeId.indexOf(this.svgObject.id + "_TrackSymbol_") >= 0) {
                                isElement = true;
                                isTrackball = true;
                            }
                        }
                    }
                }
            }

            if (this.model.enableCanvasRendering)
                isSelectionFound = this.findCanvasSelection(seriesIndex, pointIndex, mode);
            else {
                className = $("#" + targetId).attr('class') ? $("#" + targetId).attr('class') : '';
                isSelectionFound = className.indexOf('Selection') != -1 ? true : false;
                if (this.model.enable3D) {
                    className = $("[id*=" + '_Region_Series_' + seriesIndex + '_Point_' + pointIndex + "]").attr('class') ? $("[id*=" + '_Region_Series_' + seriesIndex + '_Point_' + pointIndex + "]").attr('class') : '';
                    isSelectionFound = className.indexOf('Selection') != -1 ? true : false;
                }
            }
            //Selection Removal Logic 
            if ((isSelectionFound || !isMultiSelection) || isMultiSelection) {
                this.removeSelection(seriesIndex, pointIndex, seriesCollection, mode, isMultiSelection, legendData, isSelectionFound);
                data = this.model.selectedDataPointIndexes;
                dataLength = data.length;
                if (dataLength > 0 && !this.model._isStateChaged) {
                    if (!isMultiSelection) {
                        for (var k = 0; k < dataLength; k++) {
                            sIndex = data[k].seriesIndex;
                            pIndex = data[k].pointIndex;
                            seriesFlag = (mode == 'series' && ((sIndex == seriesIndex && pIndex == pointIndex) || (sIndex != seriesIndex || pIndex != pointIndex)));
                            accPointFlag = ((mode == 'point' || this.model.AreaType == 'none') && (sIndex == seriesIndex && pIndex == pointIndex));
                            clusterFlag = (mode == 'cluster' && (pIndex == pointIndex));
                            if (seriesFlag || accPointFlag || clusterFlag) {
                                data.splice(k, 1); dataLength = data.length; k = -1;
                            }
                        }
                    } else if (isSelectionFound) {
                        for (var k = 0; k < dataLength; k++) {
                            sIndex = data[k].seriesIndex;
                            pIndex = data[k].pointIndex;
                            seriesFlag = (mode == 'series' && (sIndex == seriesIndex));
                            accPointFlag = ((mode == 'point' || this.model.AreaType == 'none') && (sIndex == seriesIndex && pIndex == pointIndex));
                            clusterFlag = (mode == 'cluster' && (pIndex == pointIndex));
                            if (((seriesFlag || clusterFlag) && this.model.AreaType != 'none') || accPointFlag) {
                                data.splice(k, 1); dataLength = data.length; k = -1;
                            }
                        }
                    }
                }
            }
            //Selection Started for 2D,3D,Canvas
            if (!isSelectionFound) {
                this.model.enableCanvasRendering ? this.canvasSelection(this, evt, series, legendData, seriesIndex, pointIndex, data, selectionSettings) : this.selection(chart, evt, series, isTrackball, legendData, seriesIndex, pointIndex, parentNodeId, targetId, data);
                data = this.model.selectedDataPointIndexes;
                dataLength = data.length;
                if (!this.model._isStateChaged) {
                    if (dataLength > 0) {
                        if (!isMultiSelection) {
                            for (var k = 0; k < dataLength; k++) {
                                sIndex = data[k].seriesIndex;
                                pIndex = data[k].pointIndex;
                                accSeriesClusterFlag = ((mode == 'series' || mode == 'cluster' || this.model.AreaType == 'none') && (data[k].SeriesIndex != seriesIndex || data[k].PointIndex != pointIndex));
                                pointFlag = (mode == 'point' && (data[k].SeriesIndex == seriesIndex));
                                if (accSeriesClusterFlag || pointFlag) {
                                    data.splice(k, 1); dataLength = this.model.selectedDataPointIndexes.length; k = -1;
                                }
                            }
                            data.push({ 'legendData': legendData, 'seriesIndex': seriesIndex, 'pointIndex': pointIndex });
                        } else {
                            data.push({ 'legendData': legendData, 'seriesIndex': seriesIndex, 'pointIndex': pointIndex });
                        }
                    } else
                        data.push({ 'legendData': legendData, 'seriesIndex': seriesIndex, 'pointIndex': pointIndex });
                }
            }

            //Getting selected data here
            var selectedData = { selectedData: this.model.selectedDataPointIndexes };
            this._trigger("seriesRegionClick", selectedData);
        },


        //legend Selection logic perform here
        legendSelection: function (chart, legenddata, evt, data) {
            var selectedData = this.model.selectedDataPointIndexes ? this.model.selectedDataPointIndexes : [],
                length = this.model._visibleSeries.length,
                index = (chart.model.AreaType == 'none' && length == 1) ? legenddata.legendItem.LegendItem.PointIndex : legenddata.legendItem.LegendItem.SeriesIndex,
                seriesIndex = legenddata.legendItem.LegendItem.SeriesIndex,
                pointIndex = index,
                legendItem = chart.svgObject.id + '_LegendItemShape' + index,
                legendClass = $('#' + legendItem).attr('class') ? $('#' + legendItem).attr('class') : '';
            if ($('#' + chart._id + '_Selection_Legend' + index + '_canvas').length == 1 || legendClass.indexOf('Selection') != -1) {
                $('#' + chart._id + '_Selection_Legend' + index + '_canvas').remove();
                $("[id*=" + chart._id + '_Selection_series' + index + "]").remove();
                $('#' + this._id + '_Selection_series' + seriesIndex + '_point_' + pointIndex + '_canvas').remove();
                $('#' + legendItem).attr('class', '');
                $("[id*=" + chart.svgObject.id + '_Series' + seriesIndex + "]").attr('class', '');
                $("[id*=" + '_Region_Series_' + seriesIndex + "]").attr('class', '');
                for (var k = 0; k < selectedData.length; k++) {
                    if (selectedData[k].seriesIndex == index || (this.model.AreaType == 'none' && selectedData[k].pointIndex == index)) {
                        selectedData.splice(k, 1); break;
                    }
                }
            }
            else
                chart.segmentSelection(evt, legenddata, seriesIndex, pointIndex, data);
        },

        chartMouseClick: function (evt) {

            this.cancelEvent(evt);
            if (window.navigator.msPointerEnabled) {
                evt = evt.originalEvent;
            }
            this._doClick(evt);
        },
        chartMouseDoubleClick: function (evt) {


            if (window.navigator.msPointerEnabled) {
                evt = evt.originalEvent;
            }
            //chartDoubleClick event
            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY }, size: { height: this.model.svgHeight, width: this.model.svgWidth }, id: evt.target.id, pageX: evt.pageX, pageY: evt.pageY };
            this._trigger("chartDoubleClick", commonEventArgs);

        },
        drawTrackerSymbol: function (series, seriesIndex, ptIndex, tracker, point, id, trackcount) {

            var type = series.type.toLowerCase(), offsetX, offsetY;
            var chartSeriesObj = new sf.seriesTypes[type]();
            var index = series.type.toLowerCase() == "boxandwhisker" ? trackcount : ptIndex;
            var trans = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, this.model.requireInvertedAxes);
            offsetX = !series.isTransposed ? series.xAxis.plotOffset : series.yAxis.plotOffset;
            offsetY = !series.isTransposed ? series.yAxis.plotOffset : series.xAxis.plotOffset;
            var clipRectOptions = {
                'id': this.svgObject.id + '_ClipRectTrack' + '_' + seriesIndex,
                'x': - offsetX,
                'y': - offsetY,
                'width': trans.width + offsetX * 2,
                'height': trans.height + offsetY * 2,
                'fill': 'white',
                'stroke-width': 1,
                'stroke': 'Gray'
            };
            if (this.model.AreaType != "none") {
                if (this.model.AreaType == 'cartesianaxes' && ((point.X + trans.x) <= (trans.x + trans.width)) && ((point.X + trans.x) >= trans.x || point.X == 0) &&
                    ((point.Y + trans.y) >= (trans.y) || point.Y == 0)) {
                    if (this.model.crosshair.visible || type == "bubble" || type == "scatter") {
                        if (!series.trackerRemoved) {
                            var trackId = this.svgObject.id + '_TrackSymbol' + '_' + seriesIndex;
                            trackId = (type == "boxandwhisker") ? trackId + index : trackId;
                            $("#" + this._id).find('[id*=' + trackId + ']').remove();
                            var trackId = "canvas_trackSymbol_" + seriesIndex;
                            trackId = (type == "boxandwhisker") ? trackId + index : trackId;
                            $("#" + this._id).find('[id*=' + trackId + ']').remove();

                        }
                        var transSymbolOptions = { 'clip-path': 'url(#' + this.svgObject.id + '_ClipRectTrack' + '_' + seriesIndex + ')', 'class': 'Tracker', 'id': this.svgObject.id + '_TrackSymbol' + '_' + seriesIndex + '_' + index, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };
                        this.gTrackerEle = this.svgRenderer.createGroup(transSymbolOptions);
                    } else
                        this.gTrackerEle = null; // empty the previously created tracker group if no tracker is drawn now
                }
                else {

                    $('#' + this.svgObject.id + '_TrackSymbol' + '_' + seriesIndex + '_' + index).remove();
                    var transSymbolOptions = { 'id': this.svgObject.id + '_TrackSymbol' + '_' + seriesIndex + '_' + index };
                    this.gTrackerEle = this.svgRenderer.createGroup(transSymbolOptions);
                    if (!this.model.enableCanvasRendering) {
                        if (this.model.AreaType == 'polaraxes')
                            this.gTrackerEle.setAttribute('clip-path', 'url(#' + this.svgObject.id + '_SeriesGroup_' + seriesIndex + '_ClipRect)');
                        else {
                            this.gTrackerEle.setAttribute('clip-path', 'url(#' + this.svgObject.id + '_ClipRectTrack' + '_' + seriesIndex + ')');
                            this.gTrackerEle.setAttribute('transform', 'translate(' + trans.x + ',' + trans.y + ')');
                        }
                    }
                }
                if ($("#" + this.svgObject.id + "_CrosshairGroup").length == 0) {
                    var gTrackballOptions = { 'id': this.svgObject.id + '_CrosshairGroup', 'visibility': 'visible' };
                    this.gTrackball = this.svgRenderer.createGroup(gTrackballOptions);
                    this.svgRenderer.append(this.gTrackball, this.svgObject);
                }
                if (this.model.crosshair.marker.visible && !series.isIndicator && series._visiblePoints[ptIndex].visible) {
                    chartSeriesObj.drawSymbol(seriesIndex, series, ptIndex, (point.X), (point.Y), this, tracker, trackcount);
                    if (point.low)
                        chartSeriesObj.drawSymbol(seriesIndex, series, ptIndex, (this.model.requireInvertedAxes ? point.low : point.X), (this.model.requireInvertedAxes ? point.Y : point.low), this, tracker);
                }
                if (this.gTrackerEle && $("#" + this.gTrackerEle.id).length < 1)
                    this.svgRenderer.append(this.gTrackerEle, this.gTrackball);
            }
            if ($(this.svgObject).find("#" + this.svgObject.id + '_ClipRectTrack' + '_' + seriesIndex).length == 0 && !this.vmlRendering) {
                this.svgRenderer.drawClipPath(clipRectOptions, $("#" + this.svgObject.id + "_CrosshairGroup"));
            }


        },
        getClosesPointXY: function (serX, serY, series, x, y, evt) {
            var closestPoint,
                valAxis = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, this.model.requireInvertedAxes), outlierPosition,
                ptIndex, chartPoint, location, pointIndex, pointVisible, closestX, padding = 10, isTouch = this.isTouch(evt),
                visiblePointsLength = series._visiblePoints ? series._visiblePoints.length : 0, closestY,
                size = series.marker ? $.extend(true, {}, series.marker.size) : { height: 6, width: 6 };
            size.height = (isTouch && size.height < padding * 2) ? size.height + padding : size.height;
            size.width = (isTouch && size.width < padding * 2) ? size.width + padding : size.width;
            if ((y <= (valAxis.y + valAxis.height) && valAxis.y <= y) && (valAxis.x <= x && x <= (valAxis.x + valAxis.width))) {
                for (var i = 0; i < visiblePointsLength; i++) {
                    chartPoint = series._visiblePoints[i];
                    location = chartPoint.location;
                    pointVisible = false;
                    pointIndex = i;
                    closestX = null;
                    closestY = null;

                    if (series.type == "boxandwhisker" && (!this.model.enable3D) && !(sf.util.isNullOrUndefined(chartPoint.boxPlotLocation))) {

                        for (var k = 0; k < chartPoint.boxPlotLocation.length; k++) {
                            var symbolOptions = {
                                X: chartPoint.boxPlotLocation[k].X, Y: chartPoint.boxPlotLocation[k].Y
                            };
                            if (chartPoint.boxPlotLocation[k].outlier == true) {
                                if (x > ((symbolOptions.X + valAxis.x) - size.width) && x < (symbolOptions.X + valAxis.x + size.width)) {
                                    closestX = chartPoint.x;
                                    if (sf.util.isNullOrUndefined(closestX))
                                        pointVisible = chartPoint.visible;
                                    if (y > ((symbolOptions.Y + valAxis.y) - size.height) && y < symbolOptions.Y + valAxis.y + size.height + padding) {
                                        closestY = chartPoint.boxPlotValues.outliers[k];
                                        outlierPosition = { X: symbolOptions.X, Y: symbolOptions.Y };
                                    }
                                    if (!sf.util.isNullOrUndefined(outlierPosition)) {
                                        closestPoint = chartPoint;
                                        ptIndex = i;
                                    }
                                }
                            }

                        }
                    }
                    if (location) {
                        if (x > location.X + valAxis.x - (size.width / 2) && x < location.X + valAxis.x + (size.width / 2)) {
                            closestX = chartPoint.x;
                            if (sf.util.isNullOrUndefined(closestX))
                                pointVisible = chartPoint.visible;
                        }
                        if (y > location.Y + valAxis.y - (size.height / 2) && y < location.Y + valAxis.y + (size.height / 2)) {
                            closestY = chartPoint.YValues[0];
                        }
                        if ((!sf.util.isNullOrUndefined(closestX) || pointVisible) && !sf.util.isNullOrUndefined(closestY)) {
                            closestPoint = chartPoint;
                            ptIndex = i;
                        }
                    }
                }
            }
            return { point: closestPoint, index: ptIndex, outlierPosition: outlierPosition };
        },
        getClosestPointX: function (serX, series, x, y) {
            var closestPoint = [];
            var valAxis = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, this.model.requireInvertedAxes);
            if (this.model.requireInvertedAxes) {
                x = Math.abs(y - (valAxis.y + valAxis.height));
                y = Math.abs(x - valAxis.x);
            }
            else {
                x = Math.abs(x - valAxis.x);
                y = Math.abs(y - (valAxis.y + valAxis.height));
            }
            var mousePoint = sf.EjSvgRender.utils._getValuebyPoint(x, y, series, this.model.requireInvertedAxes);
            var pointX = (this.model.requireInvertedAxes) ? mousePoint.PointX : mousePoint.PointX;
            var ptIndex = [];

            $.each(series.points, function (pointIndex, chartPoint) {
                serX.push(chartPoint.xValue);
            });
            var closest = this.getClosest(serX, pointX);
            if (!sf.util.isNullOrUndefined(closest)) {
                if (typeof closest == 'number') {
                    $.each(series._visiblePoints, function (pointIndex, cPoint) {
                        if (cPoint.xValue == closest) {
                            closestPoint.push(cPoint);
                            ptIndex.push(pointIndex);

                        }
                    });
                } else {
                    closest = closest.getTime();
                    $.each(series._visiblePoints, function (pointIndex, cPoint) {
                        if (typeof cPoint.xValue == "number" ? cPoint.xValue == closest : cPoint.xValue.getTime() == closest) {
                            closestPoint.push(cPoint);
                            ptIndex.push(pointIndex);

                        }
                    });
                }
            }
            return { point: closestPoint, index: ptIndex };
        },
        getClosest: function (obj, val) {
            var closest = null;
            this._beforeMin = false;
            this._afterMax = false;

            // Work out min and max
            var min = Math.min.apply(null, obj);
            var max = Math.max.apply(null, obj);

            // Only calculate closest if point is within array
            if (val >= min - 0.5 && val <= max + 0.5) {
                var i;
                for (i = 0; i < obj.length; i++) {
                    if (closest == null || Math.abs(obj[i] - val) < Math.abs(closest - val)) {
                        closest = obj[i];
                    }
                }
                this._closest = null;
            }
            else {
                if (val > max) {
                    closest = obj[obj.length - 1];
                    this._closest = sf.util.isNullOrUndefined(this._closest) ? closest : (closest > this._closest ? closest : this._closest);
                    this._afterMax = true;
                }
                else {
                    closest = obj[0];
                    this._closest = sf.util.isNullOrUndefined(this._closest) ? closest : (closest < this._closest ? closest : this._closest);
                    this._beforeMin = true;

                }
            }
            return closest;
        },
        createTooltip: function (region, evt, series) {
            if (!series)
                series = this.model._visibleSeries[region.SeriesIndex];
            var seriesPoint = (series.type == "pieofpie") ? this._getPieOfPiePoint(region.Region.PointIndex, series) : (series.type == "pie" || series.type == "doughnut") && !this.model.enable3D ? series._visiblePoints[region.Region.Index] : series._visiblePoints[region.Region.PointIndex];
            var point = (this.dragPoint) ? series.pointCollection[region.Region.PointIndex] : $.extend(true, {}, seriesPoint);
            var tooltipMargin = 10;
            var isRTL = series.tooltip.isReversed;
            if (point.visible !== false) {
                var format = series.tooltip.format;
                if (series.type == "boxandwhisker") {
                    var mouseMoveCords = this.calMousePosition(evt);
                    this.mousemoveX = mouseMoveCords.X;
                    this.mousemoveY = mouseMoveCords.Y;
                    var flag = region.Region.Bounds ? true : false;
                    if (flag) {
                        if (region.Region.Bounds.Width == series.outlierSettings.size.width) {
                            for (var s = 0; s < point.boxPlotLocation.length; s++) {
                                if (point.boxPlotLocation[s].outlier == true) {
                                    if ((point.boxPlotLocation[s].X + (series.outlierSettings.size.width / 2) > (this.mousemoveX - series.xAxis.x)) && (point.boxPlotLocation[s].X - (series.outlierSettings.size.width / 2) < (this.mousemoveX - series.xAxis.x))) {
                                        if ((point.boxPlotLocation[s].Y + (series.outlierSettings.size.height / 2) > (this.mousemoveY - series.yAxis.y)) && (point.boxPlotLocation[s].Y - (series.outlierSettings.size.height / 2) < (this.mousemoveY - series.yAxis.y))) {
                                            var dataPoints = this.getTooltipFormat(point, series, region.SeriesIndex, region.Region.PointIndex, format, point.boxPlotLocation[s]);
                                            point.x = dataPoints.data.x;
                                            point.y = dataPoints.text;
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            var dataPoints = this.getTooltipFormat(point, series, region.SeriesIndex, region.Region.PointIndex, format, point.boxPlotLocation[0]);
                            point.x = dataPoints.data.x;
                            point.y = dataPoints.text;
                        }
                    }
                }
                else {
                    var dataPoints = this.getTooltipFormat(point, series, region.SeriesIndex, region.Region.PointIndex, format);
                    point.x = dataPoints.data.x;
                    point.y = dataPoints.data.y;
                }
                var tooltip = null;
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = { currentText: tooltip, seriesIndex: region.SeriesIndex, pointIndex: region.Region.PointIndex, series: series };
                this._trigger("toolTipInitialize", commonEventArgs);
                var tooltipdiv = $('.tooltipDiv' + this._id);
                $("#" + this.svgObject.id).find("#" + this.svgObject.id + "_TrackToolTip").attr('visibility', 'hidden');
                $("#" + this.svgObject.id + "_TrackToolTip").attr('visibility', 'hidden').hide();
                if ($('.tooltipDiv' + this._id).length == 0) {
                    this.tooltipFirst = true;
                    tooltipdiv = $("<div></div>").attr('class', 'tooltipDiv' + this._id).css({ 'position': 'absolute', 'z-index': '13000', 'display': 'block' });
                    $(document.body).append(tooltipdiv);
                    $('.tooltipDiv' + this._id).addClass(this.svgObject.id);
                } else {
                    $(".tooltipDiv" + this._id).css("display", "block");
                    this.tooltipFirst = false;
                }
                if (series.tooltip.template != null) {
                    var cloneNode = $("#" + series.tooltip.template).clone();
                    $('.tooltipDiv' + this._id)[0].innerHTML = "";
                    $(cloneNode).css("display", "block").appendTo(tooltipdiv);
                    series.count = 1;
                    point.count = 1;
                    var seriesColor = this.getSeriesColor(point, region.SeriesIndex, series);
                    if (seriesColor)
                        $(tooltipdiv).css("background-color", jQuery.type(seriesColor) == "array" ? seriesColor[0].color : seriesColor);
                    else
                        $(tooltipdiv).css("background-color", this.model.pointColors[region.Region.PointIndex]);
                    var data = { series: series, point: point };
                    if (!sf.util.isNullOrUndefined(commonEventArgs.data.currentText))
                        $(tooltipdiv).html($(cloneNode).html(commonEventArgs.data.currentText));
                    else
                        $(tooltipdiv).html($(tooltipdiv).html().parseTemplate(data));
                } else {
                    $(tooltipdiv).html(commonEventArgs.data.ToolTip);
                }
                var areaBounds = this.model.m_AreaBounds;
                var xPos = evt.pageX + tooltipMargin;
                var yPos = evt.pageY + tooltipMargin;
                var tooltipWidth = $(tooltipdiv).width();
                var tooltipHeight = $(tooltipdiv).height();
                var position = document.getElementById(this.svgObject.id).getClientRects()[0];
                if (xPos === undefined || xPos === null)
                    xPos = evt.pageX + tooltipMargin;
                if (yPos === undefined || yPos === null)
                    yPos = evt.pageY + tooltipMargin;
                var leftPos = xPos;
                var topPos = yPos;
                //Checking top position whether tooltip display outside of the area bounds
                if ((xPos - $(this.svgObject).offset().left + tooltipWidth) > (areaBounds.X + areaBounds.Width)) {
                    var diff = (xPos - (tooltipWidth + (2 * tooltipMargin)));
                    leftPos = diff + $(document).scrollLeft();
                }
                if ((yPos - $(this.svgObject).offset().top + tooltipHeight) > areaBounds.Y + areaBounds.Height) {
                    var diff = (yPos + tooltipHeight) - (areaBounds.Y + areaBounds.Height + position.top)
                    topPos = yPos - diff + $(document).scrollTop();
                }
				if(leftPos < 0){
					var chartContainer = $("#"+ this._id)[0].getBoundingClientRect();
					if(evt.pageX < chartContainer.width/2)					
						leftPos = xPos;
					else{
						$(tooltipdiv).css('width', xPos - (2 * tooltipMargin));
						leftPos = 0;
					 }
				}
                $(tooltipdiv).css('left', leftPos);
                $(tooltipdiv).css('top', topPos);

                var tooltipOptions = series.tooltip;
                if (tooltipOptions.enableAnimation) {
                    $(tooltipdiv).css({
                        'transition-property': 'left,top',
                        '-moz-transition-property': 'left,top', /* Firefox 4 */
                        '-webkit-transition-property': 'left,top', /* Safari and Chrome */
                        '-o-transition-property': 'left,top',
                        'transition-duration': tooltipOptions.duration,
                        '-moz-transition-duration': tooltipOptions.duration, /* Firefox 4 */

                        '-webkit-transition-duration': this.tooltipFirst ? '0s' : tooltipOptions.duration, /* Safari and Chrome */
                        '-o-transition-duration': tooltipOptions.duration /* Opera */
                    });
                }
                var templateRect = $(tooltipdiv)[0].getBoundingClientRect();
                if (templateRect.top < areaBounds.Y + position.top)
                    $(tooltipdiv).css('top', areaBounds.Y + position.top + $(document).scrollTop());
                if (isRTL) {
                    $(tooltipdiv).css('left', xPos - (tooltipWidth + (tooltipMargin*2)));
                    if (xPos - (tooltipWidth + (tooltipMargin*2)) < series.xAxis.x)
                        $(tooltipdiv).css('left', xPos);
                }
            }
        },

        translate: function (axis, translateX, translateY, currentScale) {
            var offset = axis.orientation.toLowerCase() == "horizontal"
                ? translateX / axis.width / currentScale
                : translateY / axis.height / currentScale;

            axis.zoomPosition = axis.orientation.toLowerCase() == "horizontal"
                ? sf.EjSvgRender.utils._minMax(axis.zoomPosition + offset, 0, (1 - axis.zoomFactor))
                : sf.EjSvgRender.utils._minMax(axis.zoomPosition - offset, 0, (1 - axis.zoomFactor));
        },
        highlightFill: function (highlight, chart, seriesIndex, pointIndex, legendData) {
            var seriesColors = chart.model.seriesColors;
            var pointColors = chart.model.pointColors;
            var color = highlight.color;
            var length = this.model._visibleSeries.length;
            if (legendData && chart.model.AreaType == 'none') {
                if (length == 1)
                    pointIndex = legendData.legendItem.LegendItem.PointIndex;
                else
                    seriesIndex = legendData.legendItem.LegendItem.SeriesIndex;
            }
            var pointColor = legendData ? seriesColors[seriesIndex] : pointIndex ? chart.model.series[seriesIndex].points[pointIndex] ? chart.model.series[seriesIndex].points[pointIndex].fill : null : null;
            var fill = (color != "" ? color : chart.model.AreaType == 'none' ? pointColors[pointIndex] : legendData ? seriesColors[seriesIndex] : pointColor ? pointColor : seriesColors[seriesIndex]);
            if (Object.prototype.toString.call(fill) === '[object Array]')
                fill = fill[1].color;
            return fill;
        },



        // Canvas highlight and selection started here
        // Canvas highlight started here
        canvasHighlight: function (chart, evt, series, legendData) {

            var highlight = series.highlightSettings;
            var data = series.data;
            var color = highlight.color;
            var opacity = highlight.opacity;
            var borderColor = highlight.border.color;
            var borderWidth = highlight.border.width;
            var patternName = highlight.pattern.toLowerCase();
            var legendVisible = chart.model.legend.visible;
            var mode = highlight.mode;
            var seriesIndex = series.seriesIndex;
            var pointIndex = series.pointIndex;
            var seriesType = series.type.toLowerCase();
            var containerStyle = document.getElementById(chart._id + '_canvas').getBoundingClientRect();
            var regions = [];
            var points = [];
            var clusterPoints = [];
            var length = this.model._visibleSeries.length, clusterseriesIndex, clusterpointIndex, ctx;
            var fill = this.highlightFill(highlight, chart, seriesIndex, pointIndex, legendData);
            if (chart.model.AreaType != 'none' || (chart.model.AreaType == 'none' && length > 1 && (mode == 'series' || legendData))) {
                for (var i = 0, len = chart.model.chartRegions.length; i < len; i++) {
                    if ((mode == 'series' || legendData) && (seriesIndex == chart.model.chartRegions[i].SeriesIndex))
                        regions.push(chart.model.chartRegions[i].Region);
                }


            } else {
                for (var i = 0, len = chart.model.chartRegions.length; i < len; i++) {
                    if (seriesIndex == chart.model.chartRegions[i].SeriesIndex && pointIndex == chart.model.chartRegions[i].Region.PointIndex)
                        regions.push(chart.model._isPieOfPie ? chart._getPieOfPiePoint(chart.model.chartRegions[i].Region.PointIndex, series) : chart.model.chartRegions[i].Region[pointIndex]);
                }
            }
            if (mode == 'cluster' && chart.model.Areatype != 'none' && typeof pointIndex !== "undefined") {
                var xvalue = chart.model._visibleSeries[seriesIndex]._visiblePoints[pointIndex].xValue;
                for (var i = 0, len = chart.model._visibleSeries.length; i < len; i++) {
                    for (var j = 0; j < chart.model._visibleSeries[i]._visiblePoints.length; j++) {
                        if (xvalue == chart.model._visibleSeries[i]._visiblePoints[j].xValue)
                            clusterPoints[clusterPoints.length] = { seriesIndex: i, pointIndex: j };

                    }
                }
            }
            for (var k = 0; k < clusterPoints.length; k++) {
                clusterseriesIndex = clusterPoints[k].seriesIndex;
                clusterpointIndex = clusterPoints[k].pointIndex;
                for (var l = 0; l < chart.model.chartRegions.length; l++) {
                    if (clusterseriesIndex == chart.model.chartRegions[l].SeriesIndex && clusterpointIndex == chart.model.chartRegions[l].Region.PointIndex)
                        if (mode != "cluster")
                            regions.push(chart.model.chartRegions[l].Region);
                        else
                            regions.push(chart.model.chartRegions[l]);
                }
            }
            var index = (chart.model.AreaType == 'none' && length == 1) ? pointIndex : seriesIndex;
            if ((mode == 'series' || legendData) && ($('#' + chart._id + '_Selection_series' + index + '_canvas').length == 0) && $('#' + chart._id + '_Selection_' + 'Cluster' + '_point_' + pointIndex + '_canvas').length == 0 && $('#' + chart._id + '_Selection_' + seriesIndex + '_point_' + pointIndex + '_canvas').length == 0) {
                points = series._visiblePoints
                ctx = this.createCanvasElement(chart._id + '_Highlight_series' + seriesIndex + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
                color = (patternName == "none" || patternName == "") ? fill : this.canvasPattern(ctx, chart, evt, fill, highlight);
                this.createRect(chart, ctx);
                if (seriesType.indexOf("column") != -1 || seriesType.indexOf("waterfall") != -1 || seriesType.indexOf("bar") != -1) {
                    for (i = 0; i < regions.length; i++) {
                        var isUnSelected = $('#' + chart._id + '_Selection_' + seriesIndex + '_point_' + i + '_canvas').length == 0 ? true : false;
                        this.canvasSeriesRect(regions[i], opacity, borderColor, borderWidth, color, isUnSelected, series);
                    }
                }
                else if (seriesType == 'pie' || seriesType == 'doughnut' || seriesType == "pieofpie") {
                    regions = (length == 1) ? regions : regions[0];
                    this.canvasHighlightCircle(chart, highlight, pointIndex, opacity, borderColor, borderWidth, color, regions, seriesType, ctx);
                }
                else if (seriesType == 'pyramid' || seriesType == 'funnel')
                    this.canvasHighlightPyramid(chart, regions[0], highlight, ctx, opacity, borderColor, borderWidth, color, seriesType);
                else if (seriesType == 'bubble')
                    this.canvasBubbleHighlight(highlight, regions, chart, seriesIndex, color, borderWidth, opacity, borderColor);
                else if (seriesType == 'scatter')
                    this.canvasScatterHighlight(regions, color, borderWidth, opacity, borderColor);
            }
            else if (mode == 'cluster' && $('#' + chart._id + '_Selection_' + 'Cluster' + '_point_' + pointIndex + '_canvas').length == 0 && this.model.AreaType != 'none' && $('#' + chart._id + '_Selection_' + seriesIndex + '_point_' + pointIndex + '_canvas').length == 0 && $('#' + chart._id + '_Selection_series' + seriesIndex + '_canvas').length == 0) {
                for (var i = 0, len = this.model._visibleSeries.length; i < len; i++) {
                    var series = this.model._visibleSeries[i];
                    series.seriesIndex = i;
                    points.push(series._visiblePoints[pointIndex]);

                }
                var sbRegion = [], colors = [];// scatter & bubble region calculation
                ctx = this.createCanvasElement(chart._id + '_Highlight_' + '_Cluster' + '_point_' + pointIndex + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
                this.createRect(chart, ctx);
                for (var i = 0, len = this.model._visibleSeries.length; i < len; i++) {
                    sbRegion = [];
                    highlight = chart.model._visibleSeries[i].highlightSettings;
                    color = highlight.color;
                    opacity = highlight.opacity;
                    borderColor = highlight.border.color;
                    borderWidth = highlight.border.width;
                    patternName = highlight.pattern.toLowerCase();
                    fill = this.highlightFill(highlight, chart, i, pointIndex, index, legendData);
                    color = (patternName == "none" || patternName == "") ? fill : this.canvasPattern(ctx, chart, evt, fill, highlight);
                    colors.push(color);
                    for (var r = 0, rlen = regions.length; r < rlen; r++) {
                        if (regions[r].SeriesIndex == i) {
                            sbRegion.push(regions[r].Region);
                        }
                    }
                    if (seriesType.indexOf("column") != -1 || seriesType.indexOf("waterfall") != -1 || seriesType.indexOf("bar") != -1) {
                        var isUnSelected = $('#' + chart._id + '_Selection_' + i + '_point_' + pointIndex + '_canvas').length == 0 ? true : false;
                        for (var r = 0, rlen = sbRegion.length; r < rlen; r++) {
                            this.canvasSeriesRect(sbRegion[r], opacity, borderColor, borderWidth, color, isUnSelected, series);
                        }
                    }
                    else if (seriesType == 'bubble') {
                        this.canvasBubbleHighlight(highlight, sbRegion, chart, i, color, borderWidth, opacity, borderColor);
                    }
                    else if (seriesType == 'scatter') {
                        this.canvasScatterHighlight(sbRegion, color, borderWidth, opacity, borderColor);
                    }

                }
            }
            else if ((mode == "cluster" && this.model.AreaType == 'none') || mode == 'point' && $('#' + chart._id + '_Selection_' + seriesIndex + '_point_' + pointIndex + '_canvas').length == 0 && $('#' + chart._id + '_Selection_series' + seriesIndex + '_canvas').length == 0 && $('#' + chart._id + '_Selection_' + 'Cluster' + '_point_' + pointIndex + '_canvas').length == 0) {
                points[0] = this.model._isPieOfPie ? this._getPieOfPiePoint(pointIndex, series) : series._visiblePoints[pointIndex];
                ctx = this.createCanvasElement(chart._id + '_Highlight_' + seriesIndex + '_point_' + pointIndex + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
                this.createRect(chart, ctx);
                color = (patternName == "none" || patternName == "") ? fill : this.canvasPattern(ctx, chart, evt, fill, highlight);
                if (seriesType.indexOf("column") != -1 || seriesType.indexOf("waterfall") != -1 || seriesType.indexOf("bar") != -1) {
                    regions = []; regions[0] = data.region.Region;
                    this.canvasSeriesRect(regions[0], opacity, borderColor, borderWidth, color, true, series);
                }
                else if (seriesType == 'pie' || seriesType == 'doughnut' || seriesType == "pieofpie") {
                    regions = []; regions[0] = data.pointData[0];
                    this.canvasHighlightCircle(chart, highlight, pointIndex, opacity, borderColor, borderWidth, color, regions, seriesType, ctx);
                }
                else if (seriesType == 'pyramid' || seriesType == 'funnel') {
                    this.canvasHighlightPyramid(chart, regions[0], highlight, ctx, opacity, borderColor, borderWidth, color, seriesType);
                }
                else if (seriesType == 'bubble') {
                    regions = []; regions[0] = data.region.Region;
                    this.canvasBubbleHighlight(highlight, regions, chart, seriesIndex, color, borderWidth, opacity, borderColor);
                }
                else if (seriesType == 'scatter') {
                    regions = []; regions[0] = data.region.Region;
                    this.canvasScatterHighlight(regions, color, borderWidth, opacity, borderColor);
                }
            }
            // legend highlight (legend symbol)
            if (legendVisible && $('#' + chart._id + '_Selection_Legend' + index + '_canvas').length == 0) {
                if (mode == 'cluster' && !legendData && this.model.AreaType != 'none') {
                    var serIndex, chartSeries;
                    for (var i = 0, len = clusterPoints.length; i < len; i++) {
                        serIndex = clusterPoints[i].seriesIndex;
                        chartSeries = this.model._visibleSeries[serIndex];
                        this.canvasHighlightLegend(chart, chartSeries, highlight, 'Highlight', containerStyle, colors[serIndex]);
                    }
                }
                else
                    this.canvasHighlightLegend(chart, series, highlight, 'Highlight', containerStyle, color);

            }
            if (series.visibility === 'visible' && series.marker.visible == true && this.model.AreaType != 'none')
                this.canvasHighlightMarker(chart, series, points, highlight, ctx, evt, colors);
        },

        // canvas rect operations perform here
        canvasSeriesRect: function (regions, opacity, borderColor, borderWidth, color, isUnSelected, series) {
            var options = {
                'opacity': opacity,
                'stroke': borderColor,
                'stroke-width': borderWidth,
                'fill': color
            }
            var cornerRadius = series.cornerRadius, ctx;
            if (regions) {
                options.x = regions.Bounds.X;
                options.y = regions.Bounds.Y;
                options.width = regions.Bounds.Width;
                options.height = regions.Bounds.Height;
                if (isUnSelected)
                    if ((typeof (cornerRadius) != "object" && cornerRadius > 0) || cornerRadius.topLeft > 0 || cornerRadius.bottomLeft > 0
                        || cornerRadius.topRight > 0 || cornerRadius.bottomRight > 0) {
                        var roundrect = sf.EjSvgRender.utils._calculateroundedCorner(cornerRadius, options);
                        options.d = roundrect;
                        sf.EjCanvasRender.prototype.drawPath(options, ctx);
                    }
                    else
                        this.drawRect(options, ctx);
            }
        },

        // // canvas selection logic started here
        canvasSelection: function (chart, evt, series, legendData, seriesIndex, pointIndex, data, selectionSettings) {
            series.seriesIndex = seriesIndex;
            series.pointIndex = pointIndex;
            var seriesCollection = this.model._visibleSeries,
                color = selectionSettings.color,
                opacity = selectionSettings.opacity,
                borderColor = selectionSettings.border.color,
                borderWidth = selectionSettings.border.width,
                patternName = selectionSettings.pattern.toLowerCase(),
                legendVisible = chart.model.legend.visible,
                mode = selectionSettings.mode,
                seriesType = series.type.toLowerCase(),
                containerStyle = document.getElementById(chart._id + '_canvas').getBoundingClientRect(),
                regions = [],
                points = [],
                length = this.model._visibleSeries.length,
                chartRegions = chart.model.chartRegions,
                clusterPoints = this.model.clusterPoints,
                seriesData = { seriesIndex: seriesIndex, series: series },
                index = (chart.model.AreaType == 'none' && length == 1) ? pointIndex : seriesIndex,
                fill = this.highlightFill(selectionSettings, chart, seriesIndex, pointIndex, legendData, data), regionsLength, cRlength, len, highlight, ctx;
            regionsLength = chartRegions.length;
            if (chart.model.AreaType != 'none' || (chart.model.AreaType == 'none' && length > 1)) {
                for (var i = 0; i < regionsLength; i++) {
                    if (((mode == 'series' || legendData) && seriesIndex == chartRegions[i].SeriesIndex) || ((mode == 'point' || legendData) && (seriesIndex == chartRegions[i].SeriesIndex && pointIndex == chartRegions[i].Region.PointIndex))) {
                        if (chart.model.AreaType == 'none' && mode == 'point' && !legendData)
                            regions.push(chartRegions[i].Region[pointIndex])
                        else
                            regions.push(chartRegions[i].Region);
                    }
                }
            } else if (regionsLength > 0) {
                if (this.model._isPieOfPie) {
                    if (legendData) {
                        for (var p = 0; p < series.pieCollections.length; p++) {
                            var piePoints = series.pieCollections[p];
                            for (var q = 0; q < piePoints.length; q++) {
                                if (piePoints[q].actualIndex == legendData.legendItem.LegendItem.PointIndex) {
                                    var pieColIndex = p;
                                    break;
                                }
                            }
                        }
                    }
                    var pieSrIndex = series.data ? series.data.pointData[0].PieSeriesIndex : pieColIndex;
                    var chartRegion = chartRegions[pieSrIndex];
                }
                else
                    var chartRegion = chartRegions[0];
                cRlength = chartRegion.Region.length;
                for (var i = 0; i < cRlength; i++) {
                    if (pointIndex == chartRegion.Region[i].PointIndex)
                        regions.push(chartRegion.Region[i]);
                }
            }
            if ((mode == 'series' || legendData) && (this.model.AreaType != 'none' || this.model.AreaType == 'none' && length > 1)) {
                points = series._visiblePoints;
                ctx = this.createCanvasElement(chart._id + '_Selection_series' + index + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
                color = (patternName == "none" || patternName == "") ? fill : this.canvasPattern(ctx, chart, evt, fill, selectionSettings);
                this.createRect(chart, ctx);
                if (seriesType.indexOf("column") != -1 || seriesType.indexOf("waterfall") != -1 || seriesType.indexOf("bar") != -1) {
                    for (i = 0; i < regions.length; i++)
                        this.canvasSeriesRect(regions[i], opacity, borderColor, borderWidth, color, true, series);
                }
                else if (seriesType == 'pie' || seriesType == 'doughnut' || seriesType == "pieofpie")
                    this.canvasHighlightCircle(chart, selectionSettings, pointIndex, opacity, borderColor, borderWidth, color, regions[0], seriesType, ctx);
                else if (seriesType == 'bubble')
                    this.canvasBubbleHighlight(selectionSettings, regions, chart, seriesIndex, color, borderWidth, opacity, borderColor);
                else if (seriesType == 'scatter')
                    this.canvasScatterHighlight(regions, color, borderWidth, opacity, borderColor);
            }
            else if (mode == 'cluster' && this.model.AreaType != 'none' && $('#' + chart._id + '_Selection_' + 'Cluster' + '_point_' + pointIndex + '_canvas').length == 0) {
                var clength = clusterPoints.length, clusterseriesIndex, clusterpointIndex, region, rlength;
                for (var k = 0; k < clength; k++) {
                    clusterseriesIndex = clusterPoints[k].seriesIndex;
                    clusterpointIndex = clusterPoints[k].pointIndex;
                    region = $.grep(chartRegions, function (x) { return x.SeriesIndex == clusterseriesIndex && x.Region.PointIndex == clusterpointIndex });
                    rlength = region.length;
                    if (rlength > 0) {
                        regions.push(region[0]);
                        points.push(seriesCollection[region[0].SeriesIndex]._visiblePoints[pointIndex]);
                    } else
                        points.push(seriesCollection[k]._visiblePoints[pointIndex]);
                }
                this.selectedPoint = pointIndex;
                var sbRegion = [], colors = [];
                ctx = this.createCanvasElement(chart._id + '_Selection_' + 'Cluster' + '_point_' + pointIndex + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
                this.createRect(chart, ctx);
                for (i = 0, len = seriesCollection.length; i < len; i++) {
                    sbRegion = [];// scatter & bubble region calculation
                    highlight = seriesCollection[i].selectionSettings;
                    color = highlight.color;
                    opacity = highlight.opacity;
                    borderColor = highlight.border.color;
                    borderWidth = highlight.border.width;
                    patternName = highlight.pattern.toLowerCase();
                    fill = this.highlightFill(highlight, chart, i, pointIndex, legendData);
                    color = (patternName == "none" || patternName == "") ? fill : this.canvasPattern(ctx, chart, evt, fill, highlight);
                    colors.push(color);
                    for (var r = 0, rlen = regions.length; r < rlen; r++) {
                        if (regions[r].SeriesIndex == i) {
                            sbRegion.push(regions[r].Region);
                        }
                    }
                    if (seriesType.indexOf("column") != -1 || seriesType.indexOf("waterfall") != -1 || seriesType.indexOf("bar") != -1) {
                        for (var sr = 0, srlen = sbRegion.length; sr < srlen; sr++) {
                            this.canvasSeriesRect(sbRegion[sr], opacity, borderColor, borderWidth, color, true, series);
                        }
                    }
                    else if (seriesType == 'bubble')
                        this.canvasBubbleHighlight(highlight, sbRegion, chart, i, color, borderWidth, opacity, borderColor);
                    else if (seriesType == 'scatter')
                        this.canvasScatterHighlight(sbRegion, color, borderWidth, opacity, borderColor);
                    if (!legendData && this.model.AreaType != 'none' && legendVisible) {
                        series = seriesCollection[i];
                        series.seriesIndex = i;
                        this.canvasHighlightLegend(chart, series, selectionSettings, 'Selection_Cluster', containerStyle, color);
                    }
                }
            }
            else if ((mode == 'point' && $('#' + chart._id + '_Selection_' + seriesIndex + '_point_' + pointIndex + '_canvas').length == 0) || this.model.AreaType == 'none') {
                this.selectedPoint = pointIndex;

                points[0] = this.model._isPieOfPie ? this._getPieOfPiePoint(pointIndex, series) : series._visiblePoints[pointIndex];
                ctx = this.createCanvasElement(chart._id + '_Selection_series' + seriesIndex + '_point_' + pointIndex + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
                this.createRect(chart, ctx);
                color = (patternName == "none" || patternName == "") ? fill : this.canvasPattern(ctx, chart, evt, fill, selectionSettings);
                if (seriesType.indexOf("column") != -1 || seriesType.indexOf("waterfall") != -1 || seriesType.indexOf("bar") != -1)
                    this.canvasSeriesRect(regions[0], opacity, borderColor, borderWidth, color, true, series);
                else if (seriesType == 'pie' || seriesType == 'doughnut' || seriesType == "pieofpie")
                    this.canvasHighlightCircle(chart, selectionSettings, pointIndex, opacity, borderColor, borderWidth, color, regions, seriesType, ctx);
                else if (seriesType == 'pyramid' || seriesType == 'funnel')
                    this.canvasHighlightPyramid(chart, regions[0], selectionSettings, ctx, opacity, borderColor, borderWidth, color, seriesType);
                else if (seriesType == 'bubble')
                    this.canvasBubbleHighlight(selectionSettings, regions, chart, seriesIndex, color, borderWidth, opacity, borderColor);
                else if (seriesType == 'scatter')
                    this.canvasScatterHighlight(regions, color, borderWidth, opacity, borderColor);
            }
            // legend highlight (legend symbol)
            if (legendVisible && (mode != 'cluster' || legendData))
                this.canvasHighlightLegend(chart, series, selectionSettings, 'Selection', containerStyle, color);
            if (series.marker.visible == true && this.model.AreaType != 'none')
                this.canvasHighlightMarker(chart, series, points, selectionSettings, ctx, evt, colors);
        },

        // clip rect logic calculated here
        createRect: function (chart, ctx) {
            if (chart.model.AreaType != 'none') {
                ctx.lineWidth = 0;
                ctx.strokeStyle = 'transparent';
                ctx.rect(chart.model.m_AreaBounds.X, chart.model.m_AreaBounds.Y, chart.model.m_AreaBounds.Width, chart.model.m_AreaBounds.Height);
                ctx.clip();
                ctx.stroke();
                ctx.save();
            }
        },

        //canvas pyramid and funnel draw
        canvasHighlightPyramid: function (chart, regions, highlight, ctx, opacity, borderColor, borderWidth, color, seriesType) {
            var fill = (highlight.color != "" ? highlight.color : chart.model.pointColors[regions.PointIndex]);
            var measureTitle = (chart.model.title.text) ? sf.EjSvgRender.utils._measureText(chart.model.title.text, $(this.svgObject).width() - chart.model.margin.left - chart.model.margin.right, chart.model.title.font) : 0;
            var pyrX = chart.pyrX = ((chart.model.legend.position.toLowerCase() === "left") ? (chart.model.LegendViewerBounds.Width) : 0) + chart.model.elementSpacing + chart.model.margin.left;
            var pyrY = chart.pyrY = ((chart.model.legend.position.toLowerCase() === "top") ? (chart.model.LegendViewerBounds.Height) : 0) + ((chart.model.title.text) ? (chart.model._titleLocation.Y + measureTitle.height) : (chart.model.margin.top + chart.model.elementSpacing));
            var options = {
                'opacity': opacity,
                'stroke': borderColor,
                'stroke-width': borderWidth,
                'fill': color,
                'type': seriesType,
                'd': "M" + " " + (pyrX + regions.Line1.x) + " " + (pyrY + regions.Line1.y) + " " + "L" + " " + (pyrX + regions.Line2.x) + " " + (pyrY + regions.Line2.y) + " " + "L" + " " + (pyrX + regions.Line3.x) + " " + (pyrY + regions.Line3.y) + " " + "L" + " " + (pyrX + regions.Line4.x) + " " + (pyrY + regions.Line4.y) + " " + "z"
            }
            if (seriesType == 'funnel')
                options.d = "M" + " " + (pyrX + regions.Line1.x) + " " + (pyrY + regions.Line1.y) + " " + "L" + " " + (pyrX + regions.Line2.x) + " " + (pyrY + regions.Line2.y) + " " + "L" + " " + (pyrX + regions.Line3.x) + " " + (pyrY + regions.Line3.y) + " " + "L" + " " + (pyrX + regions.Line4.x) + " " + (pyrY + regions.Line4.y) + " " + "L" + " " + (pyrX + regions.Line5.x) + " " + (pyrY + regions.Line5.y) + " " + "L" + " " + (pyrX + regions.Line6.x) + " " + (pyrY + regions.Line6.y) + " " + "z";
            sf.EjCanvasRender.prototype.drawPath(options, ctx);
        },

        // canvas scatter logic
        canvasScatterHighlight: function (regions, color, borderWidth, opacity, borderColor) {
            var location, options = {}, size = {}, ctx;
            for (var i = 0; i < regions.length; i++) {
                location = { startX: regions[i].Bounds.X + regions[i].Bounds.Height / 2, startY: regions[i].Bounds.Y + regions[i].Bounds.Width / 2 };
                size.height = regions[i].Bounds.Height;
                size.width = regions[i].Bounds.Width;
                options = {};
                options.ShapeSize = size;
                options.cx = location.startX;
                options.cy = location.startY;
                options.Style = {};
                options.Style.BorderColor = borderColor;
                options.Style.Color = color;
                options.Style.Opacity = opacity;
                options.Style.BorderWidth = borderWidth;
                sf.EjSvgRender.chartSymbol['_drawCircle'](location, options, this, ctx);
            }
        },

        // canvas bubble logic perform here
        canvasBubbleHighlight: function (highlight, regions, chart, seriesIndex, color, borderWidth, opacity, borderColor) {
            var size = 10, radius, fill, bubbleOptions = {}, ctx;
            for (var i = 0; i < regions.length; i++) {
                radius = regions[i].Bounds.Height / 2;
                fill = (highlight.color != "" ? highlight.color : chart.model.seriesColors[seriesIndex]);
                bubbleOptions = {
                    'cx': regions[i].Bounds.X - this.model.series[seriesIndex].xAxis.x + radius + this.canvasX,
                    'cy': regions[i].Bounds.Y - this.model.series[seriesIndex].yAxis.y + radius + this.canvasY,
                    'r': radius,
                    'fill': color,
                    'stroke-width': borderWidth,
                    'opacity': opacity,
                    'stroke': borderColor
                };
                sf.EjCanvasRender.prototype.drawCircle(bubbleOptions, ctx);
            }
        },

        // canvas circle draw
        canvasHighlightCircle: function (chart, highlight, pointIndex, opacity, borderColor, borderWidth, color, regions, seriesType, ctx) {
            for (var i = 0; i < regions.length; i++) {
                var fill = (highlight.color != "" ? highlight.color : (highlight.mode == "series" && chart.model._visibleSeries.length > 1) ? chart.model.pointColors[i] : chart.model.pointColors[pointIndex]);
                var options = {
                    'opacity': opacity,
                    'stroke': borderColor,
                    'lineWidth': borderWidth,
                    'color': color,
                    'x': regions[i].StartX,
                    'y': regions[i].StartY,
                    'radius': chart.model._isPieOfPie ? chart.model.circularRadius[regions[i].PieSeriesIndex] : chart.model.circularRadius[regions[i].SeriesIndex],
                    'innerRadius': chart.model.innerRadius[regions[i].SeriesIndex],
                    'startAngle': regions[i].StartAngle,
                    'endAngle': regions[i].EndAngle,
                    'type': seriesType
                }
                this.highlightSegment(ctx, options);
            }
        },

        // canvas marker logic
        canvasHighlightMarker: function (chart, series, points, settings, ctx, evt, colors) {
            var highlight = settings;
            var patternName = highlight.pattern.toLowerCase();
            var seriesType = series.type.toLowerCase();
            var options = {};
            var fill = (highlight.color != "" ? highlight.color : chart.model.seriesColors[series.seriesIndex]), color;
            color = (patternName == "none" || patternName == "") ? fill : this.canvasPattern(ctx, chart, evt, fill, highlight);
            options.Style = {};
            options.Style.BorderColor = highlight.border.color;
            options.Style.Opacity = highlight.opacity;
            options.Style.BorderWidth = highlight.border.width;
            var symbolLocation, location, markerOptions, symbolName;
            for (var i = 0; i < points.length; i++) {
                symbolLocation = points[i].symbolLocation;
                symbolLocation = (seriesType.indexOf("line") != -1 || seriesType.indexOf("area") != -1) ? points[i].location : points[i].symbolLocation;
                if (symbolLocation) {
                    location = this.model.AreaType == "cartesianaxes" ? { startX: symbolLocation.X + this.canvasX, startY: symbolLocation.Y + this.canvasY } : { startX: symbolLocation.X, startY: symbolLocation.Y };
                    markerOptions = series.marker;
                    symbolName;
                    $.each(chart.model.symbolShape, function (name) {
                        if (markerOptions.shape.toLowerCase() == name.toLowerCase())
                            symbolName = name;
                    });
                    options.ShapeSize = markerOptions.size;
                    options.r = Math.sqrt(markerOptions.size.height * markerOptions.size.height + markerOptions.size.width * markerOptions.size.width) / 2;
                    options.cx = location.startX;
                    options.cy = location.startY;
                    options.Style.Color = colors ? colors[i] : color;
                    sf.EjSvgRender.chartSymbol['_draw' + symbolName](location, options, chart, ctx);
                }
            }

        },

        // canvas selction legend logic perform here
        canvasHighlightLegend: function (chart, series, settings, name, containerStyle, color) {
            var length = this.model._visibleSeries.length, legendCtx, legendRegion;
            var index = (chart.model.AreaType == 'none' && length == 1) ? series.pointIndex : series.seriesIndex,
                id = chart._id + '_' + name + '_Legend' + index + '_canvas';
            if ($('#' + id).length == 0 && index < series.points.length) {
                legendCtx = this.createCanvasElement(chart._id + '_' + name + '_Legend' + index + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
                if (chart.model.AreaType != 'none' || (chart.model.AreaType == "none" && length > 1))
                    legendRegion = chart.model.legendRegion[series.seriesIndex];
                else
                    legendRegion = chart.model.legendRegion[series.pointIndex];
                var legendBounds = { startX: legendRegion.Bounds.LegendBound.X + legendRegion.Location.startX, startY: legendRegion.Bounds.LegendBound.Y + legendRegion.Location.startY },
                    svgData = { svgRenderer: chart.svgRenderer, svgObject: chart.svgObject },
                    symbolStyle = { 'SeriesIndex': index, 'Style': { 'Color': color, 'Opacity': settings.opacity, 'Visibility': true, 'BorderWidth': 0, BorderColor: color }, 'context': true, 'ShapeSize': legendRegion.Style.ShapeSize }
                if (legendRegion.SymbolShape.toLowerCase() == 'seriestype') {
                    chart.legendItem = legendRegion.LegendItem;
                    sf.EjSvgRender.chartSymbol["_draw" + legendRegion.SymbolShape](legendBounds, symbolStyle, chart);
                } else
                    sf.EjSvgRender.chartSymbol["_draw" + legendRegion.SymbolShape](legendBounds, symbolStyle, svgData, legendCtx);
            }
        },

        // canvas create element 
        createCanvasElement: function (id, width, height, style) {
            var chartCavasOffset, highLightCanvas,
            svgObj = document.createElement('canvas'),
            _rootId = jQuery(this.element).attr("id");
            svgObj.setAttribute('id', id);
            svgObj.height = height;
            svgObj.width = width;
            svgObj.style["touch-action"] && (svgObj.style["touch-action"] = "none")
            svgObj.style["-ms-touch-action"] && (svgObj.style["-ms-touch-action"] = "none")
            this.svgRenderer.append(svgObj, this.element);
            var main = document.getElementById(id);
            main.style.left = style.left + $(document).scrollLeft() + 'px';
            main.style.top = style.top + $(document).scrollTop() + 'px';
            main.style.position = "absolute";
            chartCavasOffset = $("#" + this._id + "_canvas").offset();
            highLightCanvas = $(main).offset();
            if (chartCavasOffset.left < highLightCanvas.left) main.style.left = (style.left - Math.abs(chartCavasOffset.left - highLightCanvas.left) + $(document).scrollLeft()) + "px";
            if (chartCavasOffset.top < highLightCanvas.top) main.style.top = (style.top - Math.abs(chartCavasOffset.top - highLightCanvas.top) + $(document).scrollTop()) + "px";
            return svgObj.getContext("2d");
        },

        // canvas pie doughnut logic
        highlightSegment: function (ctx, options) {
            ctx.save();
            ctx.beginPath();
            if (options.type == 'pie' || options.type == "pieofpie") {
                ctx.moveTo(options.x, options.y);
                ctx.arc(options.x, options.y, options.radius, options.startAngle - 1.57, options.endAngle - 1.57, false);
            } else {
                ctx.arc(options.x, options.y, options.radius, options.startAngle - 1.57, options.endAngle - 1.57, false);
                ctx.arc(options.x, options.y, options.innerRadius, options.endAngle - 1.57, options.startAngle - 1.57, true);
            }
            ctx.fillStyle = options.color;
            ctx.globalAlpha = options.opacity;
            ctx.fill();
            ctx.lineWidth = options.lineWidth;
            ctx.strokeStyle = options.stroke;
            ctx.clip();
            ctx.stroke();
            ctx.closePath();
            ctx.restore();
        },

        // Canvas pattern started here
        canvasPattern: function (ctx, chart, evt, fill, settings) {

            var hoverStyle = settings;
            var name = hoverStyle.name;
            var style = hoverStyle.pattern.toLowerCase();
            var color = fill;
            var opacity = hoverStyle.opacity;
            var backgroundColor = "#ffffff";
            var borderColor = hoverStyle.border.color;
            var borderWidth = hoverStyle.border.width;
            var patternStyle = document.createElement('canvas');
            var patternContext = patternStyle.getContext('2d');
            var pathOptions = [], translate = [];
            switch (style) {
                case "chessboard":
                    pathOptions[0] = { 'x': 0, 'y': 0, 'width': 10, 'height': 10, 'fill': 'white', 'stroke': 'white', 'opacity': opacity, 'name': 'rect' };
                    pathOptions[1] = { 'x': 0, 'y': 0, 'width': 5, 'height': 5, 'fill': color, 'opacity': opacity, 'name': 'rect' };
                    pathOptions[2] = { 'x': 5, 'y': 5, 'width': 5, 'height': 5, 'fill': color, 'opacity': opacity, 'name': 'rect' };
                    patternStyle.width = 10;
                    patternStyle.height = 10;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "pacman":
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 18, 'height': 18, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                    pathOptions[1] = { 'name': 'path', 'd': 'M 9.081 9.194 L 14.887 6.114 C 14.075000000000001 4.618 12.484 3.0620000000000007 10.596 3.0620000000000007 L 8.835 3.0620000000000007 C 6.138 3.063 3 6.151 3 8.723 L 3 10.402000000000001 C 3 12.974 6.138 16.063000000000002 8.835 16.063000000000002 L 10.596 16.063000000000002 C 12.681000000000001 16.063000000000002 14.431000000000001 14.303000000000003 15.131 12.549000000000003 L 9.081 9.194 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    patternStyle.width = 18;
                    patternStyle.height = 18;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "crosshatch":
                    pathOptions[0] = { 'x': 0, 'y': 0, 'width': 8, 'height': 8, 'fill': 'white', 'stroke': fill, 'opacity': opacity, 'name': 'rect' };
                    pathOptions[1] = {
                        'd': 'M 0 0 L 8 8 Z',
                        'stroke-width': 1,
                        'stroke': color,
                        'name': 'path'
                    };
                    pathOptions[2] = {
                        'd': 'M 8 0 L 0 8 Z',
                        'stroke-width': 1,
                        'stroke': color,
                        'name': 'path'
                    };
                    patternStyle.width = 8;
                    patternStyle.height = 8;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "dots":
                    pathOptions[0] = { 'x': 0, 'y': 0, 'width': 7, 'height': 7, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity, 'name': 'rect' };
                    pathOptions[1] = {
                        'cx': 3,
                        'cy': 3,
                        'r': 2,
                        'stroke-width': 1,
                        'fill': color,
                        'name': 'circle'
                    };
                    patternStyle.width = 7;
                    patternStyle.height = 7;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "diagonalforward":
                    pathOptions[0] = { 'x': 0, 'y': 0, 'width': 6, 'height': 6, 'fill': 'white', 'stroke': fill, 'opacity': opacity, 'name': 'rect' };
                    pathOptions[1] = {
                        'd': 'M 3 -3 L 9 3 M 6 6 L 0 0 M 3 9 L -3 3',
                        'stroke-width': 2,
                        'stroke': color,
                        'name': 'path'
                    };
                    patternStyle.width = 6;
                    patternStyle.height = 6;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "diagonalbackward":
                    pathOptions[0] = { 'x': 0, 'y': 0, 'width': 6, 'height': 6, 'stroke-width': 2, 'fill': 'white', 'stroke': fill, 'opacity': opacity, 'name': 'rect' };
                    pathOptions[1] = {
                        'd': 'M 3 -3 L -3 3 M 0 6 L 6 0 M 9 3 L 3 9',
                        'stroke-width': 2,
                        'stroke': color,
                        'name': 'path'
                    };
                    patternStyle.width = 6;
                    patternStyle.height = 6;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "grid":
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 6, 'height': 6, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                    pathOptions[1] = {
                        'name': 'path',
                        'd': 'M 1 3.5 L 11 3.5 M 0 3.5 L 11 3.5 M 0 7.5 L 11 7.5 M 0 11.5 L 11 11.5 M 5.5 0 L 5.5 12 M 11.5 0 L 11.5 12 Z',
                        'stroke-width': 1,
                        'stroke': color
                    };
                    patternStyle.width = 6;
                    patternStyle.height = 6;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "turquoise":
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 17, 'height': 17, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                    pathOptions[1] = { 'name': 'path', 'd': 'M 2.697 0.5319999999999996 C 3.8695005238907747 0.5319999999999996 4.82 1.4771268931071944 4.82 2.643 C 4.82 3.808873106892805 3.8695005238907747 4.754 2.697 4.754 C 1.5244994761092252 4.754 0.5739999999999998 3.808873106892805 0.5739999999999998 2.643 C 0.5739999999999998 1.4771268931071944 1.5244994761092252 0.5319999999999996 2.697 0.5319999999999996 Z', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                    pathOptions[2] = { 'name': 'path', 'd': 'M 13.928 0.5319999999999996 C 15.100500523890776 0.5319999999999996 16.051000000000002 1.4771268931071944 16.051000000000002 2.643 C 16.051000000000002 3.808873106892805 15.100500523890776 4.754 13.928 4.754 C 12.755499476109225 4.754 11.805 3.808873106892805 11.805 2.643 C 11.805 1.4771268931071944 12.755499476109225 0.5319999999999996 13.928 0.5319999999999996 Z', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                    pathOptions[3] = { 'name': 'path', 'd': 'M 8.313 0.5319999999999996 C 9.485500523890776 0.5319999999999996 10.436 1.4771268931071944 10.436 2.643 C 10.436 3.808873106892805 9.485500523890776 4.754 8.313 4.754 C 7.140499476109226 4.754 6.19 3.808873106892805 6.19 2.643 C 6.19 1.4771268931071944 7.140499476109226 0.5319999999999996 8.313 0.5319999999999996 Z', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                    pathOptions[4] = { 'name': 'path', 'd': 'M 13.928 6.16 C 15.100500523890776 6.16 16.051000000000002 7.105126893107196 16.051000000000002 8.271 C 16.051000000000002 9.436873106892806 15.100500523890776 10.382000000000001 13.928 10.382000000000001 C 12.755499476109225 10.382000000000001 11.805 9.436873106892806 11.805 8.271 C 11.805 7.105126893107196 12.755499476109225 6.16 13.928 6.16 Z', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                    pathOptions[5] = { 'name': 'path', 'd': 'M 8.313 6.16 C 9.485500523890776 6.16 10.436 7.105126893107196 10.436 8.271 C 10.436 9.436873106892806 9.485500523890776 10.382000000000001 8.313 10.382000000000001 C 7.140499476109226 10.382000000000001 6.19 9.436873106892806 6.19 8.271 C 6.19 7.105126893107196 7.140499476109226 6.16 8.313 6.16 Z', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                    pathOptions[6] = { 'name': 'path', 'd': 'M 13.928 11.787999999999998 C 15.100500523890776 11.787999999999998 16.051000000000002 12.733126893107194 16.051000000000002 13.899 C 16.051000000000002 15.064873106892804 15.100500523890776 16.009999999999998 13.928 16.009999999999998 C 12.755499476109225 16.009999999999998 11.805 15.064873106892804 11.805 13.899 C 11.805 12.733126893107194 12.755499476109225 11.787999999999998 13.928 11.787999999999998 Z', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                    pathOptions[7] = { 'name': 'path', 'd': 'M 8.313 11.787999999999998 C 9.485500523890776 11.787999999999998 10.436 12.733126893107194 10.436 13.899 C 10.436 15.064873106892804 9.485500523890776 16.009999999999998 8.313 16.009999999999998 C 7.140499476109226 16.009999999999998 6.19 15.064873106892804 6.19 13.899 C 6.19 12.733126893107194 7.140499476109226 11.787999999999998 8.313 11.787999999999998 Z', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                    patternStyle.width = 17;
                    patternStyle.height = 17;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "star":
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 21, 'height': 21, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                    pathOptions[1] = {
                        'name': 'path',
                        'd': 'M 15.913 18.59 L 10.762 12.842 L 5.613 18.75 L 8.291 11.422 L 0.325 9.91 L 8.154 8.33 L 5.337 0.91 L 10.488 6.658 L 15.637 0.75 L 12.959 8.078 L 20.925 9.59 L 13.096 11.17 z',
                        'stroke-width': 1,
                        'stroke': color,
                        'fill': color
                    };
                    patternStyle.width = 21;
                    patternStyle.height = 21;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "triangle":
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 10, 'height': 10, 'fill': 'white', 'opacity': opacity };
                    pathOptions[1] = {
                        'name': 'path',
                        'd': 'M 4.987 0 L 7.48 4.847 L 9.974 9.694 L 4.987 9.694 L 0 9.694 L 2.493 4.847 z',
                        'stroke-width': 1,
                        'stroke': color,
                        'fill': color
                    };
                    patternStyle.width = 10;
                    patternStyle.height = 10;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "circle":
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 9, 'height': 9, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                    pathOptions[1] = {
                        'name': 'circle',
                        'cx': 5.125,
                        'cy': 3.875,
                        'r': 3.625,
                        'stroke-width': 1,
                        'fill': color
                    };
                    patternStyle.width = 9;
                    patternStyle.height = 9;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "tile":
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 18, 'height': 18, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                    pathOptions[1] = { 'name': 'path', 'd': 'M 0 9 L 0 0 L 9 0 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    pathOptions[2] = { 'name': 'path', 'd': 'M 9 9 L 9 0 L 18 0 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    pathOptions[3] = { 'name': 'path', 'd': 'M 0 18 L 0 9 L 9 9 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    pathOptions[4] = { 'name': 'path', 'd': 'M 9 18 L 9 9 L 18 9 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    patternStyle.width = 18;
                    patternStyle.height = 18;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "horizontaldash":
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 12, 'height': 12, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                    pathOptions[1] = { 'name': 'path', 'd': 'M 0 1.5 L 10 1.5 M 0 5.5 L 10 5.5 M 0 9.5 L 10 9.5 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    patternStyle.width = 12;
                    patternStyle.height = 12;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "verticaldash":
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 12, 'height': 12, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                    pathOptions[1] = { 'name': 'path', 'd': 'M 1.5 0 L 1.5 10 M 5.5 0 L 5.5 10 M 9.5 0 L 9.5 10 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    patternStyle.width = 12;
                    patternStyle.height = 12;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "rectangle":
                    pathOptions[0] = { 'x': 0, 'y': 0, 'name': 'rect', 'width': 12, 'height': 12, 'fill': 'white', 'opacity': opacity };
                    pathOptions[1] = { 'name': 'rect', 'x': 1, 'y': 2, 'width': 4, 'height': 9, 'fill': color, 'opacity': opacity };
                    pathOptions[2] = { 'name': 'rect', 'x': 7, 'y': 2, 'width': 4, 'height': 9, 'fill': color, 'opacity': opacity };
                    patternStyle.width = 12;
                    patternStyle.height = 12;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "box":
                    pathOptions[0] = { 'x': 0, 'y': 0, 'name': 'rect', 'width': 13, 'height': 13, 'fill': 'white', 'opacity': opacity };
                    pathOptions[1] = { 'name': 'rect', 'x': 1.5, 'y': 1.5, 'width': 10, 'height': 9, 'fill': color, 'opacity': opacity };
                    patternStyle.width = 10;
                    patternStyle.height = 10;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "horizontalstripe":
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 10, 'height': 12, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                    pathOptions[1] = { 'name': 'path', 'd': 'M 0 0.5 L 10 0.5 M 0 4.5 L 10 4.5 M 0 8.5 L 10 8.5 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    patternStyle.width = 10;
                    patternStyle.height = 12;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "verticalstripe":
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 12, 'height': 10, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                    pathOptions[1] = { 'name': 'path', 'd': 'M 0.5 0 L 0.5 10 M 4.5 0 L 4.5 10 M 8.5 0 L 8.5 10 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    patternStyle.width = 12;
                    patternStyle.height = 10;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;
                case "bubble":
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 20, 'height': 20, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = { 'name': 'circle', 'cx': 5.217, 'cy': 11.325, 'r': 3.429, 'stroke-width': 1, 'fill': '#D0A6D1' };
                    pathOptions[2] = { 'name': 'circle', 'cx': 13.328, 'cy': 6.24, 'r': 4.884, 'stroke-width': 1, 'fill': color };
                    pathOptions[3] = { 'name': 'circle', 'cx': 13.277, 'cy': 14.66, 'r': 3.018, 'stroke-width': 1, 'fill': '#D0A6D1' };
                    patternStyle.width = 20;
                    patternStyle.height = 20;
                    this.loadPattern(chart, pathOptions, '', patternContext);
                    break;



                case "custom":
                    patternStyle = document.getElementById(hoverStyle.customPattern);
                    break;
            }
            var pattern = ctx.createPattern(patternStyle, 'repeat');
            return pattern;
        },
        // Canvas pattern end
        // Canvas highlight and selection end

        //Get selected class for removing lengeds selection in multiselection mode
        foundClasses: function (id) {
            var pointClasses = [];
            $("[id*=" + id + "]").each(function () {
                var pointClass = $(this).attr('class') ? $(this).attr('class') : '';
                if (pointClass.indexOf('Selection') >= 0) {
                    pointClasses.push(pointClass);
                }
            });
            return pointClasses;
        },
        // SVG selection started here
        selection: function (chart, evt, series, tracker, legendData, seriesIndex, pointIndex, parentNodeId, targetId, data) {
            var clusterPoints = this.model.clusterPoints,
                clusterPointslength = clusterPoints ? clusterPoints.length : 0,
                seriesCollection = this.model._visibleSeries,
                seriesLenth = seriesCollection.length,
                index = (this.model.AreaType == 'none' && seriesLenth == 1) ? pointIndex : seriesIndex,
                highlight = series.selectionSettings,
                isMultiSelection = this.model._visibleSeries[seriesIndex].selectionSettings.type.toLowerCase() == 'multiple' ? true : false,
                name = 'series' + seriesIndex,
                found_class = false,
                pathName = $('#' + targetId).attr('name'),
                patternName = highlight.pattern.toLowerCase(),
                mode = highlight.mode, isElement;
            if (parentNodeId)
                isElement = (parentNodeId.indexOf(this.svgObject.id + "_SeriesGroup_") >= 0 || parentNodeId.indexOf(this.svgObject.id + "_Chart3D") >= 0) ? true : false;

            if (this.model.AreaType != 'none' || (this.model.AreaType == 'none' && mode == "series" && seriesLenth > 1)) {
                $('style').each(function () {
                    if ($(this).html().indexOf('.' + chart._id + 'SelectionStyle' + name) > -1) {
                        found_class = true;
                    }
                });
            }
            if (!chart.vmlRendering && this.model.enable3D) {
                if ((mode == 'series' || legendData) && (this.model.AreaType != 'none' || (this.model.AreaType == 'none' && seriesLenth != 1))) {
                    this.highlightSeries(chart, seriesIndex, pointIndex, 'Selection', name, highlight, evt, legendData, data)
                    $('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class', 'Selection' + name + 'Style' + name + '1');
                }
                else if (mode == 'cluster' && chart.model.AreaType != 'none')
                    this.highlightCluster(chart, seriesIndex, pointIndex, 'Selection', name, highlight, evt, data)
                else {
                    if (this.model.AreaType == 'none') {
                        this.highlightPoint(chart, seriesIndex, pointIndex, 'Selection', name + index, highlight, evt, data);
                        $('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class', 'Selection' + name + index + 'Style' + name + index + '1');
                    } else {
                        this.highlightPoint(chart, seriesIndex, pointIndex, 'Selection', name, highlight, evt, data)
                        $('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class', 'Selection' + name + 'Style' + name + '1');
                    }
                }
            }
            else {
                if ((mode != 'cluster' || legendData) || chart.model.AreaType == 'none') {
                    var colorStyle = {};
                    colorStyle.name = "2D",
                        colorStyle.index = this.model.AreaType == 'none' ? index : seriesIndex; colorStyle.api = "Selection",
                            colorStyle.color = highlight.color != "" ? highlight.color : legendData ? (this.model.AreaType == 'none' ? this.model.pointColors[index] : this.model.seriesColors[index]) :
                                $('#' + targetId).attr('fill') != 'none' ? $('#' + targetId).attr('fill') : $('#' + targetId).attr('stroke');
                    if (Object.prototype.toString.call(colorStyle.color) === '[object Array]')
                        colorStyle.color = colorStyle.color[1].color;
                    var fill = ((patternName == "none" || chart.vmlRendering) || patternName == "") ? highlight.color : this.pattern(chart, evt, colorStyle, highlight),
                        opacity = highlight.opacity,
                        strokeColor = highlight.border.color,
                        strokeWidth = highlight.border.width;
                    if (!found_class) {
                        if (this.model.AreaType == 'none' && (((mode == 'series' || legendData) && seriesLenth == 1) || (mode != 'series' && !legendData))) {
                            $('style').each(function () {
                                if ($(this).html().indexOf('.SelectionStyle' + name + 'Point' + index) > -1) {
                                    found_class = true;
                                }
                            });
                            if (!found_class) {
                                this.createStyle(chart, chart._id + 'Selection', name + 'Point' + index, opacity, fill, strokeColor, strokeWidth);
                                this.createStyle(chart, chart._id + 'SelectionLegend', name + 'Point' + index, opacity, fill, 'transparent', 0);
                            }
                        } else if (this.model.AreaType == 'none' && seriesLenth > 1 || this.model.AreaType != 'none') {
                            this.createStyle(chart, chart._id + 'Selection', name, opacity, fill, strokeColor, strokeWidth);
                            this.createStyle(chart, chart._id + 'SelectionLegend', name, opacity, fill, 'transparent', 0);
                        }

                    }
                }
                if ((mode == 'series' || legendData) && ((chart.model.AreaType == 'none' && seriesLenth > 1) || (chart.model.AreaType != 'none'))) {
                    if (!isElement) {
                        var otherElements = $('#' + parentNodeId).childNodes ? $('#' + parentNodeId).childNodes : [];
                        for (var i = 0; i < otherElements.length; i++)
                            $('#' + otherElements[i].id).attr('class', chart._id + 'SelectionStyle');
                    }
                    $("[id*=" + this.svgObject.id + '_Series' + index + "]").each(function () {
                        if (this.parentNode.id == chart.svgObject.id + '_SeriesGroup_' + index || this.parentNode.id == chart.svgObject.id + '_symbolGroup_' + index) {
                            var className = $(this).attr("name") ? chart._id + 'SelectionPathStyle' + name : chart._id + 'SelectionStyle' + name;
                            $(this).attr('class', className);
                        }
                    });

                    //for legend selection sets here              
                    $('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class', chart._id + 'SelectionLegendStyle' + name);

                    // removed tracker symbol
                    if (tracker) $('#' + parentNodeId).remove();

                }

                else if (mode == "cluster" && (chart.model.AreaType != 'none') && !sf.util.isNullOrUndefined(targetId)) {
                    var matchString, clustername, indexVal, text, colorStyle, opacity, strokeColor, fill, strokeWidth;
                    matchString = this.svgObject.id + "_Series";
                    var clusterPoints = chart.model.clusterPoints;
                    index = targetId.match(/(\d+)/g);
                    pointIndex = parseInt(index[index.length - 1]);
                    if (targetId.indexOf('SeriesText') >= 0) {
                        var datas = this.GetSeriesPoint(evt);
                        pointIndex = datas.region.Region.PointIndex;
                    }
                    var findClass, seriesSelectionIndex;
                    for (var k = 0; k < clusterPoints.length; k++) {
                        seriesSelectionIndex = clusterPoints[k].seriesIndex;
                        name = 'ClusterSeries' + seriesSelectionIndex;
                        //creating individual styles for the points in different series
                        colorStyle = {};
                        colorStyle.index = seriesSelectionIndex;
                        colorStyle.name = "2D"; colorStyle.api = "Selection" + name;
                        highlight = seriesCollection[seriesSelectionIndex].selectionSettings;
                        colorStyle.color = highlight.color != "" ? highlight.color : this.model.seriesColors[seriesSelectionIndex];
                        if (Object.prototype.toString.call(colorStyle.color) === '[object Array]')
                            colorStyle.color = colorStyle.color[1].color;
                        opacity = highlight.opacity;
                        var strokeColor = highlight.border.color;
                        var strokeWidth = highlight.border.width;
                        var fill = ((patternName == "none" || chart.vmlRendering) || patternName == "") ? colorStyle.color : this.pattern(chart, evt, colorStyle, highlight);
                        $('style').each(function () {
                            if ($(this).html().indexOf('.' + chart._id + 'SelectionStyle' + name) > -1) {
                                findClass = true;
                            }
                        });
                        if (!findClass) {
                            this.createStyle(chart, chart._id + 'Selection', name, opacity, fill, strokeColor, strokeWidth);
                            this.createStyle(chart, chart._id + 'SelectionLegend', name, opacity, fill, 'transparent', 0);
                        }
                        var className = $('#' + matchString + clusterPoints[k].seriesIndex + '_Point' + clusterPoints[k].pointIndex).attr("name") ? chart._id + 'SelectionPathStyle' + name : chart._id + 'SelectionStyle' + name;
                        $('#' + matchString + clusterPoints[k].seriesIndex + '_Point' + clusterPoints[k].pointIndex).attr('class', className);
                        $('#' + matchString + clusterPoints[k].seriesIndex + '_Point' + clusterPoints[k].pointIndex + '_symbol').attr('class', className);
                        if (chart.model._visibleSeries[seriesSelectionIndex].visibility != "hidden")
                            $('#' + this.svgObject.id + '_LegendItemShape' + seriesSelectionIndex).not("[class*='Highlight']").attr('class', chart._id + 'SelectionLegendStyle' + name);
                        // checked condition for financial series
                        var finName = $('#' + targetId).attr("name");
                        if (finName != undefined && (finName == 'candle' || finName.indexOf('hilo') >= 0)) {
                            $('[id$=' + matchString + clusterPoints[k].seriesIndex + '_' + 'Point' + clusterPoints[k].pointIndex + ']').attr('class', 'HighlightStyle' + name);
                        }
                    }
                    if (tracker) {
                        $('#' + this.svgObject.id + '_Series' + seriesSelectionIndex + '_Point' + pointIndex).attr('class', chart._id + 'SelectionStyle' + name);
                        $('#' + this.svgObject.id + '_Series' + seriesSelectionIndex + '_Point' + pointIndex + '_symbol').attr('class', chart._id + 'SelectionStyle' + name);
                        $('#' + parentNodeId).remove();
                    }
                }


                else {
                    // checked condition for whether target id is area related or not
                    if ((!$('#' + targetId).attr("name") && targetId != chart.svgObject.id + '_Series' + index) && chart.model.AreaType != 'none') {
                        $('#' + targetId).attr('class', chart._id + 'SelectionStyle' + name);
                        if (this.model.commonSeriesOptions.columnFacet == 'cylinder' || series.columnFacet == 'cylinder') {
                            for (i = 0; i < 2; i++) {
                                $('#' + targetId.replace(/2$/, i)).attr('class', chart._id + 'SelectionStyle' + name);
                            }
                        }
                        $('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class', chart._id + 'SelectionLegendStyle' + name);
                        $('#' + targetId + '_symbol').attr('class', chart._id + 'SelectionStyle' + name);

                        if (tracker) {
                            $('#' + targetId + '_symbol').attr('class', chart._id + 'SelectionStyle' + name);
                            $('#' + parentNodeId).remove();
                        }
                    } else {
                        $('#' + targetId).attr('class', chart._id + 'SelectionStyle' + name + 'Point' + index);
                        $('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class', chart._id + 'SelectionLegendStyle' + name + 'Point' + index);
                        if (tracker) $('#' + parentNodeId).remove();
                    }

                    // checked condition for financial series
                    var finName = $('#' + targetId).attr("name");
                    if (finName != undefined && (finName == 'candle' || finName.indexOf('hilo') >= 0)) {
                        $('[id$=' + targetId + ']').attr('class', chart._id + 'SelectionStyle' + name);
                        $('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class', chart._id + 'SelectionLegendStyle' + name);
                    }
                }
            }
        },

        //Selection Removing Logic
        removeSelection: function (seriesIndex, pointIndex, seriesCollection, mode, isMultiSelection, legendData, isSelected) {
            var seriesLength = seriesCollection.length,
                clusterPoints = this.model.clusterPoints, pointClasses, 
                clusterPointslength = clusterPoints ? clusterPoints.length : 0, selectionSettings;
            //Removing selectiond mode series
            if ((mode == 'series' || legendData) && (this.model.AreaType != 'none' || (this.model.AreaType == 'none' && seriesLength > 1))) {
                for (var i = 0; i < seriesLength; i++) {
                    selectionSettings = seriesCollection[i].selectionSettings;
                    if ((selectionSettings.mode != 'point' && selectionSettings.type.toLowerCase() == 'single') || (legendData && selectionSettings.type.toLowerCase() == 'single')) {
                        $(this.svgObject).find('[id*=' + this.svgObject.id + '_SeriesGroup_' + i + '],[id*=' + this.svgObject.id + '_symbolGroup_' + i + '],[id*=_Region_Series_' + i + '_]').each(function () {
                            $(this).find("*").attr('class', '');
                            $(this).attr('class', '');
                        });
                        $('#' + this._id + '_Selection_Legend' + i + '_canvas').remove();
                        $('#' + this._id + '_Selection_series' + i + '_canvas').remove();
                        $("[id*=" + '_Region_Series_' + i + "]").attr('class', '');
                        $('#' + this.svgObject.id + '_LegendItemShape' + i).attr('class', '');
                    } else if (isSelected && selectionSettings.type.toLowerCase() == 'multiple') {
                        $('#' + this._id + '_Selection_series' + seriesIndex + '_canvas').remove();
                        $('#' + this._id + '_Selection_Legend' + seriesIndex + '_canvas').remove();
                        $("[id*=" + '_Region_Series_' + seriesIndex + "]").attr('class', '');
                        $("[id*=" + this.svgObject.id + '_Series' + seriesIndex + "]").attr('class', '');
                        $('#' + this.svgObject.id + '_LegendItemShape' + seriesIndex).attr('class', '');
                    }
                }
            }
            //Removing selection mode Cluster
            if (mode == 'cluster' && this.model.AreaType != 'none' && !legendData) {
                if (!isMultiSelection) {
                    if (this.model.enableCanvasRendering) {
                        $('[id*=' + this._id + '_Selection_Cluster' + ']').remove();
                        $('[id*=' + this._id + '_SelectionCluster_Legend' + ']').remove();
                        this.selectedPoint = null;
                    } else
                        for (var k = 0; k < clusterPointslength; k++) {
                            $("[id*=" + '_Region_Series_' + clusterPoints[k].seriesIndex + '_Point_' + "]").attr('class', '');
                            $("[id*=" + this.svgObject.id + '_Series' + clusterPoints[k].seriesIndex + '_Point' + "]").attr('class', '');
                            $('#' + this.svgObject.id + '_LegendItemShape' + clusterPoints[k].seriesIndex).attr('class', '');
                        }
                }
                else {
                    if (!this.model.enableCanvasRendering) {
                        for (var k = 0; k < clusterPointslength; k++) {
                            $("[id*=" + "_Region_Series_" + clusterPoints[k].seriesIndex + "_Point_" + clusterPoints[k].pointIndex + "]").attr('class', '');
                            $("[id*=" + this.svgObject.id + '_Series' + clusterPoints[k].seriesIndex + '_Point' + clusterPoints[k].pointIndex + "]").attr('class', '');
                        }
                        pointClasses = this.model.enable3D ? this.foundClasses('_Region_Series_' + seriesIndex) : this.foundClasses(this.svgObject.id + '_Series' + seriesIndex);
                        (pointClasses.length == 0) ? $("[id*=" + this.svgObject.id + '_LegendItemShape' + "]").attr('class', '') : 0;
                    } else {
                        $('[id*=' + this._id + '_Selection_Cluster' + '_point_' + pointIndex + ']').remove();
                        $('[id*=' + this._id + '_Selection_Cluster' + ']').length == 0 ? $('[id*=' + this._id + '_SelectionCluster_Legend' + ']').remove() : 0;
                    }
                }
            }

            //Removing selection mode point
            if (mode == 'point' && this.model.AreaType != 'none' && !legendData) {
                if (!isMultiSelection) {
                    $('[id*=' + this._id + '_Selection_series' + seriesIndex + '_point_' + ']').remove();
                    $('[id*=' + this._id + '_Selection_Legend' + seriesIndex + ']').remove();
                    $("[id*=" + '_Region_Series_' + seriesIndex + '_Point_' + "]").attr('class', '');
                    $("[id*=" + this.svgObject.id + '_Series' + seriesIndex + '_Point' + "]").attr('class', '');
                    $('#' + this.svgObject.id + '_LegendItemShape' + seriesIndex).attr('class', '');
                }
                else {
                    $('#' + this._id + '_Selection_series' + seriesIndex + '_point_' + pointIndex + '_canvas').remove();
                    $("[id*=" + '_Region_Series_' + seriesIndex + '_Point_' + pointIndex + "]").attr('class', '');
                    $("[id*=" + this.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex + "]").attr('class', '');
                    $("[id*=" + this._id + '_Selection_series' + seriesIndex + "]").length == 0 ? $('#' + this._id + '_Selection_Legend' + seriesIndex + '_canvas').remove() : 0;
                    pointClasses = this.model.enable3D ? this.foundClasses('_Region_Series_' + seriesIndex) : this.foundClasses(this.svgObject.id + '_Series' + seriesIndex);
                    (pointClasses.length == 0) ? $('#' + this.svgObject.id + '_LegendItemShape' + seriesIndex).attr('class', '') : 0;
                }
            }

            //Removing accoumulation series types selections
            if ((mode == 'point' || mode == 'cluster') || (mode == "series" && this.model._visibleSeries.length == 1) && this.model.AreaType == 'none' && !legendData) {
                if (!isMultiSelection) {
                    $("[id*=" + this._id + '_Selection_series' + ']').remove();
                    $("[id*=" + this._id + '_Selection_Legend' + ']').remove()
                    $("[id*=" + '_Region_Series_' + seriesIndex + '_Point_' + "]").attr('class', '');
                    $("[id*=" + this.svgObject.id + '_Series' + seriesIndex + '_Point' + "]").attr('class', '');
                    (this.model._visibleSeries.length > 1) ? $("[id*=" + this.svgObject.id + '_LegendItemShape' + seriesIndex + "]").attr('class', '') : $("[id*=" + this.svgObject.id + '_LegendItemShape' + "]").attr('class', '');
                } else {
                    $('#' + this._id + '_Selection_series' + seriesIndex + '_point_' + pointIndex + '_canvas').remove();
                    $("[id*=" + '_Region_Series_' + seriesIndex + '_Point_' + pointIndex + "]").attr('class', '');
                    $("[id*=" + this.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex + "]").attr('class', '');
                    (this.model._visibleSeries.length > 1) ? $('#' + this.svgObject.id + '_LegendItemShape' + seriesIndex).attr('class', '') : $('#' + this.svgObject.id + '_LegendItemShape' + pointIndex).attr('class', '');
                    (this.model._visibleSeries.length > 1) ? $('#' + this._id + '_Selection_Legend' + seriesIndex + '_canvas').remove() : $('#' + this._id + '_Selection_Legend' + pointIndex + '_canvas').remove();
                }
            }
        },
        // style append operation perform here
        createStyle: function (chart, api, name, opacity, fill, strokeColor, strokeWidth, strokeOpacity) {
            if (chart.vmlRendering) {
                var style = document.createElement('style');
                style.id = api + "Segment";
                opacity = opacity * 100;
                var text = "." + api + "Style" + name + " {filter: alpha(opacity=" + opacity + ");}." + api + "PathStyle" + name + "  {filter: alpha(opacity=" + opacity + ");}";
                style.setAttribute("type", "text/css");
                if (style.styleSheet) {   // for IE
                    style.styleSheet.cssText = text;
                } else {                // others
                    var textnode = document.createTextNode(text);
                    style.appendChild(textnode);
                }
                var header = document.getElementsByTagName('head')[0];
                header.appendChild(style);
            } else {
                $("<style id=" + api + "Segment" + name + " type='text/css'> ." + api + "Style" + name + "{ fill:" + fill + ";opacity:" + opacity + ";stroke:" + strokeColor + ";stroke-width:" + strokeWidth + ";stroke-opacity:" + strokeOpacity + "}</style>").appendTo("body");
                $("<style id=" + api + "Path" + name + " type='text/css'> ." + api + "PathStyle" + name + "{ opacity:" + opacity + ";stroke:" + strokeColor + ";stroke-width:" + strokeWidth + ";stroke-opacity:" + strokeOpacity + "}</style>").appendTo("body");
            }
        },

        // point highlight 3D perform here
        highlightPoint: function (chart, seriesIndex, pointIndex, api, name, highlight, evt) {
            var pathId = "_Region_Series_" + seriesIndex + "_Point_" + pointIndex,
                gElement = $(this.svgObject).find('[id$=' + pathId + '],[id*=' + pathId + 'back],[id*=' + pathId + 'front]');
            for (var i = 0; i < gElement.length; i++) {
                var style3D = [];
                style3D.api = api + name; style3D.seriesName = name;
                style3D.name = $("[id=" + gElement[i].id + "]").attr('name');
                style3D.index = i;
                var color = this.highlightFill(highlight, chart, seriesIndex, pointIndex);
                var className = ($('#' + gElement[i].id).attr('class'));
                className = className ? className : '';
                if (className.indexOf('Selection') < 0) {
                    $("[id=" + gElement[i].id + "]").attr('class', this.dStyle(style3D, color, chart, evt, highlight));
                }
            }
        },
        //cluster highlight of 3D is perfomed here
        highlightCluster: function (chart, seriesIndex, pointIndex, api, name, highlight, evt) {
            if (chart.model.AreaType != 'none') {
                var name, pathId, gElement, style3D, color, className, clusterPoints = [];
                var xvalue = chart.model._visibleSeries[seriesIndex]._visiblePoints[pointIndex].x;
                for (var i = 0, len = chart.model._visibleSeries.length; i < len; i++) {
                    for (var j = 0; j < chart.model._visibleSeries[i]._visiblePoints.length; j++) {
                        if (xvalue == chart.model._visibleSeries[i]._visiblePoints[j].x)
                            clusterPoints[clusterPoints.length] = { seriesIndex: i, pointIndex: j };
                    }
                }
                for (var k = 0; k < clusterPoints.length; k++) {
                    name = 'series' + k;
                    pathId = "_Region_Series_" + clusterPoints[k].seriesIndex + "_Point_" + clusterPoints[k].pointIndex;
                    gElement = $(this.svgObject).find('[id$=' + pathId + '],[id*=' + pathId + 'back],[id*=' + pathId + 'front]');
                    for (var j = 0; j < gElement.length; j++) {
                        style3D = [];
                        style3D.api = api + name; style3D.seriesName = 'series' + k;
                        style3D.name = $("[id=" + gElement[j].id + "]").attr('name');
                        style3D.index = j;
                        seriesIndex = k;
                        highlight = (api == 'Highlight') ? chart.model._visibleSeries[k].highlightSettings : chart.model._visibleSeries[k].selectionSettings;
                        color = this.highlightFill(highlight, chart, seriesIndex, pointIndex);
                        className = ($('#' + gElement[j].id).attr('class'));
                        className = className ? className : '';
                        if ((className.indexOf('Selection' + name + 'Style') < 0) && (className.indexOf('SelectionStyle') < 0)) {
                            $("[id=" + gElement[j].id + "]").attr('class', this.dStyle(style3D, color, chart, evt, highlight));
                        }

                    }
                    if (api == 'Highlight')
                        $('#' + this.svgObject.id + '_LegendItemShape' + k).not("[class*='Selection']").attr('class', 'Highlight' + name + 'Style' + name + '1');
                    else
                        $('#' + this.svgObject.id + '_LegendItemShape' + k).attr('class', 'Selection' + name + 'Style' + name + '1');
                }

            }
        },
        // point series 3D perform here
        highlightSeries: function (chart, seriesIndex, index, api, name, highlight, evt, legendData) {
            var seriesIndex = seriesIndex,
                pointIndex = index,
                length = chart.model._visibleSeries.length,
                pathId = (chart.model.AreaType == 'none' && length == 1) ? "_Region_Series_" + seriesIndex + "_Point_" + index : "_Region_Series_" + seriesIndex + "_Point_",
                gElement = $(this.svgObject).find('[id*=' + pathId + ']'), style3D, color,
                className = legendData ? $('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class') : evt ? ($('#' + evt.target.id).attr('class')) : '';
            className = className ? className : '';
            if (className.indexOf('SelectionStyle') < 0 || legendData) {
                for (var i = 0; i < gElement.length; i++) {
                    style3D = [];
                    style3D.api = api + name, style3D.seriesName = name,
                        style3D.name = $("[id=" + gElement[i].id + "]").attr('name'),
                        style3D.index = i;
                    color = this.highlightFill(highlight, chart, seriesIndex, pointIndex, legendData);
                    className = $('#' + gElement[i].id).attr('class');
                    className = className ? className : '';
                    if (className.indexOf('SelectionStyle') < 0 && (className.indexOf('Selection' + name + 'Style') < 0)) {
                        $("[id=" + gElement[i].id + "]").attr('class', this.dStyle(style3D, color, chart, evt, highlight));
                    }
                }
            }
        },

        //SVG highlight logic started here
        highlight: function (chart, evt, series, legendData, data, parentNodeId, targetID, tracker) {
            var highlight = series.highlightSettings, myLocation;
            var seriesIndex = $.inArray(series, chart.model._visibleSeries), pointIndex;
            var name = 'series' + seriesIndex;//series.name.replace(/ /g, ''); // removed space for series name
            var found_class = false;
            var index = seriesIndex;
            var targetId = targetID || evt.target.id;
            var matched = jQuery.uaMatch(navigator.userAgent);
            if (!tracker && this.isTouch(evt) && matched.browser == 'chrome') {
                myLocation = evt.originalEvent.changedTouches[0];
                targetId = document.elementFromPoint(myLocation.clientX, myLocation.clientY).id;
            }
            parentNodeId = parentNodeId || evt.target.parentNode.id;
            var isElement = (parentNodeId.indexOf(this.svgObject.id + "_SeriesGroup_") >= 0 || parentNodeId.indexOf(this.svgObject.id + "_Chart3D") >= 0) ? true : false;
            var pathName = $('#' + targetId).attr('name');
            var patternName = highlight.pattern.toLowerCase();
            var length = chart.model._visibleSeries.length;
            if (chart.model.AreaType == 'none' && length == 1) {
                if (!chart.model.enable3D) {
                    var matchStr = legendData ? this.svgObject.id + '_LegendItemShape' : this.svgObject.id + "_Series" + seriesIndex + "_Point";
                    var id = legendData ? this.svgObject.id + '_LegendItemShape' + legendData.legendItem.LegendItem.PointIndex : targetId;
                    pointIndex = id.substr(matchStr.length);
                    index = pointIndex;
                } else {
                    index = legendData ? legendData.legendItem.LegendItem.PointIndex : data.region.Region.PointIndex;
                }
            }
            $('style').each(function () {
                if ($(this).html().indexOf('.HighlightStyle' + name) > -1) {
                    found_class = true;
                }
            });
            if (chart.model.enable3D && !chart.vmlRendering) {
                if ((highlight.mode == 'series' || legendData) && ((chart.model.AreaType == 'none' && length != 1) || chart.model.AreaType != 'none')) {
                    this.highlightSeries(chart, seriesIndex, index, 'Highlight', name, highlight, evt, legendData)
                    $('#' + this.svgObject.id + '_LegendItemShape' + index).not("[class*='Selection']").attr('class', 'Highlight' + name + 'Style' + name + '1');
                } else if (highlight.mode == 'cluster' && chart.model.AreaType != 'none') {
                    this.highlightCluster(chart, seriesIndex, data.pointData.pointIndex, 'Highlight', name, highlight, evt);

                } else {
                    pointIndex = data ? data.pointData.pointIndex : index;
                    this.highlightPoint(chart, seriesIndex, pointIndex, 'Highlight', name + pointIndex, highlight, evt)
                    $('#' + this.svgObject.id + '_LegendItemShape' + index).not("[class*='Selection']").attr('class', 'Highlight' + name + pointIndex + 'Style' + name + pointIndex + '1');
                }
            } else {
                if (highlight.mode || this.model.AreaType == 'none') {
                    var colorStyle = {};
                    colorStyle.name = "2D";
                    colorStyle.index = seriesIndex; colorStyle.api = "Highlight"; colorStyle.color = highlight.color != "" ? highlight.color : legendData ? (this.model.AreaType == 'none' ? this.model.pointColors[index] : this.model.seriesColors[index]) : $('#' + targetId).attr('fill');
                    if (Object.prototype.toString.call(colorStyle.color) === '[object Array]')
                        colorStyle.color = colorStyle.color[1].color;
                    var fill = ((patternName == "none" || chart.vmlRendering) || patternName == "") ? highlight.color : this.pattern(chart, evt, colorStyle, highlight);
                    var opacity = tracker ? 1 : highlight.opacity;
                    var strokeColor = (tracker) ? ((series.type.toLowerCase().indexOf("hilo") == -1) ? chart.model.highlightColor : fill) : highlight.border.color;
                    var strokeWidth = tracker ? 3.5 : highlight.border.width;
                    var strokeOpacity = (tracker && series.type.toLowerCase().indexOf("hilo") == -1) ? 0.5 : 1;
                    if (!found_class) {
                        this.createStyle(chart, 'Highlight', name, opacity, fill, strokeColor, strokeWidth, strokeOpacity);
                        this.createStyle(chart, 'HighlightLegend', name, opacity, fill, 'transparent', 0, strokeOpacity);
                    }
                }

                // sets the style for the segment or path started here
                var className = legendData ? $('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class') : $('#' + targetId).attr('class');
                className = className ? className : '';
                if (className.indexOf("Selection") == -1) {
                    // checked mode of the highlight series
                    if (((highlight.mode == 'series' && !tracker) || legendData) && ((chart.model.AreaType == 'none' && length != 1) || chart.model.AreaType != 'none')) {
                        $("[id*=" + this.svgObject.id + '_Series' + index + "]").each(function () {
                            if (this.parentNode.id == chart.svgObject.id + '_SeriesGroup_' + index || this.parentNode.id == chart.svgObject.id + '_symbolGroup_' + index) {
                                var selectClass = $(this).attr('class');
                                var className = $(this).attr("name") ? 'HighlightPathStyle' + name : 'HighlightStyle' + name;
                                // this condition is checked for whether already selected and it's symbol
                                if ((selectClass == undefined || selectClass.indexOf('SelectionStyle') == -1) && selectClass != 'SelectionStyle' + name && selectClass != 'SelectionStyleClusterSeries' + seriesIndex && selectClass != 'SelectionPathStyle' + name && parentNodeId.indexOf(chart.svgObject.id + '_symbolGroup_' + index) <= 0) {
                                    $(this).attr('class', className);
                                }
                            }
                        });
                        //for legend highlight sets here
                        $('#' + this.svgObject.id + '_LegendItemShape' + index).not("[class*='Selection']").attr('class', 'HighlightLegendStyle' + name);
                    }
                    else if (highlight.mode == "cluster" && chart.model.AreaType != 'none' && !tracker) {
                        var matchString = this.svgObject.id + "_Series";
                        var clusterPoints = [], seriesHighlightIndex;
                        index = targetId.match(/(\d+)/g);
                        if (index && targetId.toLowerCase().indexOf("point") > 0) {
                            pointIndex = parseInt(index[index.length - 1]);
                            var xvalue = chart.model._visibleSeries[seriesIndex]._visiblePoints[pointIndex].xValue, point;
                            for (var i = 0, len = chart.model._visibleSeries.length; i < len; i++) {
                                for (var j = 0; j < chart.model._visibleSeries[i]._visiblePoints.length; j++) {
                                    point = chart.model._visibleSeries[i]._visiblePoints[j];
                                    if (xvalue == point.xValue && point.isEmpty == false && point.visible == true)
                                        clusterPoints[clusterPoints.length] = { seriesIndex: i, pointIndex: j };
                                }
                            }
                        }
                        for (var k = 0; k < clusterPoints.length; k++) {
                            seriesHighlightIndex = clusterPoints[k].seriesIndex;
                            name = 'series' + seriesHighlightIndex;
                            //creating individual styles for the points in different series
                            colorStyle = {};
                            colorStyle.name = "2D"; colorStyle.api = "Highlight" + name;
                            highlight = chart.model._visibleSeries[seriesHighlightIndex].highlightSettings;
                            colorStyle.color = highlight.color != "" ? highlight.color : this.model.seriesColors[seriesHighlightIndex];
                            if (Object.prototype.toString.call(colorStyle.color) === '[object Array]')
                                colorStyle.color = colorStyle.color[1].color;
                            opacity = highlight.opacity;
                            strokeColor = highlight.border.color;
                            strokeWidth = highlight.border.width;
                            fill = ((patternName == "none" || chart.vmlRendering) || patternName == "") ? colorStyle.color : this.pattern(chart, evt, colorStyle, highlight);
                            if (!found_class) {
                                this.createStyle(chart, 'Highlight', name, opacity, fill, strokeColor, strokeWidth);
                                this.createStyle(chart, 'HighlightLegend', name, opacity, fill, 'transparent', 0);
                            }

                            //applying the created style to the selected element 
                            var selectClass = $('#' + matchString + clusterPoints[k].seriesIndex + '_Point' + clusterPoints[k].pointIndex).attr('class');
                            var symbol = $('#' + matchString + clusterPoints[k].seriesIndex + '_Point' + clusterPoints[k].pointIndex + '_symbol').attr('class');
                            var className = $('#' + matchString + clusterPoints[k].seriesIndex + '_Point' + clusterPoints[k].pointIndex).attr("name") ? 'HighlightPathStyle' + name : 'HighlightStyle' + name;
                            // this condition is checked for whether already selected and it's symbol
                            if ((selectClass == undefined || selectClass.indexOf('SelectionStyleseries' + k) == -1) && selectClass != 'SelectionStyle' + 'series' + k && selectClass != 'SelectionPathStyle' + name && parentNodeId.indexOf(chart.svgObject.id + '_symbolGroup_' + k) <= 0) {
                                $('#' + matchString + clusterPoints[k].seriesIndex + '_' + 'Point' + clusterPoints[k].pointIndex).attr('class', className);
                                $('#' + matchString + clusterPoints[k].seriesIndex + '_' + 'Point' + clusterPoints[k].pointIndex + '_symbol').attr('class', className);
                            }
                            if (chart.model._visibleSeries[seriesHighlightIndex].visibility != "hidden")
                                $('#' + this.svgObject.id + '_LegendItemShape' + seriesHighlightIndex).not("[class*='Selection']").attr('class', 'HighlightLegendStyle' + name);
                            // checked condition for financial series
                            var finName = $('#' + targetId).attr("name");
                            if (finName != undefined && (finName == 'candle' || finName.indexOf('hilo') >= 0)) {
                                $('[id$=' + matchString + clusterPoints[k].seriesIndex + '_' + 'Point' + clusterPoints[k].pointIndex + ']').attr('class', 'HighlightStyle' + name);
                            }
                        }

                    }

                    else {
                        // checked condition for whether target id is area related or not
                        if (!$('#' + targetId).attr("name") && targetId != chart.svgObject.id + '_Series' + index) {
                            selectClass = $('#' + targetId).attr('class') ? $('#' + targetId).attr('class') : '';
                            if ((selectClass.indexOf('Selection') != 0 && parentNodeId.indexOf(chart.svgObject.id + '_symbolGroup_' + index) <= 0 && (data || legendData))) {
                                if (isElement) {
                                    $('#' + targetId).attr('class', 'HighlightStyle' + name);
                                    if (this.model.commonSeriesOptions.columnFacet == 'cylinder' || series.columnFacet == 'cylinder') {
                                        for (i = 0; i < 2; i++) {
                                            $('#' + targetId.replace(/2$/, i)).attr('class', 'HighlightStyle' + name);
                                        }
                                    }
                                }
                                $('#' + targetId + '_symbol').attr('class', 'HighlightStyle' + name);
                                $('#' + this.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex).not("[class*='Selection']").attr('class', 'HighlightStyle' + name);
                                $('#' + this.svgObject.id + '_LegendItemShape' + index).not("[class*='Selection']").attr('class', 'HighlightLegendStyle' + name);
                            }
                            if (targetId.indexOf("symbol") > -1)
                                $('#' + targetId).attr('class', 'HighlightStyle' + name);
                        }
                        // checked condition for financial series
                        var finName = $('#' + targetId).attr("name");
                        if (finName != undefined && (finName == 'candle' || finName.indexOf('hilo') >= 0)) {
                            $('[id$=' + targetId + ']').attr('class', 'HighlightStyle' + name);
                            $('#' + this.svgObject.id + '_LegendItemShape' + index).not("[class*='Selection']").attr('class', 'HighlightLegendStyle' + name);
                        }

                    }
                }
            }

        },

        // 3D style class created here
        dStyle: function (style3D, color, chart, evt, settings) {
            var vector = sf.Ej3DRender.prototype.polygon3D.prototype;
            var highlight = settings;
            var name = style3D.api;
            var seriesName = style3D.seriesName;
            var opacity = highlight.opacity;
            color = chart.colorNameToHex(color);
            if (style3D.name == "XLight")
                color = vector.applyXLight(color, chart);
            else if (style3D.name == "ZLight")
                color = vector.applyZLight(color, chart);
            else
                color = color;
            var colorStyle = {};
            colorStyle.name = style3D.name; colorStyle.color = color; colorStyle.api = name;
            color = (highlight.pattern == "none") ? color : this.pattern(chart, evt, colorStyle, highlight);
            if (document.getElementById(name + "Segment" + seriesName)) {
                var style = document.getElementById(name + "Segment" + seriesName);
                style.innerHTML = style.innerHTML + '.' + name + 'Style' + seriesName + style3D.index + ' { fill:' + color + ";opacity:" + opacity + ' }';
            } else {
                var style = document.createElement('style');
                style.id = name + "Segment" + seriesName;
                style.type = 'text/css';
                style.innerHTML = '.' + name + 'Style' + seriesName + style3D.index + ' { fill:' + color + ";opacity:" + opacity + ' }';
                document.getElementsByTagName('head')[0].appendChild(style);
            }
            return name + "Style" + seriesName + style3D.index;

        },

        // 3D style class end

        // pattern of the SVG started here
        pattern: function (chart, evt, colorStyle, settings) {
            var hoverStyle = settings;
            var name = colorStyle.api;
            var style = hoverStyle.pattern.toLowerCase();
            var color = colorStyle.color;
            var opacity = hoverStyle.opacity != "" ? hoverStyle.opacity : $('#' + evt.target.id).attr('opacity');
            var backgroundColor = "#ffffff";
            if (document.getElementById(name + "Def")) {
                var svg = $("#" + name + "Def")[0];
            } else {
                var svgid = { 'id': name + "Def" }
                var svg = chart.svgRenderer.createPattern(svgid, 'svg');
                chart.svgRenderer.append(svg, chart.svgObject);
            }
            if (chart.model.enable3D) {
                if (colorStyle.name == "XLight")
                    backgroundColor = "#595959";
                else if (colorStyle.name == "ZLight")
                    backgroundColor = "#737373";
                else
                    backgroundColor = "#808080";
            }
            if (("#" + style + '_' + name + '_' + colorStyle.name + '_' + colorStyle.index))
                $("#" + style + '_' + name + '_' + colorStyle.name + '_' + colorStyle.index).remove();

            var pathOptions = [];
            switch (style) {
                case "chessboard":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'x': 0, 'y': 0, 'width': 10, 'height': 10 }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'x': 0, 'y': 0, 'width': 10, 'height': 10, 'fill': backgroundColor, 'opacity': opacity, 'name': 'rect' };
                    pathOptions[1] = { 'x': 0, 'y': 0, 'width': 5, 'height': 5, 'fill': color, 'opacity': opacity, 'name': 'rect' };
                    pathOptions[2] = { 'x': 5, 'y': 5, 'width': 5, 'height': 5, 'fill': color, 'opacity': opacity, 'name': 'rect' };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "pacman":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '17.917', 'height': '18.384' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 17.917, 'height': 18.384, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = { 'name': 'path', 'd': 'M9.081,9.194l5.806-3.08c-0.812-1.496-2.403-3.052-4.291-3.052H8.835C6.138,3.063,3,6.151,3,8.723v1.679   c0,2.572,3.138,5.661,5.835,5.661h1.761c2.085,0,3.835-1.76,4.535-3.514L9.081,9.194z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "crosshatch":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '8', 'height': '8' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'x': 0, 'y': 0, 'width': 8, 'height': 8, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity, 'name': 'rect' };
                    pathOptions[1] = {
                        'd': 'M0 0L8 8ZM8 0L0 8Z',
                        'stroke-width': 1,
                        'stroke': color,
                        'name': 'path'
                    };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "dots":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '6', 'height': '6' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'x': 0, 'y': 0, 'width': 7, 'height': 7, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity, 'name': 'rect' };
                    pathOptions[1] = {
                        'cx': 3,
                        'cy': 3,
                        'r': 2,
                        'stroke-width': 1,
                        'fill': color,
                        'name': 'circle'
                    };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "diagonalforward":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '6', 'height': '6' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'x': 0, 'y': 0, 'width': 6, 'height': 6, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity, 'name': 'rect' };
                    pathOptions[1] = {
                        'd': 'M 3 -3 L 9 3 M 6 6 L 0 0 M 3 9 L -3 3',
                        'stroke-width': 2,
                        'stroke': color,
                        'name': 'path'
                    };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "diagonalbackward":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '6', 'height': '6' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'x': 0, 'y': 0, 'width': 6, 'height': 6, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity, 'name': 'rect' };
                    pathOptions[1] = {
                        'd': 'M 3 -3 L -3 3 M 0 6 L 6 0 M 9 3 L 3 9',
                        'stroke-width': 2,
                        'stroke': color,
                        'name': 'path'
                    };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "grid":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '6', 'height': '6' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 6, 'height': 6, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = {
                        'name': 'path',
                        'd': 'M1 3.5L11 3.5 M0 3.5L11 3.5 M0 7.5L11 7.5 M0 11.5L11 11.5 M5.5 0L5.5 12 M11.5 0L11.5 12Z',
                        'stroke-width': 1,
                        'stroke': color
                    };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "turquoise":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '17', 'height': '17' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 17, 'height': 17, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = { 'name': 'path', 'd': 'M0.5739999999999998,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                    pathOptions[2] = { 'name': 'path', 'd': 'M11.805,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                    pathOptions[3] = { 'name': 'path', 'd': 'M6.19,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                    pathOptions[4] = { 'name': 'path', 'd': 'M11.805,8.217a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                    pathOptions[5] = { 'name': 'path', 'd': 'M6.19,8.217a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                    pathOptions[6] = { 'name': 'path', 'd': 'M11.805,13.899a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                    pathOptions[7] = { 'name': 'path', 'd': 'M6.19,13.899a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "star":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '21', 'height': '21' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 21, 'height': 21, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = {
                        'name': 'path',
                        'd': 'M15.913,18.59L10.762 12.842 5.613 18.75 8.291 11.422 0.325 9.91 8.154 8.33 5.337 0.91 10.488 6.658 15.637 0.75 12.959 8.078 20.925 9.59 13.096 11.17 z',
                        'stroke-width': 1,
                        'stroke': color,
                        'fill': color
                    };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "triangle":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '10', 'height': '10' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 10, 'height': 10, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = {
                        'name': 'path',
                        'd': 'M4.987,0L7.48 4.847 9.974 9.694 4.987 9.694 0 9.694 2.493 4.847 z',
                        'stroke-width': 1,
                        'stroke': color,
                        'fill': color
                    };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "circle":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '9', 'height': '9' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 9, 'height': 9, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = {
                        'name': 'circle',
                        'cx': 5.125,
                        'cy': 3.875,
                        'r': 3.625,
                        'stroke-width': 1,
                        'fill': color
                    };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "tile":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '18', 'height': '18' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 18, 'height': 18, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = { 'name': 'path', 'd': 'M0,9L0 0 9 0 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    pathOptions[2] = { 'name': 'path', 'd': 'M9,9L9 0 18 0 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    pathOptions[3] = { 'name': 'path', 'd': 'M0,18L0 9 9 9 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    pathOptions[4] = { 'name': 'path', 'd': 'M9,18L9 9 18 9 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "horizontaldash":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '12', 'height': '12' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 12, 'height': 12, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = { 'name': 'path', 'd': 'M0,1.5 L10 1.5 M0,5.5 L10 5.5 M0,9.5 L10 9.5 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "verticaldash":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '12', 'height': '12' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 12, 'height': 12, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = { 'name': 'path', 'd': 'M1.5,0 L1.5 10 M5.5,0 L5.5 10 M9.5,0 L9.5 10 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "rectangle":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'x': 0, 'y': 0, 'width': 12, 'height': 12 }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'name': 'rect', 'width': 12, 'height': 12, 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = { 'name': 'rect', 'x': 1, 'y': 2, 'width': 4, 'height': 9, 'fill': color, 'opacity': opacity };
                    pathOptions[2] = { 'name': 'rect', 'x': 7, 'y': 2, 'width': 4, 'height': 9, 'fill': color, 'opacity': opacity };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "box":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'x': 0, 'y': 0, 'width': 10, 'height': 10 }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'name': 'rect', 'width': 13, 'height': 13, 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = { 'name': 'rect', 'x': 1.5, 'y': 1.5, 'width': 10, 'height': 9, 'fill': color, 'opacity': opacity };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "horizontalstripe":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '10', 'height': '12' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 10, 'height': 12, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = { 'name': 'path', 'd': 'M0,0.5 L10 0.5 M0,4.5 L10 4.5 M0,8.5 L10 8.5 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "verticalstripe":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '12', 'height': '10' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 12, 'height': 10, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = { 'name': 'path', 'd': 'M0.5,0 L0.5 10 M4.5,0 L4.5 10 M8.5,0 L8.5 10 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "bubble":
                    var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '20', 'height': '20' }
                    var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                    pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 20, 'height': 20, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                    pathOptions[1] = { 'name': 'circle', 'cx': 5.217, 'cy': 11.325, 'r': 3.429, 'stroke-width': 1, 'fill': '#D0A6D1' };
                    pathOptions[2] = { 'name': 'circle', 'cx': 13.328, 'cy': 6.24, 'r': 4.884, 'stroke-width': 1, 'fill': color };
                    pathOptions[3] = { 'name': 'circle', 'cx': 13.277, 'cy': 14.66, 'r': 3.018, 'stroke-width': 1, 'fill': '#D0A6D1' };
                    this.loadPattern(chart, pathOptions, pattern);
                    svg.appendChild(pattern);
                    return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                case "custom":
                    return "url(#" + hoverStyle.customPattern + ")";
            }

        },
        loadPattern: function (chart, options, pattern, ctx) {
            var path;
            for (var i = 0; i < options.length; i++) {
                if (!ctx) {
                    path = chart.svgRenderer.createPattern(options[i], options[i].name);
                    pattern.appendChild(path);
                } else {
                    if (options[i].name == 'rect') {
                        options[i].stroke = 'transparent';
                        this.drawRect(options[i], ctx);
                    }
                    else if (options[i].name == 'path')
                        sf.EjCanvasRender.prototype.drawPath(options[i], ctx);
                    else if (options[i].name == 'circle') {
                        options[i].stroke = 'transparent';
                        sf.EjCanvasRender.prototype.drawCircle(options[i], ctx);
                    }
                }
            }
        },
        drawRect: function (options, element) {
            element.save();
            element.beginPath();
            element.globalAlpha = options.opacity;
            element.lineWidth = options["stroke-width"];
            element.strokeStyle = options.stroke;
            element.rect(options.x, options.y, options.width, options.height);
            if (options.fill == "none") options.fill = "transparent";
            element.fillStyle = options.fill;
            if (options.transform) element.translate(options.transform[0], options.transform[1]);
            element.rotate(options.rotate * Math.PI / 180);
            element.fillRect(options.x, options.y, options.width, options.height);
            element.clip();
            element.stroke();
            element.restore();
        },
        // pattern of the SVG end
        // SVG highlight and selection end

        chartRightClick: function (evt) {
            this.chartRightClick = true;
            if (this.isTouch(evt) && this.model.crosshair.visible) {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }
        },

        chartMouseUpTouch: function (evt) {
            var chart = this,
                matched = jQuery.uaMatch(navigator.userAgent),
                mouseMoveCords = this.calMousePosition(evt),
                browserInfo = this.model.browserInfo,
                element;
            this.mousemoveX = mouseMoveCords.X;
            this.mousemoveY = mouseMoveCords.Y;
            this.enableTrackBall();

            clearTimeout(this.model.doubleTapTimer);

            if (!this.drag)
                this.model.doubleTapTimer = setTimeout(function () {
                    if ((chart.model.tapNum < 2 || chart.model.crosshair.visible))
                        chart.singleTap(evt);
                    chart.model.tapNum = 0;
                    chart.model.cachedX = 0;
                    chart.model.cachedY = 0;

                }, 200);

            if (chart.model.tapNum == 2)
                chart.model.doubleTapped = false;

            return true;
        },
        getEvent: function (event) {
            return event.targetTouches && event.targetTouches[0] ? event.targetTouches[0] : event
        },

        // Method to check the double tap in chart.
        doubleTap: function (e) {

            var pointer = this.getEvent(e),
                currX = pointer.pageX,
                currY = pointer.pageY,
                model = this.model,
                padding = 200,
                element,
                bounds = model.m_AreaBounds;

            this.model.cachedX = this.model.cachedX || currX;

            this.model.cachedY = this.model.cachedY || currY;

            var timestamp = new Date().getTime();


            if (this.mouseDownX >= bounds.X && this.mouseDownX < (bounds.X + bounds.Width) && this.mouseDownY < (bounds.Y + bounds.Height) && this.mouseDownY >= bounds.Y && Math.abs(currX - this.model.cachedX) < padding && Math.abs(currY - this.model.cachedY) < padding)
                this.model.tapNum++;


            if (this.model.tapNum == 2) {
                this.model.doubleTapped = true;
                this.multiSelectMouseDown(e);
                this.drag = this.model.zooming.enable || this._isMultiSelect;
                element = this.model.trackerElement;
                if (element) {
                    $(element).finish();
                    element = null;
                }
            }

        },
        // Method invoking userinteraction in single Tap.
        singleTap: function (evt) {
            var chart = this,
                targetid = evt.target.id,
                seriesCollection = this.model._visibleSeries,
                element,
                pointer = this.getEvent(evt),
                currX = pointer.pageX,
                currY = pointer.pageY,
                swipeThreshold = 10;

            if ((!this.panning && !this.isZoomButtonHovered(evt.target))) {
                this.cancelEvent(evt);
                if (chart.model.trackerElement) {
                    if ($.finish)
                        $(chart.model.trackerElement).finish();
                    else
                        $(chart.model.trackerElement).stop(true, true);
                    chart.model.trackerElement = null;
                }
                $(".ejTooltip" + this._id).remove();
                //if ($(element).find("#" + chart.svgObject.id + "_CrosshairGroup").length==0) {
                if ((!chart.model.crosshair.visible || chart.model.AreaType != "cartesianaxes") && Math.abs(currX - chart.model.cachedX) < swipeThreshold && Math.abs(currY - chart.model.cachedY) < swipeThreshold) {
                    this.chartInteractiveBehavior(evt);
                }

                else {

                    chart.model.element = $(document).find("#" + this.svgObject.id + "_CrosshairGroup");
                    chart.model.trackerElement = $(chart.model.element).children().not('.Tracker').not("defs");
                    if ($(chart.model.trackerElement).length > 0)
                        $(chart.model.trackerElement).fadeOut(1000, function () {
                            $(chart.model.element).find('[id*="trackSymbol"]').attr("visibility", "hidden");
                            chart.model.trackerElement = null;
                            chart._removeHighlight();
                        });
                    var groupElement = $(document).find('[id*="_trackball_grouping_tooltip"]');
                    if ($(groupElement).length > 0)
                        $(groupElement).fadeOut(1000, function () {
                            $(groupElement).remove();
                        });
                }

                this.axisTooltip(evt, targetid);

                this.showTitleTooltip(evt, targetid);

                if (this.model.enableCanvasRendering) {
                    this._textTooltip(evt, this.model.xAxisLabelRegions);
                    this._textTooltip(evt, this.model.yAxisLabelRegions);
                }

                for (var i = 0, seriesLength = this.model.series.length; i < seriesLength; i++) {
                    var series = this.model.series[i], dataLabel = series.marker.dataLabel;
                    if (series._enableSmartLabels && !this.model.enable3D && !dataLabel.enableWrap) {
                        var template = dataLabel.template;
                        var font = dataLabel.font;
                        if (this.model.AreaType == "none" && sf.util.isNullOrUndefined(template)) {
                            this.datalabelTooltip(evt, i, font);
                        }
                    }
                }

                if ($(".ejTooltip" + this._id).length > 0)
                    element = $(".ejTooltip" + this._id);
                if ($(".tooltipDiv" + this._id).length > 0)
                    element = $(".tooltipDiv" + this._id);
                window.clearTimeout(chart.model.timer);
                chart.model.trackerElement = element;
                chart.model.timer = setTimeout(function () {
                    var pointData = chart.model.prevPoint;
                    if (chart.model.trackerElement) {
                        chart.model.trackerElement.fadeOut(500, function () {
                            if (pointData) {
                                if (chart.model.AreaType != "polaraxes") {
                                    var prevLocation = sf.EjSvgRender.utils._getPoint(pointData.point, pointData.series);
                                    chart.drawTrackerSymbol(pointData.series, pointData.seriesIndex, pointData.pointIndex, null, prevLocation);
                                }
                                $("#" + "canvas" + "_trackSymbol").remove();
                            }
                            $("[id*=" + "_TrackSymbol" + "]").remove();
                        });
                    }
                    else {
                        if (pointData) {
                            if (chart.model.AreaType != "polaraxes") {
                                var prevLocation = sf.EjSvgRender.utils._getPoint(pointData.point, pointData.series);
                                chart.drawTrackerSymbol(pointData.series, pointData.seriesIndex, pointData.pointIndex, null, prevLocation);
                            }
                        }
                        if (!chart.model.crosshair.visible) {
                            $("#" + "canvas" + "_trackSymbol").remove();
                            $("[id*=" + "_TrackSymbol" + "]").remove();
                        }
                    }

                }, 1200);


            }
            if (!evt.originalEvent.pointerType && !this.panning && (this.model.selectionEnable || ((this.isDevice() && this._isSafari))))
                this._doClick(evt);
        },
        _getPieOfPiePoint: function (index, series, legenddata) {
            var visiblePoints = legenddata ? series.points : series._visiblePoints;
            var length = visiblePoints.length;
            for (var j = 0; j < length; j++) {
                if (index == visiblePoints[j].actualIndex)
                    var seriesPoint = visiblePoints[j];
            }
            return seriesPoint;
        },
        tooltip: function (chart, evt) {
            var tooltipShowing = false;
            var chartSeries;
            var seriesIndex;
            var data = this.GetSeriesPoint(evt);
            $("#" + "canvas" + "_trackSymbol").remove();
            if (sf.util.isNullOrUndefined(data) && !this.dragPoint) // To hide the tooltip when it is moved on chartArea other than series
                $("#" + chart.svgObject.id + "_TrackToolTip").remove();

            if (!this.model.crosshair.visible && this.model.AreaType == "cartesianaxes") {
                var indicators = this.model.indicators,
                    seriesCollection = this.model._visibleSeries,
                    currentIndicator, l, k, trendLines,
                    length = seriesCollection.length;
                var trackcount = 0;
                for (k = 0; k < length; k++) {
                    trendLines = seriesCollection[k].trendlines;
                    for (l = 0; l < trendLines.length; l++) {
                        if (trendLines[l].visibility.toLowerCase() == "visible" && !trendLines[l].isNull && this.model.series[0].type != "boxandwhisker") {
                            trendLines[l]._visiblePoints = trendLines[l].points;
                            seriesCollection = seriesCollection.concat(trendLines[l]);
                        }
                    }
                }

                for (var j = 0; j < indicators.length && indicators[j].segment; j++) {
                    currentIndicator = indicators[j];
                    if (currentIndicator.visible)
                        seriesCollection = seriesCollection.concat(currentIndicator.segment);
                }
                var seriesCollectionLength = seriesCollection.length;
                for (var i = 0; i < seriesCollectionLength; i++) {
                    chartSeries = seriesCollection[i];
                    seriesIndex = i;

                    var type = chartSeries.type.toLowerCase();
                    if (chartSeries.visibility.toLowerCase() == 'visible' && type !== "scatter" && type !== "bubble" && type !== "column" && (type.indexOf("bar") == -1) && type !== "stackingcolumn" && type !== "stackingcolumn100" && !chartSeries._hiloTypes) {
                        $("#" + chart.svgObject.id + "_TrackToolTipTemplate_" + seriesIndex).remove();
                        if (!($(".tooltipDiv" + this._id).hasClass(chart.svgObject.id)))
                            $(".tooltipDiv" + this._id).remove();
                        $("#" + chart.svgObject.id).find("#" + chart.svgObject.id + "_TrackSymbol" + '_' + seriesIndex).remove();
                        $('#' + chart.svgObject.id + '_TrackSymbol' + '_' + seriesIndex).remove();
                        var serY = [];
                        var serX = [];
                        location = null;
                        var closestXyPoint = chart.getClosesPointXY(serX, serY, chartSeries, chart.mousemoveX, chart.mousemoveY, evt);
                        if (sf.util.isNullOrUndefined(closestXyPoint.point) && (!this.model.prevPoint || (this.model.prevPoint.seriesIndex && !this.model.series[this.model.prevPoint.seriesIndex].tooltip.visible)) && !this.dragPoint && ($(".tooltipDiv" + this._id).hasClass(this.svgObject.id))) {
                            clearTimeout(this.removeTooltip);
                            chart.removeTooltip = setTimeout(function () {   // To hide the tooltip when it is moved on chartArea other than series
                                $(".tooltipDiv" + chart._id).remove();
                            }, 1000);
                        }
                        if (closestXyPoint.point) {
                            if (chartSeries.type.toLowerCase() == "boxandwhisker") {
                                trackcount++;
                                location = closestXyPoint.outlierPosition;
                            } else
                                location = sf.EjSvgRender.utils._getPoint(closestXyPoint.point, chartSeries);
                            var commonPointEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                            commonPointEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveX }, region: { SeriesIndex: i, Region: { PointIndex: closestXyPoint.index } } };
                            chart._trigger("pointRegionMouseMove", commonPointEventArgs);
                        }
                        var pointData = this.model.prevPoint;
                        if (pointData && pointData.seriesIndex == i && !closestXyPoint.point) {
                            if (chartSeries.type.toLowerCase() == "boxandwhisker") {
                                trackcount++;
                                pointLocation = pointData.outlierPosition;

                            }
                            else
                                var pointLocation = sf.EjSvgRender.utils._getPoint(pointData.point, pointData.series);
                            if (!chart.model.enableCanvasRendering) // No need to draw again in canvas chart after explode marker
                                chart.drawTrackerSymbol(pointData.series, pointData.seriesIndex, pointData.pointIndex, null, pointLocation);
                            this.model.prevPoint = null;
                        }
                        if (!chartSeries.isIndicator && !chartSeries.isTrendLine && !chartSeries.selectionSettings.enable && !chartSeries.highlightSettings.enable && (chartSeries.marker.visible || chartSeries.type.toLowerCase() == "boxandwhisker") && closestXyPoint.point && !commonPointEventArgs.cancel) {
                            if (sf.util.isNullOrUndefined(closestXyPoint.point.marker) || sf.util.isNullOrUndefined(closestXyPoint.point.marker.visible) || (closestXyPoint.point.marker && closestXyPoint.point.marker.visible))
                                chart.drawTrackerSymbol(chartSeries, seriesIndex, closestXyPoint.index, false, location);
                            else if (chartSeries.type == "boxandwhisker" && !closestXyPoint.point.marker)
                                chart.drawTrackerSymbol(chartSeries, seriesIndex, closestXyPoint.index, false, location);
                            if (pointData && closestXyPoint.point != pointData.point) {
                                if (chartSeries.type.toLowerCase() == "boxandwhisker") {
                                    trackcount++;
                                    prevLocation = pointData.outlierPosition;
                                }
                                else
                                    var prevLocation = sf.EjSvgRender.utils._getPoint(pointData.point, pointData.series);
                                chart.drawTrackerSymbol(pointData.series, pointData.seriesIndex, pointData.pointIndex, null, prevLocation, id, trackcount);
                            }
                            if (sf.util.isNullOrUndefined(closestXyPoint.point.marker) || sf.util.isNullOrUndefined(closestXyPoint.point.marker.visible) || (closestXyPoint.point.marker && closestXyPoint.point.marker.visible))
                                this.model.prevPoint = { point: closestXyPoint.point, pointIndex: closestXyPoint.index, series: chartSeries, seriesIndex: seriesIndex, outlierPosition: closestXyPoint.outlierPosition };
                        }


                        if (chartSeries.tooltip.visible && closestXyPoint.point && (!data || (i > data.region.SeriesIndex && !(chartSeries._zOrder < this.model._visibleSeries[data.region.SeriesIndex]._zOrder)))) {
                            trans = sf.EjSvgRender.utils._getTransform(chartSeries.xAxis, chartSeries.yAxis, chart.model.requireInvertedAxes);
                            if ((location.X + trans.x) <= (trans.x + trans.width) && ((location.X + trans.x) >= trans.x || location.X == 0) && (Math.abs(location.Y - (trans.y + trans.height)) <= (trans.y + trans.height))
                                && (Math.abs(location.Y - (trans.y + trans.height)) >= trans.y || location.Y == 0)) {
                                if (!commonPointEventArgs.cancel) {
                                    if ($(chart.svgObject).find("#" + chart.svgObject.id + "_TrackToolTip").length == 0) {
                                        var transOptions = { 'id': chart.svgObject.id + '_TrackToolTip', 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };
                                        chart.gTransToolEle = chart.svgRenderer.createGroup(transOptions);
                                    }
                                    chart.svgRenderer._setAttr($(chart.svgObject).find("#" + chart.svgObject.id + "_TrackToolTip"), { 'transform': 'translate(' + trans.x + ',' + trans.y + ')', 'visibility': 'visible' });
                                    if (sf.util.isNullOrUndefined(chartSeries.tooltip.template)) {
                                        tooltipShowing = true;
                                        $(".tooltipDiv" + this._id).remove();
                                        chart.displayShowTooltip(location, closestXyPoint.point, chartSeries, closestXyPoint.index);
                                    }
                                    else {
                                        tooltipShowing = true;
                                        $("#" + chart.svgObject.id).find("#" + chart.svgObject.id + "_TrackToolTip").attr('visibility', 'hidden');
                                        var region = { SeriesIndex: seriesIndex, Region: { PointIndex: closestXyPoint.index } };
                                        chart.createTooltip(region, evt, chartSeries);
                                    }

                                    //Comment the below code for VML -The line series tooltip color not displayed due to attach and detach the element to DOM
                                    // var detachEle = $(chart.svgObject).find("#" + chart.svgObject.id + "_TrackToolTip").detach();
                                    //detachEle.appendTo(chart.svgObject);
                                }

                            }
                        }
                    }
                    else if (sf.util.isNullOrUndefined(data) && !this.dragPoint && ($(".tooltipDiv" + this._id).hasClass(this.svgObject.id))) {
                        clearTimeout(this.removeTooltip);
                        chart.removeTooltip = setTimeout(function () {   // To hide the tooltip when it is moved on chartArea other than series
                            $(".tooltipDiv" + chart._id).remove();
                        }, 1000);
                    }
                }
            }
            else {
                $("#" + this.svgObject.id).find("#" + this.svgObject.id + "_TrackToolTip").hide();
                if (sf.util.isNullOrUndefined(data)) {
                    clearTimeout(this.removeTooltip);
                    chart.removeTooltip = setTimeout(function () {   // To hide the tooltip when it is moved on chartArea other than series
                        $(".tooltipDiv" + chart._id).remove();
                    }, 1000);
                }
            }

            if (!($(".tooltipDiv" + this._id).hasClass(this.svgObject.id)))
                $(".tooltipDiv" + this._id).remove();
            if (data && sf.util.isNullOrUndefined(data.region.isStripLine)) {
                var seriesType = this.model._visibleSeries[data.region.SeriesIndex].type.toLowerCase();
                if ((seriesType == "pie" || seriesType == "pieofpie" || seriesType == "doughnut") && this.model._visibleSeries[data.region.SeriesIndex].explode) {
                    if (this.model._visibleSeries[data.region.SeriesIndex].enableAnimation) {
                        if (this.model.AnimationComplete || this.model.enableCanvasRendering)
                            this.pieExplosion(data, evt);
                    }
                    else if (!this.model.enable3D)
                        this.pieExplosion(data, evt);
                }
                if (data.region.isIndicator) {
                    series = this.model.indicators[data.region.SeriesIndex];
                    var seriesPoint = series.segment[0]._visiblePoints[data.region.Region.PointIndex];
                    series.fill = series.segment[0].fill;
                } else {
                    series = this.model._visibleSeries[data.region.SeriesIndex];
                    if (series.type == "pieofpie" && !this.model.enable3D)
                        var seriesPoint = this._getPieOfPiePoint(data.region.Region.PointIndex, series);
                    else if ((series.type == "pie" || series.type == "doughnut") && !this.model.enable3D) {
                        for (var v = 0; v < series._visiblePoints.length; v++) {
                            if (data.region.Region.length == series._visiblePoints.length) {
                                if (data.region.Region.PointIndex == series._visiblePoints[v].actualIndex) {
                                    var seriesPoint = this.model._visibleSeries[data.region.SeriesIndex]._visiblePoints[v];
                                    break;
                                }
                            }
                            else {
                                if (data.region.Region.Index == v) {
                                    var seriesPoint = this.model._visibleSeries[data.region.SeriesIndex]._visiblePoints[v];
                                    break;
                                }
                            }
                        }
                    }
                    else
                        var seriesPoint = this.model._visibleSeries[data.region.SeriesIndex]._visiblePoints[data.region.Region.PointIndex];
                }

                if (seriesPoint && this.model.AreaType == 'polaraxes') {
                    for (var i = 0; i < this.model._visibleSeries.length; i++) {
                        $("[id*=" + "_TrackSymbol" + "]").remove();
                        var trackId = "canvas_trackSymbol_" + i;
                        $("#" + this._id).find('[id*=' + trackId + ']').remove();
                    }
                    var pointlocation = (this.model.AreaType != "polaraxes")
                        ? sf.EjSvgRender.utils._getPoint(seriesPoint, series)
                        : (sf.EjSvgRender.utils.TransformToVisible(series, seriesPoint.xValue, seriesPoint.y, this))
                    var prevPoint = this.model.prevPoint;
                    if (!sf.util.isNullOrUndefined(prevPoint) && prevPoint != data && series.marker.visible) {
                        var series = this.model._visibleSeries[prevPoint.region.SeriesIndex],
                            prevSeriesPoint = this.model._visibleSeries[prevPoint.region.SeriesIndex]._visiblePoints[prevPoint.region.Region.PointIndex],
                            prevlocation = sf.EjSvgRender.utils.TransformToVisible(series, prevSeriesPoint.xValue, prevSeriesPoint.y, this);
                        this.drawTrackerSymbol(series, prevPoint.region.SeriesIndex, prevPoint.region.Region.PointIndex, null, prevlocation);
                        this.model.prevPoint = null;
                    }
                    if ((series.marker.visible && series.drawType != "column") && (series.drawType.toLowerCase() != "rangecolumn")) {
                        this.drawTrackerSymbol(series, data.region.SeriesIndex, data.region.Region.PointIndex, true, pointlocation);
                        this.model.prevPoint = data;
                    }
                }

                if (series.tooltip.visible && !tooltipShowing) {

                    if (series.visibility.toLowerCase() == 'visible') {
                        if (sf.util.isNullOrUndefined(series.tooltip.template)) {
                            var location;
                            if (this.model.AreaType == "cartesianaxes") {

                                var trans = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, this.model.requireInvertedAxes);
                                if ($(this.svgObject).find("#" + this.svgObject.id + "_TrackToolTip").length == 0) {
                                    var transToolOptions = { 'id': this.svgObject.id + '_TrackToolTip', 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };
                                    this.gTransToolEle = this.svgRenderer.createGroup(transToolOptions);
                                }
                                this.svgRenderer._setAttr($(this.svgObject).find("#" + this.svgObject.id + "_TrackToolTip"), { 'transform': 'translate(' + trans.x + ',' + trans.y + ')' });
                                $('#' + this.svgObject.id + "_TrackToolTip").attr("visibility", "visible");
                                location = { X: (data.location.x - this.model.m_AreaBounds.X), Y: Math.abs(data.location.y - (this.model.m_AreaBounds.Y)) };
                            } else {
                                if ($(this.svgObject).find("#" + this.svgObject.id + "_TrackToolTip").length == 0) {
                                    var transToolTipOptions = { 'id': this.svgObject.id + '_TrackToolTip' };
                                    this.gTransToolEle = this.svgRenderer.createGroup(transToolTipOptions);
                                }
                                location = { X: (data.location.x), Y: Math.abs(data.location.y) };
                            }


                            $(".tooltipDiv" + this._id).remove();
                            this.displayShowTooltip(location, seriesPoint, series, data.region.Region.PointIndex);

                            //Comment the below code for VML -The line series tooltip color not displayed due to attach and detach the element to DOM
                            // if (series.type.toLowerCase() == "bubble" || series.type.toLowerCase() == "scatter") {
                            //     var detachEle = $(this.svgObject).find("#" + this.svgObject.id + "_TrackToolTip").detach();
                            //    detachEle.appendTo(this.svgObject);
                            // }
                        } else {
                            $("#" + chart.svgObject.id).find("#" + chart.svgObject.id + "_TrackToolTip").attr('visibility', 'hidden');
                            this.createTooltip(data.region, evt);
                        }
                    }
                }
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = data;
                this._trigger("pointRegionMouseMove", commonEventArgs);
            }
            else if (!sf.util.isNullOrUndefined(this.model.prevPoint) && this.model.AreaType == "polaraxes") {
                var prevPoint = this.model.prevPoint;
                series = this.model._visibleSeries[prevPoint.region.SeriesIndex];
                seriesPoint = this.model._visibleSeries[prevPoint.region.SeriesIndex]._visiblePoints[prevPoint.region.Region.PointIndex];
                pointlocation = sf.EjSvgRender.utils.TransformToVisible(series, seriesPoint.xValue, seriesPoint.y, this);
                this.drawTrackerSymbol(series, prevPoint.region.SeriesIndex, prevPoint.region.Region.PointIndex, null, pointlocation);
                this.model.prevPoint = null;
            }
            else {
                if (!sf.util.isNullOrUndefined(this.model.explodeValue)) {
                    var type = this.model.series[this.model.explodeValue.SeriesIndex].type.toLowerCase();
                    var series = this.model._visibleSeries[this.model.explodeValue.SeriesIndex];
                    var seriesType = new sf.seriesTypes[type]();
                    var targetElement;
                    var id;
                    var _labelPosition = series.labelPosition.toLowerCase();
                    var seriesIndex = this.model.explodeValue.SeriesIndex;
                    var visiblePoint = (this.model._isPieOfPie) ? this._getPieOfPiePoint(this.model.explodeValue.PointIndex, series) : series._visiblePoints[this.model.explodeValue.Index];
                    var result = seriesType._calculateArcData(this, this.model.explodeValue.PointIndex, visiblePoint, series, seriesIndex, this.model.explodeValue.PieSeriesIndex);
                    if (this.model.enableCanvasRendering) {
                        this.model.series[seriesIndex].explodeIndex = null;
                        var chartRect = document.getElementById(this.svgObject.id).getClientRects()[0];
                        this.svgRenderer.ctx.clearRect(chartRect.left, chartRect.top, chartRect.width, chartRect.height);
                        $("#" + this._id).ejChart("redraw");
                    }
                    id = this.svgObject.id + '_SeriesGroup' + '_' + seriesIndex;
                    targetElement = this.model.explodeValue.PieSeriesIndex == 1 ? $(this.gSeriesEle).children('#' + id)[1] : $(this.gSeriesEle).children('#' + id)[0];
                    var elements = $(targetElement).children();
                    for (var i = 0; i < elements.length; i++) {
                        var element = elements[i];
                        var index = this.svgRenderer._getAttrVal($(element)[0], "data-pointIndex");
                        if (parseInt(index) == this.model.explodeValue.PointIndex) {
                            this.svgRenderer._setAttr($(element), { 'd': result.Direction });
                            break;
                        }
                    }
                    seriesType.drawDataLabelAcc(this, series, this.model.explodeValue.Index, visiblePoint, seriesIndex, this.model.explodeValue.PieSeriesIndex);
                    this.model.explodeValue = null;
                    this.model.explode = false;
                }
            }
        },

        chartTrackball: function (chart, mouseLocation, evt) {
            this.crosshairLinePath = [];
            var requireInvertedAxes = chart.model.requireInvertedAxes, store = [], color = [], point, seriesColor, closePointLength, seriesIndex, series, dir, indicators = this.model.indicators, seriesCollection = this.model._visibleSeries,
                showTrackLine = false, seriesIndex, serX, insideBounds, closestPoint, seriesArray = [], visibleRange, chartPos, pathOptions, leftPos, topPos, chartAreaStartPos, chartAreaEndPos, pointPos, seriesLength, data,
                crossHairTrans, tToolOptions, prePoint, initialPoint, rectxt, tooltipfont, textarea, tgap = 0, currentLength, tX, tY, chartLocation, element, visiblepts = [], tooltipRanges = [],
                DisplayTooltipOptions = [], enableCanvas = this.model.enableCanvasRendering, totalVisible = 0, maxWidth = 0, heightwidth = 0, chartOffset = $("#" + this._id).offset(),
                textCollection = [], textOptionsCollection = [], groupingTextId = [], trackballDisplayMode = this.model.crosshair.trackballTooltipSettings.mode.toLowerCase(), groupTooltipId = chart._id + "_trackball_grouping_tooltip",
                locale = this.model.locale, boxSeriesCount = 0, trackOutlier = 0;
            if ((!this.model.enable3D) && this.model.crosshair.visible && this.model.crosshair.type.toLowerCase() == "trackball") {

                if ($("#" + this.svgObject.id + "_CrosshairGroup").length == 0) {     // condition to check track axis tooltip is existing in DOM
                    var gTrackballOptions = { 'id': chart.svgObject.id + '_CrosshairGroup', 'visibility': 'visible' };
                    if (enableCanvas) {
                        gTrackballOptions.position = "absolute";
                        chart.svgRenderer.drawCrosshairLine(gTrackballOptions, '#chartContainer_' + this._id);
                    }
                    else {
                        chart.gTrackball = chart.svgRenderer.createGroup(gTrackballOptions);
                        chart.svgRenderer.append(chart.gTrackball, chart.svgObject);
                    }
                }
                else {
                    if (chart.model.trackerElement) {
                        if ($.finish)
                            $(chart.model.trackerElement).finish();
                        else
                            $(chart.model.trackerElement).stop(true, true);
                        chart.model.trackerElement = null;
                    }
                }
                if (!this.model.enableCanvasRendering) {
                    // removed highlight style
                    $("[class*=" + "HighlightStyle" + "]").attr('class', '');
                    $("[class*=" + "HighlightLegendStyle" + "]").attr('class', '');
                    $("[class*=" + "HighlightLegendPathStyle" + "]").attr('class', '');
                    $("[class*=" + "HighlightPathStyle" + "]").attr('class', '');
                    $("[class*=" + "Highlightseries" + "]").attr('class', '');
                    $("[id*=" + this._id + "_Highlight_" + "]").remove();// removed canvas highlight           
                }
                //Hiding previous trackball and tooltip when moving from one column to another
                $("#secondCanvas").remove(), $("#" + this._id).find('[id*="_gTooltip_"]').remove(), $("#" + groupTooltipId).children().remove(), $(document).find('[id*="TrackGroupToolTipTemplate"]').remove(), $(document).find('[id*="TrackToolTipTemplate"]').remove();
                if (enableCanvas) {
                    $("#" + this._id).find('[id*="canvas_trackSymbol"]').css("visibility", "hidden");
                }
                var seriesLenIndicator = seriesCollection.length;
                for (var j = 0; j < indicators.length && indicators[j].segment; j++) {
                    seriesCollection = seriesCollection.concat(indicators[j].segment);
                }
                seriesLength = seriesCollection.length;
                for (var i = 0; i < seriesLength; i++) {
                    if (seriesCollection[i].visibility == "visible" && seriesCollection[i].enableTrackTooltip) {
                        seriesIndex = i;
                        serX = [];

                        if (!requireInvertedAxes)
                            insideBounds = chart.mousemoveX + seriesCollection[i].xAxis.plotOffset > seriesCollection[i].xAxis.x && chart.mousemoveX < seriesCollection[i].xAxis.x + seriesCollection[i].xAxis.width + seriesCollection[i].xAxis.plotOffset;
                        else
                            insideBounds = chart.mousemoveY + seriesCollection[i].xAxis.plotOffset > seriesCollection[i].xAxis.y && chart.mousemoveY < seriesCollection[i].xAxis.y + seriesCollection[i].xAxis.height + seriesCollection[i].xAxis.plotOffset;
                        if (enableCanvas)
                            this.canvasX = seriesCollection[i].xAxis.x;
                        closestPoint = chart.getClosestPointX(serX, seriesCollection[i], chart.mousemoveX, chart.mousemoveY);
                        visibleRange = seriesCollection[i].xAxis.visibleRange;   // condition to check the closestPoint is inside the visible range
                        if (closestPoint.point != "") {
                            var closestPointValues = seriesCollection[i].type.toLowerCase() == "boxandwhisker" ? closestPoint.point[0].boxPlotLocation[0].YValues : closestPoint.point[0].YValues[0];
                            if (closestPoint.point != "" && (closestPointValues >= seriesCollection[i].yAxis.visibleRange.min || trackballDisplayMode == "grouping") && (closestPoint.point[0].xValue >= visibleRange.min) && (closestPoint.point[0].xValue <= visibleRange.max)) {
                                if (insideBounds) {
                                    for (var t = 0; t < closestPoint.point.length; t++) {
                                        if (closestPoint.point[t].visible) {
                                            if (!seriesCollection[i].isIndicator) {
                                                totalVisible++;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                for (var i = 0; i < seriesLength; i++) {
                    //   if(seriesCollection[0].xAxis.name == seriesCollection[i].xAxis.name)
                    seriesIndex = i, series = seriesCollection[i];
                    var trackPoints = [];
                    if (series.visibility.toLowerCase() == 'visible' && series.enableTrackTooltip) {
                        serX = [];
                        if (!requireInvertedAxes)
                            insideBounds = chart.mousemoveX + seriesCollection[i].xAxis.plotOffset > series.xAxis.x && chart.mousemoveX < series.xAxis.x + series.xAxis.width + seriesCollection[i].xAxis.plotOffset;
                        else
                            insideBounds = chart.mousemoveY + seriesCollection[i].xAxis.plotOffset > series.xAxis.y && chart.mousemoveY < series.xAxis.y + series.xAxis.height + seriesCollection[i].xAxis.plotOffset;
                        if (enableCanvas)
                            this.canvasX = series.xAxis.x;
                        closestPoint = chart.getClosestPointX(serX, series, chart.mousemoveX, chart.mousemoveY);
                        visibleRange = series.xAxis.visibleRange;   // condition to check the closestPoint is inside the visible range
                        var point1;
                        if (closestPoint.point != "") {
                            var closestPointValues = seriesCollection[i].type.toLowerCase() == "boxandwhisker" ? closestPoint.point[0].boxPlotValues.midvalue : closestPoint.point[0].YValues[0];
                            if ((closestPointValues >= seriesCollection[i].yAxis.visibleRange.min || trackballDisplayMode == "grouping") && (closestPoint.point[0].xValue >= visibleRange.min) && (closestPoint.point[0].xValue <= visibleRange.max)) {
                                if (insideBounds) {
                                    var closePointLength = closestPoint.point.length;
                                    for (var t = 0; t < closePointLength; t++) {
                                        if (closestPoint.point[t].visible) {
                                            if (!series.isIndicator) {
                                                if (series.type == "boxandwhisker") {
                                                    boxSeriesCount++;
                                                    var boxvalue = { "xValue": closestPoint.point[t].xValue, "YValues": closestPoint.point[t].boxPlotLocation[0].YValues };
                                                    point = sf.EjSvgRender.utils._getPoint(boxvalue, series);
                                                    point.YValues = boxvalue.YValues;
                                                    trackPoints.push(point);
                                                    for (var q = 0; q < closestPoint.point[t].boxPlotLocation.length; q++) {
                                                        if (closestPoint.point[t].boxPlotLocation[q].outlier == true) {
                                                            point1 = { X: closestPoint.point[t].boxPlotLocation[q].X, Y: closestPoint.point[t].boxPlotLocation[q].Y, YValues: closestPoint.point[t].boxPlotLocation[q].YValues, outlier: closestPoint.point[t].boxPlotLocation[q].outlier };
                                                            trackPoints.push(point1);
                                                        }
                                                    }
                                                } else
                                                    point = sf.EjSvgRender.utils._getPoint(closestPoint.point[t], series);
                                                this.model.financial = seriesLenIndicator == 1 && closePointLength == 1 && series._hiloTypes || false;
                                                if (requireInvertedAxes) {
                                                    if (this.model.financial) {
                                                        var high = point.X > point.low ? point.X : point.low;
                                                        var low = point.X < point.low ? point.X : point.low;
                                                        dir = "M" + " " + (series.yAxis.x) + " " + (point.Y + series.xAxis.y) + " " + "L" + " " + (low + series.yAxis.x) + " " + (point.Y + series.xAxis.y) + " " + "M" + " " + (series.yAxis.x + high) + " " + (point.Y + series.xAxis.y) + " " + "L" + " " + (series.yAxis.x + series.yAxis.width) + " " + (point.Y + series.xAxis.y);
                                                    }
                                                    else
                                                        dir = "M" + " " + (series.yAxis.x) + " " + (point.Y + series.xAxis.y) + " " + "L" + " " + (series.yAxis.x + series.yAxis.width) + " " + (point.Y + series.xAxis.y);
                                                    if (series.type == "boxandwhisker") {
                                                        for (var p = 0; p < trackPoints.length; p++) {
                                                            visiblepts.push({ X: (trackPoints[p].X), Y: (trackPoints[p].Y), YValues: trackPoints[p].YValues, outlier: trackPoints[p].outlier });
                                                        }
                                                    } else
                                                        visiblepts.push({ X: (closestPoint.point[t].location.X + series.yAxis.x), Y: (closestPoint.point[t].location.Y + series.xAxis.y) });
                                                }
                                                else {
                                                    if (this.model.financial) {
                                                        var high = point.Y < point.low ? point.Y : point.low;
                                                        var low = point.Y > point.low ? point.Y : point.low;
                                                        dir = "M" + " " + (point.X + series.xAxis.x) + " " + (chart.model.m_AreaBounds.Y) + " " + "L" + " " + (point.X + series.xAxis.x) + " " + (high + series.yAxis.y) + " " + "M" + " " + (point.X + series.xAxis.x) + " " + (low + series.yAxis.y) + " " + "L" + " " + (point.X + series.xAxis.x) + " " + (chart.model.m_AreaBounds.Y + chart.model.m_AreaBounds.Height);
                                                    }
                                                    else
                                                        dir = "M" + " " + (point.X + series.xAxis.x) + " " + (chart.model.m_AreaBounds.Y) + " " + "L" + " " + (point.X + series.xAxis.x) + " " + (chart.model.m_AreaBounds.Y + chart.model.m_AreaBounds.Height);
                                                    if (series.type == "boxandwhisker") {
                                                        for (var p = 0; p < trackPoints.length; p++) {
                                                            visiblepts.push({ X: (trackPoints[p].X), Y: (trackPoints[p].Y), YValues: trackPoints[p].YValues, outlier: trackPoints[p].outlier });
                                                        }
                                                    } else
                                                        visiblepts.push({ X: (closestPoint.point[t].location.X + series.xAxis.x), Y: (closestPoint.point[t].location.Y + series.yAxis.y) });
                                                }

                                                chartPos = { left: chartOffset.left, top: chartOffset.top };

                                                pathOptions = {
                                                    'id': chart.svgObject.id + "_Tracker",
                                                    'fill': 'none',
                                                    'stroke-width': chart.model.crosshair.line.width,
                                                    'clip-path': 'url(#' + chart.svgObject.id + '_ChartAreaClipRect)',
                                                    'stroke': chart.model.crosshair.line.color,
                                                    'd': dir
                                                };
                                                this.crosshairLinePath.push(pathOptions);
                                                if ($("#" + chart.svgObject.id + "_Tracker").length == 0) {
                                                    if (enableCanvas) {
                                                        var obj = this.svgRenderer.createCrosshairCanvas();
                                                        obj.ctx = obj.getContext('2d');
                                                    }
                                                    else {
                                                        var obj = this.svgRenderer;
                                                        var parentElement = chart.gTrackball;
                                                    }

                                                    chart.svgRenderer.drawPath.call(obj, pathOptions, parentElement);
                                                    showTrackLine = true;

                                                }
                                                else {
                                                    showTrackLine = true;
                                                    if (!sf.util.isNullOrUndefined(this._closest)) {
                                                        if (this._beforeMin) {
                                                            if (this._closest >= closestPoint.point[t].xValue)
                                                                chart.svgRenderer._setAttr($(chart.svgObject).find("#" + chart.svgObject.id + "_Tracker"), { "d": dir, "visibility": "visible" });

                                                        }
                                                        else if (this._afterMax) {
                                                            if (this._closest <= closestPoint.point[t].xValue)
                                                                chart.svgRenderer._setAttr($(chart.svgObject).find("#" + chart.svgObject.id + "_Tracker"), { "d": dir, "visibility": "visible" });
                                                        }
                                                    }
                                                    else {
                                                        chart.svgRenderer._setAttr($(chart.svgObject).find("#" + chart.svgObject.id + "_Tracker"), { "d": dir, "visibility": "visible" });
                                                    }
                                                    $("#" + chart.svgObject.id + "_Tracker").css({ "display": "block" });
                                                    if (enableCanvas) {
                                                        var obj = this.svgRenderer.createCrosshairCanvas();
                                                        obj.ctx = obj.getContext('2d');
                                                        chart.svgRenderer.drawPath.call(obj, pathOptions, chart.gTrackball);

                                                    }
                                                    $("#" + this._id).find('[id*="canvas_Tracker"]').css("visibility", "visible");
                                                }

                                                crossHairTrans = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);
                                                tToolOptions = { 'transform': 'translate(' + crossHairTrans.x + ',' + crossHairTrans.y + ')', 'id': chart.svgObject.id + '_TrackToolTip' + '_' + seriesIndex };
                                                chart.gTransToolEle = chart.svgRenderer.createGroup(tToolOptions);
                                                prePoint = this.model.prePoint;

                                                //To check the current closestPoint and previous point is same
                                                if (sf.util.isNullOrUndefined(prePoint) || prePoint.pointIndex[0] != closestPoint.index[0] || !$('#' + chart.svgObject.id + "_trackSymbol_" + seriesIndex + '_' + closestPoint.index)) {

                                                    //Remove the track elements only once on point change
                                                    if (sf.util.isNullOrUndefined(initialPoint)) {
                                                        if (chart.gTransToolEle && chart.gTrackerEle) {
                                                            $(this.svgObject).find('[id*="_TrackSymbol_"],[id*="_TrackToolTip"]').attr("visibility", "hidden");
                                                            $("#" + this._id).find('[id*="canvas_trackSymbol"]').css("visibility", "hidden");
                                                        }
                                                        initialPoint = closestPoint;
                                                    }
                                                    var type = series.type.toLowerCase(), trackcount = 0;
                                                    if (!series._hiloTypes || type.indexOf("rangearea") > -1)
                                                        if (trackballDisplayMode != "grouping" || (trackballDisplayMode == "grouping" && type.indexOf("column") < 0 && type.indexOf("bar") < 0))
                                                            if (series.type == "boxandwhisker") {
                                                                for (var z = 0; z < trackPoints.length; z++) {
                                                                    chart.drawTrackerSymbol(series, seriesIndex, closestPoint.index[t], true, trackPoints[z], null, trackcount);
                                                                    trackcount++;
                                                                }
                                                            }
                                                            else
                                                                chart.drawTrackerSymbol(series, seriesIndex, closestPoint.index[t], true, point);
                                                    series.trackerRemoved = true;

                                                    // Condition to find the crosshair is specified with tooltip template
                                                    if (!chart.model.crosshair.trackballTooltipSettings.tooltipTemplate) {
                                                        var currentLength = visiblepts.length - 1, trackOutlier = trackPoints.length;
                                                        if (trackballDisplayMode == "grouping") {
                                                            var seriesColor = this.getSeriesColor(closestPoint.point[t], seriesIndex, series),
                                                                textOptions, tooltipFormat = series.tooltip.format, currentText, boxgroupingtext, boxtext = [];
                                                            if (series.type == "boxandwhisker") {
                                                                for (var p = 0; p < trackOutlier; p++) {
                                                                    boxgroupingtext = this.getTooltipFormat(closestPoint.point[t], series, seriesIndex, closestPoint.index[t], tooltipFormat, trackPoints[p]);
                                                                    boxtext.push(boxgroupingtext);
                                                                    currentText = null;
                                                                }
                                                            }
                                                            else
                                                                currentText = this.getTooltipFormat(closestPoint.point[t], series, seriesIndex, closestPoint.index[t], tooltipFormat);

                                                            var textColor = series.tooltip.font ? ((series.tooltip.font.color ? series.tooltip.font.color : seriesColor)) : seriesColor,
                                                                font = series.tooltip.font ? $.extend(false, series.font, {}, series.tooltip.font) : series.font;
                                                            if (typeof (textColor) == "object") {
                                                                textColor = seriesColor[1].color;
                                                            }
                                                            if (series.type == "boxandwhisker") {
                                                                for (var b = 0; b < boxtext.length; b++)
                                                                    textCollection.push({ text: boxtext[b].text, seriesIndex: seriesIndex, pointIndex: closestPoint.index[t] });
                                                            }
                                                            else {
                                                                currentText.text = "&nbsp" + currentText.text + "&nbsp";
                                                                textCollection.push({ text: currentText.text, seriesIndex: seriesIndex, pointIndex: closestPoint.index[t] });
                                                            }
                                                            if ((series._hiloTypes && type != "rangearea") || type.indexOf("column") > -1 || type.indexOf("bar") > -1) {
                                                                data = { region: { Region: { PointIndex: closestPoint.index[t] }, SeriesIndex: seriesIndex } };
                                                                this.highlightStart(evt, data, this._id + "_svg_SeriesGroup_" + seriesIndex, this._id + "_svg_Series" + seriesIndex + "_Point" + closestPoint.index[t], true);
                                                            }
                                                            if (series.type == "boxandwhisker") {
                                                                for (var b = 0; b < boxtext.length; b++) {
                                                                    groupingTextId.push(chart._id + "_grouping_text_" + seriesIndex + "_" + closestPoint.index[t] + b);
                                                                }
                                                            }
                                                            else
                                                                groupingTextId.push(chart._id + "_grouping_text_" + seriesIndex + "_" + closestPoint.index[t]);
                                                            textOptions = {
                                                                "color": textColor,
                                                                'font-size': font.size,
                                                                'font-family': font.fontFamily,
                                                                'font-style': font.fontStyle,
                                                                'font-weight': font.fontWeight,
                                                            };
                                                            if (series.type == "boxandwhisker") {
                                                                for (var b = 0; b < boxtext.length; b++) {
                                                                    textOptionsCollection.push(textOptions);
                                                                }
                                                            }
                                                            else
                                                                textOptionsCollection.push(textOptions);
                                                            if (boxSeriesCount == totalVisible && series.type == "boxandwhisker")
                                                                chart.displayTooltip(true, { point: closestPoint.point[t], series: series, textCollection: textCollection, textOptionsCollection: textOptionsCollection, groupingTextId: groupingTextId });
                                                            else if (totalVisible == textCollection.length && series.type != "boxandwhisker") {
                                                                chart.displayTooltip(true, { point: closestPoint.point[t], series: series, textCollection: textCollection, textOptionsCollection: textOptionsCollection, groupingTextId: groupingTextId });
                                                            }
                                                        }
                                                        else {
                                                            var rectxt = this.getTooltipFormat(closestPoint.point[t], series, seriesIndex, i, series.tooltip.format, i),
                                                                tooltip = series.tooltip, font = tooltip.font ? $.extend(false, series.font, {}, tooltip.font) : series.font, textarea = sf.EjSvgRender.utils._measureText(rectxt.text, null, font), padding, heightwidth = (requireInvertedAxes) ? textarea.height : textarea.width, maxWidth = (maxWidth > heightwidth) ? maxWidth : heightwidth, newLines = Math.ceil(rectxt.text.toString().split("<br/>").length / 2);
                                                            this.model.tooltipPadding = Number(font.size.toString().replace(/px/i, '')) / 3;
                                                            padding = this.model.tooltipPadding + series.tooltip.border.width * 2;
                                                            if (!requireInvertedAxes) {
                                                                if (series.type == "boxandwhisker") {
                                                                    for (var p = 0; p < trackOutlier; p++) {
                                                                        tooltipRanges.push({ Start: trackPoints[p].Y - padding * newLines - textarea.height / 2, End: trackPoints[p].Y + padding * newLines + textarea.height / 2 });
                                                                        DisplayTooltipOptions.push({ Point: trackPoints[p], ClosestPoint: closestPoint.point[t], Series: series, ClosestPointIndex: closestPoint.index[t], Tgap: tgap, StEnd: tooltipRanges[p], TextArea: textarea, ReqInvertAxis: requireInvertedAxes });
                                                                    }
                                                                }
                                                                else {
                                                                    tooltipRanges.push({ Start: visiblepts[currentLength].Y - padding * newLines - textarea.height / 2, End: visiblepts[currentLength].Y + padding * newLines + textarea.height / 2 });
                                                                    DisplayTooltipOptions.push({ Point: visiblepts[currentLength], ClosestPoint: closestPoint.point[t], Series: series, ClosestPointIndex: closestPoint.index[t], Tgap: tgap, StEnd: tooltipRanges[currentLength], TextArea: textarea, ReqInvertAxis: requireInvertedAxes });
                                                                }
                                                            }
                                                            else {
                                                                tooltipRanges.push({ Start: visiblepts[currentLength].X - padding - (textarea.width / 2), End: visiblepts[currentLength].X + padding + (textarea.width / 2) });
                                                                DisplayTooltipOptions.push({ Point: visiblepts[currentLength], ClosestPoint: closestPoint.point[t], Series: series, ClosestPointIndex: closestPoint.index[t], Tgap: tgap, StEnd: tooltipRanges[currentLength], TextArea: textarea, ReqInvertAxis: requireInvertedAxes });
                                                            }
                                                            if (series.type == "boxandwhisker" && boxSeriesCount == totalVisible) {
                                                                maxWidth += (2 * padding);
                                                                if (requireInvertedAxes) {
                                                                    DisplayTooltipOptions = DisplayTooltipOptions.sort(function (a, b) { return a.Point.X - b.Point.X });
                                                                }
                                                                else {
                                                                    DisplayTooltipOptions = DisplayTooltipOptions.sort(function (a, b) { return a.Point.Y - b.Point.Y });
                                                                }
                                                                this.SmartTooltipPosition(DisplayTooltipOptions);
                                                                var displayLength = DisplayTooltipOptions.length;
                                                                chart.displayTooltip(false, DisplayTooltipOptions, maxWidth);
                                                                for (var i = 0; i < displayLength; i++) {
                                                                    var seriesIndex = $.inArray(DisplayTooltipOptions[i].Series, this.model._visibleSeries);
                                                                    if (DisplayTooltipOptions[i].Series._hiloTypes) {
                                                                        data = { region: { Region: { PointIndex: DisplayTooltipOptions[i].ClosestPointIndex }, SeriesIndex: seriesIndex } };
                                                                        this.highlightStart(evt, data, this._id + "_svg_SeriesGroup_" + seriesIndex, this._id + "_svg_Series" + seriesIndex + "_Point" + DisplayTooltipOptions[i].ClosestPointIndex, true);
                                                                    }
                                                                }
                                                            }
                                                            else if (DisplayTooltipOptions.length == totalVisible && series.type != "boxandwhisker") {
                                                                maxWidth += (2 * padding);
                                                                if (requireInvertedAxes) {
                                                                    DisplayTooltipOptions = DisplayTooltipOptions.sort(function (a, b) { return a.Point.X - b.Point.X });
                                                                }
                                                                else {
                                                                    DisplayTooltipOptions = DisplayTooltipOptions.sort(function (a, b) { return a.Point.Y - b.Point.Y });
                                                                }
                                                                this.SmartTooltipPosition(DisplayTooltipOptions);
                                                                var displayLength = DisplayTooltipOptions.length;
                                                                chart.displayTooltip(false, DisplayTooltipOptions, maxWidth);
                                                                for (var i = 0; i < displayLength; i++) {
                                                                    var seriesIndex = $.inArray(DisplayTooltipOptions[i].Series, this.model._visibleSeries);
                                                                    if (DisplayTooltipOptions[i].Series._hiloTypes) {
                                                                        data = { region: { Region: { PointIndex: DisplayTooltipOptions[i].ClosestPointIndex }, SeriesIndex: seriesIndex } };
                                                                        this.highlightStart(evt, data, this._id + "_svg_SeriesGroup_" + seriesIndex, this._id + "_svg_Series" + seriesIndex + "_Point" + DisplayTooltipOptions[i].ClosestPointIndex, true);
                                                                    }
                                                                }

                                                            }
                                                        }
                                                    }
                                                    else {
                                                        if (trackballDisplayMode === 'grouping') {
                                                            closestPoint = chart.getClosestPointX(serX, series, chart.mousemoveX, chart.mousemoveY);
                                                            seriesColor = this.getSeriesColor(closestPoint.point[t], seriesIndex, series);
                                                            color.push({ seriesColor: seriesColor });
                                                            closePointLength = closestPoint.point.length;
                                                            currentText = this.getTooltipFormat(closestPoint.point[t], series, seriesIndex, closestPoint.index[t], tooltipFormat),
                                                                currentText.text = "&nbsp" + currentText.text + "&nbsp";
                                                            textCollection.push({ text: currentText.text, seriesIndex: seriesIndex, pointIndex: closestPoint.index[t] });
                                                            store.push({ point: closestPoint.point[t] }); seriesArray.push({ series: series });
                                                            if ((series._hiloTypes && type != "rangearea") || type.indexOf("column") > -1 || type.indexOf("bar") > -1) {
                                                                data = { region: { Region: { PointIndex: closestPoint.index[t] }, SeriesIndex: seriesIndex } };
                                                                this.highlightStart(evt, data, this._id + "_svg_SeriesGroup_" + seriesIndex, this._id + "_svg_Series" + seriesIndex + "_Point" + closestPoint.index[t], true);
                                                            }
                                                            if (totalVisible === textCollection.length) {
                                                                chartLocation = document.getElementById(this.svgRenderer.svgObj.id).getClientRects()[0];
                                                                chart.displayGroupingTemplate(tX, tY, point, store, seriesArray, seriesIndex, closestPoint.index[t], chartLocation, color);
                                                            }
                                                        } else {
                                                            tX, tY;
                                                            chartLocation = document.getElementById(this.svgRenderer.svgObj.id).getClientRects()[0];
                                                            chart.displayTemplateTooltip(tX, tY, point, closestPoint.point[t], series, seriesIndex, closestPoint.index[t], chartLocation);
                                                        }
                                                    }
                                                } else {
                                                    // If both are same points, then viibility is set to visible
                                                    element = $(this.svgObject).find('[id*="_TrackSymbol_"],[id*="_TrackToolTip"]');
                                                    this.svgRenderer._setAttr($(element), { "visibility": 'visible' });
                                                    $("#" + this._id).find('[id*="canvas_trackSymbol"]').css("visibility", "visible");
                                                    element = $(this.svgObject).find('[id*="_TrackToolTip"]').children();
                                                    this.svgRenderer._setAttr($(element), { "visibility": 'visible' });

                                                    element = $(this.svgObject).find('[id*="_trackSymbol_"]');
                                                    this.svgRenderer._setAttr($(element), { "visibility": 'visible' });

                                                    $(chart.svgObject).find('[id*="_TrackAxisToolTip"]').attr("visibility", "visible");

                                                    // Sets the tooltip template visibility to visible
                                                    if (this.model.crosshair.trackballTooltipSettings.tooltipTemplate != null) {
                                                        if (trackballDisplayMode === 'grouping') {
                                                            element = $(document).find('[id*="TrackGroupToolTipTemplate"]');
                                                            this.svgRenderer._setAttr($(element), { "visibility": 'visible' });
                                                        } else {
                                                            element = $(document).find('[id*="_TrackToolTipTemplate_"]');
                                                            this.svgRenderer._setAttr($(element), { "visibility": 'visible' });
                                                        }
                                                    }
                                                }
                                            }
                                        } else {

                                            $('#' + this.svgObject.id + '_TrackSymbol_' + seriesIndex).remove();
                                        }
                                    }
                                }
                                else {
                                    this._removeTrackBall();
                                }
                            }
                        } else {
                            if (!showTrackLine) // //condition checked to display Track line for single series when chart have more than one series. 
                                $(chart.svgObject).find('[id*="_Tracker"]').remove();
                            var elem = $("#" + chart.svgObject.id + "_TrackSymbol_" + i);
                            var trackId = this.svgObject.id + '_TrackSymbol' + '_' + seriesIndex;
                            $("#" + this._id).find('[id*=' + trackId + ']').remove();
                            $("#" + chart._id).find('[id*=' + "_canvas_trackSymbol_" + i + ']').css("visibility", "hidden");
                            if (!this.model.enableCanvasRendering) {
                                // removed highlight style
                                $("[class*=" + "HighlightStyle" + "]").attr('class', '');
                                $("[class*=" + "HighlightLegendStyle" + "]").attr('class', '');
                                $("[class*=" + "HighlightLegendPathStyle" + "]").attr('class', '');
                                $("[class*=" + "HighlightPathStyle" + "]").attr('class', '');
                                $("[class*=" + "Highlightseries" + "]").attr('class', '');
                                $("[id*=" + this._id + "_Highlight_" + "]").remove();// removed canvas highlight           
                            }
                        }
                    }
                    series.trackerRemoved = false;
                }


                // To get the previous point values
                if (this.model.closestPoint != null) {
                    this.model.prePoint = { point: closestPoint.point, pointIndex: closestPoint.index, series: series, seriesIndex: seriesIndex };
                }
                if ($("#" + this.svgObject.id + "_TrackAxisToolTip").length == 0 && this.model.crosshairLabelVisibility) {     // condition to check track axis tooltip is existing in DOM
                    var gTrackAxisOptions = { 'id': chart.svgObject.id + '_TrackAxisToolTip', 'visibility': 'visible' };
                    chart.gTrackAxisEle = chart.svgRenderer.createGroup(gTrackAxisOptions);
                    chart.svgRenderer.append(chart.gTrackAxisEle, chart.gTrackball);
                }
                else {
                    $("#" + this.svgObject.id + "_TrackAxisToolTip").css("display", "block");
                }

                if (point) {
                    var pointValue = closestPoint.point[0];
                    //Hide unnecessary crosshair labels. SVG and Canvas renders crosshair labels differently
                    if (enableCanvas)
                        $(chart.svgObject.parentElement).find('[id*="AxisToolTipRect"]').css({ "visibility": "hidden", "display": "none" });
                    else
                        $(chart.svgObject).find('[id*="_TrackAxisToolTip"]').attr("visibility", "visible").children().attr({ "display": "none" });
                    $.each(chart.model._axes, function (axisIndex, axis) {
                        var areaX = axis.x;
                        var opposedPosition = axis._opposed;
                        if (!requireInvertedAxes) {
                            if (axis.orientation.toLowerCase() == "horizontal" && axis.crosshairLabel.visible) {
                                if ((point.X + areaX) <= (axis.x + axis.width) && axis.x <= (visiblepts[visiblepts.length - 1].X)) {
                                    var valueType = axis._valueType.toLowerCase(), xVal, pointLocation;
                                    xVal = ((point.X / (axis.width)) * (axis.visibleRange.delta) + axis.visibleRange.min).toFixed(2).replace(new RegExp("\\.0{" + 2 + "}"), "");
                                    if (valueType == "logarithmic") xVal = Math.pow(axis.logBase, xVal);
                                    if (valueType == "datetime") xVal = (sf.format(new Date(Math.floor(xVal)), ((sf.util.isNullOrUndefined(axis.labelFormat)) ? sf.EjSvgRender.utils._dateTimeLabelFormat(axis._intervalType, axis) : axis.labelFormat), locale));
                                    if (valueType == "category" || valueType == "datetimecategory") {
                                        if (typeof (pointValue.x) !== "object")
                                            xVal = pointValue.xValue;
                                        if (valueType == "category" || !sf.util.isNullOrUndefined(axis.labelFormat))
                                            xVal = sf.EjSvgRender.utils._getLabelContent(Math.floor(xVal), axis, locale);
                                        else
                                            xVal = sf.format(new Date(axis.labels[Math.floor(xVal)]), sf.EjSvgRender.utils._dateTimeLabelFormat(axis.intervalType, axis), locale);
                                        xVal = xVal ? xVal : "undefined";
                                    }
                                    pointLocation = { X: (visiblepts[visiblepts.length - 1].X), Y: (opposedPosition) ? (axis.y + axis.height - axis.majorTickLines.size) : (axis.y + axis.height + axis.majorTickLines.size + 10) };
                                    chart.displayAxisTooltip(pointLocation, xVal, axis, axisIndex, mouseLocation, true);
                                }
                            }
                        }
                        else {
                            if (axis.orientation.toLowerCase() == "vertical" && axis.crosshairLabel.visible) {
                                if ((chart.mousemoveY) <= (axis.y + axis.height) && axis.y <= (chart.mousemoveY)) {
                                    var valueType = axis._valueType.toLowerCase(), yVal = pointValue.xValue, ypointLocation = [];
                                    if (valueType == "logarithmic") yVal = Math.pow(axis.logBase, yVal).toFixed(2).replace(new RegExp("\\.0{" + 2 + "}"), "");
                                    if (valueType == "datetime") yVal = (sf.format(new Date(Math.floor(yVal)), ((sf.util.isNullOrUndefined(axis.labelFormat)) ? sf.EjSvgRender.utils._dateTimeLabelFormat(axis._intervalType, axis) : axis.labelFormat), locale));
                                    if (valueType == "category") yVal = sf.EjSvgRender.utils._getLabelContent(yVal, axis, locale);
                                    ypointLocation = { X: axis.x, Y: (point.Y + axis.y) };
                                    chart.displayAxisTooltip(ypointLocation, yVal, axis, axisIndex, mouseLocation);
                                }
                            }
                        }

                    });
                }
                if (trackballDisplayMode !== "grouping" && chart.model.crosshair.trackballTooltipSettings.tooltipTemplate) {
                    var floatElements = $(document).find('[id*="_TrackToolTipTemplate_"]');
                    for (var i = 0; i < floatElements.length; i++) {
                        $(floatElements[i]).appendTo(this.templateContainer);
                        $(this.templateContainer).appendTo(this.chartContainer);
                    }
                }
            }
        },
        chartCrossHair: function (chart, mouseLocation) {
            var round = ((sf.util.isNullOrUndefined(this.model.primaryYAxis.roundingPlaces)) ? 2 : this.model.primaryYAxis.roundingPlaces),
                enableCanvas = chart.model.enableCanvasRendering, locale = this.model.locale;
            if ((!this.model.enable3D) && this.model.crosshair.visible && this.model.crosshair.type.toLowerCase() == "crosshair") {
                if ($("#" + this.svgObject.id + "_CrosshairGroup").length == 0) {
                    var gTrackballOptions = { 'id': this.svgObject.id + '_CrosshairGroup', 'visibility': 'visible' };
                    if (enableCanvas) {
                        gTrackballOptions.position = "absolute";
                        chart.svgRenderer.drawCrosshairLine(gTrackballOptions, '#chartContainer_' + this._id);
                    }
                    else {
                        this.gCrosshair = this.svgRenderer.createGroup(gTrackballOptions);
                        this.svgRenderer.append(this.gCrosshair, this.svgObject);
                    }
                }
                else
                    $("#" + this.svgObject.id + "_CrosshairGroup").css("display", "block");
                if (chart.model.trackerElement) {
                    if ($.finish)
                        $(this.model.trackerElement).finish();
                    else
                        $(this.model.trackerElement).stop(true, true);
                    this.model.trackerElement = null;
                }
				var trans = this.getScaleValues(this);
				var mousePosition = $.extend(true, {}, mouseLocation);
				mouseX = mousePosition.x / trans.x;
				mouseY = mousePosition.y / trans.y;				
                var minX, maxX, minY, maxY;
                for (var i = 0; i < this.model._axes.length; i++) {
                    var axis = this.model._axes[i];
                    if (axis.orientation.toLowerCase() == 'vertical') {
                        if (mouseY >= axis.y && mouseY <= axis.y + axis.height)
                            if (axis.x < mouseX)
                                minX = Math.min(minX || axis.x, axis.x);
                            else
                                maxX = Math.max(maxX || axis.x, axis.x);
                    }
                    else
                        if (mouseX >= axis.x && mouseX <= axis.x + axis.width)
                            if (axis.y < mouseY)
                                minY = Math.min(minY || axis.y, axis.y);
                            else
                                maxY = Math.max(maxY || axis.y, axis.y);
                }
                var left = minX || this.model.m_AreaBounds.X,
                    width = maxX ? maxX - left : this.model.m_AreaBounds.X + this.model.m_AreaBounds.Width - left,
                    top = minY || this.model.m_AreaBounds.Y,
                    height = maxY ? maxY - top : this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height - top;

				this.mousemoveX = this.mousemoveX / trans.x;
				this.mousemoveY = this.mousemoveY / trans.y;
                var d = "M" + " " + (this.mousemoveX) + " " + (top) + " " + "L" + " " + (this.mousemoveX) + " " + (top + height),
                    dhor = "M" + " " + (left) + " " + (this.mousemoveY) + " " + "L" + " " + (left + width) + " " + (this.mousemoveY),
                    chartOffset = $("#" + this._id).offset(),
                    svgObject = chart.svgObject, options, optionsHor,
                    chartPos = {
                        left: svgObject.offsetLeft > chartOffset.left ? svgObject.offsetLeft : chartOffset.left,
                        top: svgObject.offsetTop > chartOffset.top ? svgObject.offsetTop : chartOffset.top
                    };
                if ($("#" + chart.svgObject.id + "_CrosshairVertical").length == 0) {
                    options = {
                        'id': chart.svgObject.id + "_CrosshairVertical",
                        'fill': 'none',
                        'stroke-width': chart.model.crosshair.line.width,
                        'stroke': chart.model.crosshair.line.color,
                        'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)',
                        'd': d
                    };
                    if (enableCanvas) {
                        options.width = 0,
                            options.height = height,
                            options.top = top,
                            options.left = left,
                            options.position = "absolute", options.style = "solid", options.opacity = 0.5,
                            chart.svgRenderer.drawCrosshairLine(options, '#' + this.svgObject.id + '_CrosshairGroup');
                    }
                    else
                        chart.svgRenderer.drawPath(options, chart.gCrosshair);
                } else {
                    chart.svgRenderer._setAttr($(chart.svgObject).find("#" + chart.svgObject.id + "_CrosshairVertical"), { "d": d });
                    if (enableCanvas) {
                        $("#secondCanvas").remove();
                        $("#" + chart.svgObject.id + "_CrosshairVertical").css("left", this.mousemoveX).css({ "top": top, "height": height, "display": "block" });
                    }
                    $("#" + chart.svgObject.id + "_CrosshairVertical").attr("visibility", "visible").css("display", "block");
                }

                if ($("#" + chart.svgObject.id + "_CrosshairHorizontal").length == 0) {
                    optionsHor = {
                        'id': chart.svgObject.id + "_CrosshairHorizontal",
                        'fill': 'none',
                        'stroke-width': chart.model.crosshair.line.width,
                        'stroke': chart.model.crosshair.line.color,
                        'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)',
                        'd': dhor
                    };
                    if (enableCanvas) {
                        optionsHor.top = top + chartPos.top,
                            optionsHor.left = left + chartPos.left,
                            optionsHor.width = width,
                            optionsHor.height = 0,
                            optionsHor.position = "absolute", optionsHor.style = "solid", optionsHor.opacity = 0.5,
                            chart.svgRenderer.drawCrosshairLine(optionsHor, '#' + this.svgObject.id + '_CrosshairGroup');
                    }
                    else
                        chart.svgRenderer.drawPath(optionsHor, chart.gCrosshair);
                } else {
                    chart.svgRenderer._setAttr($(chart.svgObject).find("#" + chart.svgObject.id + "_CrosshairHorizontal"), { "d": dhor });
                    $("#" + chart.svgObject.id + "_CrosshairHorizontal").attr("visibility", "visible").css("display", "block");
                    if (enableCanvas) {
                        $("#" + chart.svgObject.id + "_CrosshairHorizontal").css("top", this.mousemoveY).css({ "left": left, "width": width, "display": "block" });
                    }
                }
                if ($('#' + chart.svgObject.id + '_AxisCrossToolTip').length == 0) {
                    var gAxisCrossOptions = { 'id': chart.svgObject.id + '_AxisCrossToolTip', 'visibility': 'visible' };
                    chart.gTrackAxisEle = chart.svgRenderer.createGroup(gAxisCrossOptions);
                    chart.svgRenderer.append(chart.gTrackAxisEle, chart.gCrosshair);
                }
                else {
                    this.svgRenderer._setAttr($(chart.gTrackAxisEle), { "visibility": 'visible' });
                    $(chart.gTrackAxisEle).css('display', 'block');
                }

                $.each(chart.model._axes, function (axisIndex, axis) {
                    var valueType = axis._valueType.toLowerCase();
                    if (axis.orientation.toLowerCase() == "horizontal" && axis.crosshairLabel.visible) {
                        if ((chart.mousemoveX) <= (axis.x + axis.width) && axis.x <= (chart.mousemoveX)) {
                            var labelplacement = (axis._valueType == "category" && axis.labelPlacement.toLowerCase() == 'betweenticks') ? 0.5 : 0;
                            var xVal = ((Math.abs(chart.mousemoveX - (axis.isInversed ? axis.x + axis.width : axis.x)) / (axis.width)) * (axis.visibleRange.delta) + axis.visibleRange.min + labelplacement).toFixed(2).replace(new RegExp("\\.0{" + 2 + "}"), "");
                            if (valueType == "logarithmic") xVal = Math.pow(axis.logBase, xVal).toFixed(2).replace(new RegExp("\\.0{" + 2 + "}"), "");
                            if (valueType == "datetime") xVal = (sf.format(new Date(Math.floor(xVal)), ((sf.util.isNullOrUndefined(axis.labelFormat)) ? sf.EjSvgRender.utils._dateTimeLabelFormat(axis._intervalType, axis) : axis.labelFormat), locale));
                            if (valueType == "category" || valueType == "datetimecategory") {
                                if (valueType == "category" || !sf.util.isNullOrUndefined(axis.labelFormat))
                                    xVal = sf.EjSvgRender.utils._getLabelContent(xVal, axis, locale);
                                else {
                                    xVal = xVal < 0 ? 0 : xVal;
                                    xVal = (sf.format(new Date(axis.labels[Math.floor(xVal)]), sf.EjSvgRender.utils._dateTimeLabelFormat(axis.intervalType, axis), locale));
                                }
                            }
                            var xPointLocation = { X: (chart.mousemoveX), Y: (axis.y) };
                            chart.displayAxisTooltip(xPointLocation, xVal, axis, axisIndex, mouseLocation, false, trans);
                            $("#" + chart.svgObject.id + '_AxisToolTipText' + '_' + axisIndex).show();
                            $("#" + chart.svgObject.id + '_AxisToolTipRect' + '_' + axisIndex).show();
                        }
                        else {
                            $("#" + chart.svgObject.id + '_AxisToolTipText' + '_' + axisIndex).hide();
                            $("#" + chart.svgObject.id + '_AxisToolTipRect' + '_' + axisIndex).hide();
                        }
                    } else if (axis.orientation.toLowerCase() == "vertical" && axis.crosshairLabel.visible) {
                        if ((chart.mousemoveY) <= (axis.y + axis.height) && axis.y <= (chart.mousemoveY)) {
                            var yVal = ((Math.abs(1 - (Math.abs(chart.mousemoveY - (axis.isInversed ? axis.y + axis.height : axis.y)) / (axis.width)) / (axis.height)) * (axis.visibleRange.delta) + axis.visibleRange.min).toFixed(round).replace(new RegExp("\\.0{" + round + "}"), ""));
                            if (valueType == "logarithmic") yVal = Math.pow(axis.logBase, yVal).toFixed(2).replace(new RegExp("\\.0{" + 2 + "}"), "");
                            if (valueType == "datetime") yVal = (sf.format(new Date(Math.floor(yVal)), ((sf.util.isNullOrUndefined(axis.labelFormat)) ? sf.EjSvgRender.utils._dateTimeLabelFormat(axis._intervalType, axis) : axis.labelFormat), locale));
                            if (valueType == "category" || valueType == "datetimecategory") {
                                if (valueType == "category" || sf.util.isNullOrUndefined(axis.labelFormat))
                                    yVal = sf.EjSvgRender.utils._getLabelContent(yVal, axis, locale);
                                else
                                    yVal = sf.format(new Date(axis.labels[Math.floor(yVal)]), sf.EjSvgRender.utils._dateTimeLabelFormat(axis.intervalType, axis), locale);

                            }
                            var ypointLocation = { X: axis.x, Y: (chart.mousemoveY) };
                            chart.displayAxisTooltip(ypointLocation, yVal, axis, axisIndex, mouseLocation, false, trans);
                            $("#" + chart.svgObject.id + '_AxisToolTipText' + '_' + axisIndex).show();
                            $("#" + chart.svgObject.id + '_AxisToolTipRect' + '_' + axisIndex).show();
                        }
                        else {
                            $("#" + chart.svgObject.id + '_AxisToolTipText' + '_' + axisIndex).hide();
                            $("#" + chart.svgObject.id + '_AxisToolTipRect' + '_' + axisIndex).hide();
                        }
                    }
                });

            }
        },
        chartTouchMove: function (evt) {
            this.cancelEvent(evt);
            evt = evt.originalEvent.touches[0];
            this.chartInteractiveBehavior(evt);

        },

        isZoomButtonHovered: function (target) {
            if (target.parentNode != null) {
                var parentId = target.parentNode.id;
                var id = target.id;
                if (id.indexOf('_ZoomInBtn ') == -1 && id.indexOf('ZoomOutBtn') == -1 && id.indexOf('_ZoomBtn') == -1 && id.indexOf('_ResetZoom') == -1 && id.indexOf('_PanBtn') == -1 && parentId && parentId.indexOf('_ZoomInBtn') == -1 && parentId.indexOf('_ZoomOutBtn') == -1 && parentId.indexOf('_ZoomBtn') == -1 && parentId.indexOf('_ResetZoom') == -1 && parentId.indexOf('_PanBtn') == -1)
                    return false;
            }
            return true;
        },
        showTooltipOnDrag: function (chart, evt) {
            $("#" + chart.svgObject.id).find("#" + chart.svgObject.id + "_TrackToolTip").attr('visibility', 'visible');
            $("#" + chart.svgObject.id + "_TrackToolTip").show();
            $(".tooltipDiv").css("display", "block");
        },
		getScaleValues: function(chart) {
			// to check transform for chart container
			var scaleElement = document.getElementById(chart.element[0].id);
			var scaleX = 1, scaleY = 1;
			var width = scaleElement.offsetWidth;
			var height = scaleElement.offsetHeight;
			if (width > 0) {
				scaleX = scaleElement.getBoundingClientRect().width / width;
				scaleY = scaleElement.getBoundingClientRect().height / height;
			}
			return {x : scaleX, y : scaleY };
		},
        chartInteractiveBehavior: function (evt) {
            var mouseMoveCords = this.calMousePosition(evt);
            this.mousemoveX = mouseMoveCords.X;
            this.mousemoveY = mouseMoveCords.Y;
			var trans = this.getScaleValues(this);
			var areaBounds = $.extend(true, {}, this.model.m_AreaBounds),
				m_AreaBoundsX = areaBounds.X * trans.x,
				m_AreaBoundsY = areaBounds.Y * trans.y,
				m_AreaBoundsWidth = areaBounds.Width * trans.x,
				m_AreaBoundsHeight = areaBounds.Height * trans.y;
            var id = "#" + this.svgObject.id;
            if (this.mouseWheelCoords) {
                var changeX = Math.abs(this.mouseWheelCoords.x - evt.pageX);
                var changeY = Math.abs(this.mouseWheelCoords.y - evt.pageY);
                if ((changeX > 0 || changeY > 0) && !(this.panning)) {
                    this.enableTrackBall();
                } else {
                    this.disableTrackBall();
                }
            }

            var chart = this,
                targetId = evt.target.id;
            if (chart.model.AreaType == "cartesianaxes" && this.mousemoveX >= m_AreaBoundsX && this.mousemoveX < (m_AreaBoundsX + m_AreaBoundsWidth) && this.mousemoveY < (m_AreaBoundsY + m_AreaBoundsHeight) && this.mousemoveY >= m_AreaBoundsY && this.model.initSeriesRender) {
                var mouseLocation = { x: chart.mousemoveX, y: chart.mousemoveY };
                var targetId = chart.svgRenderer._getAttrVal($(evt.target).parent(), "id");
                if ((targetId != undefined) && (targetId == chart.svgRenderer._getAttrVal($(this.svgObject).find(id + '_ZoomBtn'), "id") || targetId == chart.svgRenderer._getAttrVal($(this.svgObject).find(id + '_ResetZoom'), "id") || targetId == chart.svgRenderer._getAttrVal($(this.svgObject).find(id + '_PanBtn'), "id"))) {
                    this.disableTrackBall();
                }
                else {
                    this.enableTrackBall();
                }

                //show tooltip and track ball
                if (!this.model.crosshair.visible && !this.isZoomButtonHovered(evt.target))
                    this.tooltip(chart, evt);
                else {
                    if (this.dragPoint)
                        this.showTooltipOnDrag(chart, evt)
                    else if (!this.closestXyPoint) {
                        $("#" + chart.svgObject.id).find("#" + chart.svgObject.id + "_TrackToolTip").attr('visibility', 'hidden');
                        $("#" + chart.svgObject.id + "_TrackToolTip").hide();
                        $(".tooltipDiv" + this._id).css("display", "none");
                    }
                }
                if (!this.model.enable3D) {
                    //crossHair of chart
                    this.chartTrackball(chart, mouseLocation, evt);

                    //crossHair for chart area
                    this.chartCrossHair(chart, mouseLocation);
                }

            } else {
                if ((chart.model.AreaType == "none" || chart.model.AreaType == 'polaraxes') && !this.isZoomButtonHovered(evt.target))
                    this.tooltip(chart, evt);
                else {
                    if (this.dragPoint)
                        this.showTooltipOnDrag(chart, evt)
                    else if (!this.closestXyPoint) {
                        $("#" + chart.svgObject.id).find("#" + chart.svgObject.id + "_TrackToolTip").attr('visibility', 'hidden');
                        $("#" + chart.svgObject.id + "_TrackToolTip").hide();
                        $(".tooltipDiv" + this._id).css("display", "none");
                        this._removeTrackBall();
                        this._removeHighlight();
                    }
                }
                //Removing exploded marker symbol when placing mouse outside chart area
                var pointData = this.model.prevPoint;
                if (pointData && pointData.point) {
                    if (this.model.enableCanvasRendering)
                        $("#canvas_trackSymbol").remove();
                    else {
                        if (pointData.series.type == "boxandwhisker")
                            var pointLocation = pointData.outlierPosition;
                        else
                            var pointLocation = sf.EjSvgRender.utils._getPoint(pointData.point, pointData.series);
                        chart.drawTrackerSymbol(pointData.series, pointData.seriesIndex, pointData.pointIndex, null, pointLocation);
                    }
                    this.model.prevPoint = null;
                }
            }

        },

        // highlight SVG logic started here
        highlightSvg: function (chart, parentNodeId, isElement, evt, data, targetID, tracker) {
            if (parentNodeId != undefined) {
                var matchStr = this.svgObject.id + "_SeriesGroup_";
                var serIndex = parentNodeId.substr(matchStr.length);
                if (parentNodeId.indexOf(this.svgObject.id + "_symbolGroup_") >= 0) {
                    matchStr = this.svgObject.id + "_symbolGroup_";
                    serIndex = parentNodeId.substr(matchStr.length);
                }
            }

            serIndex = data != undefined ? data.region.SeriesIndex : serIndex
            var series = this.model.series[serIndex];
            if (isElement && series) {
                if (series.highlightSettings.enable || tracker)
                    this.highlight(chart, evt, series, null, data, parentNodeId, targetID, tracker);
            }

        },

        // canvas highlight logic started here
        highlightCanvas: function (chart, evt, data) {
            for (var i = 0; i < this.model._visibleSeries.length; i++) {
                var seriesIndex;
                var chartSeries;
                seriesIndex = i;
                chartSeries = this.model._visibleSeries[i];
                var type = chartSeries.type.toLowerCase();
                if (this.model.AreaType == "cartesianaxes" && chartSeries.visibility.toLowerCase() == 'visible' && type !== "scatter" && type !== "bubble" && type !== "column" && type.indexOf("bar") == -1 && type !== "stackingcolumn" && type !== "stackingcolumn100" && !chartSeries._hiloTypes) {
                    var serY = [];
                    var serX = [];
                    var location = null;
                    var mouseMoveCords = this.calMousePosition(evt);
                    this.mousemoveX = mouseMoveCords.X;
                    this.mousemoveY = mouseMoveCords.Y;
                    var closestXyPoint = this.getClosesPointXY(serX, serY, chartSeries, this.mousemoveX, this.mousemoveY, evt);
                    if (!sf.util.isNullOrUndefined(closestXyPoint.point)) {
                        var commonPointEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                        commonPointEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY }, region: { SeriesIndex: i, Region: { PointIndex: closestXyPoint.index } } };
                    }
                }
            }
            var data = commonPointEventArgs ? commonPointEventArgs.data : data;
            if (data && this.model.series[data.region.SeriesIndex].highlightSettings.enable) {
                var series = $.extend({}, this.model.series[data.region.SeriesIndex]);
                series.pointIndex = data.region.Region.PointIndex;
                series.seriesIndex = data.region.SeriesIndex;
                series.data = data;
                if ($('#' + this._id + '_Selection_series' + series.seriesIndex + '_canvas').length == 0) {
                    // removed canvas highlight
                    $("[id*=" + this._id + "_Highlight_" + "]").remove();
                    if (!this.findCanvasSelection(series.seriesIndex, series.pointIndex, series.selectionSettings.mode.toLowerCase()))
                        this.canvasHighlight(this, evt, series);
                }
            }
        },
        //change cursor symbols after resizing
        resizeCursor: function (containerSvg, mousemoveX, mousemoveY, chartAreaX, chartAreaY, chartAreaWidth, chartAreaHeight) {
            var selectedRectIndex = this.selectedRectIndex;
            if ((mousemoveX <= chartAreaX) || (mousemoveY <= chartAreaY) || (mousemoveX >= (chartAreaWidth + chartAreaX)) || (mousemoveY >= (chartAreaHeight + chartAreaY))) {
                $("#" + containerSvg + '_resize_rightRect' + selectedRectIndex).css({ 'cursor': 'default' });
                $("#" + containerSvg + '_resize_leftRect' + selectedRectIndex).css({ 'cursor': 'default' });
                $("#" + containerSvg + '_resize_bottomRect' + selectedRectIndex).css({ 'cursor': 'default' });
                $("#" + containerSvg + '_resize_topRect' + selectedRectIndex).css({ 'cursor': 'default' });
                $("#" + containerSvg + '_resize_bottomRightCornerCircle' + selectedRectIndex).css({ 'cursor': 'default' });
            }
            else if ((mousemoveX >= chartAreaX) || (mousemoveY >= chartAreaY) || (mousemoveX <= (chartAreaWidth + chartAreaX)) || (mousemoveY <= (chartAreaHeight + chartAreaY))) {
                $("#" + containerSvg + '_resize_rightRect' + selectedRectIndex).css({ 'cursor': 'e-resize' });
                $("#" + containerSvg + '_resize_leftRect' + selectedRectIndex).css({ 'cursor': 'w-resize' });
                $("#" + containerSvg + '_resize_bottomRect' + selectedRectIndex).css({ 'cursor': 's-resize' });
                $("#" + containerSvg + '_resize_topRect' + selectedRectIndex).css({ 'cursor': 'n-resize' });
                $("#" + containerSvg + '_resize_bottomRightCornerCircle' + selectedRectIndex).css({ 'cursor': 'se-resize' });
            }
        },
        multiSelectMouseMove: function (evt) {
            if (this._isMultiSelect && (this.multiSelectMode == 'range') && !this.dragPoint) {
                var mouseMoveCords = this.calMousePosition(evt),
                    mouseMoveX = mouseMoveCords.X,
                    mouseMoveY = mouseMoveCords.Y,
                    gripMouseMoveX, gripMouseMoveY, translate,
                    selectionSettingsType = this.multiSelectType,
                    width, height, x, y,
                    rectX, rectY, rectWidth, rectHeight, id,
                    x1, x2, y1, y2, xPlotOffset, yPlotOffset,
                    modifiedX, modifiedY,
                    mouseDownX = this.mouseDownX,
                    mouseDownY = this.mouseDownY,
                    selectedRectIndex = this.selectedRectIndex,
                    containerSvg = this.svgObject.id,
                    chartArea = '#' + containerSvg + '_ChartArea',
                    chartAreaX = parseInt($(chartArea).attr('x')),
                    chartAreaY = parseInt($(chartArea).attr('y')),
                    chartAreaWidth = parseInt($(chartArea).attr('width')),
                    chartAreaHeight = parseInt($(chartArea).attr('height')),
                    multiSelectMouseDownId = this.multiSelectMouseDownId,
                    selctRectId = '#' + containerSvg + '_selectRect',
                    multiAxis = this.multiAxis;
                for (var q = 0; q < multiAxis.length; q++) {
                    if (multiAxis[q].orientation.toLowerCase() == 'horizontal') {
                        x1 = multiAxis[q].Location.X1; x2 = multiAxis[q].Location.X2;
                        xPlotOffset = multiAxis[q].plotOffset;
                    }
                    else {
                        y1 = multiAxis[q].Location.Y1; y2 = multiAxis[q].Location.Y2;
                        yPlotOffset = multiAxis[q].plotOffset;
                    }
                }
                if ((this.drag) && (!this.resize) && (!this.rectPan) && (!this.removeRect)) {
                    var currentX = mouseMoveX,
                        currentY = mouseMoveY,
                        areaBounds = this.model.m_AreaBounds;
                    this.multiSelectDraw = true;
                    if (mouseMoveX < areaBounds.X) {
                        currentX = areaBounds.X;
                    }
                    else if (mouseMoveX > (areaBounds.X + areaBounds.Width)) {
                        currentX = areaBounds.X + areaBounds.Width;
                    }
                    if (mouseMoveY < areaBounds.Y) {
                        currentY = areaBounds.Y;
                    } else if (mouseMoveY > (areaBounds.Y + areaBounds.Height)) {
                        currentY = areaBounds.Y + areaBounds.Height;
                    }
                    else {
                        currentY = mouseMoveY;
                    }
                    switch (selectionSettingsType) {
                        case 'x':
                            width = Math.abs(currentX - mouseDownX);
                            height = y1 - y2 + yPlotOffset + yPlotOffset;
                            x = currentX > mouseDownX ? mouseDownX : currentX;
                            y = y2 - yPlotOffset;
                            break;
                        case 'y':
                            width = x2 - x1 + xPlotOffset + xPlotOffset;
                            height = Math.abs(currentY - mouseDownY);
                            x = x1 - xPlotOffset;
                            y = currentY > mouseDownY ? mouseDownY : currentY;
                            break;
                        case 'xy':
                            width = Math.abs(currentX - mouseDownX);
                            height = Math.abs(currentY - mouseDownY);
                            x = currentX > mouseDownX ? mouseDownX : currentX;
                            y = currentY > mouseDownY ? mouseDownY : currentY;
                            break;
                    }
                    if (width > 0 && height > 0) {
                        var rectOptions = {
                            'id': this.svgObject.id + '_selectRect' + this.selectedRectIndex,
                            'x': x,
                            'y': y,
                            'width': width,
                            'height': height,
                            'fill': 'rgba(41,136,214,0.2)',
                            'stroke-width': 2,
                            'stroke': 'rgba(41,136,214,0.5)',
                            'cursor': 'pointer',
                            'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)'
                        };
                        if ((x >= x1 + xPlotOffset) && (mouseMoveX <= x2 - xPlotOffset) && (mouseMoveY <= y1 + yPlotOffset) && (y >= y2 - yPlotOffset))
                            this.svgRenderer.drawRect(rectOptions, this.gEle);
                        if ((this.gEle != null)) {
                            $(this.gEle).appendTo(this.parentgEle);
                            if (this.selectedRectIndex == 0) {
                                this.model.gCurrentEle = this.gEle;
                            }
                            $(this.parentgEle).appendTo(this.svgObject);
                        }
                    }
                }
                rectX = parseInt($(selctRectId + selectedRectIndex).attr('x'));
                rectY = parseInt($(selctRectId + selectedRectIndex).attr('y'));
                rectWidth = parseInt($(selctRectId + selectedRectIndex).attr('width'));
                rectHeight = parseInt($(selctRectId + selectedRectIndex).attr('height'));
                if (!this.drag && (evt.target.id.indexOf("selectRect") >= 0 || evt.target.id.indexOf("resize") >= 0)) {
                    if (evt.target.parentNode.id.indexOf("selectedRect") >= 0) {
                        id = evt.target.parentNode.id.split("selectedRect")[1].match(/\d+/)[0];
                        this.gripIndex = eval(id);
                    }
                    var selectRectId = '#' + containerSvg + '_selectRect',
                        selectRectWidth = parseInt($(selectRectId + this.gripIndex).attr("width")),
                        selectRectHeight = parseInt($(selectRectId + this.gripIndex).attr("height")),
                        selectRectX = parseInt($(selectRectId + this.gripIndex).attr("x")),
                        selectRectY = parseInt($(selectRectId + this.gripIndex).attr("y"));
                    $("#" + containerSvg + "_gripCollection" + selectedRectIndex).css({ 'visibility': 'hidden' });
                    if (selectRectX + selectRectWidth - 16 >= selectRectX || selectRectY + selectRectHeight - 16 >= selectRectY)
                        $("#" + this.svgObject.id + "_gripCollection" + this.gripIndex).attr({ 'transform': "" });
                    if (selectRectX + selectRectWidth - 16 < selectRectX || selectRectY + selectRectHeight - 16 < selectRectY) {
                        var translate = 'translate(' + 15 + ',' + 15 + ')';
                        $("#" + this.svgObject.id + "_gripCollection" + this.gripIndex).attr({ 'transform': translate });
                    }
                    if (this.oldId != evt.target.id)
                        $("#" + containerSvg + "_gripCollection" + this.oldGripIndex).css({ 'visibility': 'hidden' });
                    $("#" + containerSvg + "_gripCollection" + this.gripIndex).css({ 'visibility': 'visible' });
                    this.oldId = evt.target.id;
                    this.oldGripIndex = this.gripIndex;
                }
                if ((evt.target.id.indexOf("selectRect") < 0) && (evt.target.id.indexOf("resize") < 0))
                    $("#" + containerSvg + "_gripCollection" + this.gripIndex).css({ 'visibility': 'hidden' });
                if (this.resize) {
                    $("#" + containerSvg + "_closeTopRightCornerCircle" + selectedRectIndex).hide();
                    $("#" + containerSvg + "_closePath" + selectedRectIndex).hide();
                    $("#" + containerSvg + "_closePathOpposite" + selectedRectIndex).hide();
                    $("#" + containerSvg + "_gripCollection" + selectedRectIndex).css({ 'visibility': 'hidden' });
                    var oldRectX = this.oldRectX[selectedRectIndex], oldRectY = this.oldRectY[selectedRectIndex],
                        oldRectHeight = this.oldRectHeight[selectedRectIndex], oldRectWidth = this.oldRectWidth[selectedRectIndex],
                        oldReBottomRectY = this.oldReBottomRectY[selectedRectIndex],
                        oldReRightRectX = this.oldReRightRectX[selectedRectIndex];
                    switch (selectionSettingsType) {
                        case 'x':
                            if (multiSelectMouseDownId == containerSvg + '_resize_rightRect' + selectedRectIndex) {
                                rectWidth = mouseMoveX - oldRectX;
                                $("#" + containerSvg + "_resize_rightRect" + selectedRectIndex).attr('x', mouseMoveX - 5);
                                if (mouseMoveX < oldRectX) {
                                    rectX = mouseMoveX;
                                    rectWidth = oldRectX - mouseMoveX;
                                }
                                else if (mouseMoveX >= oldRectX) rectX = oldRectX;
                            }
                            else if (multiSelectMouseDownId == containerSvg + '_resize_leftRect' + selectedRectIndex) {
                                rectX = mouseMoveX;
                                rectWidth = oldRectWidth + oldRectX - mouseMoveX;
                                $("#" + containerSvg + "_resize_leftRect" + selectedRectIndex).attr('x', mouseMoveX - 5);
                                if (mouseMoveX > (oldReRightRectX + 5)) {
                                    rectX = oldReRightRectX + 5;
                                    rectWidth = mouseMoveX - oldRectX - oldRectWidth;
                                }
                            }
                            this.resizeCursor(containerSvg, mouseMoveX, mouseMoveY, chartAreaX, chartAreaY, chartAreaWidth, chartAreaHeight);
                            break;
                        case 'y':
                            if (multiSelectMouseDownId == containerSvg + '_resize_topRect' + selectedRectIndex) {
                                rectHeight = oldRectHeight + oldRectY - mouseMoveY;
                                rectY = mouseMoveY;
                                $("#" + containerSvg + "_resize_topRect" + selectedRectIndex).attr('y', mouseMoveY - 5);
                                if (mouseMoveY > (oldReBottomRectY + 5)) {
                                    rectY = oldReBottomRectY + 5;
                                    rectHeight = mouseMoveY - oldRectY - oldRectHeight;
                                }
                            }
                            else if (multiSelectMouseDownId == (containerSvg + '_resize_bottomRect' + selectedRectIndex)) {
                                rectHeight = mouseMoveY - oldRectY;
                                $("#" + containerSvg + "_resize_bottomRect" + selectedRectIndex).attr('y', mouseMoveY - 5);
                                if (mouseMoveY < oldRectY) {
                                    rectY = mouseMoveY;
                                    rectHeight = oldRectY - mouseMoveY;
                                }
                                else if (mouseMoveY >= oldRectY) rectY = oldRectY;
                            }
                            this.resizeCursor(containerSvg, mouseMoveX, mouseMoveY, chartAreaX, chartAreaY, chartAreaWidth, chartAreaHeight);
                            break;
                        case 'xy':
                            if (multiSelectMouseDownId == containerSvg + '_resize_rightRect' + selectedRectIndex) {
                                rectWidth = mouseMoveX - oldRectX;
                                $("#" + containerSvg + "_resize_rightRect" + selectedRectIndex).attr('x', mouseMoveX - 5);
                                if (mouseMoveX < oldRectX) {
                                    rectX = mouseMoveX;
                                    rectWidth = oldRectX - mouseMoveX;
                                }
                                else if (mouseMoveX >= oldRectX)
                                    rectX = oldRectX;
                            }
                            else if (multiSelectMouseDownId == containerSvg + '_resize_leftRect' + selectedRectIndex) {
                                rectX = mouseMoveX;
                                rectWidth = oldRectWidth + oldRectX - mouseMoveX;
                                $("#" + containerSvg + "_resize_leftRect" + selectedRectIndex).attr('x', mouseMoveX - 5);
                                if (mouseMoveX > (oldReRightRectX + 5)) {
                                    rectX = oldReRightRectX + 5;
                                    rectWidth = mouseMoveX - oldRectX - oldRectWidth;
                                }
                            }
                            else if (multiSelectMouseDownId == containerSvg + '_resize_topRect' + selectedRectIndex) {
                                rectHeight = oldRectHeight + oldRectY - mouseMoveY;
                                rectY = mouseMoveY;
                                $("#" + containerSvg + "_resize_topRect" + selectedRectIndex).attr('y', mouseMoveY - 5);
                                if (mouseMoveY > (oldReBottomRectY + 5)) {
                                    rectY = oldReBottomRectY + 5;
                                    rectHeight = mouseMoveY - oldRectY - oldRectHeight;
                                }
                            }
                            else if (multiSelectMouseDownId == (containerSvg + '_resize_bottomRect' + selectedRectIndex)) {
                                rectHeight = mouseMoveY - oldRectY;
                                $("#" + containerSvg + "_resize_bottomRect" + selectedRectIndex).attr('y', mouseMoveY - 5);
                                if (mouseMoveY < oldRectY) {
                                    rectY = mouseMoveY;
                                    rectHeight = oldRectY - mouseMoveY;
                                }
                                else if (mouseMoveY >= oldRectY)
                                    rectY = oldRectY;
                            }
                            else if (multiSelectMouseDownId == containerSvg + '_resize_bottomRightCornerCircle' + selectedRectIndex) {
                                rectWidth = mouseMoveX - oldRectX;
                                rectHeight = mouseMoveY - oldRectY;
                                $("#" + containerSvg + "_resize_bottomRightCornerCircle" + selectedRectIndex).attr({ 'cx': mouseMoveX, 'cy': mouseMoveY });
                                if ((mouseMoveX < oldRectX) && (mouseMoveY < oldRectY)) {
                                    rectX = mouseMoveX;
                                    rectY = mouseMoveY;
                                    rectWidth = oldRectX - mouseMoveX;
                                    rectHeight = oldRectY - mouseMoveY;
                                }
                                else if (mouseMoveX < oldRectX) {
                                    rectX = mouseMoveX;
                                    rectWidth = oldRectX - mouseMoveX;
                                }
                                else if (mouseMoveY < oldRectY) {
                                    rectY = mouseMoveY;
                                    rectHeight = oldRectY - mouseMoveY;
                                }
                                else if ((mouseMoveX >= oldRectX) && (mouseMoveY >= oldRectY)) {
                                    rectX = oldRectX;
                                    rectY = oldRectY;
                                }
                            }
                            this.resizeCursor(containerSvg, mouseMoveX, mouseMoveY, chartAreaX, chartAreaY, chartAreaWidth, chartAreaHeight);
                            break;
                    }
                    switch (selectionSettingsType) {
                        case 'x':
                            if (rectX >= x1 - xPlotOffset && (rectWidth + rectX - x1 <= x2 - x1 - xPlotOffset))
                                $(selctRectId + selectedRectIndex).attr({ 'x': rectX, 'width': rectWidth });
                            break;
                        case 'y':
                            if (((rectHeight + rectY - y2) <= y1 - y2 + yPlotOffset) && (rectY >= y2 - yPlotOffset))
                                $(selctRectId + selectedRectIndex).attr({ 'y': rectY, 'height': rectHeight });
                            break;
                        case 'xy':
                            if (rectX >= x1 - xPlotOffset && (rectWidth + rectX - x1 <= x2 - x1 - xPlotOffset) && (rectHeight + rectY - y2 <= y1 - y2 + yPlotOffset) && rectY >= y2 - yPlotOffset)
                                $(selctRectId + selectedRectIndex).attr({ 'x': rectX, 'y': rectY, 'width': rectWidth, 'height': rectHeight });;
                            break;
                    }
                }
                if ((this.rectPan)) {
                    $("#" + containerSvg + "_closeTopRightCornerCircle" + selectedRectIndex).hide();
                    $("#" + containerSvg + "_closePath" + selectedRectIndex).hide();
                    $("#" + containerSvg + "_closePathOpposite" + selectedRectIndex).hide();
                    $("#" + containerSvg + "_gripCollection" + selectedRectIndex).css({ 'visibility': 'hidden' });
                    if ((mouseMoveX <= chartAreaX || mouseMoveY <= chartAreaY || (mouseMoveX >= chartAreaX + chartAreaWidth) || (mouseMoveY >= chartAreaY + chartAreaHeight)))
                        this.multiSelectMouseUp(evt);
                    modifiedX = this.PreviousCoords.X - evt.pageX;
                    modifiedY = this.PreviousCoords.Y - evt.pageY;
                    rectX = rectX - modifiedX;
                    rectY = rectY - modifiedY;
                    this.PreviousCoords.X = evt.pageX;
                    this.PreviousCoords.Y = evt.pageY;
                    switch (selectionSettingsType) {
                        case 'x':
                            if (rectX >= x1 - xPlotOffset && (rectWidth + rectX - x1 <= x2 - x1 - xPlotOffset))
                                $(selctRectId + selectedRectIndex).attr({ 'x': rectX });
                            break;
                        case 'y':
                            if ((rectHeight + rectY - y2 <= y1 - y2 + yPlotOffset) && rectY >= y2 - yPlotOffset)
                                $(selctRectId + selectedRectIndex).attr({ 'y': rectY });
                            break;
                        case 'xy':
                            if (rectX >= x1 - xPlotOffset && (rectWidth + rectX - x1 <= x2 - x1 - xPlotOffset) && (rectHeight + rectY - y2 <= y1 - y2 + yPlotOffset) && rectY >= y2 - yPlotOffset)
                                $(selctRectId + selectedRectIndex).attr({ 'x': rectX, 'y': rectY });
                            break;
                    }
                }
            }
        },
        isTouch: function (evt) {
            var browserInfo = this.model.browserInfo,
                event = evt.originalEvent ? evt.originalEvent : evt;
            if ((event.pointerType == "touch") || (event.pointerType == 2) || (event.type.indexOf("touch") > -1))
                return true;
            return false;

        },
        highlightStart: function (evt, data, parentNodeId, targetID, tracker) {
            if (evt.target.parentNode != null) {
                var parentNodeId = parentNodeId || evt.target.parentNode.id;
                var isElement = (parentNodeId.indexOf(this.svgObject.id + "_SeriesGroup_") >= 0 || parentNodeId.indexOf(this.svgObject.id + "_symbolGroup_") >= 0 || parentNodeId.indexOf(this.svgObject.id + "_TrackSymbol_") >= 0 || parentNodeId.indexOf(this.svgObject.id + "_Chart3D") >= 0) ? true : false;
            }

            if (this.model.enableCanvasRendering)
                this.highlightCanvas(this, evt, data);
            else
                this.highlightSvg(this, parentNodeId, isElement, evt, data, targetID, tracker)
        },

        _changeDraggingPoints: function (chartSeries, index, X, Y) {
            X = chartSeries.xAxis._valueType == "datetime" ? new Date(X) : X;
            Y = chartSeries.yAxis._valueType == "datetime" ? new Date(Y) : Y;
            var dragType = chartSeries.dragSettings.type.toLowerCase();
            if ((dragType == "x" || dragType == "xy") && chartSeries.xAxis._valueType != "category") {
                if (this.dragPoint) {
                    chartSeries.pointCollection[index].x = X;
                    chartSeries.pointCollection[index].xValue = (chartSeries.xAxis._valueType == "datetime" && typeof X != "object") ? new Date(X) : X;
                }
                else {
                    chartSeries._visiblePoints[index].x = chartSeries.points[index].x = X;
                    chartSeries._visiblePoints[index].xValue = chartSeries.points[index].xValue = (chartSeries.xAxis._valueType == "datetime" && typeof X == "object") ? Date.parse(X) : X;
                }
                if (!sf.util.isNullOrUndefined(chartSeries.dataSource))
                    chartSeries.dataSource[index][chartSeries.xName] = X;
            }
            if (dragType == "y" || dragType == "xy") {
                if (this.dragPoint) {
                    chartSeries.pointCollection[index].y = Y
                    chartSeries.pointCollection[index].YValues[0] = (chartSeries.yAxis._valueType == "datetime" && typeof Y != "object") ? new Date(Y) : Y;
                }
                else {
                    chartSeries._visiblePoints[index].y = chartSeries.points[index].y = Y;
                    chartSeries._visiblePoints[index].YValues[0] = chartSeries.points[index].YValues[0] = (chartSeries.yAxis._valueType == "datetime" && typeof Y == "object") ? Date.parse(Y) : Y;
                }
                if (!sf.util.isNullOrUndefined(chartSeries.dataSource))
                    chartSeries.dataSource[index][chartSeries.yName] = Y;
            }
        },

        // Triggers while dragging the point
        _dragDelta: function (newXval, newYval, oldXval, oldYval, srIndex, ptIndex) {
            var chart = this,
                oldValue = { X: oldXval, Y: oldYval },
                newValue = { X: newXval, Y: newYval },
                commonDragEventArgs = $.extend({}, this.commonDragEventArgs);
            commonDragEventArgs.data = { seriesIndex: srIndex, pointIndex: ptIndex, oldValue: oldValue, newValue: newValue };
            this._trigger("dragging", commonDragEventArgs);
            this.commonDragEventArgs = commonDragEventArgs;
        },
        _getDraggedPoint: function (chartSeries, currentX, currentY) {
            var mousePoint, PointX, PointY, x, y;
            var valAxis = sf.EjSvgRender.utils._getTransform(chartSeries.xAxis, chartSeries.yAxis, this.model.requireInvertedAxes);
            if (this.model.requireInvertedAxes) {
                x = (valAxis.y + valAxis.height) - currentY;
                y = (currentX - valAxis.x);
            }
            else {
                x = (currentX - valAxis.x);
                y = (valAxis.y + valAxis.height) - currentY;
            }
            mousePoint = sf.EjSvgRender.utils._getValuebyPoint(x, y, chartSeries, this.model.requireInvertedAxes);
            PointX = parseFloat(mousePoint.PointX.toFixed(2));
            PointY = parseFloat(mousePoint.PointY.toFixed(2));
            return { X: PointX, Y: PointY };
        },

        _pointDragandDrop: function (chartSeries, evt, chart) {
            var i = chartSeries.data.seriesIndex, canvasElement, 
                pointCollection = [], translate = null,
                chartType = chartSeries.type.toLowerCase();
            var params = {};
            params.axes = {};
            for (var k = 0; k < this.model._axes.length; k++)
                params.axes[this.model._axes[k].name] = {};


            $("[id*=" + "_Marker" + "]").remove();
            var draggedPoints = this._getDraggedPoint(chartSeries, this.mousemoveX, this.mousemoveY),
                xPoint = draggedPoints.X,
                yPoint = draggedPoints.Y,
                xVal = this.commonDragEventArgs.data.currentPoint ? this.commonDragEventArgs.data.currentPoint.xValue : this.commonDragEventArgs.data.oldValue.X,
                yVal = this.commonDragEventArgs.data.currentPoint ? this.commonDragEventArgs.data.currentPoint.yValue[0] : this.commonDragEventArgs.data.oldValue.Y;
            if (chartSeries.region) {
                var region = chartSeries.region;
                chart._dragDelta(xPoint, yPoint, xVal, yVal, region.SeriesIndex, region.Region.PointIndex);
            }
            else {
                var closestPoint = chartSeries.pointData;
                chart._dragDelta(xPoint, yPoint, xVal, yVal, closestPoint.seriesIndex, closestPoint.index);
            }
            if (this.model.enableCanvasRendering) {
                if (this.canvasElement) this.canvasElement.clearRect(0, 0, chart.svgWidth, chart.svgHeight);
                if ($('#' + chart._id + '_PreviewSeries' + i + '_canvas').length == 0) {
                    var containerStyle = document.getElementById(chart._id + '_canvas').getBoundingClientRect();
                    canvasElement = this.createCanvasElement(chart._id + '_PreviewSeries' + i + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
                    this.createRect(chart, canvasElement);
                    this.canvasElement = canvasElement;
                }
            }
            else {
                chartSeries.xAxis = (chartSeries.xAxis === null || chartSeries.xAxis === undefined) ? this.model._axes[0] : chartSeries.xAxis;
                chartSeries.yAxis = (chartSeries.yAxis === null || chartSeries.yAxis === undefined) ? this.model._axes[1] : chartSeries.yAxis;
                var trans = sf.EjSvgRender.utils._getTransform(chartSeries.xAxis, chartSeries.yAxis, this.model.requireInvertedAxes);
                var translate = 'translate(' + trans.x + ',' + trans.y + ')';
                var serOptions = { 'id': this.svgObject.id + '_PreviewSeriesGroup', 'transform': translate, 'cursor': 'default', 'visibility': 'visible' };
                $("#" + this.svgObject.id + "_PreviewSeriesGroup").attr("transform", translate);
                if (!this.gPreviewSeriesGroupEle) {
                    this.chartObj = chart;
                    this.chartObj.gPreviewSeriesGroupEle = this.gPreviewSeriesGroupEle = this.svgRenderer.createGroup(serOptions);
                }
                if (this.gPreviewSeriesGroupEle.childNodes.length > 0)
                    this.gPreviewSeriesGroupEle.removeChild(this.gPreviewSeriesGroupEle.childNodes[0]);
            }
            pointCollection = $.extend(true, {}, chartSeries._visiblePoints);
            chartSeries.pointCollection = pointCollection;
            pointCollection.length = chartSeries._visiblePoints.length;
            var dragEventArgs = chart.commonDragEventArgs.data;
            var ptindex = dragEventArgs.pointIndex,
                srindex = dragEventArgs.seriesIndex;
            chart._changeDraggingPoints(chartSeries, ptindex, dragEventArgs.newValue.X, dragEventArgs.newValue.Y);

            var series = new sf.seriesTypes[chartType](),
                point = chartSeries.pointCollection[ptindex];
            if (chartType == "bubble") {
                var location = sf.EjSvgRender.utils._getPoint(point, chartSeries);
                var options = {
                    'id': this.svgObject.id + '_PreviewSeries' + srindex + '_Point' + ptindex,
                    'cx': location.X + this.canvasX,
                    'cy': (location.Y) + this.canvasY,
                    'r': point.radius,
                    'fill': chartSeries.fill,
                    'stroke-width': 2,
                    'visibility': 'visible',
                    'stroke-dasharray': "",
                    'opacity': 0.6,
                    'stroke': 'transparent'
                };
                if (this.model.enableCanvasRendering)
                    sf.EjCanvasRender.prototype.drawCircle(options, canvasElement);
                else
                    this.svgRenderer.drawCircle(options, this.gPreviewSeriesGroupEle);
                this.svgRenderer.append(this.gPreviewSeriesGroupEle, this.gSeriesEle);
            }
            else if (chartType == "scatter") {
                var location = sf.EjSvgRender.utils._getPoint(point, chartSeries);
                var symbolName = (chartSeries.marker.shape).capitalizeFirstString();
                var location = { startX: location.X + this.canvasX, startY: location.Y + this.canvasY };
                var style = {
                    ShapeSize: { width: chartSeries.marker.size.width, height: chartSeries.marker.size.height },
                    ID: this.svgObject.id + '_PreviewSeries' + srindex + '_Point' + ptindex,
                    Style: {
                        Color: chartSeries.fill,
                        BorderWidth: chartSeries.marker.border.width,
                        BorderColor: 'transparent',
                        Opacity: 0.6,
                        Visibility: 'visible'
                    }
                };
                if (this.model.enableCanvasRendering)
                    sf.EjSvgRender.chartSymbol["_draw" + symbolName](location, style, this, canvasElement);
                else
                    sf.EjSvgRender.chartSymbol["_draw" + symbolName](location, style, this, this.gPreviewSeriesGroupEle);
                this.svgRenderer.append(this.gPreviewSeriesGroupEle, this.gSeriesEle);
            }

            else if (chartType == "column" || chartType == "bar") {
                point.xValue = (typeof point.xValue == "object") ? Date.parse(point.xValue) : point.xValue;
                var origin = sf.EjSeriesRender.prototype.getOrigin(chart, chartSeries, params);
                var sidebysideinfo = chartSeries.sidebysideInfo;
                var y1 = point.YValues[0];
                var y2 = origin;
                //calculate sides
                var data = sf.EjSeriesRender.prototype.calculateSides(point, sidebysideinfo);
                var x1 = data.x1;
                var x2 = data.x2;
                var rect = sf.EjSeriesRender.prototype.getRectangle(x1, y1, x2, y2, chartSeries, chart);
                options = {
                    'id': this.svgObject.id + '_PreviewSeries' + srindex + '_Point' + ptindex,
                    'x': rect.X + this.canvasX,
                    'y': rect.Y + this.canvasY,
                    'width': rect.Width,
                    'height': rect.Height,
                    'cornerRadius': chartSeries.cornerRadius,
                    'fill': chartSeries.fill,
                    'stroke-width': 2,
                    'plot': y1 < 0 ? "negative" : "positive",
                    'opacity': 0.6,
                    'stroke': 'transparent',
                    'stroke-dasharray': "",
                };
                if (this.model.enableCanvasRendering)
                    sf.EjCanvasRender.prototype.drawRect(options, canvasElement);
                else {
                    this.svgRenderer.drawRect(options, this.gPreviewSeriesGroupEle);
                    this.svgRenderer.append(this.gPreviewSeriesGroupEle, this.gSeriesEle);
                }
            }
            else {
                if (chartType == "spline" || chartType == "splinearea")
                    point.xValue = (typeof point.xValue == "object") ? Date.parse(point.xValue) : point.xValue;
                series.draw(this, chartSeries, params);
            }
            var location = sf.EjSvgRender.utils._getPoint(point, chartSeries);
            if (chartSeries.tooltip.visible) {
                if (sf.util.isNullOrUndefined(chartSeries.tooltip.template)) {
                    $(".tooltipDiv" + this._id).remove();
                    chart.displayShowTooltip(location, point, chartSeries, point.actualIndex);
                }
                else {
                    $("#" + chart.svgObject.id).find("#" + chart.svgObject.id + "_TrackToolTip").attr('visibility', 'hidden');
                    var region = { SeriesIndex: srindex, Region: { PointIndex: point.actualIndex } };
                    chart.createTooltip(region, evt, chartSeries);
                }
            }

        },
        // to show marker symbol for line type charts in dragdrop
        _dragPointMarker: function (chartSeries, currentX, currentY, evt, closestXyPoint) {
            var location = null, ctx,
                srIndex = chartSeries.seriesIndex;
            location = sf.EjSvgRender.utils._getPoint(closestXyPoint.point, chartSeries);
            if (this.model.enableCanvasRendering) {
                if ($('#' + this.svgObject.id + '_Marker').length == 0) {
                    var containerStyle = document.getElementById(this.svgObject.id).getBoundingClientRect();
                    ctx = this.createCanvasElement(this.svgObject.id + '_Marker', this.svgWidth, this.svgHeight, containerStyle);
                }
            }
            else {
                var markerOptions = { 'id': this.svgObject.id + '_markerGroup' + '_' + srIndex };
                if (!this.gMarkerGroupEle)
                    this.gMarkerGroupEle = this.svgRenderer.createGroup(markerOptions);
            }
            var options = {
                'id': this.svgObject.id + '_Series' + srIndex + '_Point' + closestXyPoint.index + '_Marker',
                'cx': location.X + this.model.m_AreaBounds.X,
                'cy': location.Y + this.model.m_AreaBounds.Y,
                'r': 7,
                'fill': chartSeries.fill,
                'stroke-width': 3,
                'opacity': 1,
                'stroke': 'white',
                'visibility': 'visible'
            };
            if (this.model.enableCanvasRendering)
                sf.EjCanvasRender.prototype.drawCircle(options, ctx);
            else {
                this.svgRenderer.drawCircle(options, this.gMarkerGroupEle);
                this.svgRenderer.append(this.gMarkerGroupEle, this.gSeriesEle);
            }
        },
        // to show 3 circles for column and bar while hovering rect in dragdrop
        _dragPointGripper: function (data) {
            var type = data.region.type.toLowerCase(),
                chartSeries = this.model._visibleSeries[data.region.SeriesIndex],
                point = chartSeries._visiblePoints[data.region.Region.PointIndex],
                transposed = chartSeries.isTransposed, canvasGripper,
                inversed = chartSeries.yAxis.isInversed;
            if (type == "column" || type == "bar") {
                if (this.model.enableCanvasRendering) {
                    var containerStyle = document.getElementById(this.svgObject.id).getBoundingClientRect();
                    canvasGripper = this.createCanvasElement(this.svgObject.id + '_Marker', this.svgWidth, this.svgHeight, containerStyle);
                    document.getElementById(canvasGripper.canvas.id).style.zIndex = 1;
                }
                else {
                    var markerOptions = { 'id': this.svgObject.id + '_markerGroup' + '_' + data.region.SeriesIndex };
                    if (!this.gMarkerGroupEle)
                        this.gMarkerGroupEle = this.svgRenderer.createGroup(markerOptions);
                }
                var circleLength = 3, value, boundValue, loc, diff, radius, cxy,
                    bounds = data.region.Region.Bounds;
                if ((transposed && type == "bar") || (type == "column" && !transposed)) {
                    value = bounds.Width;
                    boundValue = bounds.X;
                }
                if ((!transposed && type == "bar") || (type == "column" && transposed)) {
                    value = bounds.Height;
                    boundValue = bounds.Y;
                }
                loc = value < 75 ? value - value / 3 : 75 - 25;
                diff = value > 75 ? value - 75 : 0;
                radius = (loc - 6) / 6;
                cxy = diff / 2 + boundValue + loc / 6 + radius / 2;
                for (var k = 1; k <= circleLength; k++) {
                    var options = {
                        'id': this.svgObject.id + '_Series' + data.region.SeriesIndex + '_Point' + data.region.Region.PointIndex + '_Marker' + k,
                        'fill': 'white',
                        'opacity': 1,
                        'stroke': 'white',
                        'visibility': 'visible'
                    };
                    if (k == 1)
                        cxy += radius;
                    else
                        cxy += 2 * radius + 3;
                    options.r = Math.abs(radius);
                    if ((transposed && type == "bar") || (type == "column" && !transposed)) {
                        options.cx = cxy;
                        options.cy = inversed ? bounds.Y + bounds.Height - radius - 5 : bounds.Y + radius + 5;
                    }
                    if ((!transposed && type == "bar") || (type == "column" && transposed)) {
                        options.cx = inversed ? bounds.X + radius + 5 : bounds.X + bounds.Width - radius - 5;
                        options.cy = cxy;
                    }
                    if (this.model.enableCanvasRendering)
                        sf.EjCanvasRender.prototype.drawCircle(options, canvasGripper);
                    else
                        this.svgRenderer.drawCircle(options, this.gMarkerGroupEle);
                }
                this.svgRenderer.append(this.gMarkerGroupEle, this.gSeriesEle);
            }
        },
        chartMouseMove: function (evt) {

            var data = this.GetSeriesPoint(evt),
                svgObject = this.svgObject,
                model = this.model, zooming = model.zooming.enable,
                enableCanvas = model.enableCanvasRendering;
            model.event = evt;
            clearTimeout(this.removeTooltip); // to clear the set timeout used to remove the tooltip template
            if (this.doPan && evt.target.id.indexOf(this._id + '_scrollbar') > -1)
                this.doPan = false;
            var classList = evt.target.classList,
                chartOffset = { left: 0, top: 0 };
            if (this.multiSelectAreaType == 'cartesianaxes' && (!zooming) && (!enableCanvas))
                this.multiSelectMouseMove(evt);
            if (this.rotateActivate && this.oPreviousCoords) {
                var difY = (this.oPreviousCoords.Y - this.mousemoveY);
                var difX = (this.oPreviousCoords.X - this.mousemoveX);
                if (difX || difY) {
                    model.tilt -= difY;
                    model.rotation += difX;
                    // store the class name 
                    if (this.model.isSelected)
                        var selection = this.selectedStyle(this);
                    if (!this.isTouch(evt))
                        $(this.chart3D).empty();
                    $('#template_group_' + this._id).empty();
                    var size = { Width: $(svgObject).width(), Height: $(svgObject).height() };
                    this.graphics.view(svgObject, this, model.rotation, model.tilt, size, model.perspectiveAngle, model.depth);
                    this.svgRenderer.append(this.chart3D, svgObject);
                    // Apply the class
                    if (this.model.isSelected)
                        for (var i = 0; i < selection.length; i++) {
                            $('#' + selection[i].id).attr('class', selection[i].className);
                        }
                }
                this.oPreviousCoords.Y = this.mousemoveY;
                this.oPreviousCoords.X = this.mousemoveX;
            }

            var targetId = evt.target.id,
                svgObjectId = svgObject.id,
                isZoom = this.isZoomButtonHovered(evt.target),
                visibleSeries = model._visibleSeries,
                seriesLength = visibleSeries.length;
            $("[id*=" + "_Marker" + "]").remove();
            for (var i = seriesLength - 1; i >= 0; i--) {
                var chartSeries = visibleSeries[i];
                type = chartSeries.type.toLowerCase();
                if (chartSeries.dragSettings.enable && !model.enable3D) {
                    this._enableDragging(chartSeries, i, evt);
                    if (this.dragPoint)
                        break;
                    mouseMoveCords = this.calMousePosition(evt);
                    this.mousemoveX = mouseMoveCords.X;
                    this.mousemoveY = mouseMoveCords.Y;
                    var regionData = this.GetSeriesPoint(evt);
                    if (!chartSeries.marker.visible && type != "bubble" && type != "scatter" && type != "column" && type != "bar") {
                        var closestXyPoint = this.getClosesPointXY(serX, serY, chartSeries, this.mousemoveX, this.mousemoveY, evt);
                        if (closestXyPoint.point) {
                            chartSeries.seriesIndex = i;
                            this._dragPointMarker(chartSeries, this.mousemoveX, this.mousemoveY, evt, closestXyPoint);
                            this.closestXyPoint = closestXyPoint;
                            break;
                        }
                    }
                    if (regionData && regionData.region.SeriesIndex == i) {
                        this._dragPointGripper(regionData);
                        break;
                    }
                }
            }

            var chart = this;
            if (this.dragPoint) {
                var serX = [], serY = [], type;
                $(document).keyup(function (evt) {
                    if (evt.keyCode == 27) {
                        $(".tooltipDiv" + this._id).remove();
                        $("#" + svgObjectId + "_TrackToolTip").remove();
                        chart.dragPoint = false;
                        visibleSeries[chart.commonDragEventArgs.data.seriesIndex].pointCollection = null;
                        chart.chartMouseUp(evt);
                    }
                });
                var index = this.dragIndex.seriesIndex;
                chart._pointDragandDrop(visibleSeries[index], evt, chart);
            }

            this.calMousePosition(evt)
            $("#" + this._id + "_tooltip").remove();

            if (this.dragPoint || (!this.drag && !isZoom && ((!this.isTouch(evt) && !model.doubleTapped) || model.crosshairMoved))) {
                this.chartInteractiveBehavior(evt);
            }
            // Checked condition for series highlighting
            if ((!model.crosshair.visible || model.AreaType != "cartesianaxes")) {
                if (!enableCanvas || !data) {
                    // removed highlight style
                    $("[class*=" + "HighlightStyle" + "]").attr('class', '');
                    $("[class*=" + "HighlightLegendStyle" + "]").attr('class', '');
                    $("[class*=" + "HighlightLegendPathStyle" + "]").attr('class', '');
                    $("[class*=" + "HighlightPathStyle" + "]").attr('class', '');
                    $("[class*=" + "Highlightseries" + "]").attr('class', '');
                    $("[id*=" + this._id + "_Highlight_" + "]").remove();// removed canvas highlight           
                }
                this.highlightStart(evt, data);
            }
            if (!this.panning) {
                var id = "#" + svgObjectId;
                if (zooming && model.AreaType == "cartesianaxes" && !model.enable3D) {
                    if (this.drag && !this.dragPoint && !this.chartRightClick) {
                        this.disableTrackBall();
                        $('#' + svgObjectId + '_ZoomArea').remove();
                        var width, height, x, y;
						var trans = this.getScaleValues(this);
                        var currentX = this.mousemoveX / trans.x,
                            currentY = this.mousemoveY / trans.y,
                            areaBounds = model.m_AreaBounds;
                        if ((this.mousemoveX / trans.x) < areaBounds.X) {
                            currentX = areaBounds.X;
                        } else if ((this.mousemoveX / trans.x) > (areaBounds.X + areaBounds.Width)) {
                            currentX = areaBounds.X + areaBounds.Width;
                        }
                        if ((this.mousemoveY / trans.y) < areaBounds.Y) {
                            currentY = areaBounds.Y;
                        } else if ((this.mousemoveY / trans.y) > (areaBounds.Y + areaBounds.Height)) {
                            currentY = areaBounds.Y + areaBounds.Height;
                        }
                        else {
                            currentY = this.mousemoveY / trans.y;
                        }
                        var zoomingType = model.zooming.type.toLowerCase();
                        if (zoomingType == "x") {
                            width = Math.abs(currentX - (this.mouseDownX / trans.x));
                            height = areaBounds.Height;
                            x = currentX > (this.mouseDownX / trans.x) ? this.mouseDownX / trans.x : currentX;
                            y = areaBounds.Y;
                        } else if (zoomingType == "y") {
                            width = areaBounds.Width;
                            height = Math.abs(currentY - (this.mouseDownY / trans.y));
                            x = areaBounds.X;
                            y = currentY > (this.mouseDownY / trans.y) ? this.mouseDownY / trans.y : currentY;

                        } else {
                            width = Math.abs(currentX - (this.mouseDownX / trans.x));
                            height = Math.abs(currentY - (this.mouseDownY / trans.y));
                            x = currentX > (this.mouseDownX / trans.x) ? this.mouseDownX / trans.x : currentX;
                            y = currentY > (this.mouseDownY / trans.y) ? this.mouseDownY / trans.y : currentY;

                        }
                        $(svgObject).css({
                            '-moz-user-select': '-moz-none',
                            '-khtml-user-select': 'none',
                            '-webkit-user-select': 'none',
                            '-ms-user-select': 'none',
                            'user-select': 'none'
                        });

                        this.zooming = true;

                        var rectOptions = {
                            'id': svgObjectId + '_ZoomArea',
                            'x': x + chartOffset.left,
                            'y': y + chartOffset.top,
                            'width': width,
                            'height': height,
                            'fill': 'rgba(69,114,167,0.25)',
                            'stroke-width': 1,
                            'stroke': 'rgba(69,114,167,0.25)',
                            'clip-path': 'url(#' + svgObjectId + '_ChartAreaClipRect)'
                        };
                        if (enableCanvas)
                            this.svgRenderer.drawZoomRect(rectOptions, this);
                        else
                            this.svgRenderer.drawRect(rectOptions, svgObject);
                    }

                }
            }
            var deferredZoom = model.zooming.enableDeferredZoom;
            // Panning
            if (this.panning && this.doPan && model.AreaType == "cartesianaxes" && !this.dragPoint) {
                this.currentPageX = evt.pageX;
                this.currentPageY = evt.pageY;
				$("#secondCanvas").remove();
                $("#" + this._id + "_canvas").css({ "cursor": "pointer" });
                if (!sf.isTouchDevice() && !deferredZoom) {
                    var oDelta;
                    oDelta = {
                        'x': this.oPreviousCoords.x - evt.pageX,
                        'y': this.oPreviousCoords.y - evt.pageY
                    };

                    this.oPreviousCoords = {
                        'x': evt.pageX,
                        'y': evt.pageY
                    };
                    $.each(model._axes, function (index, axis) {
                        var currentScale = Math.max(1 / sf.EjSvgRender.utils._minMax(axis.zoomFactor, 0, 1), 1);
                        chart.translate(axis, (oDelta.x), (oDelta.y), currentScale);
                    });
                    this._updateScroll();
                    this.redraw(true, null, evt.target, this.isTouch(evt));
                    this._cursorToPointer();
                    this._enableZoomingButtons();
                }
                // Translate the series for other devices
                else if (sf.isTouchDevice() || deferredZoom) {
                    for (var k = 0; k < visibleSeries.length; k++) {
                        var series = model.series[k],
                            transform = sf.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, model.requireInvertedAxes),
                            transX = (evt.pageX - this.oPreviousCoords.x) + transform.x,
                            transY = (evt.pageY - this.oPreviousCoords.y) + transform.y,
                            translate = 'translate(' + transX + ',' + transY + ')';

                        $("#" + svgObjectId + "_SeriesGroup_" + k).attr("transform", translate);
                        $("#" + svgObjectId + "_symbolGroup_" + k).attr("transform", translate);
                        $("#" + svgObjectId + "_TextGroup_" + k).attr("transform", translate);

                    }
                    for (var index = 0; index < model.indicators.length && model.indicators[index]._points.length > 0; index++) {
                        var indicator = model.indicators[index];
                        transform = sf.EjSvgRender.utils._getTransform(indicator.xAxis, indicator.yAxis, model.requireInvertedAxes);
                        transX = (evt.pageX - this.oPreviousCoords.x) + transform.x;
                        transY = (evt.pageY - this.oPreviousCoords.y) + transform.y;
                        translate = 'translate(' + transX + ',' + transY + ')';
                        $("#" + svgObjectId + "_indicatorGroup_" + index).attr("transform", translate);
                    }
                }
            }

            //Declaration
            var targetid = evt.target.id;
            if (targetid == "" && !sf.util.isNullOrUndefined(evt.target.parentNode))
                targetid = evt.target.parentNode.id.indexOf("_XLabel_") >= 0 || evt.target.parentNode.id.indexOf("_YLabel_") >= 0 ? evt.target.parentNode.id : targetid;
            var id = this._id;
            var parentId = sf.util.isNullOrUndefined(evt.target.parentNode) ? "" : evt.target.parentNode.id;

            //condition to find the buttons and display tooltip on hover
            if (zooming) {
                if (parentId == id + '_svg_ResetZoom')
                    createBtnTooltip(this._localizedLabels.reset);
                else if (parentId == id + '_svg_PanBtn')
                    createBtnTooltip(this._localizedLabels.pan);
                else if (parentId == id + '_svg_ZoomBtn')
                    createBtnTooltip(this._localizedLabels.zoom);
                else if (parentId == id + '_svg_ZoomInBtn')
                    createBtnTooltip(this._localizedLabels.zoomIn);
                else if (parentId == id + '_svg_ZoomOutBtn')
                    createBtnTooltip(this._localizedLabels.zoomOut);
            }
            // method to create tooltip for zooming and panning buttons
            function createBtnTooltip(text) {
                var id = chart._id;
                if ($("#" + id + "_tooltip").length <= 0) {
                    var tooltipdiv = $("<div></div>").attr({ 'id': id + "_tooltip", "class": "zoom" + id });
                    $(tooltipdiv).html("&nbsp" + text + "&nbsp");
                    $(document.body).append(tooltipdiv);
                    // adding css prop to the div
                    $(tooltipdiv).css({
                        "left": evt.pageX + 10,
                        "top": evt.pageY + 10,
                        "display": "block",
                        "position": "absolute",
                        "z-index": "13000",
                        "cursor": "default",
                        "font-family": "Segoe UI",
                        "color": "#707070",
                        "font-size": "12px",
                        "background-color": "#FFFFFF",
                        "border": "1px solid #707070"
                    });
                } else {
                    $("#" + id + "_tooltip").css({
                        "left": evt.pageX + 10,
                        "top": evt.pageY + 10
                    });
                }

            }
            // axisLabelMouseMove event
            var axisData = this.getAxisLabelData(evt);
            if (axisData) {
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = axisData;
                this._trigger("axisLabelMouseMove", commonEventArgs);
            }

            if (!this.isTouch(evt)) {
                this.axisTooltip(evt, targetid);
                if (model.title.enableTrim)
                    this.showTitleTooltip(evt, targetid);
                for (var i = 0, seriesLength = model.series.length; i < seriesLength; i++) {
                    var series = model.series[i], dataLabel = series.marker && series.marker.dataLabel;
                    if (series._enableSmartLabels && !this.model.enable3D && !dataLabel.enableWrap) {
                        var template = dataLabel.template;
                        var font = dataLabel.font;
                        if (model.AreaType == "none" && sf.util.isNullOrUndefined(template)) {
                            this.datalabelTooltip(evt, i, font);
                        }
                    }
                }
            }



            if ($(svgObject).find(id + '_ResetZoom,' + id + '_PanBtn,' + id + '_ZoomBtn').length > 0) {
                $(svgObject).find(id + '_ResetZoom,' + id + '_PanBtn,' + id + '_ZoomBtn').appendTo(svgObject);
            }

            var legenddata = this.getLegendData(evt);
            if (legenddata) {
                var isLegendRTL = this.model.legend.isReversed;
                var font = this.model.legend.font;
                var commonLegendMoveEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonLegendMoveEventArgs.data = legenddata;
                if (legenddata.series.highlightSettings.enable) {
                    if (enableCanvas) {
                        var series = $.extend({}, legenddata.series);
                        series.seriesIndex = legenddata.legendItem.LegendItem.SeriesIndex;
                        series.pointIndex = legenddata.legendItem.LegendItem.PointIndex;
                        var index = this.model.AreaType == 'none' ? series.pointIndex : series.seriesIndex;
                        if ($('#' + chart._id + '_Selection_Legend' + index + '_canvas').length == 0) {
                            //remove canvas legend highlight 
                            $("[id*=" + this._id + "_Highlight_" + "]").remove();
                            this.canvasHighlight(chart, evt, series, legenddata);
                        }
                    }
                    else
                        this.highlight(chart, evt, legenddata.series, legenddata);
                }
                this._trigger("legendItemMouseMove", commonLegendMoveEventArgs);
                if (enableCanvas) {
                    var mouseMoveCords = this.calMousePosition(evt),
                        mousemoveX = mouseMoveCords.X,
                        mousemoveY = mouseMoveCords.Y,
                        legendBounds = model.LegendBounds;
                    $(this.legendContainer).children().css({ "cursor": "pointer" });
                    if ((mousemoveX >= legendBounds.X) && (mousemoveX <= legendBounds.X + model.LegendViewerBounds.Width)) {
                        if ((mousemoveY <= legendBounds.Y + (model.LegendViewerBounds.Height)) && (mousemoveY >= legendBounds.Y)) {
                            this._textTooltip(evt, model.legendTextRegion, isLegendRTL, font);
                        }
                    }
                }
                else
                    this._textTooltip(evt, model.legendTextRegion, isLegendRTL, font);
            }
            else if (enableCanvas)
                $(this.legendContainer).children().css('cursor', 'default');
            if (enableCanvas) {

                //condition to find the buttons and display tooltip on hover for Canvas
                if (targetid.indexOf("_ResetZoom") != -1 || parentId.indexOf("_ResetZoom") != -1)
                    createBtnTooltip(this._localizedLabels.reset);
                else if (targetid.indexOf("_PanBtn") != -1 || parentId.indexOf("_PanBtn") != -1)
                    createBtnTooltip(this._localizedLabels.pan);
                else if (targetid.indexOf("_ZoomBtn") != -1 || parentId.indexOf("_ZoomBtn") != -1)
                    createBtnTooltip(this._localizedLabels.zoom);
                else if (targetid.indexOf("_ZoomInBtn") != -1 || parentId.indexOf("_ZoomInBtn") != -1)
                    createBtnTooltip(this._localizedLabels.zoomIn);
                else if (targetid.indexOf("_ZoomOutBtn") != -1 || parentId.indexOf("_ZoomOutBtn") != -1)
                    createBtnTooltip(this._localizedLabels.zoomOut);
                if (!this.isTouch(evt)) {
                    this._textTooltip(evt, model.xAxisLabelRegions);
                    this._textTooltip(evt, model.yAxisLabelRegions);
                }
            }

            var proxy = this;
            if (model.xAxisTitleRegion) {
                var currentX = this.mousemoveX,
                    currentY = this.mousemoveY;
                var isTitleRTL = this.model.primaryXAxis.title.isReversed,
                    titleFont = this.model.primaryXAxis.font;
                $.each(model.xAxisTitleRegion, function (index, regionItem) {
                    if ((currentX >= regionItem.Bounds.X) && (currentX <= regionItem.Bounds.X + regionItem.Bounds.Width)) {
                        if ((currentY >= regionItem.Bounds.Y - (regionItem.Bounds.Height)) && (currentY <= regionItem.Bounds.Y)) {
                            if (regionItem.trimText != regionItem.labelText) {
                                proxy.showAxisTooltip(evt.pageX, evt.pageY, regionItem.labelText, regionItem.trimText, isTitleRTL, titleFont);
                            }
                        }
                    }
                });
            }
            if (model.yAxisTitleRegion) {
                var currentX = this.mousemoveX,
                    currentY = this.mousemoveY;
                var isTitleRTL = this.model.primaryXAxis.title.isReversed,
                   titleFont = this.model.primaryXAxis.font;
                $.each(model.yAxisTitleRegion, function (index, regionItem) {
                    if ((currentX >= regionItem.Bounds.X) && (currentX <= regionItem.Bounds.X + regionItem.Bounds.Width)) {
                        if ((currentY >= regionItem.Bounds.Y - (regionItem.Bounds.Height)) && (currentY <= regionItem.Bounds.Y)) {
                            if (regionItem.trimText != regionItem.labelText) {
                                proxy.showAxisTooltip(evt.pageX, evt.pageY, regionItem.labelText, regionItem.trimText, isTitleRTL, titleFont);
                            }
                        }
                    }
                });
            }
            if (model.axisMultiLevelLabelRegions) {
                var currentX = this.mousemoveX,
                    currentY = this.mousemoveY;
                $.each(model.axisMultiLevelLabelRegions, function (index, regionItem) {
                    if ((currentX >= regionItem.Bounds.X) && (currentX <= regionItem.Bounds.X + regionItem.Bounds.Width)) {
                        if ((currentY >= regionItem.Bounds.Y - (regionItem.Bounds.Height)) && (currentY <= regionItem.Bounds.Y)) {
                            if (regionItem.trimText != regionItem.labelText) {
                                proxy.showAxisTooltip(evt.pageX, evt.pageY, regionItem.labelText);
                            }
                        }
                    }
                });
            }

            //chartMouseMove event
            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY }, size: { height: model.svgHeight, width: model.svgWidth }, id: evt.target.id, pageX: evt.pageX, pageY: evt.pageY };
            this._trigger("chartMouseMove", commonEventArgs);
        },

        axisTooltip: function (evt, targetid) {
            var svgId = this.svgObject.id,
                hAxes = this.model.hAxes,
                vAxes = this.model.vAxes;

            //axis label tooltip for 3d 
            if (targetid.indexOf("svghorizontal") > -1) {
                var axis = hAxes[0];
                // Loop to find the axis
                var labelIndex = ((targetid.replace(this._id, '')).replace('_svghorizontal', ''));
                var ele = axis.visibleLabels[parseInt(labelIndex)];
                ele.Text = ele.Text.toString();
                if (ele.Text.indexOf('...') > -1) {
                    var str = ele.Text == ele.originalText ? "" : ele.originalText;
                    this.showAxisTooltip(evt.pageX, evt.pageY, str);
                }

            }

            if (targetid.indexOf("_YLabel_") >= 0) {
                var axis;
                // Loop to find the axis
                for (var j = 0; j < vAxes.length; j++) {
                    if (targetid.indexOf(svgId + '_' + vAxes[j].name + '_YLabel_') >= 0) {
                        axis = vAxes[j];
                        break;
                    }
                }
                if (axis && axis.enableTrim) {
                    // Loop to find the labels in the axis
                    visibleLabelsLength = axis.visibleLabels.length;
                    for (var i = 0; i < visibleLabelsLength && this.model.AreaType == 'cartesianaxes'; i++) {
                        if (targetid == svgId + '_' + vAxes[j].name + '_YLabel_' + i) {
                            var ele = axis.visibleLabels[i];
                            var str = ele.Text == ele.displayText ? "" : ((axis.labelFormat) ? axis.labelFormat.replace("{value}", ele.Text) : ele.Text);
                            if (str == "") break;
                            if (axis.labelPosition.toLowerCase() == 'inside') {
                                this._hideTooltip();
                                this._removeTrackBall();
                            }
                            this.showAxisTooltip(evt.pageX, evt.pageY, str, ele.displayText);
                        }
                    }
                }
            }

            if (targetid.indexOf("_XLabel_") >= 0) {
                var axis, visibleLabelsLength;
                // Loop to find the axis
                for (var j = 0; j < hAxes.length; j++) {
                    if (targetid.indexOf(svgId + '_' + hAxes[j].name + '_XLabel_') >= 0) {
                        axis = hAxes[j];
                        break;
                    }
                }
                if (axis && (axis.enableTrim || axis.labelIntersectAction.toLowerCase() == "trim" || axis.labelIntersectAction.toLowerCase() == "wrapbyword")) {
                    // Loop to find the labels in the axis
                    visibleLabelsLength = axis.visibleLabels.length;
                    var xLabelRTL = axis.isInversed;
                    var font = axis.font;
                    for (var i = 0; i < visibleLabelsLength && this.model.AreaType == 'cartesianaxes'; i++) {
                        if (targetid == svgId + '_' + hAxes[j].name + '_XLabel_' + i) {
                            var ele = axis.visibleLabels[i];
                            var str = ele.Text == ele.displayText ? "" : ele.Text;
                            if (str == "") break;
                            if (axis.labelPosition.toLowerCase() == 'inside') {
                                this._hideTooltip();
                                this._removeTrackBall();
                            }
                            this.showAxisTooltip(evt.pageX, evt.pageY, str, ele.displayText, xLabelRTL, font);
                        }
                    }
                }
            }
        },

        showTitleTooltip: function (evt, targetid) {
            var measureTitle = sf.EjSvgRender.utils._measureText(this.model.title.text, $(this.svgObject).width() - this.model.margin.left - this.model.margin.right, this.model.title.font), model = this.model,
                titleLocation = model._titleLocation,
                subTitleLocation = model._subTitleLocation,
                titleEnableTrim = model.title.enableTrim,
                elementSpacing = model.elementSpacing,
                currentX = this.mousemoveX, currentY = this.mousemoveY,
                titleTextOverflow = model.title.textOverflow.toLowerCase(),
                subTitleEnableTrim = model.title.subTitle.enableTrim,
                subTitleTextOverflow = model.title.subTitle.textOverflow.toLowerCase(),
                titleText = model.title.text, subTitleText = model.title.subTitle.text,
                titleRTL = model.title.isReversed, trimmedText;

            if (titleEnableTrim && this.model.trimTooltip) {
                trimmedText = sf.EjSvgRender.utils._trimText(titleText, model.title.maximumWidth, model.title.font);
                if (targetid.indexOf("ChartTitleText") >= 0)
                    this.showAxisTooltip(evt.pageX, evt.pageY, titleText, trimmedText, titleRTL, model.title.font);
                else if (this.model.enableCanvasRendering && currentX >= titleLocation.X - elementSpacing && currentX <= titleLocation.X - elementSpacing + titleLocation.size.width &&
                    currentY >= (titleLocation.Y - (titleLocation._height)) && currentY <= titleLocation.Y + titleLocation.size.height)
                    this.showAxisTooltip(evt.pageX, evt.pageY, titleText, trimmedText, titleRTL, model.title.font);
            }

            if (subTitleEnableTrim && model.subTitleTooltip) {
                trimmedText = sf.EjSvgRender.utils._trimText(subTitleText, model.title.subTitle.maximumWidth,model.title.subTitle.font);
                if (targetid.indexOf("ChartSubTitleText") >= 0)
                    this.showAxisTooltip(evt.pageX, evt.pageY, subTitleText, trimmedText, titleRTL, model.title.subTitle.font);
                else if (model.enableCanvasRendering && currentX >= subTitleLocation.X && currentX <= subTitleLocation.X + subTitleLocation.size.width &&
                    currentY >= (subTitleLocation.Y) && currentY <= (subTitleLocation.Y) + subTitleLocation.size.height)
                    this.showAxisTooltip(evt.pageX, evt.pageY, subTitleText, trimmedText, titleRTL, model.title.subTitle.font);
            }
        },

        _updateScroll: function () {

            var scrollObj = this.model.scrollObj,
                scrollLength = scrollObj ? scrollObj.length : 0,
                axes = this.model._axes,
                scroll = this.scrollbarContainer, obj;
            for (var i = 0; i < scrollLength; i++) {
                if (scrollObj[i]) {
                    obj = scrollObj[i];
                    if (obj.zoomPosition != axes[i].zoomPosition || obj.zoomFactor != axes[i].zoomFactor) {
                        obj.zoomPosition = axes[i].zoomPosition;
                        obj.zoomFactor = axes[i].zoomFactor;
                        scroll._initializeScrollbarVariables(obj);
                        scroll._scrollbarUpdate.call(this, obj);
                        scroll._setScrollPosition.call(this, obj.startX, obj.startX + obj.rectWidth, obj);
                    }
                }
            }
        },

        _hideTooltip: function () {
            $("#" + this.svgObject.id).find("#" + this.svgObject.id + "_TrackToolTip").attr('visibility', 'hidden');
            $("#" + this.svgObject.id + "_TrackToolTip").attr('visibility', 'hidden').hide();
            $('.tooltipDiv' + this._id).css("display", "none");
        },
        _removeHighlight: function () {
            $("[id*=" + "HighlightSegment" + "]").remove();
            $("[id*=" + "HighlightPath" + "]").remove();
            $("[id*=" + "HighlightLegendSegment" + "]").remove();
            $("[id*=" + "HighlightLegendPath" + "]").remove();
            $("[id*=" + "HighlightDef" + "]").remove();
            $("[id*=" + "Highlightseries" + "]").remove();
            $("[id*=" + this._id + "_Highlight_" + "]").remove();
            if (!this.model.enableCanvasRendering && !this.vmlRendering) {
                var highlightedElement = this.svgObject.querySelector("[class^='Highlight']");
                if (highlightedElement !== null && highlightedElement.length == null)
                    highlightedElement.removeAttribute("class");
                else
                    for (var j = highlightedElement && highlightedElement.length; j--;)
                        highlightedElement.removeAttribute("class");
            }
        },
        _removeSelection: function () {
            $("[id*=" + this._id + '_SelectionCluster_Legend' + "]").remove();
            $("[id*=" + this._id + '_Selection_series' + "]").remove();
            $("[id*=" + this._id + '_Selection_Cluster' + "]").remove();
            $("[id*=" + this._id + "SelectionSegment" + "]").remove();
            $("[id*=" + this._id + "SelectionPath" + "]").remove();
            $("[id*=" + this._id + "SelectionLegend" + "]").remove();
            $("[id*=" + this._id + "SelectionDef" + "]").remove();
            $("[id*=" + this._id + "Selectionseries" + "]").remove();
            $('[id*=' + this._id + '_Selection_' + ']').remove();
        },


        //tooltip for trimmed datalabel
        datalabelTooltip: function (evt, i, font) {
            var mouseMoveCords = this.calMousePosition(evt);
            this.mousemoveX = mouseMoveCords.X;
            this.mousemoveY = mouseMoveCords.Y;
            var containerId = this._id;
            var currentX = this.mousemoveX;
            var currentY = this.mousemoveY;
            var vmlRendering = this.vmlRendering;
            var space = this.model.elementSpacing;
            var chart = this;
            var minX, minY, maxX, maxY;
            var tooltipdiv, tooltipLength;
            var remaining, left;
            if (!sf.util.isNullOrUndefined(this.accDataLabelRegion[i])) {
                $.each(this.accDataLabelRegion[i], function (index, regionItem) {
                    minX = regionItem.bounds.minX;
                    minY = regionItem.bounds.minY;
                    maxX = regionItem.bounds.maxX;
                    maxY = regionItem.bounds.maxY;
                    if (vmlRendering) {
                        minX = regionItem.bounds.minX + (regionItem.bounds.width / 2);
                        maxX = regionItem.bounds.maxX + (regionItem.bounds.width / 2);
                        minY = regionItem.bounds.minY;
                        maxY = regionItem.bounds.maxY;
                    }
                    if (currentX >= minX && currentX <= maxX) {
                        if (currentY >= minY && currentY <= maxY) {
                            $("#" + containerId + "_tooltip").remove();
                            tooltipdiv = $("<div></div>").attr({ 'id': containerId + "_tooltip", 'class': 'ejTooltip' + containerId });
                            if (regionItem.trimmedText != regionItem.text) {
                                $("#" + chart.svgObject.id + "_TrackToolTip").hide();
                                $(tooltipdiv).html(regionItem.text);
                                $(document.body).append(tooltipdiv);
                                tooltipLength = sf.EjSvgRender.utils._measureText(regionItem.text, regionItem.text.length, regionItem.font).width;
                                $(tooltipdiv).css({
                                    "top": evt.pageY + space,
                                    "display": "block",
                                    "position": "absolute",
                                    "z-index": "13000",
                                    "cursor": "default",
                                    "color": "#000000",
                                    "font-size": font.size,
                                    "background-color": "#FFFFFF",
                                    "border": "1px solid #707070",
                                    "white-space": "nowrap",
                                    "padding": "5px"
                                });
                                if (regionItem.type == "pyramid" || regionItem.type == "funnel") {
                                    remaining = chart.model.m_AreaBounds.Width + chart.model.m_AreaBounds.X - evt.pageX;
                                    if (remaining > tooltipLength)
                                        $(tooltipdiv).css({ "left": evt.pageX + space });
                                    else {
                                        left = evt.pageX - tooltipLength + (2 * space);
                                        $(tooltipdiv).css({ "left": left });

                                    }
                                }
                                if (regionItem.type == "pie" || regionItem.type == "doughnut" || regionItem.type == "pieofpie") {
                                    if (minX > regionItem.bounds.centerX) {
                                        remaining = chart.svgWidth - chart.model.margin.left - chart.model.margin.right - currentX;
                                        if (remaining < tooltipLength) {
                                            left = evt.pageX - tooltipLength;
                                            $(tooltipdiv).css({ "left": left + space });
                                        }
                                        else
                                            $(tooltipdiv).css({ "left": evt.pageX + space });
                                    }
                                    else {
                                        remaining = currentX;
                                        if (remaining < tooltipLength) {
                                            $(tooltipdiv).css({ "left": evt.pageX + space });
                                        }
                                        else {
                                            left = evt.pageX - tooltipLength;
                                            $(tooltipdiv).css({ "left": left - (2 * space) });
                                        }
                                    }
                                }

                            }
                        }
                    }
                });
            }
        },
        // Tooltip in svg 
        showAxisTooltip: function (pageX, pageY, str, trimmedText, isRTL, font) {
            var id = this._id;
            var tooltipdiv = $("<div></div>").attr({ 'id': id + "_tooltip", 'class': 'ejTooltip' + id });
            $(tooltipdiv).html(str);
            if (isRTL && !sf.util.isNullOrUndefined(font)) {
                var labelTextWidth = sf.EjSvgRender.utils._measureText(str, null, font).width;
                var trimmedTextWidth = sf.EjSvgRender.utils._measureText(trimmedText, null, font).width;
                var textWidth = trimmedTextWidth <= labelTextWidth ? labelTextWidth : trimmedTextWidth;
            }
            $(document.body).append(tooltipdiv);
            // adding css prop to the div
            $(tooltipdiv).css({
                "left": isRTL ? pageX - textWidth : pageX + 10,
                "top": pageY + 10,
                "display": "block",
                "position": "absolute",
                "padding-left": "3px",
                "padding-right": "3px",
                "z-index": "13000",
                "cursor": "default",
                "font-family": "Segoe UI",
                "color": "#707070",
                "font-size": "12px",
                "background-color": "#FFFFFF",
                "border": "1px solid #707070"
            });
        },
        _textTooltip: function (evt, region, isRTL, font) {
            var chart = this,
                mouseMoveCords = this.calMousePosition(evt),
                isEjScroll = this.model.legend._ejScroller,
                scrollleft = 0, scrolltop = 0,
				vScrollerWidth = 18,
                mousemoveX = isRTL && ($("#legend_" + this._id).find('[class*="e-vscrollbar"]').length || $("#legend_" + this._id)[0].style.overflowY == "scroll")? mouseMoveCords.X - vScrollerWidth : mouseMoveCords.X,
                mousemoveY = mouseMoveCords.Y,
                currentX = mousemoveX,
                currentY = mousemoveY,
                containerId = this._id,
                chartModel = chart.model,
                legend = chartModel.legend,
                isScroll = legend.enableScrollbar,
                textOverflow = legend.textOverflow.toLowerCase(),
                displayText, tooltipdiv;
            scrolltop = isEjScroll ? $("#legend_" + this._id).ejScroller('instance').model.scrollTop : $("#legend_" + this._id).scrollTop();
            scrollleft = isEjScroll ? $("#legend_" + this._id).ejScroller('instance').model.scrollLeft : $("#legend_" + this._id).scrollLeft();
            if (isRTL && isEjScroll) {
                if (scrollleft == 0)
                    scrollleft = $("#legend_" + this._id).ejScroller('instance')._rtlScrollLeftValue;
                else if ($("#legend_" + this._id).ejScroller('instance').model.scrollLeft == $("#legend_" + this._id).ejScroller('instance')._rtlScrollLeftValue)
                    scrollleft = 0;
                else
                    scrollleft = $("#legend_" + this._id).ejScroller('instance')._rtlScrollLeftValue - $("#legend_" + this._id).ejScroller('instance').model.scrollLeft;

            }
            if (isScroll || isEjScroll) {
                currentX = mousemoveX + (scrollleft ? scrollleft : 0);
                currentY = mousemoveY + (scrolltop ? scrolltop : 0);
            }

            $.each(region, function (index, regionItem) {

                if ((currentX >= regionItem.bounds.x) && (currentX <= regionItem.bounds.x + regionItem.bounds.width)) {
                    if (((currentY >= regionItem.bounds.y) && (currentY <= regionItem.bounds.y + regionItem.bounds.height)) || ((currentY >= regionItem.bounds.y - (regionItem.bounds.height / 3)) && (currentY <= regionItem.bounds.y))) {

                        $("#" + containerId + "_tooltip").remove();
                        tooltipdiv = $("<div></div>").attr({ 'id': containerId + "_tooltip", 'class': 'ejTooltip' + containerId });
                        displayText = jQuery.type(regionItem.trimText) == "array" ? regionItem.trimText.join(" ") : regionItem.trimText;
                        if (displayText != regionItem.labelText) {
                            $(tooltipdiv).html(regionItem.labelText);
                            if (isRTL && !sf.util.isNullOrUndefined(font))
                                var labelTextWidth = sf.EjSvgRender.utils._measureText(regionItem.labelText, null, font).width;
                            $(document.body).append(tooltipdiv);
                            // adding css prop to the div
                            $(tooltipdiv).css({
                                "left": isRTL ? evt.pageX - labelTextWidth - 15 : evt.pageX + 10,
                                "top": evt.pageY + 10,
                                "display": "block",
                                "position": "absolute",
                                "padding-left": "3px",
                                "padding-right": "3px",
                                "z-index": "13000",
                                "cursor": "default",
                                "font-family": "Segoe UI",
                                "color": "#707070",
                                "font-size": "12px",
                                "background-color": "#FFFFFF",
                                "border": "1px solid #707070"
                            });
                        }
                    }
                }
            });
        },
        pieExplosion: function (data) {
            this.model.explode = true;
            var region = data;
            var id;
            var targetElement;
            var symbolName, pieSeriesIndex;
            var series = region.region.Series;
            var seriesIndex = region.region.SeriesIndex;
            var seriesType = new sf.seriesTypes[series.type.toLowerCase()]();
            var explodePoint = series.explodeIndex;
            var _labelPosition = series.labelPosition.toLowerCase();
            var currentExplodePoint = { SeriesIndex: region.pointData[0].SeriesIndex, PointIndex: region.pointData[0].Index };
            var pieActualIndex = this.model._isPieOfPie ? region.pointData[0].PointIndex : region.region.Series._visiblePoints[region.pointData[0].Index].actualIndex;
            if (explodePoint != pieActualIndex && !region.region.Series.explodeAll) {
                series.explodeIndex = pieActualIndex;
                pieSeriesIndex = region.pointData[0].PieSeriesIndex;
                if (!sf.util.isNullOrUndefined(this.model.explodeValue) && this.model.explodeValue != currentExplodePoint) {
                    if (this.model.explodeValue.SeriesIndex != region.region.SeriesIndex)
                        series = this.model._visibleSeries[this.model.explodeValue.SeriesIndex];
                    var visiblePoint = this.model._isPieOfPie ? this._getPieOfPiePoint(this.model.explodeValue.PointIndex, series) : series._visiblePoints[this.model.explodeValue.Index];
                    var result = seriesType._calculateArcData(this, this.model.explodeValue.PointIndex, visiblePoint, series, this.model.explodeValue.SeriesIndex, this.model.explodeValue.PieSeriesIndex);
                    id = this.svgObject.id + '_SeriesGroup' + '_' + this.model.explodeValue.SeriesIndex;

                    targetElement = (this.model.explodeValue.PieSeriesIndex == 1) ? $(this.gSeriesEle).children('#' + id)[1] : $(this.gSeriesEle).children('#' + id)[0];
                    var elements = $(targetElement).children();
                    for (var i = 0; i < elements.length; i++) {
                        var element = elements[i];
                        var index = this.svgRenderer._getAttrVal($(element)[0], "data-pointIndex");
                        if (parseInt(index) == this.model.explodeValue.PointIndex) {
                            this.svgRenderer._setAttr($(element), { 'd': result.Direction });
                            break;
                        }
                    }

                    seriesType.drawDataLabelAcc(this, series, this.model.explodeValue.Index, visiblePoint, this.model.explodeValue.SeriesIndex, this.model.explodeValue.PieSeriesIndex)

                }

                var seriesPoint = this.model._isPieOfPie ? this._getPieOfPiePoint(data.region.Region.PointIndex, series) : series._visiblePoints[region.pointData[0].Index];

                result = seriesType._calculateArcData(this, region.pointData[0].PointIndex, seriesPoint, region.region.Series, seriesIndex, pieSeriesIndex);

                id = this.svgObject.id + '_SeriesGroup' + '_' + region.region.SeriesIndex;
                targetElement = pieSeriesIndex == 1 ? $(this.gSeriesEle).children('#' + id)[1] : $(this.gSeriesEle).children('#' + id)[0];


                var elements = $(targetElement).children();

                for (var i = 0; i < elements.length; i++) {
                    var element = elements[i];
                    var index = this.svgRenderer._getAttrVal($(element)[0], "data-pointIndex");
                    if (parseInt(index) == region.pointData[0].PointIndex) {
                        this.svgRenderer._setAttr($(element), { 'd': result.Direction });
                        break;
                    }
                }
                if (this.model.enableCanvasRendering) {
                    var chartRect = document.getElementById(this.svgObject.id).getClientRects()[0];
                    this.svgRenderer.ctx.clearRect(chartRect.left, chartRect.top, chartRect.width, chartRect.height);
                    $("#" + this._id).ejChart("redraw");
                }


                seriesType.drawDataLabelAcc(this, series, region.pointData[0].Index, seriesPoint, seriesIndex, pieSeriesIndex)


                this.model.explodeValue = { SeriesIndex: region.pointData[0].SeriesIndex, PointIndex: region.pointData[0].PointIndex, Index: region.pointData[0].Index, PieSeriesIndex: region.pointData[0].PieSeriesIndex };
            }
            region.region.Series.explodeIndex = explodePoint;
        },
        displayGroupingTemplate: function (x, y, location, seriesPoint, series, serIndex, ptIndex, chartLoc, seriescolor) {
            var point = [], color = [], childNode = [], seriesCollection = [], seriesLength, padding, isTrans, templateLocX, templateLocY, xLoc, yLoc, div, length, tooltipdiv;
            color = $.extend(true, {}, seriescolor);
            seriesCollection = $.extend(true, {}, series);
            seriesLength = Object.keys(seriesCollection).length;// calculate object length.
            point = $.extend(true, {}, seriesPoint);
            padding = 5;
            for (var i = 0; i < seriesLength; i++) {
                isTrans = seriesCollection[i].series.isTransposed;
                point[i].point.x = point[i].point.x;
                if (seriesCollection[i].series.xAxis._valueType.toLowerCase() == "datetime")
                    point[i].point.x = (sf.format(new Date(point[i].point.x), (sf.EjSvgRender.utils._dateTimeLabelFormat(seriesCollection[i].series.xAxis.intervalType, seriesCollection[i].series.xAxis))));
                if (seriesCollection[i].series.xAxis._valueType.toLowerCase() == "category") point[i].point.x = sf.EjSvgRender.utils._getLabelContent(ptIndex, seriesCollection[i].series.xAxis);
                x = sf.util.isNullOrUndefined(x) ? 0 : x;
                y = sf.util.isNullOrUndefined(y) ? 0 : y;
                templateLocX = this.model.m_AreaBounds.X;
                templateLocY = this.model.m_AreaBounds.Y;
                xLoc = ((isTrans) || this.model.requireInvertedAxes) ? seriesCollection[i].series.yAxis.y : location.X + x + templateLocX + this.model.crosshair.marker.size.width + padding;
                yLoc = ((isTrans) || this.model.requireInvertedAxes) ? seriesCollection[i].series.xAxis.x + location.Y : this.model.m_AreaBounds.Height / 2 + templateLocY;
                div = $("#" + this.model.crosshair.trackballTooltipSettings.tooltipTemplate).clone();
                $(div).css("background-color", color[i].seriesColor);
                $(div).css("display", "block");
                point[i].point.count = 1;
                series.count = length;
                var data = { series: series, point: point[i].point };
                childNode.push($(div).html($(div).html().parseTemplate(data)));
            }
            if ($("#" + this.svgObject.id + "_TrackGroupToolTipTemplate").length == 0) {
                tooltipdiv = $("<div id =" + this.svgObject.id + 'TrackGroupToolTipTemplate' + " style='pointer-events:none; position: absolute; z-index: 13000; display: block;'></div>");
                $(tooltipdiv).appendTo(this.chartContainer);
            }
            $(tooltipdiv).append(childNode);
            var border = this.model.crosshair.trackballTooltipSettings.border;
            $(tooltipdiv).css("border", border.width + "px solid " + border.color);
            var templateHeight = parseFloat($(tooltipdiv).css('height'));
            var templateWidth = parseFloat($(tooltipdiv).css('width'));

            yLoc = ((isTrans) || this.model.requireInvertedAxes) ? yLoc : yLoc - templateHeight / 2;

            if ((seriesLength == 1) && !isTrans) {
                yLoc = location.Y + templateLocY + templateHeight / 2;
            }
            if (seriesLength == 1 && ((isTrans) || this.model.requireInvertedAxes)) {
                xLoc = location.X + x + templateLocX + this.model.crosshair.marker.size.width + padding - templateWidth / 2;
                yLoc = location.Y + templateLocY - templateHeight - this.model.crosshair.marker.size.height - padding;
            }
            if ((yLoc + (templateHeight)) < this.model.m_AreaBounds.Y) {
                yLoc = this.model.m_AreaBounds.Y;
            } else if ((yLoc + (templateHeight / 2)) > (this.model.m_AreaBounds.Height)) {
                yLoc -= templateHeight;
            }
            if ((xLoc + templateWidth > templateLocX + this.model.m_AreaBounds.Width) && (!isTrans)) {
                xLoc = location.X + x + templateLocX - this.model.crosshair.marker.size.width - padding - templateWidth;
            }

            $(tooltipdiv).css("left", xLoc);
            $(tooltipdiv).css("top", yLoc);

        },
        displayTemplateTooltip: function (x, y, location, seriesPoint, series, serIndex, ptIndex, chartLoc) {
            var point = $.extend(true, {}, seriesPoint);
            var padding = 5;
            point.x = point.x;
            if (series.xAxis._valueType.toLowerCase() == "datetime")
                point.x = (sf.format(new Date(point.x), (sf.EjSvgRender.utils._dateTimeLabelFormat(series.xAxis.intervalType, series.xAxis))));
            if (series.xAxis._valueType.toLowerCase() == "category") point.x = sf.EjSvgRender.utils._getLabelContent(ptIndex, series.xAxis);
            x = sf.util.isNullOrUndefined(x) ? 0 : x;
            y = sf.util.isNullOrUndefined(y) ? 0 : y;
            var templateLocX = this.model.m_AreaBounds.X;
            var axes = this.model._axes, pointXAxis = series._xAxisName, pointYAxis = series._yAxisName;
            var axisY, axisX;
            for (var j = 0, len = axes.length; j < len; j++) {
                if (pointXAxis == axes[j].name) {
                    if (!series._isTransposed) {
                        axisX = axes[j].Location.X1;
                    } else {
                        axisY = axes[j].Location.Y2;
                    }
                } else if (pointYAxis == axes[j].name) {
                    if (!series._isTransposed) {
                        axisY = axes[j].Location.Y2;
                    } else {
                        axisX = axes[j].Location.X1;
                    }
                }
            }
            var xLoc = location.X + this.model.crosshair.marker.size.width + axisX;
            var yLoc = location.Y + y + axisY;
            var tooltipdiv;
            if ($("#" + this.svgObject.id + "_TrackToolTipTemplate_" + serIndex).length == 0) {
                tooltipdiv = $("<div id=" + this.svgObject.id + '_TrackToolTipTemplate_' + serIndex + " style='pointer-events:none;position: absolute; z-index: 13000; display: block;'></div>");
                $(document.body).append(tooltipdiv);
            }
            if (this.model.crosshair.trackballTooltipSettings.tooltipTemplate != null) {
                var cloneNode = document.getElementById(this.model.crosshair.trackballTooltipSettings.tooltipTemplate).cloneNode(true);
                $(cloneNode).css("display", "block").appendTo(tooltipdiv);
                series.count = 1;
                point.count = 1;
                var seriesColor = this.getSeriesColor(point, serIndex, series);
                $(tooltipdiv).css("background-color", jQuery.type(seriesColor) == "array" ? seriesColor[0].color : seriesColor);
                var data = { series: series, point: point };
                $(tooltipdiv).html($(tooltipdiv).html().parseTemplate(data));
            }
            yLoc -= parseFloat($(tooltipdiv).css('height')) / 2;
            var templateHeight = parseFloat($(tooltipdiv).css('height'));
            var templateWidth = parseFloat($(tooltipdiv).css('width'));
            if ((series.isTransposed) || (this.model.requireInvertedAxes)) {
                yLoc = (location.Y + this.model.m_AreaBounds.Y) - templateHeight - padding - this.model.crosshair.marker.size.height;
                xLoc = location.X + templateLocX - templateWidth / 2;
            }
            if ((yLoc + templateHeight < this.model.m_AreaBounds.Y) && ((series.isTransposed) || this.model.requireInvertedAxes)) {
                yLoc += templateHeight + this.model.crosshair.marker.size.height + padding + chartLoc.top;
            }
            if (xLoc + templateWidth > templateLocX + this.model.m_AreaBounds.Width) {
                xLoc -= (templateWidth + (padding * 2) + this.model.crosshair.marker.size.width);
            }
            $(tooltipdiv).css("left", xLoc);
            $(tooltipdiv).css("top", yLoc);
        },
        displayAxisTooltip: function (location, text, axis, index, mouseLoc, tracker, transValue) {

            if (axis._valueType.toLowerCase() == "double") {
                var customFormat = (!(axis.labelFormat)) ? null : axis.labelFormat.match('{value}');
                text = (!(axis.labelFormat)) ? text : (customFormat != null) ? (axis.labelFormat == "${value}") ? axis.labelFormat.replace('{value}', '$' + Number(text)) : axis.labelFormat.replace('{value}', Number(text)) : (sf.format(Number(text), axis.labelFormat, this.model.locale));
            }
            var maxTickSize = 0,
                orientation = axis.orientation.toLowerCase(), position,
                hPadding = 0,
                vPadding = 0,
                opposedPosition = axis._opposed,
                enableCanvas = this.model.enableCanvasRendering,
				isEdgeInside = axis.crosshairLabel.isInside,
                maxLocation = opposedPosition ? ((maxTickSize + 10) + (axis.x + axis.width)) : (axis.x + axis.width);
            for (var i = 0; i < this.model._axes.length; i++) {
                if (this.model._axes[i].majorTickLines.size > maxTickSize) {
                    maxTickSize = this.model._axes[i].majorTickLines.size;
                }
            }

            if (location.X >= 0 && location.X <= maxLocation) {
                var x = (location.X);
                var y = location.Y;
                var padding = 5;
                var commonTrackTextArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonTrackTextArgs.data = { axisIndex: index, chartAxis: axis, currentTrackText: text, location: mouseLoc };
                this._trigger("trackAxisToolTip", commonTrackTextArgs);

                var trackAxisText = commonTrackTextArgs.data.currentTrackText;

                var textOffset = sf.EjSvgRender.utils._measureText(trackAxisText, null, axis.crosshairLabel.font);
                if (orientation == 'horizontal') {
                    x = x - textOffset.width / 2;
                    if (axis.labelPosition == 'inside' || (opposedPosition ? mouseLoc.y < axis.y : mouseLoc.y > (axis.y * transValue.y))) {
                        if (opposedPosition == false) {
                            y = axis.y - textOffset.height + maxTickSize - (axis._isScroll ? this.model.scrollerSize : 0);
                            position = "top";
                        }
                        if (opposedPosition == true) {
                            y = axis.y + textOffset.height - maxTickSize;
                            position = "bottom";
                        }
                    }
                    else {
                        if (opposedPosition == true) {
                            y = axis.y - textOffset.height / 2 - padding - maxTickSize;
                            position = "bottom";
                        }
                        if (opposedPosition == false) {
                            y = axis.y + textOffset.height - padding + maxTickSize;
                            position = "top";
                        }
                    }
                    hPadding = padding;
                    y = y + (axis._isScroll ? (axis.opposedPosition ? -this.model.scrollerSize : this.model.scrollerSize) : 0);
					if (!(opposedPosition) && isEdgeInside){
						if((x + textOffset.width) > (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X))
							x = ((this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) - textOffset.width) + padding - this.model.elementSpacing;
						else if(x < axis.x)
							x = axis.x + padding;
					}
				}
                if (orientation == 'vertical') {
                    y = location.Y + textOffset.height / 4;
                    if (axis.labelPosition == 'inside' || (!opposedPosition && mouseLoc.x < (axis.x * transValue.x))) {
                        if (opposedPosition == true) {
                            x = axis.x - textOffset.width + padding - maxTickSize;
                            position = "left";
                        }
                        if (opposedPosition == false) {
                            // Space between the marker and the trackball
                            x = axis.x + 2 * padding + (axis._isScroll ? this.model.scrollerSize : 0);
                            position = "right";
                        }
                    } else {
                        if (opposedPosition == true) {
                            // Space between the marker and the trackball
							if(textOffset.width + axis.x > $(this.svgObject).width() - padding)
								x = $(this.svgObject).width() - textOffset.width - padding;
							else
								x = axis.x + 3 * padding;
                            position = "left";
                        }
                        if (opposedPosition == false) {
							// to place crosshair tooltip inside when it exceeds area bounds
							if(textOffset.width > axis.x)
								x = 2 * padding;
							else
								x = axis.x - textOffset.width - maxTickSize;
                            position = "right";
                        }
                    }
                    x = x + (axis._isScroll ? (axis.opposedPosition ? this.model.scrollerSize : -this.model.scrollerSize) : 0);
                    vPadding = padding;
					if(isEdgeInside){
						if((y - textOffset.height) < this.model.m_AreaBounds.Y)
							y = this.model.m_AreaBounds.Y + textOffset.height;
						else if(y + (textOffset.height/2) > this.model.m_AreaBounds.Height + this.model.m_AreaBounds.Y)
							y = y - (textOffset.height/2);						
					}
                }
                var canvasPadding = (enableCanvas) ? padding / 4 : 0
                var textAxisOptions = {
                    'id': this.svgObject.id + '_AxisToolTipText' + '_' + index,
                    'x': x - (enableCanvas ? 0 : vPadding),
                    'y': y + (enableCanvas ? - canvasPadding : hPadding),
                    'fill': axis.crosshairLabel.font.color,
                    'font-size': axis.crosshairLabel.font.size,
                    'font-family': axis.crosshairLabel.font.fontFamily,
                    'font-style': axis.crosshairLabel.font.fontStyle,
                    'font-weight': axis.crosshairLabel.font.fontWeight,
                    'text-anchor': 'start',
                    'opacity': axis.crosshairLabel.font.opacity

                };
                var fontSize = sf.EjSvgRender.utils._measureText(commonTrackTextArgs.data.currentTrackText, this.model.m_AreaBounds.Width, axis.crosshairLabel.font),
                    crosshairLabel = axis.crosshairLabel,
                    x = (x - padding),
                    y = (y - (fontSize.height)),
                    width = (fontSize.width) + (2 * padding),
                    height = (2 * fontSize.height) - (2 * padding);
                var toolAxisRectOptions = {
                    'x': x - (enableCanvas ? 0 : vPadding),
                    'y': y + (enableCanvas ? -canvasPadding : hPadding),
                    'width': width,
                    'height': height,
                    'rx': crosshairLabel.rx * ((enableCanvas) ? 2 : 1),
                    'ry': crosshairLabel.ry * ((enableCanvas) ? 2 : 1)
                };
                var direction = sf.EjSvgRender.utils._calculateroundedCorner(null, toolAxisRectOptions, true, position, 0, tracker);
                toolAxisRectOptions = {
                    'id': this.svgObject.id + '_AxisToolTipRect' + '_' + index,
                    'd': direction,
                    'fill': crosshairLabel.fill,
                    'stroke-width': crosshairLabel.border.width,
                    'stroke': crosshairLabel.border.color
                };

                var axes = this.model._axes[index];
                if ((mouseLoc.y < (axes.y + axes.height) && mouseLoc.y > axes.y) || (mouseLoc.x < (axes.x + axes.width) && mouseLoc.x > axes.x)) {
                    this.svgRenderer._setAttr($('#' + this.svgObject.id + '_AxisToolTipRect' + '_' + index), { "display": 'block' });
                    this.svgRenderer._setAttr($('#' + this.svgObject.id + '_AxisToolTipText' + '_' + index), { "display": 'block' });
                    toolAxisRectOptions.display = 'block';
                }
                else {
                    this.svgRenderer._setAttr($('#' + this.svgObject.id + '_AxisToolTipRect' + '_' + index), { "display": 'none' });
                    this.svgRenderer._setAttr($('#' + this.svgObject.id + '_AxisToolTipText' + '_' + index), { "display": 'none' });
                    toolAxisRectOptions.display = 'none';
                }
                if (enableCanvas) {
                    var obj = this.svgRenderer.createCrosshairCanvas();
                    obj.ctx = obj.getContext('2d');
                }
                else
                    var obj = this.svgRenderer;
                this.svgRenderer.drawPath.call(obj, toolAxisRectOptions, this.gTrackAxisEle);
                this.svgRenderer.drawText.call(obj, textAxisOptions, commonTrackTextArgs.data.currentTrackText, this.gTrackAxisEle);
            }
        },
        maxWdithArrayCollection: function (arrayCollection, font) {
            var maxTextWidth = 0, size, width = 0, height = 0,
                measureText = sf.EjSvgRender.utils._measureText;
            for (var txt = 0, txtlength = arrayCollection.length; txt < txtlength; txt++) {
                size = measureText(arrayCollection[txt], 0, font);
                width = size.width;
                height += size.height;
                maxTextWidth = (maxTextWidth == 0) ? width : (maxTextWidth < width) ? width : maxTextWidth;
            }
            return { maxTextWidth: maxTextWidth, totalHeight: height };
        },
        displayTooltip: function (grouping, tooltipCollections, maxWidth) {
            // common variables for both grouping and float
            var crosshair = this.model.crosshair, trackball = crosshair.trackballTooltipSettings, rx = trackball.rx, ry = trackball.ry, trackballBorder = trackball.border,
                m_AreaBounds = this.model.m_AreaBounds;
            var isRTL = this.model.crosshair.isReversed;
            if (grouping) {
                var series = tooltipCollections.series, groupSize, groupHeight, container = document.getElementById(this._id),
                    offset = $(container).offset(),
                    rectOptions = series.tooltip, font = rectOptions.font ? $.extend(false, series.font, {}, rectOptions.font) : series.font,
                    point = series.type == "boxandwhisker" ? tooltipCollections.point.boxPlotLocation[3] : tooltipCollections.point.location,
                    m_width = ((series.marker.size.width / 2 + series.marker.border.width + trackballBorder.width)) + 5,// 5 for space between group element and tracker
                    yAxisY = ((series._isTransposed) ? (series.xAxis.y + m_width) : series.yAxis.y),
                    xAxisX = ((series._isTransposed) ? series.yAxis.x : (series.xAxis.x + m_width)),
                    location = { X: xAxisX + point.X, Y: yAxisY + point.Y },
                    textCollection = tooltipCollections.textCollection, textOptionsCollection = tooltipCollections.textOptionsCollection,
                    groupingTextId = tooltipCollections.groupingTextId,
                    options, span,
                    groupLocation = { X: (location.X), Y: location.Y },
                    groupElement = document.getElementById(this._id + "_trackball_grouping_tooltip");
                this._trigger("trackToolTip", { data: { currentText: textCollection, location: groupLocation } });
                if (!sf.util.isNullOrUndefined(this.model.trackToolTip) && this.model.trackToolTip != "") {
                    for (var tx = 0, len = textCollection.length; tx < len - 1; tx++) {
                        if (textCollection[tx].text == "") {
                            textCollection.splice(tx, 1);
                            textOptionsCollection.splice(tx, 1);
                            groupingTextId.splice(tx, 1);
                        }
                    }
                }
                if (sf.util.isNullOrUndefined(groupElement)) {
                    groupElement = document.createElement("div");
                    options = {
                        'left': groupLocation.X,
                        'top': groupLocation.Y,
                        'border': parseInt((trackballBorder.width) ? trackballBorder.width : 1) + "px solid " + ((trackballBorder.color) ? trackballBorder.color : "#000000"),
                        'background': (trackball.fill) ? trackball.fill : "#ffffff",
                        'opacity': trackball.opacity,
                        'position': 'absolute',
                        'height': 'auto',
                        'width': 'auto',
                        'border-radius': rx + "px " + ry + "px",
                        'pointer-events': 'none'
                    };
                    groupElement.setAttribute('id', this._id + "_trackball_grouping_tooltip");
                }
                else {
                    options = {
                        'left': groupLocation.X,
                        'top': groupLocation.Y,
                    }
                }
                for (var tx = 0, len = textCollection.length; tx < len; tx++) {
                    span = document.createElement("span");
                    span.setAttribute("id", groupingTextId[tx]);
					var groupText = textCollection[tx].text;
					$(span).html(groupText + "</br>");
                    $(span).css(textOptionsCollection[tx]);
                    groupElement.appendChild(span);
                }
                var arrayCollection = textCollection.map(function (a) { return a.text; });
                groupSize = this.maxWdithArrayCollection(arrayCollection, font);
                maxWidth = groupSize.maxTextWidth;
                groupHeight = groupSize.totalHeight;
                options.top = (series._isTransposed) ? options.top : (options.top - (groupHeight * 0.5));
                options.left = (series._isTransposed) ? (options.left - (maxWidth * 0.5)) : options.left;
                if (textCollection.length > 1) {
                    options.top = (series._isTransposed) ? options.top : (yAxisY + (m_AreaBounds.Height * 0.5 - (0.5 * groupHeight)));
                    options.left = (series._isTransposed) ? (((m_AreaBounds.Width / 2) + m_AreaBounds.X) - (maxWidth * 0.5)) : options.left;
                }
                if (!series._isTransposed) {
                    if (options.left + maxWidth >= (m_AreaBounds.X + m_AreaBounds.Width))
                        options.left -= (maxWidth + (m_width + trackballBorder.width) * 2);// extra space on edge group element swifting for already added need to remove 
                }
                else {

                    if ((groupHeight + options.top) > (m_AreaBounds.Y + m_AreaBounds.Height))
                        options.top -= (groupHeight + (m_width * 2));// extra space on edge group element swifting
                }
                options.left = (groupLocation.X == location.X) ? options.left : groupLocation.X;
                options.top = (groupLocation.Y == location.Y) ? options.top : groupLocation.Y;
                $(groupElement).css(options);
                $(groupElement).appendTo(this.chartContainer);

            }
            else {
                for (var init = 0, tlength = tooltipCollections.length; init < tlength; init++) {

                    var location = tooltipCollections[init].Point, point = tooltipCollections[init].ClosestPoint, series = tooltipCollections[init].Series, pointIndex = tooltipCollections[init].ClosestPointIndex, tgap = tooltipCollections[init].Tgap,
                        seriesIndex = $.inArray(series, this.model._visibleSeries),
                        Axis = { X1: m_AreaBounds.X, Y1: (m_AreaBounds.Y + m_AreaBounds.Height), X2: (m_AreaBounds.X + m_AreaBounds.Width), Y2: m_AreaBounds.Y },
                        axes = this.model._axes, pointXAxis = series._xAxisName, pointYAxis = series._yAxisName;

                    for (var j = 0, len = axes.length; j < len; j++) {
                        if (pointXAxis == axes[j].name) {
                            if (!series._isTransposed)
                                Axis.X1 = axes[j].Location.X1, Axis.X2 = axes[j].Location.X2;
                            else
                                Axis.Y1 = axes[j].Location.Y1, Axis.Y2 = axes[j].Location.Y2;
                        }
                        else if (pointYAxis == axes[j].name) {
                            if (!series._isTransposed)
                                Axis.Y1 = axes[j].Location.Y1, Axis.Y2 = axes[j].Location.Y2;
                            else
                                Axis.X1 = axes[j].Location.X1, Axis.X2 = axes[j].Location.X2;
                        }
                    }
                    location.X = (series.type == "boxandwhisker") ? location.X + Axis.X1 : location.X;
                    location.Y = (series.type == "boxandwhisker") ? location.Y + Axis.Y2 : location.Y;
                    if ((location.X >= Axis.X1 && location.X <= Axis.X2 && location.Y >= Axis.Y2 && location.Y <= Axis.Y1) || (grouping)) {
                        var requireInvertedAxes = this.model.requireInvertedAxes, tx, ty,
                            x = location.X + (!series.isIndicator ? ((sf.util.isNullOrUndefined(series._trackMarker)) ? series.marker.size.width : (series._trackMarker.size.width)) : 0) + padding + 1,
                            y = (location.Y), format = series.tooltip.format, numberToFixed = ((sf.util.isNullOrUndefined(series.yAxis.roundingPlaces)) ? 2 : series.yAxis.roundingPlaces);
                        if (tooltipCollections[init].Series.type == "boxandwhisker" && location.outlier)
                            var trackTooltipText = this.getTooltipFormat(point, series, seriesIndex, pointIndex, format, location);
                        else
                            var trackTooltipText = this.getTooltipFormat(point, series, seriesIndex, pointIndex, format, numberToFixed);
                        var seriesName = (series.name) ? (series.name).replace(' ', '') : "series" + seriesIndex, commonTrackTextArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs),
                            toolRectOptions, direction;
                        commonTrackTextArgs.data = { Location: { X: x, Y: y }, Series: series, serIndex: seriesIndex, pointIndex: pointIndex, currentText: trackTooltipText.text };
                        this._trigger("trackToolTip", commonTrackTextArgs);
                        if (!commonTrackTextArgs.cancel) {
                            x = commonTrackTextArgs.data.Location.X;
                            y = commonTrackTextArgs.data.Location.Y;
                            var padding = this.model.tooltipPadding, tip_pos = tgap, rectOptions = series.tooltip, font = rectOptions.font ? $.extend(false, series.font, {}, rectOptions.font) : series.font, textOffset = sf.EjSvgRender.utils._measureText(commonTrackTextArgs.data.currentText, series.xAxis.width, font), seriesColor = this.getSeriesColor(point, seriesIndex, series);
                            var toolTipOptions = this.getTooltipOptions(seriesColor, series), rectBorderColor = toolTipOptions.rectBColor, rectFillColor = toolTipOptions.rectFColor, textColor = toolTipOptions.rectTextColor, rectWidth = textOffset.width + (2 * padding), rectHeight = textOffset.height + (2 * padding), poly, tipOpen = (requireInvertedAxes) ? ((rectWidth * 10) / 100) : ((rectHeight * 30) / 100),
                                axisWidth = (requireInvertedAxes) ? series.yAxis.width : series.xAxis.width, tooltipStartPosition = (requireInvertedAxes) ? (tgap + location.X - rectWidth / 2) : (tgap + location.Y - rectHeight / 2), tooltipEndPosition = (requireInvertedAxes) ? (tgap + location.X + rectWidth / 2) : (tgap + location.Y + rectHeight / 2), boundryStart = (requireInvertedAxes) ? (m_AreaBounds.X) : (m_AreaBounds.Y), boundryEnd = (requireInvertedAxes) ? (m_AreaBounds.X + m_AreaBounds.Width) : (m_AreaBounds.Y + m_AreaBounds.Height), text_pos = [],
                                marker_width = 3 + crosshair.marker.border.width + ((!requireInvertedAxes) ? crosshair.marker.size.width : crosshair.marker.size.height) / 2,
                                swp = (!this.model.financial) ? marker_width + 5 : 0, type = series.type.toLowerCase(),
                                position, hsize = type.indexOf("rangearea") == 0 ? this.model.crosshair.marker.size.height / 2 : 0;
                            if ((tooltipStartPosition >= boundryStart && tooltipEndPosition <= (boundryEnd)) || this.model.financial) {
                                if (requireInvertedAxes) {
                                    if (location.Y - swp - maxWidth < m_AreaBounds.Y) {
                                        toolRectOptions = {
                                            'x': location.X - rectWidth / 2 + tip_pos,
                                            'y': location.Y + swp,
                                            'width': rectWidth,
                                            'height': rectHeight,
                                            'rx': rx,
                                            'ry': ry
                                        };
                                        text_pos.push({ X: location.X - rectWidth / 2 + padding + tip_pos, Y: location.Y + swp + rectHeight / 2 - padding });
                                        position = "top";

                                    } else {
                                        if (this.model.financial) {
                                            x = location.X - rectWidth / 2 + tip_pos; y = location.Y + padding + hsize; tx = x + padding; ty = y + 2 * padding;
                                            position = "top";
                                        }
                                        else {
                                            x = location.X - rectWidth / 2 + tip_pos; y = location.Y - swp - rectHeight; tx = location.X - rectWidth / 2 + padding + tip_pos; ty = location.Y - swp - rectHeight / 2 - padding;
                                            position = "bottom";
                                        }
                                        toolRectOptions = {
                                            'x': x,
                                            'y': y,
                                            'width': rectWidth,
                                            'height': rectHeight,
                                            'rx': rx,
                                            'ry': ry
                                        };
                                        text_pos.push({ X: tx, Y: ty });

                                    }
                                }
                                else {

                                    if (location.X + swp + maxWidth - m_AreaBounds.X >= axisWidth || isRTL) {
                                        if (this.model.financial) {
                                            x = location.X - rectWidth / 2; y = location.Y - rectHeight - padding - hsize; tx = x + padding; ty = y + tip_pos + rectHeight;
                                            position = "bottom";
                                        }
                                        else {
                                            if (location.X - maxWidth <= this.model.m_AreaBounds.X && isRTL) {
                                                x = location.X + swp; y = location.Y - rectHeight / 2 + tip_pos; tx = x + padding; ty = location.Y + tip_pos + rectHeight / 2;
                                                position = "left";
                                            }
                                            else {
                                                x = location.X - swp - rectWidth; y = location.Y - rectHeight / 2 + tip_pos; tx = x + padding; ty = location.Y + tip_pos + rectHeight / 2;
                                                position = "right";
                                            }
                                        }
                                        toolRectOptions = {
                                            'x': x,
                                            'y': y,
                                            'width': rectWidth,
                                            'height': rectHeight,
                                            'rx': rx,
                                            'ry': ry
                                        };

                                        text_pos.push({ X: tx, Y: ty });

                                    }
                                    else {
                                        if (this.model.financial) {
                                            x = location.X - rectWidth / 2; y = location.Y - hsize - rectHeight - 2 * padding; tx = x + padding; ty = y + tip_pos + rectHeight;
                                            position = "bottom";
                                        }
                                        else {
                                            x = location.X + swp; y = location.Y - rectHeight / 2 + tip_pos; tx = x + padding; ty = location.Y + tip_pos + rectHeight / 2;
                                            position = "left";
                                        }

                                        toolRectOptions = {
                                            'x': x,
                                            'y': y,
                                            'width': rectWidth,
                                            'height': rectHeight,
                                            'rx': rx,
                                            'ry': ry
                                        };

                                        text_pos.push({ X: tx, Y: ty });


                                    }
                                }




                                var tooltipfill = seriesColor;
                                if (typeof (tooltipfill) == "object") {
                                    tooltipfill = seriesColor[1].color;
                                }



                                var text = commonTrackTextArgs.data.currentText, fontText = text, fontSize = sf.EjSvgRender.utils._measureText(text, series.xAxis.width, font).height, len;
                                if (commonTrackTextArgs.data.currentText.indexOf("<br/>") >= 0) {
                                    text = commonTrackTextArgs.data.currentText.split("<br/>");
                                    fontText = text[0];
                                    if (!requireInvertedAxes) {
                                        var isCandle = (type.indexOf("candle") >= 0 || type.indexOf("hiloopenclose") >= 0) || false;
                                        if (location.X + swp + maxWidth - m_AreaBounds.X >= axisWidth) {
                                            if (!this.model.financial) {
                                                tx = location.X - rectWidth - swp + padding;
                                                ty = ((location.Y + tip_pos) - (rectHeight / 2) + fontSize / text.length);
                                            }
                                            else {
                                                tx = location.X - rectWidth / 2 + padding;
                                                ty = ((location.Y + tip_pos) - (rectHeight)) - hsize + ((isCandle) ? 0 : 2 * padding);
                                                toolRectOptions.y -= (isCandle) ? padding * 3 : padding;
                                                toolRectOptions.height += (isCandle) ? padding * 2 : padding;
                                            }


                                            text_pos.push({ X: tx, Y: ty });
                                        }
                                        else {
                                            if (!this.model.financial) {
                                                tx = location.X + swp + padding;
                                                ty = ((location.Y + tip_pos) - (rectHeight / 2) + fontSize / text.length);
                                            }
                                            else {

                                                tx = location.X - rectWidth / 2 + padding;
                                                ty = ((location.Y + tip_pos) - (rectHeight)) - hsize + ((isCandle) ? 0 : padding);
                                                toolRectOptions.y -= (isCandle) ? padding * 2 : padding;
                                                toolRectOptions.height += (isCandle) ? padding * 2 : padding;
                                            }
                                            text_pos.push({ X: tx, Y: ty });
                                        }
                                    }
                                    else {
                                        if (location.Y - swp - maxWidth < m_AreaBounds.Y) {
                                            text_pos.push({ X: location.X - rectWidth / 2 + padding + tip_pos, Y: location.Y + swp + (fontSize / text.length) });
                                        }
                                        else {
                                            if (!this.model.financial) {
                                                tx = location.X - rectWidth / 2 + padding + tip_pos;
                                                ty = location.Y - swp - rectHeight + (fontSize / text.length);
                                            }
                                            else {
                                                tx = location.X - rectWidth / 2 + padding + tip_pos;
                                                ty = (location.Y + 4 * padding) + hsize;
                                            }
                                            text_pos.push({ X: tx, Y: ty });
                                        }
                                    }
                                    fontSize = 0;
                                }
                                len = text_pos.length - 1;
                                fontSize = (requireInvertedAxes) ? fontSize : -fontSize;
                                var index = series.type == "boxandwhisker" ? init : pointIndex;
                                var textOptions = {
                                    'id': this.svgObject.id + '_ToolTipText' + '_' + seriesIndex + "_" + index,
                                    'x': text_pos[len].X,
                                    'y': text_pos[len].Y + fontSize / 2,
                                    'fill': rectOptions.font ? (rectOptions.font.color ? rectOptions.font.color : "#ffffff") : "#ffffff",
                                    'font-size': font.size,
                                    'font-family': font.fontFamily,
                                    'font-style': font.fontStyle,
                                    'font-weight': font.fontWeight,
                                    'text-anchor': 'start',
                                    'isTrackball': true,
                                    'padding': this.model.tooltipPadding
                                };

                                direction = sf.EjSvgRender.utils._calculateroundedCorner(null, toolRectOptions, true, position, tip_pos);

                                var arrowPath = {
                                    'id': this.svgObject.id + '_gTooltip_' + seriesIndex + '_' + index,
                                    'd': direction,
                                    'fill': ((trackball.fill) ? trackball.fill : tooltipfill),
                                    "stroke-width": parseInt(trackball.border.width ? trackball.border.width : 0) + "px",
                                    "stroke": trackball.border.color ? trackball.border.color : 'transparent',
                                    'fill-opacity': trackball.opacity
                                };

                                if (this.model.enableCanvasRendering) {
                                    var obj = this.svgRenderer.createCrosshairCanvas();
                                    obj.ctx = obj.getContext('2d');
                                }

                                else
                                    var obj = this.svgRenderer;


                                var gTooltip = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_gTooltip_' + seriesIndex + "_" + index, });

                                this.svgRenderer.drawPath.call(obj, arrowPath, gTooltip);
                                this.svgRenderer.drawText.call(obj, textOptions, text, gTooltip, font);

                            }
                        }                        
                        if ($('#' + this.svgObject.id + "_TrackToolTip_" + seriesIndex).length == 0)
                            this.svgRenderer.append($(gTooltip), this.gTrackball);
                    }
                }
            }
        },
        SmartTooltipPosition: function (SmartTooltipOptions) {
            var InitialRanges = [[], []], exceed, length_SmartTooltips = SmartTooltipOptions.length, visibleLocation = [], totalSapce = (SmartTooltipOptions[0].Series._isTransposed) ? this.model.m_AreaBounds.Width : this.model.m_AreaBounds.Height, tooltipPadding = this.model.tooltipPadding, tooltipWidth = -tooltipPadding;
            for (var a = 0; a < length_SmartTooltips; a++) {
                InitialRanges[0][a] = $.extend({}, SmartTooltipOptions[a].StEnd);
                InitialRanges[1][a] = { yAxis: SmartTooltipOptions[a].Series._yAxisName, xAxis: SmartTooltipOptions[a].Series._xAxisName, isTransposed: SmartTooltipOptions[a].Series._isTransposed };
                if (SmartTooltipOptions[a].ReqInvertAxis) {
                    visibleLocation[a] = SmartTooltipOptions[a].Point.X;
                }
                else {
                    visibleLocation[a] = SmartTooltipOptions[a].Point.Y;
                }
                tooltipWidth += SmartTooltipOptions[a].StEnd.End - SmartTooltipOptions[a].StEnd.Start + tooltipPadding;
            }
            this.ContinousOverlappingPoints(InitialRanges[0], visibleLocation);
            if (tooltipWidth < totalSapce)
                this.verticalArrangeMents(InitialRanges);
            for (var a = 0; a < length_SmartTooltips; a++) {
                SmartTooltipOptions[a].Tgap = (!this.model.financial) ? InitialRanges[0][a].Start - SmartTooltipOptions[a].StEnd.Start : 0;
            }
        },
        verticalArrangeMents: function (startEndRanges) {
            var pointsRanges = startEndRanges[0],
                axisNames = startEndRanges[1], //axis names contains isTransposed also
                obj = this.model.m_AreaBounds,
                padding = this.model.tooltipPadding,
                isTransposed,
                chartHeight,
                startPos,
                yAxisName,
                axes = this.model._axes,
                temp,//current trackabll tooltip start end
                secTemp,//vertical arrangements
                secWidth,//vertical arrange width
                condition,
                width, length = pointsRanges.length, i = length - 1, j = 0, k = 0, axisLength = axes.length;
            for (; i >= 0; i--) {
                isTransposed = axisNames[i].isTransposed;
                yAxisName = axisNames[i].yAxis;
                for (k = 0; k < axisLength; k++) {
                    if (yAxisName == axes[k].name) {
                        if (isTransposed) {
                            chartHeight = axes[k].Location.X2;
                            startPos = axes[k].Location.X1;
                        }
                        else {
                            chartHeight = axes[k].Location.Y1;
                            startPos = axes[k].Location.Y2;
                        }
                    }
                }
                temp = pointsRanges[i];
                width = temp.End - temp.Start;
                if (chartHeight < temp.End) {
                    temp.End = chartHeight - 2;
                    temp.Start = temp.End - width;
                    for (j = i - 1; j >= 0; j--) {
                        secTemp = pointsRanges[j];
                        secWidth = secTemp.End - secTemp.Start;
                        if (secTemp.End > pointsRanges[j + 1].Start && (pointsRanges[j + 1].Start > startPos && pointsRanges[j + 1].End < chartHeight)) {
                            secTemp.End = pointsRanges[j + 1].Start - padding;
                            secTemp.Start = secTemp.End - secWidth;
                        }
                    }
                }
            }
            for (i = 0; i < length; i++) {
                isTransposed = axisNames[i].isTransposed;
                yAxisName = axisNames[i].yAxis;
                for (k = 0; k < axisLength; k++) {
                    if (yAxisName == axes[k].name) {
                        if (isTransposed) {
                            chartHeight = axes[k].Location.X2;
                            startPos = axes[k].Location.X1;
                        }
                        else {
                            chartHeight = axes[k].Location.Y1;
                            startPos = axes[k].Location.Y2;
                        }
                    }
                }
                temp = pointsRanges[i];
                width = temp.End - temp.Start;
                if (temp.Start < startPos) {
                    temp.Start = startPos + 1;
                    temp.End = temp.Start + width;
                    for (j = i + 1; j <= (length - 1); j++) {
                        secTemp = pointsRanges[j];
                        secWidth = secTemp.End - secTemp.Start;
                        if (secTemp.Start < pointsRanges[j - 1].End && (pointsRanges[j - 1].Start > startPos && pointsRanges[j - 1].End < chartHeight)) {
                            secTemp.Start = pointsRanges[j - 1].End + padding;
                            secTemp.End = secTemp.Start + secWidth;
                        }
                    }
                }
            }
        },
        ContinousOverlappingPoints: function (TooltipRanges, visibleLocation) {
            var padding = this.model.tooltipPadding, temp = 0, Count = 0, Start = 0, StartPoint = 0, endPoint = TooltipRanges.length - 1, Range = (TooltipRanges[0].End - TooltipRanges[0].Start) + padding, halfHeight, midPos, tRange, kRange;
            temp = TooltipRanges[0].Start + Range;
            Start = TooltipRanges[0].Start;
            for (var i = 0; i < endPoint; i++) {
                if (temp >= TooltipRanges[i + 1].Start) {
                    Range = TooltipRanges[i + 1].End - TooltipRanges[i + 1].Start + padding;
                    temp += Range;
                    Count++;
                    if (Count - 1 == endPoint - 1 || i == endPoint - 1) {
                        halfHeight = (temp - Start) / 2;
                        midPos = (visibleLocation[StartPoint] + visibleLocation[i + 1]) / 2;
                        tRange = TooltipRanges[StartPoint].End - TooltipRanges[StartPoint].Start;
                        TooltipRanges[StartPoint].Start = midPos - halfHeight;
                        TooltipRanges[StartPoint].End = TooltipRanges[StartPoint].Start + tRange;
                        for (var k = StartPoint; k > 0; k--) {
                            if (TooltipRanges[k].Start <= TooltipRanges[k - 1].End + padding) {
                                kRange = TooltipRanges[k - 1].End - TooltipRanges[k - 1].Start;
                                TooltipRanges[k - 1].Start = TooltipRanges[k].Start - kRange - padding;
                                TooltipRanges[k - 1].End = TooltipRanges[k - 1].Start + kRange;
                            }
                            else {
                                break;
                            }
                        }
                        for (var j = StartPoint + 1; j <= StartPoint + Count; j++) {
                            tRange = TooltipRanges[j].End - TooltipRanges[j].Start;
                            TooltipRanges[j].Start = TooltipRanges[j - 1].End + padding;
                            TooltipRanges[j].End = TooltipRanges[j].Start + tRange;

                        }
                    }

                }
                else {
                    Count = i > 0 ? Count : 0;
                    if (Count > 0) {
                        halfHeight = (temp - Start) / 2;
                        midPos = (visibleLocation[StartPoint] + visibleLocation[i]) / 2;
                        tRange = TooltipRanges[StartPoint].End - TooltipRanges[StartPoint].Start;
                        TooltipRanges[StartPoint].Start = midPos - halfHeight;
                        TooltipRanges[StartPoint].End = TooltipRanges[StartPoint].Start + tRange;
                        for (var k = StartPoint; k > 0; k--) {
                            if (TooltipRanges[k].Start <= TooltipRanges[k - 1].End + padding) {
                                kRange = TooltipRanges[k - 1].End - TooltipRanges[k - 1].Start;
                                TooltipRanges[k - 1].Start = TooltipRanges[k].Start - kRange - padding;
                                TooltipRanges[k - 1].End = TooltipRanges[k - 1].Start + kRange;
                            }
                            else {
                                break;
                            }
                        }
                        for (var j = StartPoint + 1; j <= StartPoint + Count; j++) {
                            tRange = TooltipRanges[j].End - TooltipRanges[j].Start;
                            TooltipRanges[j].Start = TooltipRanges[j - 1].End + padding;
                            TooltipRanges[j].End = TooltipRanges[j].Start + tRange;
                        }
                        Count = 0;
                    }
                    Range = (TooltipRanges[i + 1].End - TooltipRanges[i + 1].Start + padding);
                    temp = TooltipRanges[i + 1].Start + Range;
                    Start = TooltipRanges[i + 1].Start;
                    StartPoint = i + 1;
                }

            }
        },
        getTooltipOptions: function (seriesColor, series) {
            var rectBorderColor, rectFillColor, rX, rY, textColor;
            if (this.model.theme.indexOf("gradient") >= 0) {
                rectBorderColor = jQuery.type(seriesColor) == "array" ? seriesColor[0].color : seriesColor;
                rectFillColor = 'white';
                textColor = "#333333";
                rX = 5;
                rY = 5;

            } else {
                var type = series.type.toLowerCase();
                if (type.indexOf("column") == -1 && type.indexOf("waterfall") == -1 && type.indexOf("bar") == -1 && type.indexOf("box") == -1 && type != "rangearea" && this.model.AreaType != "none") {
                    rectFillColor = jQuery.type(seriesColor) == "array" ? seriesColor[0].color : seriesColor;
                    rectBorderColor = 'transparent';
                    textColor = "white";
                } else {
                    rectBorderColor = "#333333";
                    rectFillColor = 'white';
                    textColor = "#333333";
                }
                rX = 0;
                rY = 0;
            }
            return { rectBColor: rectBorderColor, rectFColor: rectFillColor, rectTextColor: textColor, rectX: rX, rectY: rY };
        },
        getSeriesColor: function (point, seriesIndex, series) {
            var seriesColor;
            if (series && !series.isIndicator && !series.isTrendLine) {
                if (point._hiloFill) {
                    if (!point._hiloFill._gradientStop)
                        seriesColor = point._hiloFill;
                    else {
                        seriesColor = point._hiloFill._gradientStop[0].color;
                    }
                }
                else if (point.fill) {
                    if (!point.fill._gradientStop)
                        seriesColor = point.fill;
                    else {
                        seriesColor = point.fill._gradientStop[0].color;
                    }
                }
                else {
                    if (series.type.toLowerCase() == "waterfall" && series.positiveFill &&
                        ((point.y > 0 && !point.showIntermediateSum && !point.showTotalSum) || point.waterfallSum > 0))
                        seriesColor = series.positiveFill;
                    else
                        seriesColor = this.model.seriesColors[seriesIndex];

                }
            } else {
                seriesColor = series.fill;
            }
            return seriesColor;
        },
        getFormat: function (series, boxLocation) {

            if (!series.tooltip.format) {
                var type = series.type.toLowerCase();
                var outlierVisible = series.type != "boxandwhisker" ? 'null' : boxLocation.outlier;
                if (type.indexOf("range") > -1 || (type.indexOf("hilo") > -1 && type.indexOf("open") == -1))
                    return "#point.x# <br/> High : #point.high# <br/> Low : #point.low#";
                else if (type.indexOf("candle") > -1 || type.indexOf("open") > -1)
                    return "#point.x# <br/> High : #point.high# <br/> Low : #point.low# <br/> Open : #point.open# <br/> Close : #point.close#";
                else if (type.indexOf("bubble") > -1)
                    return "#point.x# : #point.y# : #point.size#"
                else if (type.indexOf("box") > -1 && outlierVisible)
                    return "X : #boxPlotPoints.xValue#  Y : #boxPlotPoints.YValues#";
                else if (type.indexOf("box") > -1)
                    return "Minimum : #boxPlotPoints.Minimum# <br/> Upper Quartile : #boxPlotPoints.UpperQuartile# <br/> Median : #boxPlotPoints.midvalue# <br/> Lower Quartile : #boxPlotPoints.LowerQuartile# <br/> Maximum : #boxPlotPoints.Maximum#  ";
                else
                    return "#point.x# : #point.y#"
            }
            return series.tooltip.format;
        },
        getTooltipFormat: function (seriesPoint, series, serIndex, ptIndex, format, boxLocation) {
            var point = $.extend(true, {}, seriesPoint),
                areaType = this.model.AreaType,
                locale = this.model.locale,
                xAxis = series.xAxis,
                yAxis = series.yAxis,
                xAxisValueType = xAxis._valueType.toLowerCase(),
                nullorundefined = sf.util.isNullOrUndefined,
                xAxisLabelFormat = xAxis.labelFormat,
                yAxisLabelFormat = yAxis.labelFormat,
                dateTimeFormat = sf.EjSvgRender.utils._dateTimeLabelFormat,
                decimalPlaces = sf.EjSvgRender.utils._decimalPlaces,
                xGlobalize = false, yGlobalize = false,
                xFormat, yFormat,
                customFormat, data, substr, globalizeformat, subStr1, val,
                xPrecision, yPrecision, precisionDefault = 6, precisionHighest = 20;
            series.count = 1;
            point.count = 1;
            format = this.getFormat(series, boxLocation);
            while (format.indexOf('sf.format(') >= 0) {
                substr = format.substring(format.indexOf('sf.format('), format.indexOf(")") + 1);
                var calculate = substr.substring(substr.indexOf('(') + 1, substr.indexOf(","));
                if (calculate == "#point.x#") {
                    xGlobalize = true,
                        xFormat = substr.substring(substr.indexOf(',') + 1, substr.indexOf(")"));
                }
                else if (calculate == "#point.y#") {
                    yGlobalize = true,
                        yFormat = substr.substring(substr.indexOf(',') + 1, substr.indexOf(")"));
                } else {
                    globalizeformat = substr.substring(substr.indexOf(',') + 1, substr.indexOf(")"));
                    subStr1 = calculate.substring(calculate.indexOf('#') + 1);
                    val = subStr1.substring(subStr1.indexOf('.') + 1, subStr1.indexOf('#'));
                    if (point.hasOwnProperty(val) && point[val])
                        point[val] = sf.format(point[val], globalizeformat, locale);
                }
                format = format.replace(substr, calculate)
            }
            if (areaType == "cartesianaxes") {
                if (xAxisValueType.toLowerCase() == "datetime") {
                    point.x = sf.format(new Date(point.xValue), ((nullorundefined(xAxisLabelFormat)) ? dateTimeFormat(xAxis._intervalType, xAxis) : series.xAxis.labelFormat), locale);
                    point.x = xGlobalize ? (sf.format(new Date(point.xValue), xFormat, locale)) : point.x;
                }
                else if (xAxisValueType.toLowerCase() == "datetimecategory") {
                    point.x = sf.format(new Date(point.x), ((nullorundefined(xAxisLabelFormat)) ? dateTimeFormat(xAxis.intervalType, xAxis) : xAxis.labelFormat), locale);
                    point.x = xGlobalize ? (sf.format(new Date(point.x), xFormat, locale)) : point.x;
                }
                else if (xAxisValueType.toLowerCase() == "category") {
                    if (this.model.primaryXAxis.isIndexed)
                        point.x = (point.x) ? point.x : "undefined";
                    else
                        point.x = sf.EjSvgRender.utils._getLabelContent(point.xValue, series.xAxis, locale);
                }
                else {
                    if ((xGlobalize && (xFormat.indexOf('e') == 0 || xFormat.indexOf('E') == 0))) {
                        point.x = this.convertExponential(xPrecision, precisionDefault, precisionHighest, point.x, xFormat);
                    }
                    else
                        point.x = xGlobalize ? sf.format(point.x, xFormat, locale) : point.x;
                    customFormat = (!(xAxisLabelFormat)) ? null : xAxisLabelFormat.match('{value}');
                    point.x = (!(xAxisLabelFormat)) ? point.x : (customFormat != null) ? (xAxisLabelFormat == "${value}") ? xAxisLabelFormat.replace('{value}', '$' + point.x) : xAxisLabelFormat.replace('{value}', point.x) : (xGlobalize || (xAxisLabelFormat.indexOf('e') == 0 || xAxisLabelFormat.indexOf('E') == 0)) ? point.x : (sf.format(Number(point.x), xAxisLabelFormat, locale));

                }
            }
            else {
                if (xAxisValueType == "date") {
                    point.x = (sf.format(new Date(point.xValue), (dateTimeFormat('days')), locale));
                    point.x = xGlobalize ? (sf.format(new Date(point.xValue), xFormat, locale)) : point.x;
                }
            }
            if ((yGlobalize && (yFormat.indexOf('e') == 0 || yFormat.indexOf('E') == 0))) {
                point.y = this.convertExponential(yPrecision, precisionDefault, precisionHighest, point.y, yFormat);
            }
            else {
                point.y = point.waterfallSum ? point.waterfallSum : point.y;
                point.y = yGlobalize ? sf.format(point.y, yFormat, locale) : point.y;
            }
            customFormat = (!(yAxisLabelFormat)) ? null : yAxisLabelFormat.match('{value}');
            point.y = (!(yAxisLabelFormat)) ? point.y : (customFormat != null) ? (yAxisLabelFormat == "${value}") ? yAxisLabelFormat.replace('{value}', '$' + point.y) : yAxisLabelFormat.replace('{value}', point.y) : (yGlobalize || (yAxisLabelFormat.indexOf('e') == 0 || yAxisLabelFormat.indexOf('E') == 0)) ? point.y : (sf.format(Number(point.y), yAxisLabelFormat, locale));
            if ((areaType == 'none' || areaType == 'polaraxes') && xGlobalize && (xFormat.indexOf('e') == 0 || xFormat.indexOf('E') == 0)) {
                point.x = this.convertExponential(xPrecision, precisionDefault, precisionHighest, point.x, xFormat);
            }
            if (series.isStacking && series.drawType == "area" && ((series.type == "polar") || (series.type == "radar"))) {
                point.y = series.stackedValue.EndValues[ptIndex] - series.stackedValue.StartValues[ptIndex];
            }
            if (series.type.toLowerCase() == "boxandwhisker") {
                var boxPlotLabels;
                boxPlotLabels = series._visiblePoints[ptIndex].boxPlotValues;
                if (boxLocation.outlier == true) {
                    for (var z = 0; z < boxPlotLabels.outliers.length; z++) {
                        if (boxLocation.YValues == boxPlotLabels.outliers[z])
                            boxLocation.YValues = (!(yAxisLabelFormat)) ? boxLocation.YValues : (customFormat != null) ? (yAxisLabelFormat == "${value}") ? yAxisLabelFormat.replace('{value}', '$' + boxLocation.YValues) : yAxisLabelFormat.replace('{value}', boxLocation.YValues) : (yGlobalize || (yAxisLabelFormat.indexOf('e') == 0 || yAxisLabelFormat.indexOf('E') == 0)) ? boxLocation.YValues : (sf.format(Number(boxLocation.YValues), yAxisLabelFormat, locale));
                    }
                }
                else {
                    if (boxLocation.YValues == boxPlotLabels.Minimum)
                        boxPlotLabels.Minimum = (!(yAxisLabelFormat)) ? boxPlotLabels.Minimum : (customFormat != null) ? (yAxisLabelFormat == "${value}") ? yAxisLabelFormat.replace('{value}', '$' + boxPlotLabels.Minimum) : yAxisLabelFormat.replace('{value}', boxPlotLabels.Minimum) : (yGlobalize || (yAxisLabelFormat.indexOf('e') == 0 || yAxisLabelFormat.indexOf('E') == 0)) ? boxPlotLabels.Minimum : (sf.format(Number(boxPlotLabels.Minimum), yAxisLabelFormat, locale));
                    else if (boxLocation.YValues == boxPlotLabels.Maximum)
                        boxPlotLabels.Maximum = (!(yAxisLabelFormat)) ? boxPlotLabels.Maximum : (customFormat != null) ? (yAxisLabelFormat == "${value}") ? yAxisLabelFormat.replace('{value}', '$' + boxPlotLabels.Maximum) : yAxisLabelFormat.replace('{value}', boxPlotLabels.Maximum) : (yGlobalize || (yAxisLabelFormat.indexOf('e') == 0 || yAxisLabelFormat.indexOf('E') == 0)) ? boxPlotLabels.Maximum : (sf.format(Number(boxPlotLabels.Maximum), yAxisLabelFormat, locale));
                    else if (boxLocation.YValues == boxPlotLabels.UpperQuartile)
                        boxPlotLabels.UpperQuartile = (!(yAxisLabelFormat)) ? boxPlotLabels.UpperQuartile : (customFormat != null) ? (yAxisLabelFormat == "${value}") ? yAxisLabelFormat.replace('{value}', '$' + boxPlotLabels.UpperQuartile) : yAxisLabelFormat.replace('{value}', boxPlotLabels.UpperQuartile) : (yGlobalize || (yAxisLabelFormat.indexOf('e') == 0 || yAxisLabelFormat.indexOf('E') == 0)) ? boxPlotLabels.UpperQuartile : (sf.format(Number(boxPlotLabels.UpperQuartile), yAxisLabelFormat, locale));
                    else if (boxLocation.YValues == boxPlotLabels.LowerQuartile)
                        boxPlotLabels.LowerQuartile = (!(yAxisLabelFormat)) ? boxPlotLabels.LowerQuartile : (customFormat != null) ? (yAxisLabelFormat == "${value}") ? yAxisLabelFormat.replace('{value}', '$' + boxPlotLabels.LowerQuartile) : yAxisLabelFormat.replace('{value}', boxPlotLabels.LowerQuartile) : (yGlobalize || (yAxisLabelFormat.indexOf('e') == 0 || yAxisLabelFormat.indexOf('E') == 0)) ? boxPlotLabels.LowerQuartile : (sf.format(Number(boxPlotLabels.LowerQuartile), yAxisLabelFormat, locale));
                    else if (boxLocation.YValues == boxPlotLabels.midvalue)
                        boxPlotLabels.midvalue = (!(yAxisLabelFormat)) ? boxPlotLabels.midvalue : (customFormat != null) ? (yAxisLabelFormat == "${value}") ? yAxisLabelFormat.replace('{value}', '$' + boxPlotLabels.midvalue) : yAxisLabelFormat.replace('{value}', boxPlotLabels.midvalue) : (yGlobalize || (yAxisLabelFormat.indexOf('e') == 0 || yAxisLabelFormat.indexOf('E') == 0)) ? boxPlotLabels.midvalue : (sf.format(Number(boxPlotLabels.midvalue), yAxisLabelFormat, locale));
                }
                boxPlotLabels.count = series.count;
                boxPlotLabels.xValue = point.x;
                boxPlotLabels.YValues = boxLocation.YValues;
                data = { boxPlotPoints: boxPlotLabels };
            }
            else
                data = { series: series, point: point };
            format = format.parseTemplate(data);
            return { data: point, text: format };
        },
        convertExponential: function (precision, precisionDefault, precisionHighest, point, format) {
            precision = format.match(/(\d+)/g);
            precision = precision == null ? precisionDefault : precision > precisionHighest ? precisionHighest : precision;
            point = point.toExponential(precision);
            return point;
        },
        displayShowTooltip: function (location, point, series, pointIndex) {
            var requireInvertedAxes = this.model.requireInvertedAxes;
            var isRTL = series.tooltip.isReversed;
            if (point.visible !== false) {
                // fixed multiple tooltip issue in mobile
                $(".ejTooltip" + this._id).not("#" + this.svgObject.id + "_TrackToolTip").remove();
                if ($.finish)
                    $(".ejTooltip" + this._id).finish();
                else
                    $(".ejTooltip" + this._id).stop(true, true);
                var measureText, parentZindex, seriesIndex = (!series.isIndicator && !series.isTrendLine) ? $.inArray(series, this.model._visibleSeries) : 0,
                    seriesColor,
                    textOffset,
                    padding = 7, bubbleSpacing = 15,
                    x,
                    y,
                    trackTooltipText,
                    format = series.tooltip.format;
                var position = document.getElementById(this.svgObject.id).getClientRects()[0];
                var chartPos = this.model.m_AreaBounds;
                var type = series.type.toLowerCase();
                //Set tooltip position ,text and color
                switch (this.model.AreaType) {

                    case "cartesianaxes":
                        x = isRTL ? location.X - ((!series.isIndicator && !series.isTrendLine) ? ((sf.util.isNullOrUndefined(series._trackMarker)) ?
                            (type == "bubble" ? (point.radius + bubbleSpacing) : series.marker.size.width) : (series._trackMarker.size.width)) : 0) + (type == "column" || type == "bar" || type == "stackingbar" || type == "stackingcolumn" || type == "waterfall" || type == "rangecolumn" ? chartPos.X : (requireInvertedAxes) ? series.yAxis.x : series.xAxis.x)
                            : location.X + ((!series.isIndicator && !series.isTrendLine) ? ((sf.util.isNullOrUndefined(series._trackMarker)) ?
                            (type == "bubble" ? (point.radius + bubbleSpacing) : series.marker.size.width) : (series._trackMarker.size.width)) : 0) + (type == "column" || type == "bar" || type == "stackingbar" || type == "stackingcolumn" || type == "waterfall" || type == "rangecolumn" ? chartPos.X : (requireInvertedAxes) ? series.yAxis.x : series.xAxis.x);
                        //condition checked for multipleaxis line tooltip position changed
                        y = (location.Y) + (type.indexOf("column") != -1 || type.indexOf("waterfall") != -1 || type.indexOf("bar") != -1 || type.indexOf("rangearea") != -1 || type == "scatter" || type == "bubble" ?
                            (this.dragPoint ? (requireInvertedAxes ? series.xAxis.y : series.yAxis.y) : chartPos.Y) : (requireInvertedAxes) ? series.xAxis.y : series.yAxis.y);
                        if (this.dragPoint) {
                            x = x > series.xAxis.x ? x : series.xAxis.x;
                            y = y < series.yAxis.height + series.yAxis.y ? y : series.yAxis.height + series.yAxis.y;
                        }
                        seriesColor = this.getSeriesColor(point, seriesIndex, series);
                        break;

                    case "polaraxes":
                        x = isRTL ? location.X - padding + ((sf.util.isNullOrUndefined(series._trackMarker)) ? series.marker.size.width : (series._trackMarker.size.width)) :location.X + padding + ((sf.util.isNullOrUndefined(series._trackMarker)) ? series.marker.size.width : (series._trackMarker.size.width));
                        y = location.Y;
                        seriesColor = this.getSeriesColor(point, seriesIndex, series);
                        break;

                    case "none":
                        x = isRTL ? location.X - series.marker.size.width + padding : location.X + series.marker.size.width + padding;
                        y = (location.Y);
                        seriesColor = this.model.pointColors[pointIndex];
                        break;
                }


                if (series.type.toLowerCase() == "boxandwhisker") {
                    for (var p = 0; p < series._visiblePoints[pointIndex].boxPlotLocation.length; p++) {
                        var boxLocation = series._visiblePoints[pointIndex].boxPlotLocation[p];
                        var outlierVisible = boxLocation.outlier;
                        if (outlierVisible) {
                            if (boxLocation.X + (series.outlierSettings.size.width / 2) > location.X && boxLocation.X - (series.outlierSettings.size.width / 2) < location.X) {
                                if (boxLocation.Y + (series.outlierSettings.size.height / 2) > location.Y && boxLocation.Y - (series.outlierSettings.size.height / 2) < location.Y) {
                                    trackTooltipText = this.getTooltipFormat(point, series, seriesIndex, pointIndex, format, boxLocation);
                                    textOffset = sf.EjSvgRender.utils._measureText(trackTooltipText.text);
                                }
                            }
                        }
                        else {
                            trackTooltipText = this.getTooltipFormat(point, series, seriesIndex, pointIndex, format, boxLocation);
                            textOffset = sf.EjSvgRender.utils._measureText(trackTooltipText.text);
                        }
                    }
                }
                else {
                    trackTooltipText = this.getTooltipFormat(point, series, seriesIndex, pointIndex, format);
                    textOffset = sf.EjSvgRender.utils._measureText(trackTooltipText.text);
                }
                var toolTipOptions = this.getTooltipOptions(seriesColor, series);
                var rectBorderColor = toolTipOptions.rectBColor;
                var rectFillColor = toolTipOptions.rectFColor;
                var textColor = toolTipOptions.rectTextColor;
                var rX = toolTipOptions.rectX;
                var rY = toolTipOptions.rectY;
                var rectOptions = series.tooltip;
                //draw tooltip rectangle
                var tooltipdivRect;
                var padding = 5;

                if (document.getElementById(this.svgObject.id + "_TrackToolTip") == null)
                    tooltipdivRect = $("<div></div>").attr({ 'id': this.svgObject.id + "_TrackToolTip", 'class': 'ejTooltip' + this._id });
                else
                    tooltipdivRect = $("#" + this.svgObject.id + "_TrackToolTip");
                var isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
                if (sf.isTouchDevice() && !isIE11 && !this.vmlRendering) {
                    if (window.navigator.msPointerEnabled)
                        this._on(tooltipdivRect, 'MSPointerMove', this.chartTooltipHover);
                    else
                        this._on(tooltipdivRect, 'touchmove', this.chartTooltipHover);
                }
                else {
                    this._on(tooltipdivRect, 'mousemove', this.chartTooltipHover);
                }
                $("#" + this.svgObject.id + "_TrackToolTip").show();
                parentZindex = $('#' + this._id).parent()[0].style.zIndex;
                var rectOptions = {
                    'top': y + $(document).scrollTop(),
                    'left': x + $(document).scrollLeft(),
                    "background-color": (rectOptions.fill) ? rectOptions.fill : rectFillColor,
                    "border-style": "solid",
                    "position": "absolute",
                    "border-color": (rectOptions.border.color) ? rectOptions.border.color : rectBorderColor,
                    "border-width": (rectOptions.border.width || rectOptions.border.width == 0) ? rectOptions.border.width : 1,
                    "opacity": rectOptions.opacity,
                    'z-index': parentZindex + 1000000,
                    'border-radius': ((rectOptions.rx) ? rectOptions.rx : rX).toString() + "px " + ((rectOptions.ry) ? rectOptions.ry : rY).toString() + "px",
                    "padding-left": '5px',
                    "padding-right": '5px',
                    "padding-top": '2px',
                    "padding-bottom": '2px'
                };
                $(tooltipdivRect).css(rectOptions);

                //event for tooltip text
                var commonTrackTextArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonTrackTextArgs.data = { seriesIndex: seriesIndex, pointIndex: pointIndex, currentText: trackTooltipText.text, isTrendLine: series.isTrendLine, trendlineIndex: series.trendlineIndex };
                this._trigger("toolTipInitialize", commonTrackTextArgs);
                if (!commonTrackTextArgs.cancel) {
                    //draw tooltip text
                    var fontSize = 0;
                    var tooltip = series.tooltip;
                    var font = (tooltip.font) ? $.extend(false, series.font, {}, tooltip.font) : series.font;

                    // draw tooltip text styles
                    var textOptions = {
                        'top': y + $(document).scrollTop(),
                        'left': x + $(document).scrollLeft(),
                        "color": (tooltip.font && tooltip.font.color) ? font.color : textColor,
                        'font-size': font.size,
                        'font-family': font.fontFamily,
                        'font-style': font.fontStyle,
                        'font-weight': font.fontWeight,
                        "align-self": "baseline"
                    };
                    $(tooltipdivRect).css(textOptions);

                    // append the tooltip Div (condition for performance without remove div)
                    if (document.getElementById(this.svgObject.id + "_TrackToolTip") == null)
                        $(document.body).append(tooltipdivRect[0]);

                    // Add string in text array for tooltip format
                    var text = measureText = commonTrackTextArgs.data.currentText;
                    $("#" + this.svgObject.id + "_TrackToolTip").html(text);

                    // div size calculation perform here
                    var textHeight = 0;
                    var textWidth = 0;
                    text = text.replace(/<br >/g, "<br/>")
                        .replace(/<br \/>/g, "<br/>")
                        .replace(/<br>/g, "<br/>");
                    text = text.split("<br/>");
                    for (var i = 0; i < text.length; i++) {
                        var text1 = text[i];
                        text1 = text1.split('</tr>');
                        for (var j = 0; j < text1.length; j++) {
                            var text2 = text1[j];
                            text2 = this.RemoveTableAttr(text2);
                            text2 = text2.replace(/&nbsp;/g, " ");
                            textHeight += sf.EjSvgRender.utils._measureText(text2, null, font).height;
                            var width = sf.EjSvgRender.utils._measureText(text2, null, font).width;
                            if (textWidth < width)
                                textWidth = width;
                        }
                    }

                    fontSize = (this.model.AreaType == "cartesianaxes") ? sf.EjSvgRender.utils._measureText(measureText, series.xAxis.width, font).height : sf.EjSvgRender.utils._measureText(text, null, font).height;
                    var maxWidth = (this.model.AreaType == "cartesianaxes") ? (this.model.requireInvertedAxes) ? series.yAxis.width : series.xAxis.width : $(this.svgObject).width() - (this.model.legend.position.toLowerCase() == "right" ? (this.model.LegendViewerBounds.Width + 2 * this.model.elementSpacing) : 0);
                    var maxHeight = (this.model.AreaType == "cartesianaxes") ? (this.model.requireInvertedAxes) ? series.xAxis.height : series.yAxis.height : $(this.svgObject).height() - (this.model.legend.position.toLowerCase() == "bottom" ? (this.model.LegendViewerBounds.Height + this.model.elementSpacing) : 0);

                    //Adjust x-position to display tooltip within chart area 
                    var box = $("#" + this.svgObject.id + "_TrackToolTip")[0].getBoundingClientRect();

                    $("#" + this.svgObject.id + "_TrackToolTip").css("top", ($(document).scrollTop() + box.top + position.top - ((textHeight + 4) / 2)));
                    $("#" + this.svgObject.id + "_TrackToolTip").css("left", ($(document).scrollLeft() + box.left + position.left + (box.left - x)));
                    if ((x + (textWidth + padding)) >= maxWidth + series.xAxis.x && !isRTL) {
                        var areaPos = document.getElementById(this.svgObject.id).getClientRects()[0];
                        var diff = x - ((textWidth + padding * 2) + ((!series.isIndicator && !series.isTrendLine) ? ((sf.util.isNullOrUndefined(series._trackMarker)) ? ((series.marker.visible) ?
                            series.marker.size.width : (type == "bubble" ? (point.radius + bubbleSpacing) : 0)) : series._trackMarker.size.width) : 0) + (2 * padding));
                        $("#" + this.svgObject.id + "_TrackToolTip").css("left", diff + areaPos.left - (padding) + $(document).scrollLeft());
                    }
                    box = $("#" + this.svgObject.id + "_TrackToolTip")[0].getBoundingClientRect();
                    if (box.bottom >= (series.yAxis.y + maxHeight + position.top) || box.bottom >= (series.xAxis.y + maxHeight + position.top)) {
                        var diffY = y - (((box.bottom - box.top) + ((!series.isIndicator && !series.isTrendLine) ? ((sf.util.isNullOrUndefined(series._trackMarker)) ? ((series.marker.visible) ? series.marker.size.height : 0) : series._trackMarker.size.height) : 0))) + padding + position.top;
                        $("#" + this.svgObject.id + "_TrackToolTip").css("top", diffY + $(document).scrollTop());
                    }
                    //adjust rectangle size based on text length  
                    box = $("#" + this.svgObject.id + "_TrackToolTip")[0].getBoundingClientRect();
					
                    if (box.left < 0) {		
                        // checked condition for whether left or right position display outsude of the chart area
						var areaPos = document.getElementById(this.svgObject.id).getClientRects()[0];
						var chartWidth = chartPos.Width/2;
						if(location.X < chartWidth)
							$("#" + this.svgObject.id + "_TrackToolTip").css("left", x + position.left);			
						else{
							$("#" + this.svgObject.id + "_TrackToolTip").css("width", (box.right - (2*padding)));
							$("#" + this.svgObject.id + "_TrackToolTip").css("left", 0 );
						}
                    }
                    if (box.top < position.top || box.top < 0)
                        $("#" + this.svgObject.id + "_TrackToolTip").css("top", (position.top < 0 ? $(document).scrollTop() : position.top) + 'px');
                    if (isRTL) {
                        var boxWidth = box.right - box.left;
                        $("#" + this.svgObject.id + "_TrackToolTip").css("left", box.x - boxWidth);
						if (box.x < series.xAxis.x) // to display tooltip within chartarea when it is outside for RTL
                        {
                            var diff = ((textWidth + padding * 2) + ((!series.isIndicator && !series.isTrendLine) ? ((sf.util.isNullOrUndefined(series._trackMarker)) ? ((series.marker.visible) ?
                            series.marker.size.width : (type == "bubble" ? (point.radius + bubbleSpacing) : 0)) : series._trackMarker.size.width) : 0) + (2 * padding));
                            $("#" + this.svgObject.id + "_TrackToolTip").css("left", box.x + diff);
                        }
                    }
                    $("#" + this.svgObject.id + "_TrackToolTip").show();
                }
            }
        },
		RemoveTableAttr: function (text) {
			if (text.indexOf('<table>') != -1 || text.indexOf('</table>') != -1 || text.indexOf('<td>') != -1 || text.indexOf('</td>') != -1 || 	text.indexOf('<tr>') != -1)
                     text = text.replace(/\//g, "").replace(/<table>/g, "").replace(/<th>/g, "").replace(/<tr>/g, "").replace(/<td>/g, "");
            while(text.search(/<td/i) > -1){
								if(text.search(/<tr/) > -1) text = text.slice(text.search(/<td/i))
								else {
									if(text.search(/<td/) > -1 && (text.indexOf('>') > text.search(/<td/)) ) {
										text = text.slice(text.indexOf(">") + 1);
										var splitText = text.split('<td');
										for (var i =0; i < splitText.length; i++){
											var currentText = splitText[i];
											splitText[i] = currentText.indexOf(">") > -1 ? currentText.slice(currentText.indexOf(">") + 1) : currentText;
										}
										text = splitText.join("");
									}
								}
							}
			return text;
		},
        chartTooltipHover: function (evt) {
            var box = $("#" + evt.target.id)[0].getBoundingClientRect();
            var diff = evt.clientX - box.left;
            var padding = 5;
            $("#" + evt.target.id).css("left", box.left + diff + padding);
            box = $("#" + evt.target.id)[0].getBoundingClientRect();
            var areaPos = document.getElementById(this.svgObject.id).getClientRects()[0];
            if (box.right > areaPos.right + padding)
                $("#" + evt.target.id).css("left", evt.clientX - (box.right - box.left) - padding);
        },
        _initializeSeriesColors: function () {
            var chartObj = this;
            var modelColor = (chartObj.model.palette) ? chartObj.model.palette : chartObj.model.colors;
            var count = modelColor.length;
            var areaType = chartObj.model.AreaType;
            chartObj.model.seriesColors = [];
            chartObj.model.seriesBorderColors = [];
            chartObj.model.pointColors = [];
            chartObj.model.pointBorderColors = [];
            var elementCollection, color, borderColor, element, tlines, visibleSeriesLength = chartObj.model._visibleSeries.length, visibleSeries = chartObj.model._visibleSeries
            if (areaType != "none") {
                elementCollection = chartObj.model._visibleSeries;
                color = chartObj.model.seriesColors;
                borderColor = chartObj.model.seriesBorderColors;
            }
            else {
                var lgth = 0;
                var longest;
                for (var i = 0; i < visibleSeriesLength; i++) {
                    var type = chartObj.model._visibleSeries[i].type.toLowerCase();
                    if (chartObj.model._visibleSeries[i].points.length > lgth) {
                        var lgth = chartObj.model._visibleSeries[i].points.length;
                        longest = chartObj.model._visibleSeries[i].points;
                    }
                    else if (chartObj.model._visibleSeries[i].points.length == lgth && type != "funnel" && type != "pieofpie" && type != "pyramid")
                        longest = chartObj.model._visibleSeries[i].points;
                }
                elementCollection = longest || [];
                color = chartObj.model.pointColors;
                borderColor = chartObj.model.pointBorderColors;
            }
            if (areaType == "none" && visibleSeriesLength > 1) {
                for (var k = 0; k < visibleSeriesLength; k++) {
                    chartObj.model.seriesColors[k] = modelColor[k % count];
                }
            }
            for (var i = 0; i < elementCollection.length; i++) {
                element = elementCollection[i];
                tlines = element.trendlines;
                element.isFill = (element.isFill == undefined) ? ((element.fill && element.fill != "") ? true : false) : element.isFill;
                if (element.isFill) {
                    color[i] = element.fill;
                } else {
                    color[i] = modelColor[i % count];
                    if (!element._hiloTypes)
                        element.fill = color[i];
                }
                if (areaType != "none" && tlines.length > 0)
                    this._initializeTrendlinesColors(tlines, color[i]);
                if (!sf.util.isNullOrUndefined(element.border) && !sf.util.isNullOrUndefined(element.border.color) && element.border.color != "") {
                    borderColor[i] = element.border.color;
                } else {
                    borderColor[i] = chartObj.model.seriesBorderDefaultColors[i % 10];
                    if (areaType != "none")
                        element.border.color = borderColor[i];
                }
                element.dataPoint = element.points;
				element.trendLine = element.trendlines;
            }
        },

        _initializeTrendlinesColors: function (tlines, color) {
            for (var k in tlines) {
                if (sf.util.isNullOrUndefined(tlines[k].fill) || tlines[k].fill == "")
                    tlines[k].fill = color;
            }
        },

        _createAxisLabelAndRange: function () {
            var count = 0,
                model = this.model,
                seriesCollection = model.series,
                seriesLength = seriesCollection.length,
                indicatorSeries,
                series,
                axisScroll,
                scrollRange,
                axis,
                primaryX = model.primaryXAxis,
                primaryY = model.primaryYAxis,
                axesLength;

            for (var i = 0; i < seriesLength; i++) {
                series = seriesCollection[i];
                if (series._isTransposed && this.model.AreaType != "polaraxes")
                    count++;
            }

            if (seriesLength) {
                if (count == seriesLength)
                    model.requireInvertedAxes = true;
                else {
                    series = seriesCollection[0];
                    if (series._isTransposed && this.model.AreaType != "polaraxes")
                        model.requireInvertedAxes = true;
                }
            }
            if (model.requireInvertedAxes) {
                primaryY.orientation = "horizontal";
                primaryX.orientation = "vertical";
                primaryY.labelPlacement = (!(primaryY.labelPlacement)) ? sf.datavisualization.Chart.LabelPlacement.OnTicks : primaryY.labelPlacement;
            }
            else {
                primaryY.orientation = "vertical";
                primaryX.orientation = "horizontal";
            }

            primaryY.name = sf.util.isNullOrUndefined(primaryY.name) ? "SecondaryAxis" : primaryY.name;
            primaryX.name = sf.util.isNullOrUndefined(primaryX.name) ? "PrimaryAxis" : primaryX.name;

            model._axes = [];
            model._axes[0] = primaryX;
            model._axes[1] = primaryY;

            axesLength = model.axes.length;
            indicatorSeries = model.indicators;

            for (var i = 0; i < axesLength; i++) {
                axis = model.axes[i];
                if (axis.name) {
                    //Sets orientation for axes collections
                    for (var j = 0; j < seriesLength; j++) {
                        var type = seriesCollection[j].type.toLowerCase();
                        if (seriesCollection[j].xAxisName == axis.name) {
                            axis.orientation = (type.indexOf("bar") != -1) ? seriesCollection[j].isTransposed ? "horizontal" : "vertical" : seriesCollection[j].isTransposed ? "vertical" : "horizontal";
                            break;
                        }
                        else if (seriesCollection[j].yAxisName == axis.name) {
                            axis.orientation = (type.indexOf("bar") != -1) ? seriesCollection[j].isTransposed ? "vertical" : "horizontal" : seriesCollection[j].isTransposed ? "horizontal" : "vertical";
                            break;
                        }
                    }
                    for (var k = 0; k < indicatorSeries.length; k++) {
                        if (indicatorSeries[k].xAxisName == axis.name) {
                            axis.orientation = "horizontal";
                            break;
                        }
                        else if (indicatorSeries[k].yAxisName == axis.name) {
                            axis.orientation = "vertical";
                            break;
                        }
                    }
                    if (!axis.orientation) continue;
                    if (axis.orientation.toLowerCase() == "horizontal")
                        model.axes[i] = $.extend(true, {}, model.secondaryX, axis);
                    else
                        model.axes[i] = $.extend(true, {}, model.secondaryY, axis);
                    model._axes.push(model.axes[i]);
                }
            }
            for (var k = 0; k < model._axes.length; k++) {
                var axis = this.model._axes[k],
                    axisScrollSetings = axis.scrollbarSettings,
                    scrollRange = axisScrollSetings.range,
                    orientation = axis.orientation.toLowerCase();
                axis.visibleLabels = [];
                axis.range = (axis.range.min == null && axis.range.max == null && axis.range.interval == null) ? null : axis.range;
                axis.setRange = (!(axis.range)) ? false : (sf.util.isNullOrUndefined(axis.setRange)) ? true : axis.setRange;
                axis.setRange = ((axis.actual_Range) || (axis.setRange != false)) ? true : false;
                axis.actualRange = (!(axis.actualRange)) ? (axis.range == null) ? {} : $.extend(true, {}, axis.range) : axis.actualRange;
                axis.visibleRange = (!(axis.visibleRange)) ? (axis.range == null) ? {} : axis.range : axis.visibleRange;
                axis.name = !(axis.name) ? k.toString() : axis.name;
                axis._isScroll = ((axisScrollSetings.visible && (axisScrollSetings.pointsLength != null || scrollRange.min != null || scrollRange.max != null)) || ((model.zooming.enableScrollbar && axisScrollSetings.visible) && (axis.zoomFactor < 1 || axis.zoomPosition > 0)))
                axis._pointsLength = axisScrollSetings.pointsLength;
                if (typeof scrollRange.min == "string" && scrollRange.min.indexOf("/Date(") != -1)
                    scrollRange.min = new Date(parseInt(scrollRange.min.substr(6)));
                if (typeof scrollRange.max == "string" && scrollRange.max.indexOf("/Date(") != -1)
                    scrollRange.max = new Date(parseInt(scrollRange.max.substr(6)));
            }
        },






        _drawTitle: function () {
            var title = this.model.title;
            var margin = this.model.margin;
            var svgWidth = $(this.svgObject).width();
            var measureTitle = sf.EjSvgRender.utils._measureText(title.text, svgWidth - margin.left - margin.right, title.font);
            var elementSpacing = this.model.elementSpacing;
            var modelTitleHeight = (title.text == "" || !title.visible) ? 0 : (measureTitle.height + elementSpacing);
            var margin = margin;
            var areaBounds = this.model.m_AreaBounds;
            var areaType = this.model.AreaType;
            var legendSpace = (this.model.legend.position.toLowerCase() == "left") ? this.model.LegendViewerBounds.Width / 2 : ((this.model.legend.position.toLowerCase() == "right" ? (-this.model.LegendViewerBounds.Width / 2) : 0));
            // Drawing the chart title
            var leftSpace = margin.left + elementSpacing + this.model.border.width;
            var rightSpace = margin.right + elementSpacing + this.model.border.width;
            var collection = this.model.titleWrapTextCollection;

            var titleLocation, textBorderConstant = 1.2,
                titleFontSize = parseInt(title.font.size),
                titleTextHeight = parseInt(title.font.size) * textBorderConstant,
                enableTrim = title.enableTrim, textAnchor,
                maxTitleWidth = title.maximumWidth,
                textAlignment = title.textAlignment.toLowerCase(),
                textOverflow = title.textOverflow.toLowerCase(),
                titleText = title.text,
                isRTL = title.isReversed,
                titleEnable = enableTrim && (textOverflow == "wrap" || textOverflow == "wrapandtrim") && (collection.length > 1) ? true : false;
            if (maxTitleWidth.toString() == 'auto' || maxTitleWidth.toString() == '') {
                maxTitleWidth = (areaBounds.Width * 0.75);
                this.model.titleMaxWidth = maxTitleWidth;
            }
            else
                maxTitleWidth = parseInt(maxTitleWidth);

            var titleWidthEnable = measureTitle.width > maxTitleWidth ? true : false;
            //title trim
            if (enableTrim && titleWidthEnable && textOverflow == "trim") {
                titleText = sf.EjSvgRender.utils._trimText(titleText, maxTitleWidth, title.font);
                this.model.titleTrim = measureTitle = sf.EjSvgRender.utils._measureText(titleText, svgWidth - margin.left - margin.right, title.font);
                this.model.trimTooltip = true;
            }

            if (this.model.trimTooltip && textOverflow == "wrap")
                this.model.trimTooltip = false;

            var textSize = { width: ((this.model.trimTooltip && titleEnable) || collection.length > 1) ? this.model.titleMaxWidth : measureTitle.width, height: (measureTitle.height * (collection.length > 0 ? collection.length - 1 : 1)) };
            if (title.text != "" && title.text != null) {
                if ((title.border.color == 'transparent') && (title.background == 'transparent')) {
                    titleLocation = margin.top + (modelTitleHeight / 2) + (elementSpacing);
                } else {
                    titleLocation = margin.top + (titleTextHeight / 2) + (elementSpacing) + (titleFontSize / 4);
                }
                var locX = ((areaType != "cartesianaxes") ? (svgWidth - margin.left - margin.right) / 2 + (margin.left + legendSpace) : (leftSpace + (svgWidth - rightSpace) / 2)) - textSize.width / 2;

                if (this.model.title.textAlignment.toLowerCase() == "near") {
                    locX = isRTL ? (svgWidth - rightSpace - measureTitle.width) : leftSpace;
                }
                else if (this.model.title.textAlignment.toLowerCase() == "far") {
                    locX = isRTL ? leftSpace : (svgWidth - rightSpace - textSize.width);
                }
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = { title: titleText, location: { x: locX, y: titleLocation }, size: measureTitle };
                this._trigger("titleRendering", commonEventArgs);
                var options = {
                    'id': this.svgObject.id + '_ChartTitleText',
                    'x': commonEventArgs.data.location.x,
                    'y': commonEventArgs.data.location.y,
                    'fill': title.font.color,
                    'font-size': title.font.size,
                    'font-family': title.font.fontFamily,
                    'font-style': title.font.fontStyle,
                    'font-weight': title.font.fontWeight,
                    'opacity': title.font.opacity,
                    'text-anchor': 'start'
                };
                var borderOptions = {
                    'id': this.svgObject.id + '_ChartTitleBorder',
                    'x': commonEventArgs.data.location.x - elementSpacing,
                    'y': commonEventArgs.data.location.y - titleTextHeight + (titleTextHeight / 4),
                    'rx': title.border.cornerRadius,
                    'ry': title.border.cornerRadius,
                    'width': titleEnable && titleWidthEnable ? this.model.titleMaxWidth + (2 * elementSpacing) : measureTitle.width + (2 * elementSpacing),
                    'height': titleEnable && titleWidthEnable ? measureTitle.height * collection.length : titleTextHeight,
                    'fill': title.background,
                    'stroke-width': title.border.width,
                    'stroke': title.border.color,
                    'opacity': title.border.opacity,
                    'class': "e-titleborder"
                };
                this.svgRenderer.drawRect(borderOptions, this.gTitleEle);

                if (titleEnable && titleWidthEnable) {
                    for (var k = 0; k < collection.length; k++) {
                        options.id = this.svgObject.id + '_ChartTitleText_' + k;
                        if (k != 0) options.y = options.y + measureTitle.height;
                        this.svgRenderer.drawText(options, collection[k], this.gTitleEle);
                    }
                }
                else this.svgRenderer.drawText(options, commonEventArgs.data.title, this.gTitleEle);

                this.model._titleLocation = { X: commonEventArgs.data.location.x, Y: commonEventArgs.data.location.y, size: textSize, _height: measureTitle.height };

                this.svgRenderer.append(this.gTitleEle, this.svgObject);
                if (title.subTitle.text != "" && title.subTitle.text && title.subTitle.visible)
                    this._drawSubTitle();
            }
        },



        _getLegendSize: function (series) {

            var legend = this.model.legend,
                symbolSize = legend.itemStyle,
                textSize = sf.EjSvgRender.utils._measureText(series.Text, null, series.Font),
                padding = 10,
                width = symbolSize.width + padding + textSize.width,
                height = Math.max(symbolSize.height, textSize.height);

            return { Width: width, Height: height };

        },

        _getYValues: function (points) {
            var values = [],
                length = points.length;
            for (var i = 0; i < length; i++)
                values.push(points[i].y);
            return values;
        },
        _getXValues: function (points) {
            var values = [],
                length = points.length;
            for (var i = 0; i < length; i++)
                values.push(points[i].xValue);
            return values;
        },




        _drawSubTitle: function () {

            var title = this.model.title;
            var isTitleRTL = title.isReversed;
            var subTitle = title.subTitle;
            var svgWidth = $(this.svgObject).width();
            var measureTitle = sf.EjSvgRender.utils._measureText(title.text, svgWidth - this.model.margin.left - this.model.margin.right, title.font);
            var measuresubTitle = sf.EjSvgRender.utils._measureText(subTitle.text, svgWidth - this.model.margin.left - this.model.margin.right, subTitle.font);

            var textanchor = "middle";
            var subTitleLocation, textBorderConstant = 1.2, titleBorderSpacing = 10, subTitleBorderSpacing = 10, elementSpacing = this.model.elementSpacing,
                subTitleFontSize = parseInt(subTitle.font.size),
                areaBounds = this.model.m_AreaBounds.Width,
                titleTextHeight = parseInt(title.font.size) * textBorderConstant,
                subTitleTextHeight = parseInt(subTitle.font.size) * textBorderConstant,
                modelsubTitleHeight = (subTitle.text == "" || !subTitle.visible) ? 0 : (measuresubTitle.height + elementSpacing),
                enableTrim = subTitle.enableTrim,
                maxSubTitleWidth = subTitle.maximumWidth,
                maxTitleWidth = title.maximumWidth,
                textOverflow = subTitle.textOverflow.toLowerCase(),
                titleTextAlignment = title.textAlignment.toLowerCase(),
                subTitleTextAlignment = subTitle.textAlignment.toLowerCase(),
                titleText = title.text,
                titleEnableTrim = title.enableTrim,
                titleTextOverflow = title.textOverflow.toLowerCase(),
                subTitleText = subTitle.text, locX,
                regionX,
                titleVisibility = titleEnableTrim && (titleTextOverflow == "wrap" || titleTextOverflow == "wrapandtrim") ? true : false,
                titleWidthVisibility,
                subTitleVisibility = enableTrim && (textOverflow == 'wrap' || textOverflow == 'wrapandtrim') ? true : false;

            maxTitleWidth = (maxTitleWidth.toString() == 'auto' || maxTitleWidth.toString() == '') ? (areaBounds * 0.75) : parseInt(maxTitleWidth);
            maxSubTitleWidth = (maxSubTitleWidth.toString() == 'auto' || maxSubTitleWidth.toString() == '') ? (areaBounds * 0.75) : parseInt(maxSubTitleWidth);
            var measureTitle = sf.EjSvgRender.utils._measureText(title.text, svgWidth - this.model.margin.left - this.model.margin.right, title.font);
            var titleWidthEnable = measureTitle.width > maxTitleWidth ? true : false;

            //subtitle trim
            if (enableTrim && measuresubTitle.width > maxSubTitleWidth && textOverflow == "trim") {
                titleText = titleEnableTrim && titleTextOverflow == 'trim' ? sf.EjSvgRender.utils._trimText(titleText, maxTitleWidth, title.font) : titleText;
                subTitleText = sf.EjSvgRender.utils._trimText(subTitleText, maxSubTitleWidth, subTitle.font);
                measureTitle = sf.EjSvgRender.utils._measureText(titleText, $(this.svgObject).width() - this.model.margin.left - this.model.margin.right, title.font);
                measuresubTitle = sf.EjSvgRender.utils._measureText(subTitleText, $(this.svgObject).width() - this.model.margin.left - this.model.margin.right, subTitle.font);
                this.model.subTitleTooltip = true;
            }
            titleWidthVisibility = measureTitle.width > maxTitleWidth;
            // Drawing the chart subtitle

            if (subTitleText != "" && subTitleText != null) {
                if (((this.model.title.border.color == 'transparent') && (this.model.title.background == 'transparent')) || ((this.model.title.subTitle.border.color == 'transparent') && (this.model.title.subTitle.background == 'transparent'))) {
                    subTitleLocation = (modelsubTitleHeight) / 2 + elementSpacing + this.model._titleLocation.Y + this.model._titleLocation._height * (this.model.titleWrapTextCollection ? (this.model.titleWrapTextCollection.length - 1) : 0);
                } else {
                    subTitleLocation = (subTitleTextHeight / 2) + subTitleBorderSpacing + elementSpacing + ((titleVisibility && titleWidthVisibility) ? (measureTitle.height * this.model.titleWrapTextCollection.length) : titleTextHeight) + titleBorderSpacing + (subTitleFontSize / 3);
                }
                var locX = this.model._titleLocation.X + (this.model._titleLocation.size.width / 2);

                if (subTitleTextAlignment == "near") {
                    locX = regionX = isTitleRTL ? this.model._titleLocation.X + this.model._titleLocation.size.width : this.model._titleLocation.X;
                    textanchor = isTitleRTL ? "end" : "start";
                }
                else if (subTitleTextAlignment == "far") {
                    locX = isTitleRTL ? this.model._titleLocation.X : this.model._titleLocation.X + this.model._titleLocation.size.width;
                    textanchor = isTitleRTL ? "start" : "end";

                }
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = { subTitle: subTitleText, location: { x: locX, y: subTitleLocation }, size: measuresubTitle };
                this._trigger("subTitleRendering", commonEventArgs);
                var subTitleYposition = (((title.border.color == 'transparent') && (title.background == 'transparent')) || ((title.subTitle.border.color == 'transparent') && (title.subTitle.background == 'transparent'))) ? commonEventArgs.data.location.y : commonEventArgs.data.location.y - (elementSpacing / 2);

                var options = {
                    'id': this.svgObject.id + '_ChartSubTitleText',

                    'x': commonEventArgs.data.location.x,
                    'y': subTitleYposition,
                    'fill': subTitle.font.color,
                    'font-size': subTitle.font.size,
                    'font-family': subTitle.font.fontFamily,
                    'font-style': subTitle.font.fontStyle,
                    'font-weight': subTitle.font.fontWeight,
                    'opacity': subTitle.font.opacity,
                    'text-anchor': textanchor
                };

                var x, y, subTitleXLocation = commonEventArgs.data.location.x;
                if (textanchor == "start") x = subTitleXLocation - elementSpacing;
                else if (textanchor == "end")
                    x = subTitleVisibility ? subTitleXLocation - elementSpacing - this.model.subTitleMaxWidth : subTitleXLocation - elementSpacing - (measuresubTitle.width);
                else
                    x = subTitleVisibility ? subTitleXLocation - elementSpacing - (this.model.subTitleMaxWidth / 2) : subTitleXLocation - elementSpacing - (measuresubTitle.width / 2);
                y = (((title.border.color == 'transparent') && (title.background == 'transparent')) || ((subTitle.border.color == 'transparent') && (subTitle.background == 'transparent'))) ? commonEventArgs.data.location.y - subTitleTextHeight + (subTitleTextHeight / 4) : commonEventArgs.data.location.y - subTitleTextHeight + (subTitleTextHeight / 4) - (elementSpacing / 2);
                var borderOptions = {
                    'id': this.svgObject.id + '_ChartSubTitleBorder',
                    'x': x,
                    'y': y,
                    'rx': subTitle.border.cornerRadius,
                    'ry': subTitle.border.cornerRadius,
                    'width': subTitleVisibility ? this.model.subTitleMaxWidth + (2 * elementSpacing) : measuresubTitle.width + (2 * elementSpacing),
                    'height': subTitleVisibility ? measuresubTitle.height * this.model.subTitleWrapTextCollection.length : subTitleTextHeight,
                    'fill': subTitle.background,
                    'stroke-width': subTitle.border.width,
                    'stroke': subTitle.border.color,
                    'opacity': subTitle.border.opacity,
                    'class': "e-subtitleborder"
                };

                this.svgRenderer.drawRect(borderOptions, this.gSubTitleEle);

                if (subTitleVisibility && measuresubTitle.width > maxSubTitleWidth) {
                    for (var k = 0; k < this.model.subTitleWrapTextCollection.length; k++) {
                        options.id = this.svgObject.id + '_ChartSubTitleText_' + k;
                        if (k != 0) options.y = options.y + measuresubTitle.height;
                        this.svgRenderer.drawText(options, this.model.subTitleWrapTextCollection[k], this.gSubTitleEle);
                    }

                }
                else this.svgRenderer.drawText(options, commonEventArgs.data.subTitle, this.gSubTitleEle);

                var subSize = { width: (this.model.subTitleTooltip) ? maxSubTitleWidth : measuresubTitle.width, height: (measuresubTitle.height * (this.model.subTitleWrapTextCollection.length)) };
                if (textanchor == "middle")
                    regionX = locX - subSize.width / 2;
                else if (textanchor == "end")
                    regionX = locX - subSize.width;
                this.model._subTitleLocation = { X: regionX, Y: (commonEventArgs.data.location.y - measuresubTitle.height / 2), size: subSize };

                this.svgRenderer.append(this.gSubTitleEle, this.gTitleEle);
            }
        },


        _calculateStackingValues: function (seriesCollection, axis, params) {

            var chartModel = this.model;
            chartModel.stackedValue[axis.name] = [];
            var stackedValue = chartModel.stackedValue[axis.name];
            stackedValue.min = 0;
            stackedValue.max = 0;
            var stackAxes = (!chartModel.requireInvertedAxes) ? chartModel.hAxes : chartModel.vAxes,
                stackAxesLength = stackAxes.length, visiblePointsLength, yValues, stackingGroup,
                seriesLength = seriesCollection.length, visiblePoints,
                lastPosValue, lastNegValue, values, lastValue, currentValue,
                isNul = sf.util.isNullOrUndefined;

            for (var k = 0; k < stackAxesLength; k++) {
                j = 0;
                var lastPosValue = [], lastNegValue = [], firstPositive = [], firstNegative = [],
                    crossing = 0, series, visiblePointIndex;
                for (var i = 0; i < seriesCollection.length; i++) {
                    if (seriesCollection[i]._xAxisName == stackAxes[k].name) {
                        if (seriesCollection[i].type.toLowerCase().indexOf("stacking") != -1 || seriesCollection[i].isStacking) {
                            values = {};
                            values.StartValues = [];
                            values.EndValues = [];
                            stackingGroup = seriesCollection[i].stackingGroup;
                            if (stackingGroup && seriesCollection[i].type.toLowerCase() != "stackingarea") {
                                if (isNul(lastPosValue[stackingGroup])) {
                                    lastPosValue[stackingGroup] = [];
                                    lastNegValue[stackingGroup] = [];
                                    firstPositive[stackingGroup] = [];
                                    firstNegative[stackingGroup] = [];
                                }
                            }

                            else {
                                stackingGroup = "";
                                if (isNul(lastPosValue[stackingGroup])) {
                                    lastPosValue[stackingGroup] = [];
                                    lastNegValue[stackingGroup] = [];
                                    firstPositive[stackingGroup] = [];
                                    firstNegative[stackingGroup] = [];
                                }
                            }
                            series = seriesCollection[i];
                            crossing = this._getXCrossValue(series, stackAxes[k], params);
                            if (typeof (crossing) !== 'number')
                                crossing = 0;
                            visiblePoints = sf.EjSeriesRender.prototype._isVisiblePoints(series);
                            yValues = this._getYValues(series._visiblePoints);
                            visiblePointsLength = visiblePoints.length;
                            for (var j = 0; j < visiblePointsLength; j++) {
                                var lastValue = 0, correction = 0, currentValue = yValues[j];
                                if (isNul(lastPosValue[stackingGroup][series._visiblePoints[j].xValue])) {
                                    lastPosValue[stackingGroup][series._visiblePoints[j].xValue] = crossing;
                                }
                                if (isNul(lastNegValue[stackingGroup][series._visiblePoints[j].xValue])) {
                                    lastNegValue[stackingGroup][series._visiblePoints[j].xValue] = crossing;
                                }
                                if (values.StartValues.length <= j) {
                                    values.StartValues.push(0);
                                    values.EndValues.push(0);
                                }
                                if (currentValue >= 0) {
                                    firstPositive[stackingGroup][j] = firstPositive[stackingGroup][j] == null;
                                    currentValue -= firstPositive[stackingGroup][j] && crossing;
                                    if (series.type.toLowerCase().indexOf("stacking") != -1 || currentValue > 0)
                                        lastValue = lastPosValue[stackingGroup][series._visiblePoints[j].xValue];
                                    else
                                        lastValue = 0;
                                    lastPosValue[stackingGroup][series._visiblePoints[j].xValue] += currentValue;
                                    correction = lastValue < crossing ? crossing - lastValue : 0;
                                    values.StartValues[j] = lastValue + correction;
                                    values.EndValues[j] = currentValue + lastValue;
                                }
                                else {
                                    firstNegative[stackingGroup][j] = firstNegative[stackingGroup][j] == null;
                                    currentValue -= firstNegative[stackingGroup][j] && crossing;
                                    lastValue = lastNegValue[stackingGroup][series._visiblePoints[j].xValue];
                                    lastNegValue[stackingGroup][series._visiblePoints[j].xValue] += currentValue;
                                    values.StartValues[j] = lastValue;
                                    values.EndValues[j] = currentValue + lastValue;
                                    if (crossing < values.EndValues[j]) {
                                        lastNegValue[stackingGroup][series._visiblePoints[j].xValue] = values.StartValues[j];
                                        lastPosValue[stackingGroup][series._visiblePoints[j].xValue] = values.EndValues[j];
                                        firstPositive[stackingGroup][j] = firstPositive[stackingGroup][j] == null;
                                    }
                                }

                                visiblePointIndex = visiblePoints[j].actualIndex;
                                series.points[visiblePointIndex].YValues = [values.EndValues[j]];
                            }
                            values.stackedSeries = true;
                            stackedValue.push(values);
                            if (stackedValue.min > Math.min.apply(0, values.StartValues))
                                stackedValue.min = Math.min.apply(0, values.StartValues);
                            if (stackedValue.max < Math.max.apply(0, values.EndValues))
                                stackedValue.max = Math.max.apply(0, values.EndValues);
                            series.stackedValue = values;
                        }
                    }
                }
            }
        },
        _calculateStackingCumulativeValues: function (seriesCollection, axis, params) {
            this.model.stackedValue[axis.name] = [];
            this.model.stackedValue[axis.name].min = 0;
            this.model.stackedValue[axis.name].max = 0;
            var stackAxes = (!this.model.requireInvertedAxes) ? this.model.hAxes : this.model.vAxes;
            var seriesLength = seriesCollection.length;
            var axesLength = stackAxes.length;
            var percent;
            for (var k = 0; k < axesLength; k++) {
                var posValues = [], negValues = [], frequencies = [], stackingName = " ", firstPositive = [], firstNegative = [], crossing = 0, seriesGroupCount = [];

                //calculate the cumulative frequencies from the collection of series  
                for (var i = 0; i < seriesLength; i++) {
                    var visiblePoints = sf.EjSeriesRender.prototype._isVisiblePoints(seriesCollection[i]);
                    stackingName = seriesCollection[i].stackingGroup;
                    if (seriesCollection[i].type.toLowerCase().indexOf("100") != -1) {
                        if (seriesCollection[i]._xAxisName == stackAxes[k].name) {
                            if (seriesCollection[i].stackingGroup && seriesCollection[i].type.toLowerCase() != " stackingarea100 ") {
                                if (!posValues[stackingName]) {
                                    frequencies[stackingName] = [];
                                    posValues[stackingName] = [];
                                    negValues[stackingName] = [];
                                    firstPositive[stackingName] = [];
                                    firstNegative[stackingName] = [];
                                }
                            }
                            else {
                                seriesCollection[i].stackingGroup = "";
                                stackingName = seriesCollection[i].stackingGroup;
                                if (!posValues[stackingName]) {
                                    frequencies[stackingName] = [];
                                    posValues[stackingName] = [];
                                    negValues[stackingName] = [];
                                    firstPositive[stackingName] = [];
                                    firstNegative[stackingName] = [];
                                }
                            }
                            seriesGroupCount[stackingName] = i;
                            var yValues = this._getYValues(seriesCollection[i]._visiblePoints);
                            var yValuesLength = yValues.length;
                            for (var j = 0; j < yValuesLength; j++) {
                                var getYValue = yValues[j];
                                if (!frequencies[stackingName][seriesCollection[i].points[j].xValue]) {
                                    frequencies[stackingName][seriesCollection[i].points[j].xValue] = 0;
                                }
                                frequencies[stackingName][seriesCollection[i].points[j].xValue] += Math.abs(getYValue);
                            }
                        }
                    }

                }

                //calculate the cumulative percentage for each series points
                for (var i = 0; i < seriesLength; i++) {
                    stackingName = seriesCollection[i].stackingGroup;
                    if (seriesCollection[i].type.toLowerCase().indexOf("100") != -1) {
                        var stackedSeries = false;
                        if (seriesCollection[i]._xAxisName == stackAxes[k].name) {
                            var values = {};
                            values.StartValues = [];
                            values.EndValues = [];
                            var series = seriesCollection[i];
                            crossing = this._getXCrossValue(series, stackAxes[k], params);
                            if (typeof (crossing) !== 'number')
                                crossing = 0;
                            var yValues = this._getYValues(series._visiblePoints);
                            var yValuesLength = yValues.length;
                            for (var j = 0; j < yValuesLength; j++) {
                                var lastValue, correction = 0;
                                var currentValue = yValues[j];

                                //Pecentage calculation for point 
                                percent = (currentValue / frequencies[stackingName][series.points[j].xValue]) * 100
                                currentValue = !isNaN(percent) ? percent : 0;
                                series.points[j].percentage = currentValue.toFixed(2);
                                if (!posValues[stackingName][series.points[j].xValue]) {
                                    posValues[stackingName][series.points[j].xValue] = crossing;
                                }
                                if (!negValues[stackingName][series.points[j].xValue]) {
                                    negValues[stackingName][series.points[j].xValue] = crossing;
                                }
                                if (values.StartValues.length <= j) {
                                    values.StartValues.push(0);
                                    values.EndValues.push(0);
                                }
                                if (currentValue >= 0) {
                                    var posValue = posValues[stackingName][series.points[j].xValue];
                                    firstPositive[stackingName][j] = firstPositive[stackingName][j] == null;
                                    currentValue -= firstPositive[stackingName][j] && crossing;
                                    correction = posValue < crossing ? crossing - posValue : 0;
                                    lastValue = posValue;
                                    posValues[stackingName][series.points[j].xValue] += currentValue;
                                }
                                else {
                                    var negValue = negValues[stackingName][series.points[j].xValue];
                                    firstNegative[stackingName][j] = firstNegative[stackingName][j] == null;
                                    currentValue -= firstNegative[stackingName][j] && crossing;
                                    correction = negValue > crossing ? crossing - negValue : 0;
                                    lastValue = negValue;
                                    negValues[stackingName][series.points[j].xValue] += currentValue;
                                }
                                values.StartValues[j] = lastValue + correction;
                                values.EndValues[j] = lastValue + currentValue;
                                if (values.EndValues[j] > 100) values.EndValues[j] = 100;
                                series.points[j].YValues = [values.EndValues[j]];
                                stackedSeries = seriesGroupCount[stackingName] == i ? false || (stackedSeries) : true;
                            }
                            values.stackedSeries = stackedSeries;
                            this.model.stackedValue[axis.name].push(values);
                            if (this.model.stackedValue[axis.name].min > Math.min.apply(0, values.StartValues))
                                this.model.stackedValue[axis.name].min = Math.min.apply(0, values.StartValues);
                            if (this.model.stackedValue[axis.name].max < Math.max.apply(0, values.EndValues))
                                this.model.stackedValue[axis.name].max = Math.max.apply(0, values.EndValues);
                            if (this.model.stackedValue[axis.name].min > Math.min.apply(0, values.EndValues))
                                this.model.stackedValue[axis.name].min = -100;

                            series.stackedValue = values;
                        }
                    }
                }
            }
        },
        _legendItemBounds: function (itemCount, legendItemWidth, legendItemHeight) {
            var legend = this.model.legend, legVal,
                position = legend.position.toLowerCase(),
                itemPadding = legend.itemPadding,
                legnedHeightIncr, column, legendWidth = 0, legendHeight = 0;
            if (sf.util.isNullOrUndefined(legend.columnCount) && legend.rowCount) {
                legnedHeightIncr = legend.rowCount;
                column = Math.ceil(itemCount / legnedHeightIncr);
                legendWidth = legendItemWidth * column;
                legendHeight = legendItemHeight * legnedHeightIncr;
            }
            else if (sf.util.isNullOrUndefined(legend.rowCount) && legend.columnCount) {
                legnedHeightIncr = Math.ceil(itemCount / legend.columnCount);
                legVal = legend.columnCount;
                legendWidth = legendItemWidth * legVal;
                legendHeight = legendItemHeight * legnedHeightIncr;
            }
            else if ((legend.rowCount) && (legend.columnCount)) {
                if (legend.columnCount < legend.rowCount) {
                    legnedHeightIncr = legend.rowCount;
                    column = Math.ceil(itemCount / legnedHeightIncr);
                    legendWidth = legendItemWidth * column;
                    legendHeight = legendItemHeight * legnedHeightIncr;
                }
                else if (legend.columnCount > legend.rowCount) {
                    if (position === 'top' || position === 'bottom' || position === 'custom') {
                        legnedHeightIncr = Math.ceil(itemCount / legend.columnCount);
                        legVal = legend.columnCount;
                        legendWidth = legendItemWidth * legVal;
                        legendHeight = legendItemHeight * legnedHeightIncr;
                    } else {
                        legnedHeightIncr = Math.ceil(itemCount / legend.columnCount);
                        column = Math.ceil(itemCount / legnedHeightIncr);
                        legendWidth = legendItemWidth * column;
                        legendHeight = legendItemHeight * legnedHeightIncr;
                    }
                }
                else {
                    if (position === 'top' || position === 'bottom' || position === 'custom') {
                        legnedHeightIncr = Math.ceil(itemCount / legend.columnCount);
                        legVal = Math.ceil(itemCount / legend.rowCount);
                        legendWidth = legendItemWidth * legend.columnCount;
                        legendHeight = legendItemHeight * legVal;
                    } else {
                        legnedHeightIncr = legend.rowCount;
                        column = Math.ceil(itemCount / legnedHeightIncr);
                        legendWidth = legendItemWidth * column;
                        legendHeight = legendItemHeight * legnedHeightIncr;
                    }

                }

            }
            legendHeight += this.model.elementSpacing;
            return { LegendWidth: legendWidth, LegendHeight: legendHeight };
        },

        _isEjScroller: function () {
            var chart = this,
                chartModel = chart.model,
                legendContainer = $(chart.legendContainer),
                legend = chartModel.legend;
            if (sf.util.isNullOrUndefined($('#' + legendContainer[0].id).ejScroller))
                legend._ejScroller = false;
            else
                legend._ejScroller = legend.enableScrollbar;
        },

        //legend text wrapping
        _rowsCalculation: function (data, textmaxwidth, textOverflow) {
            var chart = this,
                chartModel = chart.model,
                legend = chartModel.legend,
                word, textCollection = [], currentWidth, nextWidth,
                text = data.legendItem ? data.legendItem.Text.toString() : data.text,
                legendTextCollection = text.split(' '),
                textMaxWidth = textmaxwidth,
                font = data.legendItem ? data.legendItem.LegendStyle.Font : data.font,
                legendTextLength = legendTextCollection.length,
                wordMax = 0;

            for (var i = 0; i < legendTextLength; i++) {
                word = legendTextCollection[i];
                currentWidth = sf.EjSvgRender.utils._measureText(word, null, font).width;
                if (currentWidth <= textMaxWidth) {
                    while (i < legendTextLength) {
                        currentWidth = sf.EjSvgRender.utils._measureText(word, null, font).width;
                        nextWidth = (legendTextCollection[i + 1]) ? sf.EjSvgRender.utils._measureText(legendTextCollection[i + 1], null, font).width : 0;
                        if ((currentWidth + nextWidth) <= textMaxWidth && nextWidth > 0) {
                            word = word.concat(' ' + legendTextCollection[i + 1]);
                            i++;
                        }
                        else {
                            wordMax = Math.max(wordMax, currentWidth);
                            break;
                        }
                    }
                    textCollection.push(word);
                }
                else {
                    if (textOverflow == "wrapandtrim") {
                        word = sf.EjSvgRender.utils._trimText(word, textMaxWidth, font);
                        textCollection.push(word);
                        this.model._legendMaxWidth = textMaxWidth;
                        wordMax = Math.max(wordMax, textMaxWidth);
                        if (!data.legendItem) this.model.trimTooltip = true;
                    }
                    else {
                        textCollection.push(word);
                        if (data.legendItem)
                            this.model._legendMaxWidth = Math.max(this.model._legendMaxWidth, currentWidth);
                        else wordMax = Math.max(wordMax, currentWidth);
                    }
                }
            }
            this.model._legendMaxHeight = Math.max(this.model._legendMaxHeight, textCollection.length);
            return { textCollection: textCollection, wordMax: wordMax };
        },

        _triggerLegendEvent: function (name, color, index) {
            var chart = this,
                chartModel = chart.model,
                legend = chartModel.legend,
                areaType = chartModel.AreaType,
                itemStyle = legend.itemStyle,
                border = itemStyle.border,
                elementSpacing = chartModel.elementSpacing,
                textMaxWidth = legend.textWidth,
                svgRender = sf.EjSvgRender,
                chartSvgRender = chart.svgRenderer,
                seriesLength = chartModel._visibleSeries.length,
                svgObject = chart.svgObject,
                isCanvas = chartModel.enableCanvasRendering,
                elementSpacing = chartModel.elementSpacing,
                textOverflow = legend.textOverflow.toLowerCase(),
                legendItem, legendFont, textWidth, commonEventArgs,
                style = {
                    BorderColor: border.color,
                    BorderWidth: border.width,
                    Opacity: legend.opacity,
                    Color: color,
					Font: $.extend(true, {}, legend.font)
                };

            commonEventArgs = $.extend({}, svgRender.commonChartEventArgs);
            commonEventArgs.data = {
                svgRenderer: chartSvgRender,
                svgObject: svgObject,
                symbolShape: legend.shape,
                legendItem: {
                    Text: name,
                    Shape: legend.shape,
                    LegendStyle: style,
                    SeriesIndex: (areaType == "none" && seriesLength == 1) ? 0 : index,
                },
                style: {
                    ShapeSize: itemStyle,
                    ElementSpace: elementSpacing,
                    Style: style,
                    ID: chart.svgObject.id + '_LegendItemShape' + index,
                    SeriesIndex: (areaType == "none" && seriesLength == 1) ? 0 : index,
                },
                gLegendItemEle: chart.gLegendItemEle
            };
            if (isCanvas)
                commonEventArgs.data.style.context = true;
            chart._trigger("legendItemRendering", commonEventArgs);
            legendItem = commonEventArgs.data.legendItem.Text;
            legendFont = commonEventArgs.data.legendItem.LegendStyle.Font;
            textWidth = sf.EjSvgRender.utils._measureText(legendItem, null, legendFont).width;
            if (textOverflow == "trim") {
                if (textWidth > textMaxWidth) {
                    legendItem = sf.EjSvgRender.utils._trimText(legendItem, textMaxWidth, legendFont);
                    chart.model._legendMaxWidth = textMaxWidth;
                }
            }
            else if (textOverflow == "wrap" || textOverflow == "wrapandtrim") {
                legendItem = chart._rowsCalculation(commonEventArgs.data, textMaxWidth, this.model.legend.textOverflow.toLowerCase()).textCollection;
            }
            return { commonEventArgs: commonEventArgs, legendItem: legendItem };
        },

        _calculateLegendBounds: function () {
            // intialize
            this.model.legendCollection = [];
            this.model.legendTextRegion = [];
            this.model.legendRegion = [];
            this.model.svgHeight = $(this.svgObject).height();
            this.model.svgWidth = $(this.svgObject).width();
            this.model._legendMaxWidth = 0;
            this.model._legendMaxHeight = 0;

            var chart = this,
                chartModel = chart.model,
                math = Math,
                max = math.max,
                min = math.min,
                abs = math.abs,
                legend = chartModel.legend,
                padding = 10,
                legendSizeHeight = legend.size.height,
                legendSizeWidth = legend.size.width,
                isRTL = legend.isReversed,
                itemPadding = legend.itemPadding > 0 ? legend.itemPadding : 0,
                position = legend.position.toLowerCase(),
                width = 0, height = 0,
                svgHeight = chartModel.svgHeight,
                svgWidth = chartModel.svgWidth,
                legendItemWidth = 0,
                legendItemHeight = 0,
                legendWidth = 0,
                legendHeight = 0,
                legnedHeightIncr = 1,
                currentLegend,
                index,
                bounds, legendBounds,
                legendviewerHeight = 0, legendviewerWidth = 0,
                legendHeightTemp, legendWidthTemp,
                tempSeries = {},
                legendSeries = [], trendLineLength, trendLines,
                trendLine, j,
                trendlineType,
                areaType = chartModel.AreaType,
                visibleSeries = chartModel._visibleSeries,
                rowCount = legend.rowCount, point,
                columnCount = legend.columnCount,
                elementSpacing = chartModel.elementSpacing,
                visiblePoints, series,
                length, legendColor, legendName, legendStyleColor, legendSeriesLength, legendContainer, legendSvgContainer,
                titleSize = sf.EjSvgRender.utils._measureText(legend.title.text, null, legend.title.font),
                legendsize, colorGradName, visibleOnLegend,
                vScrollSize = 0, hScrollSize = 0,
                borderSize = chartModel.border.width,
                legendBorder = legend.border.width, type,
                legendInfo, legendStyle, legendFont, shapeWidth,
                textOverflow = legend.textOverflow.toLowerCase(),
                svgObjectHeight = svgHeight - ((elementSpacing * 4) + (borderSize * 2) + (legend.border.width * 2)),
                svgObjectWidth = svgWidth - ((elementSpacing * 4) + (borderSize * 2) + (legendBorder * 2));

            if (visibleSeries && legend.visible && visibleSeries.length != 0) {
                type = visibleSeries[0].type.toLowerCase();
                if (areaType == "none" && visibleSeries.length == 1 || type == 'pieofpie' || type == 'pyramid' || type == 'funnel') {

                    series = visibleSeries[0];
                    visiblePoints = sf.EjSeriesRender.prototype._calculateVisiblePoints(series).legendPoints;
                    length = visiblePoints.length;
                    for (isRTL && (position == "top" || position == "bottom") ? j = length - 1 : j = 0; isRTL && (position == "top" || position == "bottom") ? j >= 0 : j < length; isRTL && (position == "top" || position == "bottom") ? j-- : j++) {
                        legendColor = legend.fill ? (!(legend.fill._gradientStop) ? legend.fill : legend.fill._gradientStop) : chartModel.pointColors[visiblePoints[j].actualIndex];
                        point = visiblePoints[j];
                        legendName = !sf.util.isNullOrUndefined(point.x) ? point.x : 'series' + j;
                        visibleOnLegend = !(point.visibleOnLegend) ? 'visible' : point.visibleOnLegend;
                        if (!point.isEmpty && visibleOnLegend.toLowerCase() == 'visible' && series.visibleOnLegend.toLowerCase() == "visible") {
                            legendInfo = this._triggerLegendEvent(legendName, legendColor, j);
                            legendStyle = legendInfo.commonEventArgs.data.legendItem.LegendStyle;
                            tempSeries = {
                                Text: legendInfo.legendItem,
                                displayText: legendInfo.commonEventArgs.data.legendItem.Text,
                                Font: legendStyle.Font,
                                SeriesIndex: 0,
                                PointIndex: j,
                                ActualIndex: point.actualIndex,
                                fill: legendStyle.Color,
                                visibility: (point.visible !== false) ? 'visible' : 'hidden',
                                Shape: legendInfo.commonEventArgs.data.legendItem.Shape,
                                LegendStyle: legendStyle,
                                CommonEventArgs: { cancel: legendInfo.commonEventArgs.cancel, data: legendInfo.commonEventArgs.data }
                            };
                            legendSeries.push(tempSeries);
                        }
                    }
                }
                else {
                    length = visibleSeries.length;
                    for (isRTL && (position == "top" || position == "bottom") ? j = length - 1 : j = 0; isRTL && (position == "top" || position == "bottom") ? j >= 0 : j < length; isRTL && (position == "top" || position == "bottom") ? j-- : j++) {
                        legendColor = legend.fill ? (!(legend.fill._gradientStop) ? legend.fill : legend.fill._gradientStop) : sf.util.isNullOrUndefined(chartModel.seriesColors[j]) ? chartModel.pointColors[j] : chartModel.seriesColors[j];
                        series = visibleSeries[j];
                        legendName = series.name ? series.name : 'series' + j;
                        if (series.visibleOnLegend.toLowerCase() == "visible") {
                            legendInfo = this._triggerLegendEvent(legendName, legendColor, j);
                            legendStyle = legendInfo.commonEventArgs.data.legendItem.LegendStyle;
                            tempSeries = {
                                Text: legendInfo.legendItem,
                                displayText: legendInfo.commonEventArgs.data.legendItem.Text,
                                Font: legendStyle.Font,
                                SeriesIndex: j,
                                fill: legendStyle.Color,
                                visibility: series.visibility,
                                Shape: legendInfo.commonEventArgs.data.legendItem.Shape,
                                LegendStyle: legendStyle,
                                CommonEventArgs: { cancel: legendInfo.commonEventArgs.cancel, data: legendInfo.commonEventArgs.data }
                            };
                            legendSeries.push(tempSeries);
                        }
                        trendLines = series.trendlines;
                        trendLineLength = trendLines.length;
                        for (var i = 0; i < trendLineLength; i++) {
                            trendLine = trendLines[i];
                            legendColor = legend.fill ? (!(legend.fill._gradientStop) ? legend.fill : legend.fill._gradientStop) : trendLine.fill;
                            legendName = trendLine.name ? trendLine.name : 'series' + j;
                            if (trendLine.visibility != '' && trendLine.visibleOnLegend.toLowerCase() == "visible") {
                                legendInfo = this._triggerLegendEvent(legendName, legendColor, j);
                                legendStyle = legendInfo.commonEventArgs.data.legendItem.LegendStyle;
                                tempSeries = {
                                    Text: legendInfo.legendItem,
                                    displayText: legendInfo.commonEventArgs.data.legendItem.Text,
                                    Font: legendStyle.Font,
                                    SeriesIndex: j,
                                    trendLineIndex: i,
                                    fill: legendStyle.Color,
                                    isTrendLine: true,
                                    visibility: series.visibility.toLowerCase() == "visible" ? trendLine.visibility : "hidden",
                                    Shape: legendInfo.commonEventArgs.data.legendItem.Shape,
                                    LegendStyle: legendStyle,
                                    CommonEventArgs: { cancel: legendInfo.commonEventArgs.cancel, data: legendInfo.commonEventArgs.data }
                                };
                                legendSeries.push(tempSeries);
                            }
                        }
                    }
                }

                legendSeriesLength = legendSeries.length;
                for (var j = 0; j < legendSeriesLength; j++) {
                    currentLegend = legendSeries[j];
                    shapeWidth = currentLegend.CommonEventArgs.data.style.ShapeSize.width;
                    legendsize = chart._getLegendSize(currentLegend);
                    legendItemWidth = max(this.model._legendMaxWidth > 0 ? (this.model._legendMaxWidth + itemPadding + shapeWidth) : legendsize.Width, legendItemWidth);
                    legendItemHeight = max((textOverflow == "wrap" || textOverflow == "wrapandtrim") ? legendsize.Height * this.model._legendMaxHeight : legendsize.Height, legendItemHeight);
                }
                legendHeight = legendItemHeight + elementSpacing * 2;
                legendWidth = legendItemWidth;

                if (columnCount || rowCount) {
                    legendBounds = chart._legendItemBounds(legendSeries.length, legendItemWidth + (itemPadding), legendItemHeight + (itemPadding));
                    legendWidth = legendBounds.LegendWidth;
                    legendHeight = legendBounds.LegendHeight;
                    if (position === 'top' || position === 'bottom' || position === 'custom')
                        legendHeight = legendHeight - itemPadding + elementSpacing;
                    else
                        legendWidth = legendWidth - itemPadding;
                }
                for (var k = 0; k < legendSeriesLength; k++) {
                    currentLegend = legendSeries[k];
                    index = currentLegend.SeriesIndex;
                    series = chartModel.series[index];
                    legendsize = chart._getLegendSize(currentLegend);
                    if (textOverflow == "wrap" || textOverflow == "wrapandtrim") {
                        legendsize.Width = legendItemWidth;
                        legendsize.Height = legendItemHeight;
                    }
                    if (!(rowCount) && !(columnCount)) {

                        if ((position == 'top' || position == 'bottom' || position == 'custom')) {
                            width += legendsize.Width + itemPadding;
                            if (width > svgObjectWidth && k != 0) {
                                width -= legendsize.Width + itemPadding;
                                legendWidth = max(legendWidth, width);
                                width = legendsize.Width + itemPadding;
                                legnedHeightIncr++;
                                legendHeight += legendItemHeight + itemPadding;
                            }
                            else
                                legendWidth = max(legendWidth, width);

                            height = max(height, legendItemHeight);
                        }
                        else {
                            height += legendsize.Height + itemPadding;
                            if (height > svgObjectHeight) {
                                height -= legendsize.Height + itemPadding;
                                legendHeight = max(legendHeight, height);
                                height = legendsize.Height + itemPadding;
                                legendWidth += legendItemWidth + itemPadding;
                            }
                            else
                                legendHeight = max(legendHeight, height);

                            width = max(width, legendItemWidth);
                        }
                    }
                    if (currentLegend.visibility.toLowerCase() == "visible")
                        colorGradName = chart.svgRenderer.createGradientElement('legend' + k, legendSeries[k].fill, 0, 0, 0, svgObjectHeight, chart.gLegendEle);
                    else
                        colorGradName = 'gray';
                    currentLegend.CommonEventArgs.data.legendItem.LegendStyle.Color = colorGradName;
                    bounds = (rowCount || columnCount) ? { Width: legendItemWidth, Height: legendItemHeight } : legendsize;
                    bounds._Width = legendsize.Width;

                    if (currentLegend.isTrendLine) {
                        currentLegend.TrendLineIndex = currentLegend.trendLineIndex;
                        trendlineType = series.trendlines[currentLegend.trendLineIndex].type.toLowerCase();
                        currentLegend.CommonEventArgs.data.legendItem.drawType = currentLegend.drawType = trendlineType == 'linear' || trendlineType == "movingaverage" ? 'line' : 'spline';
                    }
                    legendSeries[k].Bounds = bounds;
                    chartModel.legendCollection.push(currentLegend);
                }

                //LegendBounds calculation Perform here..
                if (position === 'top' || position === 'bottom' || position === 'custom') {
                    legendWidth = titleSize.width > legendWidth - itemPadding ? (titleSize.width + padding * 2 + itemPadding) : legendWidth + padding * 2;
                    width += padding;
                    height += padding * 2;
                    chartModel.LegendBounds = { Width: max(legendWidth, width) - itemPadding, Height: max(legendHeight, height), Rows: legnedHeightIncr };
                }
                else {
                    legendWidth = titleSize.width > legendWidth ? (titleSize.width + padding * 2) : legendWidth + padding * 2;
                    width += padding;
                    height += padding;
                    chartModel.LegendBounds = { Width: max(legendWidth, width), Height: max(legendHeight, height) + padding - itemPadding, Columns: legnedHeightIncr };
                }
                //Calculating legend viewer bounds or calculate user specified legend bounds
                chartModel.LegendViewerBounds = { Width: "0", Height: "0" };

                if (legendSizeHeight == "" || legendSizeHeight == null) {
                    if (position == 'left' || position == 'right' || position == 'custom')
                        legendHeightTemp = abs(svgHeight);
                    else
                        legendHeightTemp = abs((svgHeight / 100) * parseInt('20%'));
                    chartModel.LegendViewerBounds.Height = min(legendHeightTemp, chartModel.LegendBounds.Height);
                }
                else {
                    if (legendSizeHeight.indexOf("%") != -1)
                        chartModel.LegendViewerBounds.Height = abs((svgHeight / 100) * parseInt(legendSizeHeight));
                    else
                        chartModel.LegendViewerBounds.Height = parseInt(legendSizeHeight);
                }

                if (legendSizeWidth == "" || legendSizeWidth == null) {
                    if (position == 'top' || position == 'bottom' || position == 'custom')
                        legendWidthTemp = abs(svgWidth);
                    else
                        legendWidthTemp = abs((svgWidth / 100) * parseInt('20%'));
                    chartModel.LegendViewerBounds.Width = min(legendWidthTemp, chartModel.LegendBounds.Width);
                }
                else {
                    if (legendSizeWidth.indexOf("%") != -1)
                        chartModel.LegendViewerBounds.Width = abs((svgWidth / 100) * parseInt(legendSizeWidth));
                    else
                        chartModel.LegendViewerBounds.Width = parseInt(legendSizeWidth);
                }
            }
            else {
                chartModel.LegendBounds = { Width: 0, Height: 0 };
                chartModel.LegendViewerBounds = { Width: 0, Height: 0 };
            }
            legendContainer = $(chart.legendContainer);
            legendSvgContainer = $(chart.legendSvgContainer);
            if (legend.enableScrollbar) {
                chartModel.LegendActualBounds = chartModel.LegendViewerBounds;
                legendContainer.removeAttr("style");
                legendContainer.css({ "visibility": 'hidden', "width": chartModel.LegendViewerBounds.Width, "height": chartModel.LegendViewerBounds.Height });
                legendSvgContainer.css({ "height": chartModel.LegendBounds.Height, "width": chartModel.LegendBounds.Width });

                if (legend._ejScroller) {
                    if (legend._ejScroller && isRTL) {
                        legendContainer.addClass("e-rtl");
                    }
                    $('#' + legendContainer[0].id).ejScroller({ width: chartModel.LegendViewerBounds.Width, height: chartModel.LegendViewerBounds.Height })
                }
                else {
                    legendContainer.css({ "overflow": "scroll" });
                    if(legendContainer.hasClass("e-rtl"))
                        legendContainer.removeClass("e-rtl");
                }

                if (chartModel.LegendBounds.Width > chartModel.LegendViewerBounds.Width && chartModel.LegendBounds.Height > chartModel.LegendViewerBounds.Height) {
                    if (legend._ejScroller) {
                        hScrollSize = $('.e-hscrollbar').height() || 0;
                        vScrollSize = $('.e-vscrollbar').width() || 0;
                    } else {
                        legendContainer.css({ "overflow": "scroll" });
                        hScrollSize = legendContainer[0].offsetHeight - (legendBorder * 2) - legendContainer[0].clientHeight;
                        vScrollSize = legendContainer[0].offsetWidth - (legendBorder * 2) - legendContainer[0].clientWidth;
                    }
                } else if (chartModel.LegendBounds.Width > chartModel.LegendViewerBounds.Width) {
                    if (legend._ejScroller) {
                        hScrollSize = $('.e-hscrollbar').height() || 0;
                        vScrollSize = 0;
                    }
                    else {
                        legendContainer[0].style.overflowX = "scroll";
                        legendContainer[0].style.overflowY = "hidden";
                        hScrollSize = legendContainer[0].offsetHeight - (legendBorder * 2) - legendContainer[0].clientHeight;
                        vScrollSize = 0;
                    }
                } else if (chartModel.LegendBounds.Height > chartModel.LegendViewerBounds.Height) {
                    if (legend._ejScroller) {
                        hScrollSize = 0;
                        vScrollSize = $('.e-vscrollbar').width();
                    }
                    else {
                        legendContainer[0].style.overflowY = "scroll";
                        legendContainer[0].style.overflowX = "hidden";
                        hScrollSize = 0;
                        vScrollSize = legendContainer[0].offsetWidth - (legendBorder * 2) - legendContainer[0].clientWidth;
                    }
                }

            }
            else {
                chartModel.LegendActualBounds = chartModel.LegendBounds;
                if (legendSizeWidth != "" && legendSizeWidth != null)
                    chartModel.LegendActualBounds.Width = parseInt(legendSizeWidth);
                if (legendSizeHeight != "" && legendSizeHeight != null)
                    chartModel.LegendActualBounds.Height = parseInt(legendSizeHeight);
            }
            chartModel.LegendActualBounds.Height += Math.abs(hScrollSize);
            chartModel.LegendActualBounds.Width += Math.abs(vScrollSize);
            chartModel.LegendActualBounds.hScrollSize = hScrollSize;
            chartModel.LegendActualBounds.vScrollSize = vScrollSize;
        },

        GetPointXYOrgin: function (x, y, orginX, orginY) {

            var xvalue = ((x - orginX) / (this.model.axes.PrimaryXaxis.visibleRange.max - orginX)) * (this.model.m_AreaBounds.Width);
            var yvalue = ((y - orginY) / (this.model.axes.PrimaryYaxis.visibleRange.max - orginY)) * (this.model.m_AreaBounds.Height - this.GetPointXY(this.model.axes.PrimaryXaxis.visibleRange.min, Math.max(this.model.axes.PrimaryYaxis.visibleRange.min, 0)).Y);

            return { X: xvalue, Y: yvalue };
        },

        _wrap: function (axis, gap, labelText, textOverflow, font, textSize) {
            var text = labelText, textWidth = textSize.width, textCollection = [], unTrimmedText = [], textLength = text.length,
                line = 0, i = 0, labelCollection = labelText.split(' '), labelCollectionLength = labelCollection.length, currentTextCollextion;
            if (textOverflow == 'wrap') {
                if (textWidth > gap) {
                    for (var w = 1; w <= text.length; w++) {
                        labelText = text.substring(0, w);
                        textWidth = sf.EjSvgRender.utils._measureText(labelText, null, font).width;
                        if (textWidth > gap) {
                            line = line + 1; // To find the no of rows splitted
                            labelText = text.substring(0, w - 1);
                            textCollection[i] = labelText;
                            text = text.slice(w - 1, textLength);
                            currentTextCollextion = text.split(' ');
                            text = labelCollection.indexOf(currentTextCollextion[0]) > -1 ? text : '-' + text;
                            var newTextWidth = sf.EjSvgRender.utils._measureText(labelText, null, font).width;
                            i++;
                            w = 0;
                        }
                    }
                }
                textCollection[i] = labelText;
            }
            else if (textOverflow == "wrapandtrim") {
                var max = 0, word, currentWidth, nextWidth;
                for (var i = 0; i < labelCollectionLength; i++) {
                    word = labelCollection[i];
                    currentWidth = sf.EjSvgRender.utils._measureText(word, null, font).width;
                    if (currentWidth < gap && textWidth > gap) {
                        while (i < labelCollectionLength) {
                            currentWidth = sf.EjSvgRender.utils._measureText(word, null, font).width;
                            nextWidth = (labelCollection[i + 1]) ? sf.EjSvgRender.utils._measureText(labelCollection[i + 1], null, font).width : 0;
                            if ((currentWidth + nextWidth) <= gap && nextWidth > 0) {
                                word = word.concat(' ' + labelCollection[i + 1]);
                                i++;
                            }
                            else {
                                // find the maximum width of the lines
                                max = Math.max(max, currentWidth);
                                break;
                            }
                        }
                        textCollection.push(word);
                    }
                    else {
                        if (textWidth > gap) {
                            unTrimmedText.push(word);
                            word = sf.EjSvgRender.utils._trimText(word, gap, font);
                            newTextWidth = sf.EjSvgRender.utils._measureText(word, null, font).width;
                            max = Math.max(max, newTextWidth)
                            textCollection.push(word);
                        } else {
                            textCollection.push(labelText);
                            break;
                        }
                    }
                }
            }
            return { text: textCollection, unTrimmedText: unTrimmedText };
        },

        // to get the size of multi level labels
        getMultiLevelLabelSize: function (axis) {
            var value = 0;
            axis._multiLevelLabelHeight = 0;

            // declaration
            var grpLabelArr = [], multiLevelLabelHeight = [], prevHeight = [], grpLabelLength = axis.multiLevelLabels.length,
                range = axis.visibleRange, grpLabel, level, i, startX, endX, labelSize, gap, height, padding = 10, textCollection, axisValue, borderStyle, greaterIndex, textOverflow,
                orientation = axis.orientation.toLowerCase(), braceFlag = [];
            if (orientation == "vertical")
                axisValue = axis.length;
            else
                axisValue = axis.width ? axis.width : (this.model.primaryYAxis.AxisMaxWidth ? axis.length - this.model.primaryYAxis.AxisMaxWidth : axis.length);
            for (i = 0; i < grpLabelLength; i++) {
                grpLabel = axis.multiLevelLabels[i] = grpLabelArr[i] = $.extend(true, {}, this.model.multiLevelLabelsDefault, axis.multiLevelLabels[i]);
                borderStyle = grpLabel.border.type.toLowerCase();
                level = grpLabel.level;
                if (grpLabel.visible && grpLabel.text != "" && !sf.util.isNullOrUndefined(grpLabel.start) && !sf.util.isNullOrUndefined(grpLabel.end)) {
                    startX = Math.ceil(sf.EjSvgRender.utils._getPointXY(grpLabel.start, range, axis.isInversed) * (axisValue));
                    endX = Math.ceil(sf.EjSvgRender.utils._getPointXY(grpLabel.end, range, axis.isInversed) * (axisValue));
                    labelSize = sf.EjSvgRender.utils._measureText(grpLabel.text, null, grpLabel.font);
                    textOverflow = grpLabel.textOverflow.toLowerCase();
                    gap = sf.util.isNullOrUndefined(grpLabel.maximumTextWidth) ? endX - startX : grpLabel.maximumTextWidth;
                    height = orientation == "vertical" ? (grpLabel.maximumTextWidth ? grpLabel.maximumTextWidth : labelSize.width) : labelSize.height;
                    height += 2 * grpLabel.border.width;
                    if (labelSize.width > gap - padding && (textOverflow == "wrap" || textOverflow == "wrapandtrim")) {   // for wrap
                        textCollection = this._wrap(axis, gap - padding, grpLabel.text, textOverflow, grpLabel.font, labelSize);
                        textCollection = textCollection["text"];
                        height = orientation == "vertical" ? gap - padding : (height * (textCollection.length));
                    }
                    if (sf.util.isNullOrUndefined(multiLevelLabelHeight[level]))
                        multiLevelLabelHeight[level] = height;
                    else
                        multiLevelLabelHeight[level] = multiLevelLabelHeight[level] < height ? height : multiLevelLabelHeight[level];
                }
            }
            // to sort based on level
            grpLabelArr.sort(function (a, b) {
                return parseFloat(a.level) - parseFloat(b.level);
            });
            axis.multiLevelLabels.sort(function (a, b) {
                return parseFloat(a.level) - parseFloat(b.level);
            });
            // to modify the level
            for (var j = 0; j < grpLabelArr.length; j++) {
                if (j == 0) {
                    axis.multiLevelLabels[j]._level = grpLabelArr[j]._level = 0;
                    greaterIndex = 0;
                }
                else if (grpLabelArr[j].level > greaterIndex + 1) {
                    axis.multiLevelLabels[j]._level = grpLabelArr[j]._level = greaterIndex + 1;
                    greaterIndex = grpLabelArr[j]._level;
                }
                else {
                    axis.multiLevelLabels[j]._level = grpLabelArr[j]._level = grpLabelArr[j].level;
                    greaterIndex = grpLabelArr[j].level > greaterIndex ? grpLabelArr[j].level : greaterIndex;
                }
                if (borderStyle == "curlybrace")
                    braceFlag[axis.multiLevelLabels[j]._level] = true;
            }
            // to find the sum
            for (var i = 0; i < multiLevelLabelHeight.length; i++) {
                prevHeight[i] = value;
                if (!sf.util.isNullOrUndefined(multiLevelLabelHeight[i])) {
                    value = borderStyle == "brace" ? value + multiLevelLabelHeight[i] : value + multiLevelLabelHeight[i] + padding / 2;
                    if (braceFlag[i]) {
                        value += padding;
                        multiLevelLabelHeight[i] += padding;
                    }
                }
                else {
                    multiLevelLabelHeight.splice(i, 1);
                    i--;
                }
            }
            axis._multiLevelLabelHeight = value;
            axis.multiLevelLabelHeight = multiLevelLabelHeight;
            axis.prevHeight = prevHeight;

            return value;
        },

        _saturationColor: function (color, lum) {

            // validate hex string
            color = this.colorNameToHex(color);
            color = String(color).replace(/[^0-9a-f]/gi, '');
            if (color.length < 6) {
                color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];
            }
            lum = lum || 0;

            // convert to decimal and change luminosity
            var rgb = "#", c, i;
            for (i = 0; i < 3; i++) {
                c = parseInt(color.substr(i * 2, 2), 16);
                c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
                rgb += ("00" + c).substr(c.length);
            }

            return rgb;
        },

        _drawChartAreaRect: function () {

            var fillColor = !(this.model.background && this.model.background._gradientStop) ? this.model.background : 'url(#' + this.svgObject.id + '_backGradient)';

            if (this.model.backGroundImageUrl)
                fillColor = 'transparent';

            var chartBorder = this.model.border;
            var options = {
                'id': this.svgObject.id + '_SvgRect',
                'x': chartBorder.width / 2,
                'y': chartBorder.width / 2,
                'width': $(this.svgObject).width() - (2 * chartBorder.width),
                'height': $(this.svgObject).height() - (2 * chartBorder.width),
                'fill': fillColor,
                'opacity': chartBorder.opacity,
                'stroke-width': chartBorder.width,
                'stroke': chartBorder.color,
                'class': "e-chartborder"
            };
            this.svgRenderer.drawRect(options, this.svgObject);



            if (this.model.backGroundImageUrl)
                this._drawBackImage();

            if (this.model.AreaType == 'cartesianaxes' && !this.model.enable3D) {
                var borderOptions = {
                    'id': this.svgObject.id + '_ChartArea',
                    'x': this.model.m_AreaBounds.X,
                    'y': this.model.m_AreaBounds.Y,
                    'width': this.model.m_AreaBounds.Width,
                    'height': this.model.m_AreaBounds.Height,
                    'fill': this.model.chartArea.background,
                    'stroke-width': this.model.chartArea.border.width,
                    'opacity': this.model.chartArea.border.opacity,
                    'stroke': this.model.chartArea.border.color,
                    'class': "e-chartareaborder"
                };
                this.svgRenderer.drawRect(borderOptions, this.svgObject);


            }

        },
        axesIndexCount: function (axis, index) {
            var vRowcount = [];
            for (var k = 0; k < axis.length; k++) {
                var currentAxis = axis[k];
                if (currentAxis.orientation.toLowerCase() == "vertical") {
                    if (currentAxis.rowIndex == index)
                        vRowcount.push(currentAxis);
                }
                else {
                    if (currentAxis.columnIndex == index)
                        vRowcount.push(currentAxis);
                }
            }
            return vRowcount;
        },
        axesCount: function (axis) {
            var vRowcount = [], indexValue = [], definitionsLength = 0;
            var chartModel = this.model;
            $.each(axis, function (index, currentAxis) {
                if (currentAxis.orientation.toLowerCase() == "vertical") {
                    definitionsLength = (chartModel.rowDefinitions) ? chartModel.rowDefinitions.length : 0;
                    if (index == 0) vRowcount.push({ axis: currentAxis, index: currentAxis.rowIndex });
                    else if (currentAxis.rowIndex != vRowcount[vRowcount.length - 1].axis.rowIndex)
                        vRowcount.push({ axis: currentAxis, index: currentAxis.rowIndex });
                }
                else {
                    definitionsLength = (chartModel.columnDefinitions) ? chartModel.columnDefinitions.length : 0;
                    if (index == 0) vRowcount.push({ axis: currentAxis, index: currentAxis.columnIndex });
                    else if (currentAxis.columnIndex != vRowcount[vRowcount.length - 1].axis.columnIndex)
                        vRowcount.push({ axis: currentAxis, index: currentAxis.columnIndex });
                }
            });
            var length = vRowcount.length;
            if (definitionsLength > length) {
                length = definitionsLength;
                for (var l = 0; l < definitionsLength; l++)
                    indexValue.push(l);
            } else {
                for (var i = 0; i < length; i++)
                    indexValue.push(vRowcount[i].index);
            }

            return { length: length, indexValue: indexValue };

        },

        //Calculate position for each vertical axis
        _calRowSize: function () {
            var start = 0;
            var yaxisOrign = [];
            var totalRealLength = 0;
            var orginY = this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height;
            //Caluculate size for rowdefinitions values
            if (this.model._rowDefinitions[0].rowDefinitions != null) {
                for (var i = 0, rowMax = this.model._rowDefinitions.length; i < rowMax; i++) {
                    var rowDef = this.model._rowDefinitions[i].rowDefinitions;
                    rowDef.rowHeight = Math.abs(rowDef.rowHeight);
                    var realLength = 0;
                    if (rowDef.unit.toLowerCase() == "percentage") {
                        var length = this._axisRowDefinitionSize(this.model.rowDefinitions);
                        realLength = Math.floor((this.model.m_AreaBounds.Height) * (rowDef.rowHeight / length));
                    }
                    else
                        realLength = rowDef.rowHeight;
                    if (i == 0) yaxisOrign.push(orginY);

                    yaxisOrign.push((orginY - realLength - totalRealLength));
                    totalRealLength += realLength;


                }

            }
            //Calculate size based on chart area size
            else {
                var height = Math.floor((this.model.m_AreaBounds.Height) / this.model._rowDefinitions.length);

                for (start = (orginY); start >= this.model.m_AreaBounds.Y; start = start - height) {
                    yaxisOrign.push(start);
					height = !height ? 1 : height;
                }
				if(yaxisOrign.length && yaxisOrign.length <= 1)
					yaxisOrign.push(start);
            }
            return yaxisOrign;
        },

        //Calculate position for each horizontal axis
        _calColumnSize: function () {
            var xaxisOrign = [];
            var orginX = this.model.m_AreaBounds.X;
            var areaWidth = this.model.m_AreaBounds.Width;
            var totalRealLength = 0;
            var columnDef = this.model._columnDefinitions;
            //Caluculate size for columndefinitions values
            if (columnDef[0].columnDefinitions != null) {
                for (var i = 0, max = columnDef.length; i < max; i++) {
                    var rowDef = columnDef[i].columnDefinitions;
                    rowDef.columnWidth = Math.abs(rowDef.columnWidth);
                    var realLength;
                    if (rowDef.unit.toLowerCase() == "percentage") {
                        var length = this._axisColumnDefinitionSize(this.model.columnDefinitions);
                        realLength = Math.floor((areaWidth) * (rowDef.columnWidth / length));
                    }
                    else
                        realLength = rowDef.columnWidth;
                    if (i == 0) xaxisOrign.push(orginX);

                    xaxisOrign.push((orginX + realLength + totalRealLength));
                    totalRealLength += realLength;
                }
            }
            //Caluculate size based on chart area size
            else {
                var width = Math.floor((areaWidth) / columnDef.length);
                for (var start = orginX, maxStart = orginX + areaWidth; start <= maxStart; start = start + width) {
                    xaxisOrign.push(start);
					width = !width ? 1 : width;
                }
				if(xaxisOrign.length && xaxisOrign.length <=1)
					xaxisOrign.push(start);
            }
            return xaxisOrign;
        },

        //Calculate position and size for each axis
        _calculateAxisSize: function (params) {

            //For Horizontal
            var isInitAxes = true, isOppInitAxes = true;
            var xaxisOrign = this._calColumnSize();
            var columnDefinition = this.model._columnDefinitions;
            for (var i = 0, maxLength = columnDefinition.length; i < maxLength; i++) {
                var x1 = xaxisOrign[i];
                var x2 = xaxisOrign[i + 1];
                var nearIndexVal = 0;
                var farIndexVal = 0;;
                var isColFirstAxes = true, isColOppFirstAxes = true;
                var oppY = this.model.m_AreaBounds.Y;
                var norY = oppY + this.model.m_AreaBounds.Height;
                for (var j = 0, maxCol = columnDefinition[i].axis.length; j < maxCol; j++) {
                    var currentColAxis = columnDefinition[i].axis[j];
                    var realY = 0, axisColumnSpace = 0;
                    var opposedPosition = currentColAxis._opposed;
                    if (!params.axes[currentColAxis.name]._validCross) {
                        if (!opposedPosition) {
                            if (!(isColFirstAxes && (isInitAxes || nearIndexVal == 0))) {
                                axisColumnSpace = columnDefinition.nearSizes[nearIndexVal];
                                realY = norY = (norY + axisColumnSpace);
                                nearIndexVal++;
                            }
                            else {
                                realY = norY;
                                isColFirstAxes = false;
                            }

                        } else {
                            if (!(isColOppFirstAxes && (isOppInitAxes || farIndexVal == 0))) {
                                axisColumnSpace = columnDefinition.farSizes[farIndexVal];
                                realY = oppY = (oppY - axisColumnSpace);
                                farIndexVal++;
                            }
                            else {
                                realY = oppY;
                                isColOppFirstAxes = false;
                            }
                        }
                    }
                    if (currentColAxis.columnSpan) {
                        //Skip the axis size calculation for duplicate span axis
                        if (!(columnDefinition[i].index == currentColAxis.columnIndex))
                            continue;
                        var axisSize = (maxLength >= (i + currentColAxis.columnSpan)) ? i + currentColAxis.columnSpan : i + 1;
                        x2 = xaxisOrign[axisSize];
                        if (!opposedPosition && nearIndexVal == 0) isInitAxes = isColFirstAxes;
                        if (opposedPosition && farIndexVal == 0) isOppInitAxes = isColOppFirstAxes;
                    } else {
                        x2 = xaxisOrign[i + 1];
                        isInitAxes = true;
                        isOppInitAxes = true;
                    }

                    currentColAxis.Location = {};
                    currentColAxis.Location.X1 = x1 + currentColAxis.plotOffset;
                    currentColAxis.Location.Y1 = realY;
                    currentColAxis.Location.X2 = x2 - currentColAxis.plotOffset;
                    currentColAxis.Location.Y2 = realY;
                    currentColAxis.x = currentColAxis.Location.X1;
                    currentColAxis.y = currentColAxis.Location.Y1;
                    currentColAxis.width = (currentColAxis.Location.X2 - currentColAxis.Location.X1);
                    currentColAxis.height = currentColAxis.Location.Y2 - currentColAxis.Location.Y1;

                }
            }

            //For Vertical
            isInitAxes = true, isOppInitAxes = true;
            var yaxisOrign = this._calRowSize();
            var rowDefinition = this.model._rowDefinitions;
            for (var i = 0, rowLength = rowDefinition.length; i < rowLength; i++) {
                var y1 = yaxisOrign[i];
                var y2 = yaxisOrign[i + 1];
                var nearIndex = 0;
                var farIndex = 0;
                var isFirstAxes = true, isOppFirstAxes = true;
                var x = this.model.m_AreaBounds.X;
                var norX = x, oppX = x + this.model.m_AreaBounds.Width;
                for (var j = 0, maxRow = rowDefinition[i].axis.length; j < maxRow; j++) {
                    var axisSpace = 0;
                    var realX = 0;

                    var currentAxis = rowDefinition[i].axis[j];
                    var opposedPosition = currentAxis._opposed;
                    if (!params.axes[currentAxis.name]._validCross) {
                        if (!opposedPosition) {
                            if (!(isFirstAxes && (isInitAxes || nearIndex == 0))) {
                                axisSpace = rowDefinition.nearSizes[nearIndex];
                                realX = norX = (norX - axisSpace);
                                nearIndex++;
                            } else {
                                realX = x;
                                isFirstAxes = false;
                            }

                        } else {
                            if (!(isOppFirstAxes && (isOppInitAxes || isOppInitAxes == 0))) {
                                axisSpace = rowDefinition.farSizes[farIndex];
                                realX = oppX = (oppX + axisSpace);
                                farIndex++;
                            } else {
                                realX = oppX;
                                isOppFirstAxes = false;
                            }
                        }
                    }
                    if (currentAxis.rowSpan) {
                        //Skip the axis size calculation for duplicate span axis
                        if (!(rowDefinition[i].index == currentAxis.rowIndex))
                            continue;
                        var axisRowSize = (rowLength >= (i + currentAxis.rowSpan)) ? i + currentAxis.rowSpan : i + 1;
                        y2 = yaxisOrign[axisRowSize];
                        if (!opposedPosition && nearIndex == 0) isInitAxes = isFirstAxes;
                        if (opposedPosition && farIndex == 0) isOppInitAxes = isOppFirstAxes;
                    } else {
                        y2 = yaxisOrign[i + 1];
                        isInitAxes = true;
                        isOppInitAxes = true;
                    }
                    currentAxis.Location = {};
                    currentAxis.Location.X1 = realX;
                    currentAxis.Location.Y1 = y1 - currentAxis.plotOffset;
                    currentAxis.Location.X2 = realX;
                    currentAxis.Location.Y2 = y2 + currentAxis.plotOffset;
                    currentAxis.x = currentAxis.Location.X1;
                    currentAxis.y = currentAxis.Location.Y2;
                    currentAxis.height = (currentAxis.Location.Y1 - currentAxis.Location.Y2);
                    currentAxis.width = currentAxis.axisLine.width;

                }
            }
        },

        //Validates whether provided crossing value is valid or not
        _validateCrossing: function (axis) {
            axis._opposedPosition = false;
            if (axis.crossesAt != null) {
                var crossAxis = this._getCrossAxis(this.model._axes, axis.orientation.toLowerCase() == 'horizontal', axis.crossesInAxis);
                axis._crossValue = this._getCrossValue(axis, crossAxis, crossAxis._valueType);
                if ((crossAxis.isInversed ? !axis.opposedPosition : axis.opposedPosition) ? axis._crossValue <= crossAxis.visibleRange.min : axis._crossValue >= crossAxis.visibleRange.max)
                    axis._opposedPosition = true;
                return (crossAxis.visibleRange.min < axis._crossValue && crossAxis.visibleRange.max > axis._crossValue);
            }
            return false;
        },

        //Method to place axis at crossed location
        _axisCrossing: function (axis, locateAxis, params) {
            var hor = axis.orientation.toLowerCase() == 'horizontal';
            var crossAxis = this._getCrossAxis(this.model._axes, hor, axis.crossesInAxis);
            var crossValue = axis._crossValue;
            var delta = Math.abs((crossAxis.isInversed ? crossAxis.visibleRange.max : crossAxis.visibleRange.min) - crossValue);
            this._locateAxis(axis, crossAxis, hor, delta);
            if (!locateAxis)
                params._crossAxisOverlap = this._avoidOverlapping(axis, this.model.m_AreaBounds, hor, axis.opposedPosition, params) || params._crossAxisOverlap;
        },

        _locateAxis: function (axis, crossAxis, hor, delta) {
            var loc = (hor ? crossAxis.height : crossAxis.width) * delta / crossAxis.visibleRange.delta;
            if (hor)
                axis.y = crossAxis.y + crossAxis.height - loc;
            else
                axis.x = crossAxis.x + loc;
        },

        _avoidOverlapping: function (axis, bounds, hor, opposed, params) {
            var diff = 0;
            var axisbounds = axis.showNextToAxisLine ? params.axes[axis.name]._bounds : 0;
            if (hor) {
                if (!opposed && axis.y + axisbounds > bounds.Y + bounds.Height) {
                    bounds.Height -= diff = axis.y + axisbounds - bounds.Y - bounds.Height;
                    this._recalculateSpace(axis, hor, opposed, diff);
                    return true;
                }
                else if (opposed && axis.y - axisbounds < bounds.Y) {
                    bounds.Y += diff = axisbounds - (axis.y - bounds.Y);
                    bounds.Height -= diff;
                    this._recalculateSpace(axis, hor, opposed, diff);
                    return true;
                }
            }
            else {
                if (!opposed && axis.x - axisbounds < bounds.X) {
                    bounds.X += diff = axisbounds - (axis.x - bounds.X);
                    bounds.Width -= diff;
                    this._recalculateSpace(axis, hor, opposed, diff);
                    return true;
                }
                else if (opposed && axis.x + axisbounds > bounds.X + bounds.Width) {
                    bounds.Width -= diff = axis.x + axisbounds - bounds.X - bounds.Width;
                    this._recalculateSpace(axis, hor, opposed, diff);
                    return true;
                }
                else if (axis.labelPosition == "inside" && axis.x + axisbounds > bounds.X + bounds.Width) {
                    bounds.Width -= diff = axis.x + axisbounds - bounds.X - bounds.Width;
                    this._recalculateSpace(axis, hor, opposed, diff, axis.showNextToAxisLine);
                    return true;
                }
            }
        },

        _recalculateSpace: function (axis, isHor, opposed, diff, isCrossing) {
            if (isHor) {
                var def = this.model._rowDefinitions;
                var index = opposed ? def.length - 1 : 0;
                for (var i = 0, len = def[index].axis.length; i < len; i++) {
                    def[index].axis[i].height -= diff;
                    def[index].axis[i].Location.Y2 -= diff;
                    if (opposed)
                        def[index].axis[i].Location.Y1 = def[index].axis[i].y += diff;
                }
                var colIndex = axis.columnIndex;
                def = this.model._columnDefinitions
                for (var i = 0, len = def.length; i < len; i++)
                    if (i !== colIndex)
                        for (var j = 0, length = def[i].axis.length; j < length; j++)
                            if (def[i].axis[j]._opposed === opposed)
                                def[i].axis[j].Location.Y1 = def[i].axis[j].Location.Y2 = def[i].axis[j].y += (opposed ? 1 : -1) * diff;
            }
            else {
                var def = this.model._columnDefinitions;
                var index = opposed ? def.length - 1 : 0;
                for (var i = 0, len = def[index].axis.length; i < len; i++) {
                    def[index].axis[i].width -= diff;
                    if (!isCrossing) {
                        if (opposed)
                            def[index].axis[i].Location.X2 -= diff;
                        else
                            def[index].axis[i].Location.X1 = def[index].axis[i].x += diff;
                    }

                }
                var rowIndex = axis.rowIndex;
                def = this.model._rowDefinitions
                for (var i = 0, len = def.length; i < len; i++)
                    if (i !== rowIndex)
                        for (var j = 0, length = def[i].axis.length; j < length; j++)
                            if (def[i].axis[j]._opposed === opposed)
                                def[i].axis[j].Location.X1 = def[i].axis[j].Location.X2 = def[i].axis[j].x += (opposed ? -1 : 1) * diff;
            }
        },

        _getCrossValue: function (axis, crossAxis, type) {
            switch (type.toLowerCase()) {
                case 'category':
                    return crossAxis.labels.indexOf(axis.crossesAt) != -1 ? crossAxis.labels.indexOf(axis.crossesAt) : axis.crossesAt;
                case 'datetime':
                    return isNaN(Date.parse(axis.crossesAt)) ? null : Date.parse(axis.crossesAt);
                case 'logarithmic':
                    return Math.log(axis.crossesAt) / Math.log(crossAxis.logBase);
            }
            return axis.crossesAt;
        },

        _getXCrossValue: function (series, axis, params) {
            var crossesInAxis = axis.crossesInAxis, yAxisName = series._yAxisName, validCross = params.axes[axis.name]._validCross || params.axes[axis.name]._validCross == null;
            //Checks whether origin should be changed for current series or not.
            return validCross && axis.crossesAt && ((!crossesInAxis && yAxisName === this.model.primaryYAxis.name) || (crossesInAxis && this._getCrossAxis(this.model._axes, true, crossesInAxis).name === yAxisName)) ? axis.crossesAt : 0;
        },

        _getAxisByName: function (axes, hor, name) {
            if (name) {
                for (var i = 0, count = axes.length; i < count; i++)
                    if (axes[i].name === name && (hor ? axes[i].orientation == 'vertical' : axes[i].orientation == 'horizontal'))
                        return axes[i];
            }
        },

        _getCrossAxis: function (axes, hor, value) {
            return this._getAxisByName(axes, hor, value) || (this.model.requireInvertedAxes ? hor ? this.model.primaryXAxis : this.model.primaryYAxis : hor ? this.model.primaryYAxis : this.model.primaryXAxis);
        },

        _arrangeAxis: function () {
            var chartobj = this;
            var axis;
            var customRow;
            //Generate columnIndex/RowIndex value if it is not specify in sample  
            for (var i = 0; i < this.model._axes.length; i++) {
                axis = this.model._axes[i];
                if (axis.orientation.toLowerCase() == "horizontal") {
                    chartobj.model.hAxes.push(axis);
                    axis.columnIndex = (sf.util.isNullOrUndefined(axis.columnIndex)) ? 0 : (axis.columnIndex);
                    chartobj.model.hAxes[chartobj.model.hAxes.length - 1].columnIndex = axis.columnIndex;
                } else if (axis.orientation.toLowerCase() == "vertical") {

                    chartobj.model.vAxes.push(axis);
                    axis.rowIndex = (sf.util.isNullOrUndefined(axis.rowIndex)) ? 0 : (axis.rowIndex);
                    chartobj.model.vAxes[chartobj.model.vAxes.length - 1].rowIndex = axis.rowIndex;
                    customRow = (!sf.util.isNullOrUndefined(chartobj.model.rowDefinitions)) ? chartobj.model.rowDefinitions[axis.rowIndex] : null;
                    if (customRow) {
                        axis.axisBottomLine = {};
                        axis.axisBottomLine.visible = true;
                        axis.axisBottomLine.lineWidth = customRow.lineWidth;
                        axis.axisBottomLine.color = customRow.lineColor;
                    }
                }
            }

            this.model.hAxes = sf.DataManager(this.model.hAxes, sf.Query().sortBy("columnIndex")).executeLocal();

            this.model.vAxes = sf.DataManager(this.model.vAxes, sf.Query().sortBy("rowIndex")).executeLocal();

            //column axis information push into _rowDefinitions
            var rowCount = this.axesCount(chartobj.model.vAxes);
            chartobj.model._rowDefinitions = [];
            if (chartobj.model.vAxes.length > 0) {
                for (var j = 0; j < rowCount.length; j++) {
                    var rowCollection = chartobj.model.rowDefinitions;
                    var rowDefinitions = ((rowCollection)) ? (rowCollection[j] ? rowCollection[j] : rowCollection[0]) : null;
                    chartobj.model._rowDefinitions.push({
                        axis: this.axesIndexCount(chartobj.model.vAxes, rowCount.indexValue[j])
                        , index: rowCount.indexValue[j], rowDefinitions: rowDefinitions
                    });
                }
            }

            var rowDefinition = chartobj.model._rowDefinitions;
            //Using filter to get spanning row axis collection
            var spanningRow = this._axisFilter(rowDefinition, "rowSpan");
            //Arrange the entire axis for row span
            this._SpanningAxes(rowDefinition, spanningRow, true);

            //column axis information push into _columnDefinitions
            var columnCount = this.axesCount(chartobj.model.hAxes);
            chartobj.model._columnDefinitions = [];
            if (chartobj.model.hAxes.length > 0) {
                for (var k = 0; k < columnCount.length; k++) {
                    var columnCollection = chartobj.model.columnDefinitions;
                    var columnDefinitions = (columnCollection) ? (columnCollection[k] ? columnCollection[k] : columnCollection[0]) : null;
                    chartobj.model._columnDefinitions.push({
                        axis: this.axesIndexCount(chartobj.model.hAxes, columnCount.indexValue[k])
                        , index: columnCount.indexValue[k], columnDefinitions: columnDefinitions
                    });
                }
            }

            var columnDefinition = chartobj.model._columnDefinitions;
            //Using filter to get spanning column axis collection
            var spanningColumn = this._axisFilter(columnDefinition, "columnSpan");
            //Arrange the entire axis for column span
            this._SpanningAxes(columnDefinition, spanningColumn, false);

            this._axisSize();


        },

        //Arrange the entire axis for spanning
        _SpanningAxes: function (definition, spanningCollection, isRow) {
            for (var spanIndex = 0, spanMax = spanningCollection.length; spanIndex < spanMax; spanIndex++) {
                var currentAxis = spanningCollection[spanIndex];
                if (currentAxis == null) break;
                var span = isRow ? currentAxis.rowSpan : currentAxis.columnSpan;
                var index = isRow ? currentAxis.rowIndex : currentAxis.columnIndex;
                if (definition[index] != undefined) {
                    var axisIndex = definition[index].axis.indexOf(currentAxis);
                    for (var k = 1, m = index + 1; k < span && m < definition.length; k++ , m++) {
                        if (definition[m].axis.length >= axisIndex) {
                            //Insert duplicate span row to appropriate rowdefinition
                            definition[m].axis.splice(axisIndex, 0, currentAxis);
                        }
                    }
                }
            }
        },

        //Filter span axis from axes
        _axisFilter: function (definition, fieldName) {
            var axisResult = [];
            definition.filter(function (axes) {
                //Execute query to get spanning axis from axis array
                var axisCollection = sf.DataManager(axes["axis"], sf.Query().where(fieldName, ">", 1)).executeLocal();
                for (var i = 0, max = axisCollection.length; i < max; i++)
                    axisResult.push(axisCollection[i]);
            });
            return axisResult;
        },

        _axisSize: function () {
            //The below calcultion to get approximate length of axis
            var spaceValue = this._getLegendSpace();
            var hSpace = $(this.svgObject).width() - this.model.margin.left - this.model.margin.right - (this.model.elementSpacing * 2) - spaceValue.leftLegendWidth - spaceValue.rightLegendWidth;
            var hWidth = Math.floor(hSpace / this.axesCount(this.model.hAxes).length);

            var vSpace = $(this.svgObject).height() - this.model.margin.top - this.model.margin.bottom - (this.model.elementSpacing * 2) - spaceValue.topLegendHeight - spaceValue.bottomLegendHeight - spaceValue.modelTitleHeight - spaceValue.modelsubTitleHeight;
            var vWidth = Math.floor(vSpace / this.axesCount(this.model.vAxes).length);



            for (var j = 0; j < this.model._axes.length; j++) {
                var axis = this.model._axes[j];
                if (axis.orientation.toLowerCase() == "horizontal") {
                    if (this.model.AreaType != "polaraxes") {
                        var customColumn = (!sf.util.isNullOrUndefined(this.model.columnDefinitions)) ? this.model.columnDefinitions[axis.columnIndex] : [];
                        var columnLength = hWidth;
                        if (customColumn) {
                            customColumn.unit = (customColumn.unit == undefined) ? "percentage" : customColumn.unit;
                            customColumn.columnWidth = (customColumn.columnWidth == undefined) ? 100 : customColumn.columnWidth;
                            if (customColumn.unit.toLowerCase() == "percentage") {
                                var length = this._axisColumnDefinitionSize(this.model.columnDefinitions);
                                columnLength = Math.floor((hWidth) * (customColumn.columnWidth / length));
                            }
                            else
                                columnLength = customColumn.columnWidth;

                        }
                        axis.length = axis.columnSpan ? axis.columnSpan * columnLength : columnLength;
                    }
                    else {
                        if (hSpace > vSpace * 2)
                            axis.length = hSpace - vSpace;
                        else
                            axis.length = hSpace;
                    }
                } else if (axis.orientation.toLowerCase() == "vertical") {
                    if (this.model.AreaType != "polaraxes") {
                        var customRow = (!sf.util.isNullOrUndefined(this.model.rowDefinitions)) ? this.model.rowDefinitions[axis.rowIndex] : [];
                        var realLength = vWidth;
                        if (customRow) {
                            customRow.unit = (customRow.unit == undefined) ? "percentage" : customRow.unit;
                            customRow.rowHeight = (customRow.rowHeight == undefined) ? 100 : customRow.rowHeight;
                            if (customRow.unit.toLowerCase() == "percentage") {
                                var length = this._axisRowDefinitionSize(this.model.rowDefinitions);
                                realLength = Math.floor((vWidth) * (customRow.rowHeight / length));
                            }
                            else
                                realLength = customRow.rowHeight;

                        }
                        axis.length = axis.rowSpan ? (axis.rowSpan * realLength) : realLength;
                    }
                    else {
                        axis.length = vSpace / 2;
                    }
                }
            }
        },
        _axisRowDefinitionSize: function (array) {
            var length = 0;
            if (array) {
                for (var i = 0; i < array.length; i++) {
                    length = length + array[i].rowHeight;
                }
            }
            length = length > 100 ? length : 100;
            return length;
        },
        _axisColumnDefinitionSize: function (array) {
            var length = 0;
            if (array) {
                for (var i = 0; i < array.length; i++) {
                    length = length + array[i].columnWidth;
                }
            }
            length = length > 100 ? length : 100;
            return length;
        },
        _axisMeasure: function (axis, realWidth, orientation, j) {
            var axisTitleHeight = 0, labelSize = 0, multiLevelLabelSize = 0;
            axis.axisLine.width = axis.axisLine.width < 0 ? 0 : axis.axisLine.width;
           	var tickSize = axis.visible ? (axis.majorTickLines.size < 0 ? 0 : axis.majorTickLines.size) : 0;
            var axisLineWidth = !this.model.enable3D && axis.visible && axis.axisLine.visible && axis.axisLine.width;
            var size = sf.EjSvgRender.utils._measureText(axis.title.text, realWidth, axis.title.font);
			var elementSpacing = axis.visible ? this.model.elementSpacing : 0;
            if (orientation == "vertical") {
                labelSize = axis._LableMaxWidth.width;
                axisTitleHeight = (axis.title.text == "" || !(axis.title.visible) || !(axis.visible)) ? 0 : ((document.documentMode === 8) ? size.width : size.height + (2 * elementSpacing));
            }
            else {
                labelSize = (axis._LableMaxWidth.height);
                axisTitleHeight = (axis.title.text == "" || !(axis.title.visible) || !(axis.visible)) ? 0 : (size.height + (elementSpacing));
            }
            axisTitleHeight = axis.title.position.toLowerCase() == "inside" ? 0 : axisTitleHeight;
            multiLevelLabelSize = this.getMultiLevelLabelSize(axis);
            var width;
            if ((j == 0) && (axis.tickLinesPosition == 'inside' && axis.labelPosition == 'inside'))
                axis.AxisMaxWidth = axisTitleHeight + multiLevelLabelSize + axisLineWidth + (elementSpacing);
            else if ((j == 0) && (axis.tickLinesPosition == 'inside' && axis.labelPosition != 'inside'))
                axis.AxisMaxWidth = axisTitleHeight + multiLevelLabelSize + axisLineWidth + (elementSpacing) + labelSize;
            else if ((j == 0) && (axis.tickLinesPosition != 'inside' && axis.labelPosition == 'inside'))
                axis.AxisMaxWidth = axisTitleHeight + multiLevelLabelSize + axisLineWidth + (elementSpacing) + tickSize;
            else
                axis.AxisMaxWidth = axisTitleHeight + multiLevelLabelSize + axisLineWidth + elementSpacing + tickSize + labelSize;
            axis.AxisMaxWidth += axis._isScroll ? 18 : 0;
            return axis.AxisMaxWidth;
        },

        _arraySum: function (val) {
            var total = 0;
            for (var i = 0; i < val.length; i++) {
                total += parseFloat(val[i]) || 0;
            }
            return total;
        },
        _calSpace: function (realWidth, definitions, orientation, params) {
            var nearSizes = [];
            var farSizes = [];
            var bounds, validCross, measureValue;
            for (var i = 0; i < definitions.length; i++) {
                var nearIndex = 0, farIndex = 0;
                for (var j = 0; j < definitions[i].axis.length; j++) {
                    var currentaxis = definitions[i].axis[j];
                    bounds = params.axes[currentaxis.name]._bounds = this._axisMeasure(currentaxis, realWidth, orientation, j);
                    validCross = params.axes[currentaxis.name]._validCross = this._validateCrossing(currentaxis);
                    measureValue = validCross ? 0 : bounds;
                    currentaxis._opposed = currentaxis.opposedPosition ? !currentaxis._opposedPosition : currentaxis._opposedPosition || currentaxis.opposedPosiiton || false;
                    if (validCross && definitions[i].axis[j].showNextToAxisLine)
                        continue;
                    if (!currentaxis.showNextToAxisLine) { measureValue = (currentaxis.labelPosition == "inside") ? bounds - currentaxis._multiLevelLabelHeight : bounds; }
                    if (!currentaxis._opposed) {
                        if (nearSizes.length <= nearIndex) {
                            nearSizes.push(measureValue);
                        } else if (nearSizes[nearIndex] < (measureValue)) {
                            nearSizes[nearIndex] = measureValue;
                        }
                        nearIndex++;
                    }
                    else {
                        if (farSizes.length <= farIndex) {
                            farSizes.push(measureValue);
                        } else if (farSizes[farIndex] < (measureValue)) {
                            farSizes[farIndex] = measureValue;
                        }
                        farIndex++;
                    }

                }
            }
            return { nearSizes: nearSizes, farSizes: farSizes };
        },

        _getLegendSpace: function () {
            var chart = this.model,
                legend = chart.legend,
                position = legend.position.toLowerCase(),
                bounds = chart.LegendActualBounds,
                measureText = sf.EjSvgRender.utils._measureText,
                title = chart.title,
                subTitle = title.subTitle,
                elementSpacing = chart.elementSpacing,
                margin = chart.margin,
                svgWidth = chart.svgWidth,
                legendBorder = legend.border.width,
                ltheight = 0, space = 0,
                itemPadding = 10,
                leftLegendWidth = 0, rightLegendWidth = 0,
                topLegendHeight = 0, bottomLegendHeight = 0,
                labelCollection = title.text.split(' '),
                text, line = 0, enableTrim = title.enableTrim,
                maxTitleWidth = title.maximumWidth,
                maxTitleWidth = (maxTitleWidth.toString() == 'auto' || maxTitleWidth.toString() == '') ? (svgWidth * 0.75) : parseInt(maxTitleWidth),
                textOverflow = title.textOverflow.toLowerCase(),
                titleText = title.text,
                titleVisible = title.visible, titleCollection, subTitleCollection, data,
                measureTitle = sf.EjSvgRender.utils._measureText(title.text, $(this.svgObject).width() - this.model.margin.left - this.model.margin.right, title.font),
                subTitleLabelCollection = subTitle.text.split(' '),
                subTitleEnableTrim = subTitle.enableTrim,
                maxSubTitleWidth = subTitle.maximumWidth,
                maxSubTitleWidth = (maxSubTitleWidth.toString() == 'auto' || maxSubTitleWidth.toString() == '') ? (svgWidth * 0.75) : parseInt(maxSubTitleWidth),
                subTitleTextOverflow = subTitle.textOverflow.toLowerCase(),
                subTitleText = subTitle.text,
                subTitleVisible = subTitle.visible,
                measureSubTitle = sf.EjSvgRender.utils._measureText(subTitle.text, $(this.svgObject).width() - this.model.margin.left - this.model.margin.right, subTitle.font),
                titleVisibility = titleVisible && enableTrim && measureTitle.width > maxTitleWidth ? true : false,
                subTitleVisibility = subTitleVisible && subTitleEnableTrim && measureSubTitle.width > maxSubTitleWidth ? true : false,
                textOverflowVisibility = textOverflow == "wrap" || textOverflow == "wrapandtrim" ? true : false,
                subTitleTextOverflowVisibility = subTitleTextOverflow == "wrap" || subTitleTextOverflow == "wrapandtrim" ? true : false;
            this.model.titleWrapTextCollection = [];
            this.model.subTitleWrapTextCollection = [];
            this.model.trimTooltip = false;
            this.model.subTitleTooltip = false;
            if (legend.visible) {
                space = (bounds.Width + (itemPadding / 2) + elementSpacing + (2 * legendBorder));
                leftLegendWidth = position == 'left' ? space : 0;
                rightLegendWidth = position == 'right' ? space : 0;
                if (legend.title.text)
                    ltheight = measureText(legend.title, null, legend.title.font).height;
                topLegendHeight = position == 'top' ? (bounds.Height + ltheight + (2 * legendBorder)) : 0;
                bottomLegendHeight = position == 'bottom' ? (bounds.Height + ltheight + (2 * legendBorder)) : 0;
            }
            if (titleVisibility && textOverflow == "wrap") {
                data = { text: titleText, font: title.font };
                titleCollection = this._rowsCalculation(data, maxTitleWidth, textOverflow);
            }
            else if (titleVisibility && textOverflow == "wrapandtrim") {
                data = { text: titleText, font: title.font };
                titleCollection = this._rowsCalculation(data, maxTitleWidth, textOverflow);
            }
            else if (textOverflow == "wrapandtrim" || textOverflow == "wrap") {
                data = { text: titleText, font: title.font };
                titleCollection = this._rowsCalculation(data, sf.EjSvgRender.utils._measureText(titleText, null, title.font).width, textOverflow);
            }
            this.model.titleWrapTextCollection = titleCollection ? titleCollection.textCollection : "";
            this.model.titleMaxWidth = titleCollection ? titleCollection.wordMax : maxTitleWidth;
            if (subTitleVisibility && subTitleTextOverflow == "wrap") {
                data = { text: subTitleText, font: subTitle.font };
                subTitleCollection = this._rowsCalculation(data, maxSubTitleWidth, subTitleTextOverflow);
            }
            else if (subTitleVisibility && subTitleTextOverflow == "wrapandtrim") {
                data = { text: subTitleText, font: subTitle.font };
                subTitleCollection = this._rowsCalculation(data, maxSubTitleWidth, subTitleTextOverflow);
                this.model.subTitleTooltip = this.model.trimTooltip;
            }
            else if (subTitleTextOverflow == "wrapandtrim" || subTitleTextOverflow == "wrap") {
                data = { text: subTitleText, font: subTitle.font };
                subTitleCollection = this._rowsCalculation(data, maxSubTitleWidth, subTitleTextOverflow);
            }
            this.model.subTitleWrapTextCollection = subTitleCollection ? subTitleCollection.textCollection : "";
            this.model.subTitleMaxWidth = subTitleCollection ? subTitleCollection.wordMax : maxSubTitleWidth;
            var titleHeight = measureText(title.text, svgWidth - margin.left - margin.right, title.font).height,
                subTitleHeight = measureText(subTitle.text, svgWidth - margin.left - margin.right, subTitle.font).height;
            var modelTitleHeight = (title.text == "" || !title.visible) ? 0 : (enableTrim && (textOverflowVisibility) && measureTitle.width > maxTitleWidth) ?
                ((titleHeight * this.model.titleWrapTextCollection.length) + elementSpacing) : (titleHeight + elementSpacing);
            var modelsubTitleHeight = (subTitle.text == "" || !subTitle.visible || !title.visible) ? 0 : (subTitleEnableTrim && (subTitleTextOverflowVisibility) && measureSubTitle.width > maxSubTitleWidth) ?
                ((subTitleHeight * this.model.subTitleWrapTextCollection.length) + elementSpacing) : (subTitleHeight + elementSpacing);

            return {
                leftLegendWidth: leftLegendWidth, rightLegendWidth: rightLegendWidth, topLegendHeight: topLegendHeight, bottomLegendHeight: bottomLegendHeight, modelTitleHeight: modelTitleHeight, modelsubTitleHeight: modelsubTitleHeight
            };
        },


        _arraySome: function (axes, orientation) {
            var scroll = false,
                isZoomScroll = this.model.zooming.enableScrollbar,
                count = axes.length,
                scrollbar,
                pointLength;

            for (var i = 0; i < count; i++) {
                scrollbar = axes[i].scrollbarSettings.enableScrollbar;
                pointLength = axes[i].scrollbarSettings.pointsLength;
                scroll = (scroll || (((axes[i]._isScroll && axes[i].maxPointLength < pointLength) || (axes[i].zoomFactor < 1 && scrollbar && isZoomScroll)) && axes[i].orientation.toLowerCase() == orientation));
            }

            return scroll;
        },

        _calculateAreaBounds: function (params) {
            var chartobj = this,
                realWidth = $(this.svgObject).width() - this.model.margin.left - this.model.margin.right,
                // Calculate area bounds X and width
                chartBorderWidth = chartobj.model.border.width,
                axis = this.model._axes[0],
                zomming = this.model.zooming.enableScrollbar,
                type = this.model.zooming.type.toLowerCase();
            chartobj.model.scrollerSize = 18;
            this.model._yScroll = this._arraySome(this.model._axes, 'vertical');
            this.model._xScroll = this._arraySome(this.model._axes, 'horizontal');

            //Calcultion for multiple axes(vertical)
            var sizes = this._calSpace(realWidth, chartobj.model._rowDefinitions, "vertical", params);
            chartobj.model._rowDefinitions.nearSizes = sizes.nearSizes;
            chartobj.model._rowDefinitions.farSizes = sizes.farSizes;
            var vAxesWidth = this._arraySum(sizes.nearSizes);
            var vAxesOppWidth = this._arraySum(sizes.farSizes);

            var spaceValue = this._getLegendSpace();

            var x = vAxesWidth + spaceValue.leftLegendWidth + chartobj.model.margin.left + chartBorderWidth;
            var rightSpacing = vAxesOppWidth + spaceValue.rightLegendWidth + chartobj.model.margin.right + chartobj.model.margin.left + (2 * chartBorderWidth);
            var width = $(this.svgObject).width();
            var boundsWidth = width - (x + rightSpacing);
			boundsWidth = Math.round(boundsWidth) <=0 ? 0 : boundsWidth;
            if (boundsWidth <= 0 && this.model.AreaType == "cartesianaxes") {
                $(this.svgObject).width(width - boundsWidth + 1);
                this._calculateAreaBounds(params);
            }
            else {
                // Calculate area bounds Y and Height   

                //Calcultion for multiple axes(Horizontal)
                var columnSizes = this._calSpace(realWidth, chartobj.model._columnDefinitions, "horizontal", params);
                chartobj.model._columnDefinitions.nearSizes = columnSizes.nearSizes;
                chartobj.model._columnDefinitions.farSizes = columnSizes.farSizes;
                var hAxesWidth = this._arraySum(columnSizes.nearSizes);
                var hAxesOppWidth = this._arraySum(columnSizes.farSizes);
				var elementSpacing = hAxesWidth || hAxesOppWidth ? this.model.elementSpacing : 0;
                var y = hAxesOppWidth + this.model.margin.top + (elementSpacing) + spaceValue.modelTitleHeight + (spaceValue.modelsubTitleHeight) + spaceValue.topLegendHeight + chartBorderWidth;
                var bottomSpacing = hAxesWidth + this.model.margin.bottom + spaceValue.bottomLegendHeight + (2 * chartBorderWidth);
                var boundsHeight = Math.abs($(this.svgObject).height() - (y + bottomSpacing));
                boundsHeight = boundsHeight == 0 ? 1 : boundsHeight;
                this.model.m_AreaBounds = { X: x, Y: y, Width: boundsWidth, Height: boundsHeight };
                this.model.m_Spacing = { Left: x, Top: y, Right: rightSpacing, Bottom: bottomSpacing };

                if (this.model.enableCanvasRendering) {  // for adding bounds in canvas rendering
                    this.canvasX = x;
                    this.canvasY = y;
                    this.canvasWidth = boundsWidth;
                    this.canvasHeight = boundsHeight;
                } else
                    this.canvasX = this.canvasY = this.canvasHeight = this.canvasWidth = 0;
            }
        }
    };

    jQuery.uaMatch = function (ua) {
        ua = ua.toLowerCase();

        var match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
            /(webkit)[ \/]([\w.]+)/.exec(ua) ||
            /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
            /(msie) ([\w.]+)/.exec(ua) ||
            ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
            [];

        return {
            browser: match[1] || "",
            version: match[2] || "0"
        };
    };



})(jQuery);;
/**
* @fileOverview Plugin to style the Html Chart elements
* @copyright Copyright Sfusion Inc. 2001 - 2013. All rights reserved.
*  Use of this code is subject to the terms of our license.
*  A copy of the current license can be obtained at any time by e-mailing
*  licensing@Sfusion.com. Any infringement will be prosecuted under
*  applicable laws. 
* @version 12.1 
* @author <a href="mailto:licensing@Sfusion.com">Sfusion Inc</a>
*/
/* global jQuery, document, window, Image, Sfusion */
(function ($, sf) {

    sf.widget("ejChart", "sf.datavisualization.Chart", {

        element: null,

        model: null,

        validTags: ["div"],

        defaults: {

            border: {

                color: 'transparent',

                width: 0,

                opacity: 0.3
            },

            chartArea:
                {

                    border: {

                        color: 'Gray',

                        width: 0.5,

                        opacity: 0.3
                    },

                    background: 'transparent'

                },

            highlightColor: null,

            primaryXAxis:
                {
                    rotateOn: "middle",

                    crossesAt: null,

                    crossesInAxis: null,

                    isIndexed: false,

                    multiLevelLabelsColor: null,

                    multiLevelLabelsFontColor: null,

                    alignment: "center",

                    labelPlacement: "",

                    scrollbarSettings: {

                        visible: true,

                        canResize: true,

                        range: {

                            min: null,

                            max: null,
                        },

                        pointsLength: null

                    },

                    range: {

                        min: null,

                        max: null,

                        interval: null
                    },

                    labelPosition: 'outside',

                    tickLinesPosition: 'outside',

                    alternateGridBand:
                        {

                            odd: {

                                fill: "transparent",

                                opacity: 1
                            },

                            even: {

                                fill: "transparent",

                                opacity: 1
                            }
                        },

                    enableAutoIntervalOnZooming: true,


                    majorGridLines:
                        {
                            color: null,

                            width: 1,

                            dashArray: "",

                            visible: true,

                            opacity: 1

                        },

                    majorTickLines:
                        {
                            color: null,

                            width: 1,

                            size: 5,

                            visible: true
                        },

                    minorGridLines:
                        {
                            color: null,

                            width: 1,

                            dashArray: "",

                            visible: true

                        },

                    minorTickLines:
                        {
                            color: null,

                            width: 1,

                            size: 5,

                            visible: true
                        },

                    labelBorder:
                        {
                            color: null,

                            width: 0
                        },

                    multiLevelLabels: [{
                        visible: false,
                        text: "",
                        textAlignment: "center",
                        start: null,
                        end: null,
                        level: 0,
                        maximumTextWidth: null,
                        textOverflow: "trim",
                        font: {
                            fontFamily: 'Segoe UI',
                            fontStyle: 'Normal',
                            size: '12px',
                            fontWeight: 'Regular',
                            opacity: 1
                        },
                        border: {
                            type: 'rectangle',
                            width: 1
                        }
                    }],

                    minorTicksPerInterval: null,

                    columnIndex: null,

                    columnSpan: null,

                    labelRotation: null,

                    valueType: null,

                    name: null,

                    labelFormat: null,

                    desiredIntervals: null,

                    intervalType: null,

                    roundingPlaces: null,

                    logBase: 10,

                    plotOffset: 0,
                    labels: [],

                    stripLine: [
                        {

                            visible: false,

                            startFromAxis: false,

                            text: "",

                            width: 0,

                            textAlignment: "middlecenter",

                            font: {

                                fontFamily: 'Segoe UI',

                                fontStyle: 'Normal',

                                size: '12px',

                                fontWeight: 'Regular',

                                color: 'black',

                                opacity: 1
                            },

                            start: null,

                            end: null,
							
							isRepeat: false,
							
							repeatEvery : null,
							
							repeatUntil : null,
							
							sizeType: 'auto',

                            color: 'gray',

                            borderColor: 'black',

                            zIndex: 'over'
                        }
                    ],

                    title:
                        {


                            text: "",

                            visible: true,

                            enableTrim: false,

                            offset: 0,
							
							titleRotation: 'none',

                            alignment: 'center',

                            isReversed: false,

                            position: 'outside',

                            maximumTitleWidth: null,

                            font:
                                {

                                    fontFamily: 'Segoe UI',

                                    fontStyle: 'Normal',

                                    size: '14px',

                                    opacity: 1,

                                    fontWeight: 'regular',

                                    color: null

                                }
                        },
                    rangePadding: 'Auto',
                    additionalPadding: [1, 1],
                    orientation: 'Horizontal',

                    maximumLabels: 3,

                    opposedPosition: false,

                    showNextToAxisLine: true,

                    axisLine:
                        {

                            visible: true,

                            width: 1,

                            dashArray: "",

                            offset: 0,

                            color: null

                        },

                    labelIntersectAction: "none",

                    maximumLabelWidth: 34,

                    enableTrim: false,


                    edgeLabelPlacement: "none",



                    isInversed: false,



                    font:
                        {

                            fontFamily: 'Segoe UI',

                            fontStyle: 'Normal',

                            size: '11px',

                            color: null,

                            fontWeight: 'regular',

                            opacity: 1

                        },

                    visible: true,

                    crosshairLabel:
                        {
                            rx: 3, ry: 3, isInside: false,
                            border: { color: null, width: 1 },
                            fill: null,
                            font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: null },
                            visible: false
                        },

                    zoomFactor: 1,

                    zoomPosition: 0,

                    backGround: 'transparent'
                },


            primaryYAxis:
                {
					rotateOn: "middle",
                    crossesAt: null,
                    crossesInAxis: null,
                    showNextToAxisLine: true,

                    alignment: "center",

                    startFromZero: true,

                    range: {

                        min: null,

                        max: null,

                        interval: null
                    },

                    scrollbarSettings: {

                        visible: true,

                        canResize: true,

                        range: {

                            min: null,

                            max: null,
                        },

                        pointsLength: null

                    },

                    labelPlacement: "",

                    labelPosition: 'outside',

                    tickLinesPosition: 'outside',

                    multiLevelLabelsColor: null,
                    multiLevelLabelsFontColor: null,

                    alternateGridBand:
                        {

                            odd: {

                                fill: "transparent",

                                opacity: 1
                            },

                            even: {


                                fill: "transparent",

                                opacity: 1
                            }
                        },

                    enableAutoIntervalOnZooming: true,

                    majorGridLines:
                        {
                            color: null,

                            width: 1,

                            dashArray: "",

                            visible: true,

                            opacity: 1

                        },

                    majorTickLines:
                        {
                            color: null,

                            width: 1,

                            size: 5,

                            visible: true
                        },

                    minorGridLines:
                        {
                            color: null,

                            width: 1,

                            dashArray: "",

                            visible: true

                        },

                    minorTickLines:
                        {
                            color: null,

                            width: 1,

                            size: 5,

                            visible: true
                        },

                    labelBorder:
                        {

                            color: null,

                            width: 0
                        },

                    multiLevelLabels: [{
                        visible: false,
                        text: "",
                        textAlignment: "center",
                        start: null,
                        end: null,
                        level: 0,
                        maximumTextWidth: null,
                        textOverflow: "trim",
                        font: {
                            fontFamily: 'Segoe UI',
                            fontStyle: 'Normal',
                            size: '12px',
                            fontWeight: 'Regular',
                            opacity: 1
                        },
                        border: {
                            type: 'rectangle',
                            width: 1
                        }
                    }],

                    minorTicksPerInterval: null,

                    rowIndex: null,

                    rowSpan: null,

                    valueType: null,

                    name: null,

                    labelFormat: null,

                    desiredIntervals: null,

                    intervalType: null,

                    roundingPlaces: null,
                    labels: [],

                    title:
                        {

                            text: "",

                            visible: true,

                            enableTrim: false,
							
							titleRotation: 'none',

                            offset: 0,

                            alignment: 'center',

                            isReversed: false,

                            position: 'outside',

                            maximumTitleWidth: null,

                            font:
                                {
                                    color: null,

                                    fontFamily: 'Segoe UI',

                                    fontStyle: 'Normal',

                                    opacity: 1,

                                    size: '14px',

                                    fontWeight: 'regular'
                                }
                        },

                    rangePadding: 'Auto',


                    stripLine: [
                        {

                            visible: false,

                            startFromAxis: false,

                            width: 0,

                            text: "",

                            textAlignment: "middlecenter",

                            font: {

                                fontFamily: 'Segoe UI',

                                fontWeight: 'Regular',

                                fontStyle: 'Normal',

                                size: '12px',

                                color: 'black',

                                opacity: 1
                            },

                            start: null,

                            end: null,
							
							isRepeat: false,
							
							repeatEvery : null,
							
							repeatUntil : null,
							
							sizeType: 'auto',

                            color: 'gray',

                            borderColor: 'black',

                            zIndex: 'over'
                        }
                    ],

                    logBase: 10,

                    plotOffset: 0,

                    orientation: 'Vertical',

                    maximumLabels: 3,

                    labelIntersectAction: "none",


                    maximumLabelWidth: 34,

                    enableTrim: false,

                    edgeLabelPlacement: "none",


                    isInversed: false,


                    crosshairLabel:
                        {
                            rx: 3, ry: 3, isInside: false,
                            border: { color: null, width: 1 },
                            fill: null,
                            font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: null },
                            visible: false
                        },

                    visible: true,

                    opposedPosition: false,

                    font:
                        {

                            fontFamily: 'Segoe UI',

                            fontStyle: 'Normal',

                            size: '11px',

                            opacity: 1,

                            fontWeight: 'regular',

                            color: null

                        },

                    axisLine:
                        {

                            visible: true,

                            width: 1,

                            dashArray: "",

                            offset: 0,

                            color: null
                        },


                    zoomFactor: 1,

                    zoomPosition: 0,

                    backGround: 'transparent'
                },
            axes: [],

            secondaryX:
                {
					rotateOn: "middle",
                    crossesAt: null,
                    crossesInAxis: null,
                    showNextToAxisLine: true,
                    alignment: "center",
                    multiLevelLabelsColor: null,
                    multiLevelLabelsFontColor: null,
                    range: {
                        min: null,
                        max: null,
                        interval: null
                    },

                    scrollbarSettings: {

                        visible: true,

                        canResize: true,

                        range: {

                            min: null,

                            max: null,
                        },

                        pointsLength: null

                    },

                    tickLinesPosition: "outside",
                    labelPosition: "outside",

                    majorGridLines:
                        {

                            color: null,

                            width: 1,

                            dashArray: "",

                            visible: true
                        },
                    alternateGridBand:
                        {
                            odd: {
                                fill: "transparent",
                                opacity: 1
                            },
                            even: {
                                fill: "transparent",
                                opacity: 1
                            }
                        },

                    enableAutoIntervalOnZooming: true,

                    majorTickLines:
                        {

                            color: null,

                            width: 1,

                            size: 5,

                            visible: true
                        },

                    minorGridLines:
                        {
                            color: null,

                            width: 1,

                            dashArray: "",

                            visible: true

                        },

                    minorTickLines:
                        {
                            color: null,

                            width: 1,

                            size: 5,

                            visible: true
                        },

                    labelBorder:
                        {
                            color: null,

                            width: 0
                        },

                    multiLevelLabels: [{
                        visible: false,
                        text: "",
                        textAlignment: "center",
                        start: null,
                        end: null,
                        level: 0,
                        maximumTextWidth: null,
                        textOverflow: "trim",
                        font: {
                            fontFamily: 'Segoe UI',
                            fontStyle: 'Normal',
                            size: '12px',
                            fontWeight: 'Regular',
                            opacity: 1
                        },
                        border: {
                            type: 'rectangle',
                            width: 1
                        }
                    }],

                    minorTicksPerInterval: null,

                    columnIndex: null,

                    columnSpan: null,

                    labelRotation: null,

                    valueType: null,

                    name: null,

                    labelFormat: null,

                    labelPlacement: "",

                    desiredIntervals: null,

                    intervalType: null,

                    roundingPlaces: null,

                    logBase: 10,

                    plotOffset: 0,
                    labels: [],
                    stripLine: [
                        {
                            visible: false,
                            startFromAxis: false,
                            text: "",
                            textAlignment: "middlecenter",
                            font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', fontWeight: 'regular', size: '12px', color: 'black', opacity: 1 },
                            start: null,
                            end: null,
							isRepeat: false,
							
							repeatEvery : null,
							
							repeatUntil : null,
							
							sizeType: 'auto',
                            color: 'gray',
                            borderColor: 'black',
                            zIndex: 'over'
                        }
                    ],

                    title:
                        {


                            text: "",
                            visible: true,
                            enableTrim: false,
                            offset: 0,
							titleRotation: 'none',
                            alignment: 'center',
                            isReversed: false,
                            position: 'outside',
                            maximumTitleWidth: null,
                            font:
                                {

                                    color: null,

                                    fontFamily: 'Segoe UI',

                                    fontStyle: 'Normal',

                                    size: '14px',

                                    opacity: 1,

                                    fontWeight: 'regular'

                                }

                        },

                    rangePadding: 'Auto',
                    additionalPadding: [1, 1],

                    orientation: 'Horizontal',

                    maximumLabels: 3,

                    opposedPosition: false,

                    axisLine:
                        {

                            visible: true,

                            width: 1,

                            dashArray: "",

                            offset: 0,

                            color: null
                        },

                    labelIntersectAction: "none",

                    edgeLabelPlacement: "none",

                    font:
                        {
                            color: null,

                            fontFamily: 'Segoe UI',

                            fontStyle: 'Normal',

                            size: '11px',

                            fontWeight: 'regular',

                            opacity: 1
                        },

                    visible: true,

                    crosshairLabel:
                        {
                            rx: 3, ry: 3, isInside: false,
                            border: { color: null, width: 1 },
                            fill: null,
                            font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: null },
                            visible: false
                        },

                    zoomFactor: 1,

                    zoomPosition: 0
                },

            secondaryY:
                {
					rotateOn: "middle",
                    crossesAt: null,
                    crossesInAxis: null,
                    showNextToAxisLine: true,
                    alignment: "center",
                    startFromZero: true,
                    multiLevelLabelsColor: null,
                    multiLevelLabelsFontColor: null,
                    range: {
                        min: null,
                        max: null,
                        interval: null
                    },

                    scrollbarSettings: {

                        visible: true,

                        canResize: true,

                        range: {

                            min: null,

                            max: null,
                        },

                        pointsLength: null

                    },

                    tickLinesPosition: "outside",
                    labelPosition: "outside",

                    majorGridLines:
                        {

                            color: null,

                            width: 1,

                            dashArray: "",

                            visible: true

                        },
                    alternateGridBand:
                        {
                            odd: {
                                fill: "transparent",
                                opacity: 1
                            },
                            even: {
                                fill: "transparent",
                                opacity: 1
                            }
                        },

                    enableAutoIntervalOnZooming: true,

                    majorTickLines:
                        {
                            color: null,

                            width: 1,

                            size: 5,

                            visible: true
                        },

                    minorGridLines:
                        {
                            color: null,

                            width: 1,

                            dashArray: "",

                            visible: true

                        },

                    minorTickLines:
                        {
                            color: null,

                            width: 1,

                            size: 5,

                            visible: true
                        },

                    labelBorder:
                        {
                            color: null,

                            width: 0
                        },

                    multiLevelLabels: [{
                        visible: false,
                        text: "",
                        textAlignment: "center",
                        start: null,
                        end: null,
                        level: 0,
                        maximumTextWidth: null,
                        textOverflow: "trim",
                        font: {
                            fontFamily: 'Segoe UI',
                            fontStyle: 'Normal',
                            size: '12px',
                            fontWeight: 'Regular',
                            opacity: 1
                        },
                        border: {
                            type: 'rectangle',
                            width: 1
                        }
                    }],

                    minorTicksPerInterval: null,

                    rowIndex: null,

                    rowSpan: null,

                    valueType: null,

                    name: null,

                    labelFormat: null,

                    desiredIntervals: null,

                    intervalType: null,

                    roundingPlaces: null,
                    labels: [],

                    title:
                        {

                            text: "",
                            visible: true,
                            enableTrim: false,
							titleRotation: 'none',
                            offset: 0,
                            alignment: 'center',
                            isReversed: false,
                            position: 'outside',
                            maximumTitleWidth: null,
                            font:
                                {
                                    fontFamily: 'Segoe UI',

                                    fontStyle: 'Normal',

                                    opacity: 1,

                                    size: '14px',

                                    fontWeight: 'regular',

                                    color: null
                                }
                        },

                    rangePadding: 'Auto',

                    stripLine: [
                        {
                            visible: false,
                            startFromAxis: false,
                            text: "",
                            textAlignment: "middlecenter",
                            font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', fontWeight: 'regular', size: '12px', color: 'black', opacity: 1 },
                            start: null,
                            end: null,
							isRepeat: false,
							
							repeatEvery : null,
							
							repeatUntil : null,
							
							sizeType: 'auto',
                            color: 'gray',
                            borderColor: 'black',
                            zIndex: 'over'
                        }
                    ],

                    logBase: 10,

                    plotOffset: 0,

                    orientation: 'Vertical',

                    maximumLabels: 3,

                    labelIntersectAction: "none",

                    labelPlacement: "",

                    edgeLabelPlacement: "none",

                    crosshairLabel:
                        {
                            rx: 3, ry: 3, isInside: false,
                            border: { color: null, width: 1 },
                            fill: null,
                            font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: null },
                            visible: false
                        },

                    visible: true,

                    opposedPosition: false,

                    font:
                        {
                            fontFamily: 'Segoe UI',

                            fontStyle: 'Normal',

                            size: '11px',

                            opacity: 1,

                            fontWeight: 'regular'

                        },

                    axisLine:
                        {
                            color: null,

                            visible: true,

                            width: 1,

                            dashArray: "",

                            offset: 0
                        },


                    zoomFactor: 1,

                    zoomPosition: 0
                },
            trendlineDefaults: {
                type: "linear",
                visibility: "",
                visibleOnLegend: "visible",
                name: "Trendline",
                fill: "",
                width: 1,
                opacity: 1,
                dashArray: "",
                forwardForecast: 0,
                backwardForecast: 0,
                polynomialOrder: 2,
                period: 2,
                intercept: null,
                tooltip: {
                    visible: false, format: null, fill: null, border: { width: 1, color: null }, duration: '500ms', enableAnimation: true, opacity: 0.95, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', fontWeight: 'Regular', size: '12px', opacity: 1 }
                }
            },
            indicatorDefaults: {
                visible: true,
                points: [],
                tooltip: { visible: false, format: null, fill: null, border: { width: 1, color: null }, duration: '500ms', enableAnimation: true, opacity: 0.95 },
                seriesName: "",
                font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', fontWeight: 'Regular', size: '12px', color: '#707070', opacity: 1 },
                type: "SMA",
                period: 14,
                standardDeviations: 2,
                kPeriod: 3,
                dPeriod: 3,
                periodLine: { fill: "blue", width: 2 },
                lowerLine: { fill: "#008000", width: 2 },
                upperLine: { fill: "#ff0000", width: 2 },
                macdLine: { fill: "#ff9933", width: 2 },
                histogram: { fill: "#ccccff", opacity: 1, border: { color: "#9999ff", width: 1 } },
                fill: "#00008B",
                width: 2,
                xAxisName: "",
                yAxisName: "",
                visibility: "visible",
                macdType: "line",
                shortPeriod: 12,
                longPeriod: 26,
                trigger: 9,
                enableAnimation: false,
                animationDuration: null,
            },
            annotationsDefault: {
                visible: false,
                content: "",
                coordinateUnit: "none",
                verticalAlignment: "middle",
                horizontalAlignment: "middle",
                region: "chart",
                x: 0,
                y: 0,
                opacity: 1,
                angle: 0,
                xAxisName: "",
                yAxisName: "",
                margin: {
                    left: 0,
                    right: 0,
                    bottom: 0,
                    top: 0
                }
            },
            multiLevelLabelsDefault: {
                visible: false,
                text: "",
                textAlignment: "center",
                start: null,
                end: null,
                level: 0,
                maximumTextWidth: null,
                textOverflow: "trim",
                font: {
                    fontFamily: 'Segoe UI',
                    fontStyle: 'Normal',
                    size: '12px',
                    fontWeight: 'Regular',
                    opacity: 1
                },
                border: {
                    type: 'rectangle',
                    width: 1
                }
            },
            stripLineDefault: {

                visible: false,

                startFromAxis: false,

                width: 0,

                text: "",

                textAlignment: 'middlecenter',

                font:
                    {

                        fontFamily: 'Segoe UI',

                        fontStyle: 'Normal',

                        fontWeight: 'Regular',

                        size: '12px',

                        color: 'black',

                        opacity: 1
                    },

                start: null,

                end: null,
				
				isRepeat: false,
							
				repeatEvery : null,
				
				repeatUntil : null,
						
				sizeType: 'auto',

                color: 'gray',

                borderColor: 'black',

                zIndex: 'over',

                borderWidth: 1
            },

            rowDefinitions: null,

            columnDefinitions: null,

            title:
                {

                    text: "",

                    enableTrim: false,

                    visible: true,

                    isReversed: false,

                    maximumWidth: 'auto',

                    textOverflow: "trim",

                    textAlignment: "center",

                    background: 'transparent',

                    border: {

                        color: 'transparent',

                        width: 1,

                        opacity: 0.8,

                        cornerRadius: 0.8

                    },

                    font: {

                        color: null,

                        fontFamily: 'Segoe UI',

                        fontStyle: 'Normal',

                        size: '16px',

                        opacity: 1,

                        fontWeight: 'regular'
                    },


                    subTitle:
                        {

                            text: "",

                            enableTrim: false,

                            visible: true,

                            maximumWidth: 'auto',

                            textOverflow: "trim",

                            textAlignment: 'far',

                            background: 'transparent',

                            border: {

                                color: 'transparent',

                                width: 1,

                                opacity: 0.8,

                                cornerRadius: 0.8

                            },


                            font:
                                {
                                    color: null,

                                    fontFamily: 'Segoe UI',

                                    fontStyle: 'Normal',

                                    size: '12px',

                                    opacity: 1,

                                    fontWeight: 'regular'
                                }
                        }

                },





            lineCap: { butt: 'butt', round: 'round', square: 'square' },
            lineJoin: { round: 'round', bevel: 'bevel', miter: 'miter' },
            legendAlignment: { near: 'near', center: 'center', far: 'far' },
            legendPosition: { top: 'top', bottom: 'bottom', right: 'right', left: 'left', custom: 'custom' },

            enableAnimation: true,

            legend:
                {

                    title:
                        {
                            text: "",

                            textAlignment: 'center',

                            font:
                                {
                                    color: null,

                                    size: '12px',

                                    fontFamily: "Segoe UI",

                                    fontStyle: 'normal',

                                    fontWeight: 'regular'
                                }
                        },

                    border:
                        {

                            color: 'transparent',


                            width: 1
                        },

                    visible: true,

                    isReversed: false,

                    textOverflow: 'none',

                    textWidth: 34,

                    toggleSeriesVisibility: true,

                    enableScrollbar: true,

                    itemPadding: 10,

                    shape: 'None',

                    alignment: 'Center',

                    position: 'Bottom',

                    location:
                        {

                            x: 0,

                            y: 0
                        },

                    itemStyle:
                        {
                            height: 9,

                            width: 9,

                            border:
                                {

                                    color: 'transparent',

                                    width: 1
                                }
                        },

                    rowCount: null,

                    columnCount: null,

                    opacity: 1,

                    fill: null,

                    background: null,

                    font:
                        {
                            color: null,

                            fontFamily: 'Segoe UI',

                            fontStyle: 'Normal',

                            fontWeight: 'Regular',

                            size: '12px'
                        },

                    size:
                        {

                            height: null,

                            width: null
                        }
                },

            indicators: [
                {
                    points: [],

                    tooltip:
                        {

                            visible: false,

                            format: null,

                            fill: null,

                            border: {

                                width: 1,

                                color: null
                            },

                            duration: '500ms',

                            enableAnimation: true,

                            opacity: 0.95
                        },

                    seriesName: "",

                    animationDuration: null,

                    type: "SMA",

                    period: 14,

                    standardDeviations: 2,

                    kPeriod: 3,

                    dPeriod: 3,

                    periodLine: {

                        fill: "blue",

                        width: 2
                    },

                    lowerLine: {


                        fill: "#008000",

                        width: 2
                    },

                    upperLine: {

                        fill: "#ff0000",

                        width: 2
                    },

                    macdLine: {

                        fill: "#ff9933",

                        width: 2
                    },

                    histogram: {

                        fill: "#ccccff",

                        opacity: 1,

                        border: {

                            color: "#9999ff",

                            width: 1
                        }
                    },

                    fill: "#00008B",

                    visible: true,

                    font: {

                        fontFamily: 'Segoe UI',

                        fontStyle: 'Normal',

                        fontWeight: 'Regular',

                        size: '12px',

                        color: '#707070',

                        opacity: 1
                    },

                    width: 2,

                    xAxisName: "",

                    yAxisName: "",

                    macdType: "line",

                    shortPeriod: 12,

                    longPeriod: 26,

                    trigger: 9,

                    visibility: "visible",

                    enableAnimation: false
                }
            ],

            background: null,

            backGroundImageUrl: null,

            annotations: [{

                visible: false,

                content: "",

                coordinateUnit: "none",

                verticalAlignment: "middle",

                horizontalAlignment: "middle",

                region: "chart",

                x: 0,

                y: 0,

                opacity: 1,

                angle: 0,

                xAxisName: "",

                yAxisName: "",

                margin: {

                    left: 0,

                    right: 0,

                    bottom: 0,

                    top: 0
                }
            }],

            series: [
                {
                    dragSettings: {
                        enable: false,
                        type: 'xy'
                    },

                    type: 'column',

                    enableTrackTooltip : true,

                    splitMode: 'value',

                    splitValue: null,

                    splineType: 'natural',

                    cardinalSplineTension: 0.5,

                    gapWidth: 50,

                    pieOfPieCoefficient: 0.6,

                    visibleOnLegend: "visible",

                    enableAnimation: false,

                    animationDuration: null,

                    animationType: 'linear',

                    isClosed: true,

                    isTransposed: false,

                    isStacking: true,

                    columnSpacing: 0,

                    columnWidth: 0.7,

                    columnFacet: 'rectangle',
                    drawType: 'line',

                    doughnutCoefficient: 0.4,

                    explodeOffset: 25,

                    pyramidMode: 'linear',

                    boxPlotMode: 'exclusive',

                    funnelWidth: '11.6%',

                    funnelHeight: '32.7%',

                    positiveFill: null,

                    showMedian: true,

                    outlierSettings: {

                        shape: 'circle',

                        size:
                            {
                                width: 6,

                                height: 6

                            },
                    },

                    cornerRadius: {

                        topLeft: 0,

                        topRight: 0,

                        bottomLeft: 0,

                        bottomRight: 0
                    },

                    connectorLine: {

                        width: 1,

                        opacity: 1,

                        dashArray: null
                    },

                    errorBar: {

                        visibility: "hidden",

                        mode: "vertical",

                        type: "fixedValue",

                        horizontalErrorValue: 1,

                        verticalErrorValue: 3,

                        horizontalPositiveErrorValue: 1,

                        horizontalNegativeErrorValue: 1,

                        verticalPositiveErrorValue: 5,

                        verticalNegativeErrorValue: 5,

                        direction: "both",

                        cap: {

                            visible: true,

                            width: 1,

                            length: 20,

                        },


                        width: 1,

                        opacity: 1,

                    },

                    highlightSettings: {

                        enable: false,

                        mode: 'series',

                        color: "",

                        opacity: 0.6,

                        border: {

                            color: "",

                            width: 2
                        },

                        pattern: 'none',

                        customPattern: ""
                    },

                    selectionSettings: {

                        type: 'Single',

                        enable: false,

                        mode: 'series',

                        rangeType: 'xy',

                        color: "",

                        opacity: 0.6,

                        border: {

                            color: "",

                            width: 2
                        },

                        pattern: 'none',

                        customPattern: ""
                    },

                    emptyPointSettings: {

                        visible: true,

                        style: {

                            color: '',

                            border: {

                                color: '',

                                width: 1

                            }

                        },

                        displayMode: 'gap'
                    },

                    labelPosition: 'inside',

                    gapRatio: 0,

                    points: null,

                    pieCoefficient: 0.8,

                    doughnutSize: 0.8,

                    dataSource: null,

                    high: '',

                    low: '',

                    open: '',

                    close: '',

                    bullFillColor: null,

                    bearFillColor: null,

                    query: null,

                    xName: '',

                    yName: '',

                    pointColorMappingName: '',



                    visibility: "visible",

                    startAngle: null,

                    endAngle: null,

                    xAxisName: null,

                    yAxisName: null,

                    explodeAll: null,

                    explode: false,

                    explodeIndex: null,

                    enableSmartLabels: null,

                    tooltip: {

                        visible: false,

                        isReversed: false,

                        format: null,

                        template: null,


                        fill: null,

                        border: {

                            width: 1,

                            color: null
                        },

                        enableAnimation: true,

                        duration: '500ms',

                        opacity: 0.95
                    },

                    fill: null,

                    opacity: 1,

                    lineCap: 'butt',

                    lineJoin: 'round',

                    dashArray: "",

                    border: {

                        width: 1,

                        color: 'transparent',

                        dashArray: ""
                    },
                    width: 2,

                    marker: {

                        shape: 'circle',

                        imageUrl: "",

                        size: {

                            width: 6,

                            height: 6
                        },

                        visible: false,

                        opacity: 1,

                        fill: null,

                        border: {

                            color: 'white',

                            width: 3
                        },

                        dataLabel: {

                            visible: false,

                            isReversed: false,

                            angle: 0,

                            showEdgeLabels: false,

                            enableContrastColor: false,

                            textMappingName: '',

                            verticalTextAlignment: 'center',

                            horizontalTextAlignment: 'center',

                            textPosition: 'top',
							
							textAnchor:'middle',

                            shape: 'none',

                            opacity: 1,

                            fill: null,

                            border: {

                                color: 'white',

                                width: 0.1
                            },

                            maximumLabelWidth: null,

                            enableWrap: false,

                            connectorLine: {

                                width: 0.5,

                                type: 'line',

                                color: null
                            },

                            offset: {

                                x: 0,

                                y: 0
                            },

                            font: {

                                fontFamily: 'Segoe UI',

                                fontStyle: 'Normal',

                                fontWeight: 'Regular',

                                color: null,

                                size: '11px',

                                opacity: 1
                            },

                            margin: {

                                left: 5,

                                top: 5,

                                bottom: 5,

                                right: 5
                            }

                        }
                    },

                    bubbleOptions: {

                        radiusMode: "minmax",

                        minRadius: 1,

                        maxRadius: 3

                    },

                    trendlines: [{

                        visibility: "",

                        visibleOnLegend: "visible",

                        type: "linear",

                        name: "Trendline",

                        fill: "",

                        width: 1,

                        opacity: 1,

                        dashArray: "",

                        forwardForecast: 0,

                        backwardForecast: 0,

                        polynomialOrder: 2,

                        period: 2,

                        intercept: null,

                        tooltip:
                            {

                                visible: false,

                                format: null,

                                fill: null,

                                border: {

                                    width: 1,

                                    color: null
                                },

                                duration: '500ms',

                                enableAnimation: true,

                                opacity: 0.95,

                                font: {

                                    fontFamily: 'Segoe UI',

                                    fontStyle: 'Normal',

                                    fontWeight: 'Regular',

                                    color: null,

                                    size: '12px',

                                    opacity: 1
                                }
                            }
                    }],


                    font: {

                        fontFamily: 'Segoe UI',

                        fontStyle: 'Normal',

                        fontWeight: 'Regular',

                        size: '12px',

                        color: '#707070',

                        opacity: 1
                    },
                    _isdesigntime: true

                }
            ],

            commonSeriesOptions: {
                dragSettings: {
                    enable: false,
                    type: 'xy'
                },

                type: 'column',

                enableTrackTooltip : true,

                splitMode: 'value',

                splitValue: null,

                splineType: 'natural',

                cardinalSplineTension: 0.5,

                gapWidth: 50,

                pieOfPieCoefficient: 0.6,

                visibleOnLegend: "visible",

                enableAnimation: false,

                animationDuration: null,

                animationType: 'linear',

                isClosed: true,

                isTransposed: false,

                isStacking: false,

                columnWidth: 0.7,

                columnSpacing: 0,

                columnFacet: 'rectangle',

                drawType: 'line',

                doughnutCoefficient: 0.4,

                explodeOffset: 25,

                pyramidMode: 'linear',

                boxPlotMode: 'exclusive',

                funnelWidth: '11.6%',

                funnelHeight: '32.7%',

                positiveFill: null,

                showMedian: true,

                outlierSettings: {

                    shape: 'circle',

                    size:
                        {
                            width: 6,

                            height: 6

                        },
                },

                cornerRadius: {

                    topLeft: 0,

                    topRight: 0,

                    bottomLeft: 0,

                    bottomRight: 0
                },

                connectorLine: {

                    width: 1,

                    opacity: 1,

                    dashArray: null
                },

                errorBar: {

                    visibility: "hidden",

                    mode: "vertical",

                    type: "fixedValue",

                    horizontalErrorValue: 1,

                    verticalErrorValue: 3,

                    horizontalPositiveErrorValue: 1,

                    horizontalNegativeErrorValue: 1,

                    verticalPositiveErrorValue: 5,

                    verticalNegativeErrorValue: 5,

                    direction: "both",

                    cap: {

                        visible: true,

                        width: 1,

                        length: 20,

                    },


                    width: 1,

                    opacity: 1,

                },

                highlightSettings: {

                    enable: false,

                    mode: 'series',

                    color: "",

                    opacity: 0.6,

                    border: {

                        color: "",

                        width: 2
                    },

                    pattern: 'none',

                    customPattern: ""
                },

                selectionSettings: {

                    type: 'Single',

                    enable: false,

                    mode: 'series',

                    rangeType: 'xy',

                    color: "",

                    opacity: 0.6,

                    border: {

                        color: "",

                        width: 2
                    },

                    pattern: 'none',

                    customPattern: ""
                },

                emptyPointSettings: {

                    visible: true,

                    style: {

                        color: '',

                        border: {

                            color: '',

                            width: 1

                        }

                    },

                    displayMode: 'gap'
                },

                labelPosition: 'inside',

                gapRatio: 0,

                pieCoefficient: 0.8,

                doughnutSize: 0.8,

                dataSource: null,

                xName: '',

                yName: '',

                pointColorMappingName: '',

                high: '',

                low: '',

                open: '',

                close: '',

                startAngle: null,

                endAngle: null,

                xAxisName: null,

                yAxisName: null,

                explodeAll: false,

                explode: false,

                explodeIndex: null,

                enableSmartLabels: null,

                tooltip: {

                    visible: false,

                    isReversed: false,

                    format: null,

                    template: null,

                    fill: null,

                    border: {

                        color: null,

                        width: 1
                    },

                    enableAnimation: true,

                    duration: '500ms',

                    opacity: 0.95
                },

                fill: null,

                opacity: 1,

                lineCap: 'butt',

                lineJoin: 'round',

                dashArray: "",

                border: {

                    color: 'transparent',

                    width: 1,

                    dashArray: ""
                },
                width: 2,

                marker:
                    {

                        shape: 'circle',

                        imageUrl: "",

                        size: {

                            width: 6,

                            height: 6
                        },

                        visible: false,

                        opacity: 1,

                        fill: null,

                        border: {

                            color: 'white',

                            width: 3
                        },

                        dataLabel:
                            {

                                visible: false,

                                isReversed: false,

                                angle: 0,

                                enableContrastColor: false,

                                showEdgeLabels: false,

                                textMappingName: '',

                                verticalTextAlignment: 'center',

                                horizontalTextAlignment: 'center',

                                textPosition: 'top',
								
								textAnchor:'middle',

                                shape: 'none',

                                maximumLabelWidth: null,

                                enableWrap: false,

                                opacity: 1,

                                fill: null,

                                border: {

                                    color: 'white',

                                    width: 0.1
                                },

                                offset: {

                                    x: 0,

                                    y: 0
                                },

                                connectorLine:
                                    {

                                        width: 0.5,

                                        type: 'line',

                                        height: null
                                    },

                                font:
                                    {

                                        fontFamily: 'Segoe UI',

                                        fontStyle: 'Normal',

                                        fontWeight: 'Regular',

                                        size: '11px',

                                        color: null,

                                        opacity: 1
                                    },

                                margin:
                                    {

                                        left: 5,

                                        top: 5,

                                        bottom: 5,

                                        right: 5
                                    }
                            }
                    },

                bubbleOptions: {

                    radiusMode: "minmax",

                    minRadius: 1,

                    maxRadius: 3

                },

                trendlines: [{

                    visibility: "",

                    visibleOnLegend: "visible",

                    type: "linear",

                    name: "Trendline",

                    fill: "",

                    width: 1,

                    opacity: 1,

                    dashArray: "",

                    forwardForecast: 0,

                    backwardForecast: 0,

                    polynomialOrder: 2,

                    period: 2,

                    intercept: null,

                    tooltip:
                        {

                            visible: false,

                            format: null,

                            fill: null,

                            border: {

                                width: 1,

                                color: null
                            },

                            duration: '500ms',

                            enableAnimation: true,

                            opacity: 0.95,

                            font: {

                                fontFamily: 'Segoe UI',

                                fontStyle: 'Normal',

                                fontWeight: 'Regular',

                                color: null,

                                size: '12px',

                                opacity: 1
                            }
                        }
                }],

                font: {

                    fontFamily: 'Segoe UI',

                    fontStyle: 'Normal',

                    fontWeight: 'Regular',

                    size: '12px',

                    color: '#707070',

                    opacity: 1
                }
            },

            crosshair:
                {
                    line: {


                        width: 1
                    },
                    marker:
                        {

                            visible: true,

                            size:
                                {

                                    width: 10,

                                    height: 10
                                },

                            opacity: 1,

                            border:
                                {

                                    width: 3
                                }
                        },

                    visible: false,

                    isReversed: false,

                    type: "crosshair",

                    trackballTooltipSettings: {

                        fill: null,

                        mode: "float",

                        border: {

                            width: null,

                            color: null,

                        },

                        rx: 3,

                        ry: 3,

                        opacity: 1,

                        tooltipTemplate: null
                    }
                },


            pointStyle:
                {
                    lineCap: 'butt', lineJoin: 'round', opacity: 1, interior: null, borderColor: null, borderWidth: 1
                },
            textStyle:
                {
                    marker: { textAlignment: 'center', textPosition: 'top' },
                    font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', fontWeight: 'Regular', size: '12px', color: '#707070', opacity: 1 }
                },
            symbolShape: {
                None: 0,
                LeftArrow: 1,
                RightArrow: 2,
                Circle: 3,
                Cross: 4,
                HorizLine: 5,
                VertLine: 6,
                Diamond: 7,
                Rectangle: 8,
                Triangle: 9,
                InvertedTriangle: 10,
                Hexagon: 11,
                Pentagon: 12,
                Star: 13,
                Ellipse: 14,
                Wedge: 15,
                Trapezoid: 16,
                UpArrow: 17,
                DownArrow: 18,
                Image: 19,
                SeriesType: 20

            },
            initSeriesRender: true,

            theme: "flatlight",

            canResize: false,

            isResponsive: false,

            enable3D: false,

            enableRotation: false,

            sideBySideSeriesPlacement: null,

            perspectiveAngle: 90,

            rotation: 0,

            tilt: 0,

            wallSize: 2,

            depth: 100,

            enableCanvasRendering: false,

            selectedDataPointIndexes: [],

            exportSettings: {

                type: "png",

                fileName: "Chart",

                orientation: "portrait",

                angle: 0,

                mode: "client",

                action: "",

                multipleExport: false
            },

            zooming:
                {

                    enable: false,

                    isReversed: false,

                    enableScrollbar: false,

                    type: 'x,y',

                    enablePinching: true,

                    enableMouseWheel: false,

                    enableDeferredZoom: false,

                    toolbarItems: ["zoomIn", "zoomOut", "zoom", "pan", "reset"]
                },
            type: 'x,y',

            locale: null,

            xZoomFactor: 1,

            yZoomFactor: 1,

            xZoomPosition: 0,

            yZoomPosition: 0,

            load: "",

            axesLabelRendering: "",

            axesRangeCalculate: "",

            axesTitleRendering: "",

            dragStart: "",

            dragging: "",

            dragEnd: "",

            chartAreaBoundsCalculate: "",

            legendItemRendering: "",

            legendBoundsCalculate: "",

            preRender: "",

            seriesRendering: "",


            trendlineRendering: "",

            symbolRendering: "",

            titleRendering: "",
            subtitleRendering: "",

            axesLabelsInitialize: "",

            pointRegionClick: "",

            seriesRegionClick: "",

            annotationClick: "",

            axisLabelClick: "",

            chartClick: "",

            scrollStart: "",

            scrollEnd: "",

            scrollChanged: "",

            chartDoubleClick: "",

            pointRegionMouseMove: "",

            legendItemClick: "",

            axisLabelMouseMove: "",

            chartMouseMove: "",

            legendItemMouseMove: "",

            chartMouseLeave: "",

            displayTextRendering: "",

            toolTipInitialize: "",

            trackAxisToolTip: "",

            trackToolTip: "",

            animationComplete: "",

            zoomed: "",

            destroy: "",

            create: "",

            beforeResize: "",

            afterResize: "",

            rangeSelected: "",

            multiLevelLabelClick: "",

            multiLevelLabelRendering: "",

            margin: { left: 10, right: 10, top: 10, bottom: 10 },
            size: { width: null, height: null },
            elementSpacing: 10,

            dateStart: 25568.791666666668

        },

        dataTypes: {
            commonSeriesOptions: { dataSource: "data" },
            axes: "array",
            series: "array",
            annotations: "array",
            indicators: "array",
            seriesColors: "array",
            palette: "array",
            rowDefinitions: "array",
            columnDefinitions: "array",
            seriesBorderColors: "array",
            pointColors: "array",
            pointBorderColors: "array",
            initSeriesRender: "boolean",
            theme: "enum",
            canResize: "boolean",
            isResponsive: "boolean",
            elementSpacing: "number",
            primaryXAxis: {
                labels: "array",
                multiLevelLabels: "array",
                stripLine: "array",
                orientation: "enum",
                rangePadding: "enum",
                labelPlacement: "enum",
                tickLinesPosition: "enum",
                labelPosition: "enum",
                opposedPosition: "boolean",
                zoomFactor: "number",
                zoomPosition: "number",
                showNextToAxisLine: "boolean"
            },
            primaryYAxis: {
                labels: "array",
                multiLevelLabels: "array",
                stripLine: "array",
                orientation: "enum",
                rangePadding: "enum",
                labelPlacement: "enum",
                opposedPosition: "boolean",
                zoomFactor: "number",
                zoomPosition: "number"
            },
            legend: {
                textOverflow: "enum",
                shape: "enum",
                alignment: "enum",
                position: "enum",
                itemPadding: "number"
            },
            exportSettings: {
                type: "string",
                fileName: "string",
                orientation: "enum",
                angle: "number",
                mode: "enum",
                action: "string",
                multipleExport: "boolean"
            },
            zooming: {
                enable: "boolean",
                type: "string",
                enableMouseWheel: "boolean",
                toolbarItems: "array",
                enableScrollbar: "boolean"
            },
            size: {
                width: "string",
                height: "string"
            }

        },

        observables: ["xZoomFactor", "yZoomFactor", "xZoomPosition", "yZoomPosition"],

        _tags: [{
            tag: "series",
            attr: ["xAxisName", "yAxisName", "zOrder", "endAngle", "startAngle", "explodeIndex", "labelPosition", "xName", "yName", "pointColorMappingName", "pyramidMode", "boxPlotMode", "showMedian",
                "pieCoefficient", "explodeAll", "explodeOffset", "funnelWidth", "columnFacet", "funnelHeight", "gapRatio", "isClosed", "isTransposed", "enableTrackTooltip",
                "isStacking", "bearFillColor", "bullFillColor", "dataSource", "enableAnimation", "animationDuration", "doughnutCoefficient", "doughnutSize",
                "enableSmartLabels", "drawType", "dashArray", "visibleOnLegend", "columnSpacing", "columnWidth", "drawType", "positiveFill", "explodeIndex", "cornerRadius",
                "lineCap", "lineJoin", "highlightSettings.enable", "highlightSettings.mode", "highlightSettings.pattern", "highlightSettings.color", "highlightSettings.opacity",
                "highlightSettings.customPattern", "highlightSettings.border.color", "highlightSettings.border.width", "selectionSettings.enable", "selectionSettings.mode", "selectionSettings.pattern",
                "selectionSettings.color", "selectionSettings.opacity", "selectionSettings.customPattern", "selectionSettings.type", "selectionSettings.rangeType",
                "selectionSettings.border.width", "selectionSettings.border.color", "dragSettings.enable", "dragSettings.type",
                "connectorLine.width", "connectorLine.opacity", "connectorLine.dashArray", "cornerRadius.topLeft", "cornerRadius.topRight", "cornerRadius.bottomLeft", "cornerRadius.bottomRight",
                "errorBar.visibility", "errorBar.mode", "errorBar.type", "errorBar.horizontalErrorValue", "errorBar.verticalErrorValue", "errorBar.horizontalPositiveErrorValue",
                "errorBar.horizontalNegativeErrorValue", "errorBar.verticalPositiveErrorValue", "errorBar.verticalNegativeErrorValue", "errorBar.direction",
                "errorBar.cap.visible", "errorBar.cap.width", "errorBar.cap.length", "errorBar.width", "errorBar.opacity", "emptyPointSettings.visible",
                "emptyPointSettings.style.color", "emptyPointSettings.style.border.color", "emptyPointSettings.style.border.width", "emptyPointSettings.displayMode",
                "bubbleOptions.minRadius", "bubbleOptions.maxRadius", "bubbleOptions.radiusMode",
                "tooltip.visible", "tooltip.format", "tooltip.template", "tooltip.fill", "tooltip.border.width", "tooltip.border.color", "tooltip.enableAnimation", "tooltip.duration",
                "tooltip.opacity", "tooltip.font.size", "tooltip.font.opacity", "tooltip.font.fontFamily", "tooltip.font.fontStyle", "tooltip.font.fontWeight", "tooltip.font.color", "border.width", "border.color", "border.dashArray", "marker.shape", "marker.imageUrl", "marker.size.width", "marker.size.height",
                "marker.visible", "marker.opacity", "marker.fill", "marker.border.color", "marker.border.width", "marker.dataLabel.visible", "marker.dataLabel.angle",
                "marker.dataLabel.template", "marker.dataLabel.textMappingName", "marker.dataLabel.verticalTextAlignment", "marker.dataLabel.horizontalTextAlignment", "marker.dataLabel.textPosition","marker.dataLabel.textAnchor", "marker.dataLabel.shape",
                "marker.dataLabel.opacity", "marker.dataLabel.fill", "marker.dataLabel.border.color", "marker.dataLabel.border.width", "marker.dataLabel.maximumLabelWidth", "marker.dataLabel.enableWrap",
                "marker.dataLabel.connectorLine.width", "marker.dataLabel.connectorLine.type", "marker.dataLabel.connectorLine.color", "marker.dataLabel.offset", "marker.dataLabel.offset.x", "marker.dataLabel.offset.y",
                "marker.dataLabel.font.size", "marker.dataLabel.font.color", "marker.dataLabel.enableContrastColor", "marker.dataLabel.showEdgeLabels", "marker.dataLabel.font.opacity", "marker.dataLabel.font.fontFamily", "marker.dataLabel.font.fontStyle", "marker.dataLabel.font.fontWeight",
                "marker.dataLabel.margin", "marker.dataLabel.margin.left", "marker.dataLabel.margin.top", "marker.dataLabel.margin.bottom", "marker.dataLabel.margin.right",
                "font.size", "font.opacity", "font.fontFamily", "font.fontStyle", "font.fontWeight", "font.color", "splineType", "cardinalSplineTension",
                [
                    {
                        tag: "trendlines", attr: ["visibility", "visibilityOnLegend", "dashArray", "forewardForecast", "backwardForecast", "polynomialOrder",
                            "tooltip.visible", "tooltip.format", "tooltip.fill", "tooltip.border.width", "tooltip.border.color", "tooltip.enableAnimation", "tooltip.duration",
                            "tooltip.opacity", "tooltip.font.size", "tooltip.font.opacity", "tooltip.font.fontFamily", "tooltip.font.fontStyle", "tooltip.font.fontWeight", "tooltip.font.color",
                        ], singular: "trendline"
                    }
                ],
                [
                    {
                        tag: "points", attr: ["x", "y", "text", "textMappingName", "isEmpty", "fill", "visible"], singular: "points"
                    }
                ]

            ],
            singular: "series"
        }, {
            tag: "axes",
            attr: ["columnIndex", "rowIndex", "desiredIntervals", "multiLevelLabelsColor", "multiLevelLabelsFontColor", "isIndexed", "labelPlacement", "edgeLabelPlacement", "intervalType", "labelFormat", "labelPosition", "labelRotation", "logBase",
                "labelIntersectAction", "opposedPosition", "plotOffset", "rangePadding", "roundingPlaces", "valueType", "zoomFactor", "zoomPosition", "orientation",
                "crossesAt", "crossesInAxis", "scrollbarSettings.visible", "scrollbarSettings.canResize", "scrollbarSettings.range.min", "scrollbarSettings.range.max", "scrollbarSettings.pointsLength",
                "range.min", "range.max", "range.interval", "tickLinesPosition", "alternateGridBand.odd.fill", "alternateGridBand.odd.opacity", "alternateGridBand.even.fill", "alternateGridBand.even.opacity",
                "enableAutoIntervalOnZooming", "majorGridLines.width", "majorGridLines.color", "majorGridLines.dashArray", "majorGridLines.visible", "majorGridLines.opacity", "majorTickLines.color", "majorTickLines.width", "majorTickLines.size", "majorTickLines.visible",
                "minorGridLines.width", "minorGridLines.dashArray", "minorGridLines.color", "minorGridLines.visible", "minorTickLines.color", "minorTickLines.width", "minorTickLines.size", "minorTickLines.visible", "labelBorder.color", "labelBorder.width", "minorTicksPerInterval",
                "columnSpan", "crosshairLabel.visible", "crosshairLabel.rx", "crosshairLabel.ry", "crosshairLabel.border.color", "crosshairLabel.border.width", "crosshairLabel.fill",
                "crosshairLabel.font.fontFamily", "crosshairLabel.font.fontStyle", "crosshairLabel.font.size", "crosshairLabel.font.fontWeight", "crosshairLabel.font.opacity", "crosshairLabel.font.color", "font.size", "font.color", "font.opacity", "font.fontFamily", "font.fontStyle", "font.fontWeight", "isInversed", "enableTrim", "maximumLabelWidth",
                "axisLine.visible", "axisLine.width", "axisLine.color", "axisLine.dashArray", "axisLine.offset", "maximumLabels", "title.text", "title.visible", "title.enableTrim", "title.offset",
                "title.alignment", "title.position", "title.maximumTitleWidth", "title.font.size", "title.font.color", "title.font.opacity", "title.font.fontFamily", "title.font.fontStyle", "title.font.fontWeight",
                "additionalPadding", "showNextToAxisLine",
                [
                    {
                        tag: "stripLine", attr: ["borderColor", "startFromAxis", "zIndex", "textAlignment", "font.size", "font.opacity", "font.fontFamily", "font.fontStyle", "font.fontWeight", "font.color"],
                        singular: "stripLine"
                    }
                ],
                [
                    {
                        tag: "multiLevelLabels", attr: ["textOverflow", "maximumTextWidth", "textAlignment", "font.size", "font.opacity", "font.fontFamily", "font.fontStyle", "font.fontWeight", "border.type", "border.width"],
                        singular: "multiLevelLabel"
                    }
                ],
            ],
            singular: "axis"
        },
        {
            tag: "primaryXAxis.stripLine",
            attr: ["borderColor", "startFromAxis", "zIndex", "textAlignment", "font.size", "font.opacity", "font.fontFamily", "font.fontStyle", "font.fontWeight", "font.color"],
            singular: "primaryXAxis.stripLine"
        },
        {
            tag: "primaryYAxis.stripLine",
            attr: ["borderColor", "startFromAxis", "zIndex", "textAlignment", "font.size", "font.opacity", "font.fontFamily", "font.fontStyle", "font.fontWeight", "font.color"],
            singular: "primaryYAxis.stripLine"
        },
        {
            tag: "primaryXAxis.multiLevelLabels",
            attr: ["textOverflow", "maximumTextWidth", "textAlignment", "font.size", "font.opacity", "font.fontFamily", "font.fontStyle", "font.fontWeight", "border.type", "border.width"],
            singular: "primaryXAxis.multiLevelLabel"
        },
        {
            tag: "primaryYAxis.multiLevelLabels",
            attr: ["textOverflow", "maximumTextWidth", "textAlignment", "font.size", "font.opacity", "font.fontFamily", "font.fontStyle", "font.fontWeight", "border.type", "border.width"],
            singular: "primaryYAxis.multiLevelLabel"
        },
        {
            tag: "indicators",
            attr: ["seriesName", "xName", "xAxisName", "macdType", "shortPeriod", "longPeriod", "enableAnimation", "animationDuration",
                "yAxisName", "standardDeviations", "kPeriod", "dPeriod", "periodLine.fill", "periodLine.width", "lowerLine.fill",
                "lowerLine.width", "upperLine.fill", "upperLine.width", "macdLine.fill", "macdLine.width", "histogram.fill", "histogram.opacity",
                "histogram.border.color", "histogram.border.width", "font.size", "font.opacity", "font.fontFamily", "font.fontStyle", "font.fontWeight", "font.color",
                "tooltip.visible", "tooltip.format", "tooltip.fill", "tooltip.border.width", "tooltip.border.color", "tooltip.enableAnimation", "tooltip.duration",
                "tooltip.opacity",
                [
                    {
                        tag: "points", attr: []
                    }
                ]
            ],
            singular: "indicator"
        },
        {
            tag: "annotations",
            attr: ["coordinateUnit", "verticalAlignment", "horizontalAlignment", "xAxisName", "yAxisName", "margin.left", "margin.right", "margin.top", "margin.bottom"],
            singular: "annotation"
        },
        {
            tag: "rowDefinitions",
            attr: ["rowHeight", "lineColor", "lineWidth", "unit"],
            singular: "rowDefinition"
        },
        {
            tag: "columnDefinitions",
            attr: ["columnWidth", "lineColor", "lineWidth", "unit"],
            singular: "columnDefinition"
        },
        ],
        _xZoomFactor: sf.util.valueFunction("xZoomFactor"),
        _yZoomFactor: sf.util.valueFunction("yZoomFactor"),
        _xZoomPosition: sf.util.valueFunction("xZoomPosition"),
        _yZoomPosition: sf.util.valueFunction("yZoomPosition"),


        _init: function () {

            this._renderSfChart();

        },
        _destroy: function () {
            $('#template_group_' + this._id).remove();
            $("#annotation_group_" + this._id).remove();
            $(this.element).removeClass("e-chart e-js").find("#" + this.svgObject.id).remove();
            $(this.element).removeClass("e-chart e-js").find("#legend_" + this.svgObject.id).remove();
        },

        _series: function (index, property, value, old) {
            this.redraw();
            this._trigger("refresh");
        },
        _series_points: function (index, property, value, old) {
            this.redraw();
            this._trigger("refresh");
        },
        _primaryXAxis_stripLine: function (index, property, value, old) {
            this.redraw();
            this._trigger("refresh");
        },
        _primaryYAxis_stripLine: function (index, property, value, old) {
            this.redraw();
            this._trigger("refresh");
        },
        _axes: function (index, property, value, old) {
            this.redraw();
            this._trigger("refresh");
        },
        _axes_stripLine: function (index, property, value, old) {
            this.redraw();
            this._trigger("refresh");
        },

        _ignoreOnExport: ["dataSource"],


        _removeZoomkit: function () {
            if (this.model.zooming.enable) {
                $("[id^=" + this._id + "_][id$=" + "_ResetZoom" + "]").remove();
                $("[id^=" + this._id + "_][id$=" + "_PanBtn" + "]").remove();
                $("[id^=" + this._id + "_][id$=" + "_ZoomBtn" + "]").remove();
                $("[id^=" + this._id + "_][id$=" + "_ZoomInBtn" + "]").remove();
                $("[id^=" + this._id + "_][id$=" + "_ZoomOutBtn" + "]").remove();
            }
        },

        //to create a new canvas element to export and print
        getCanvasElement: function (id) {
            var chart,
                printId = $("#" + id),
                exportPrintCanvas = document.createElement('canvas'),
                expCtx = exportPrintCanvas.getContext("2d"),
                chartWidth = $("#" + id + "_canvas").width(),
                chartHeight = $("#" + id + "_canvas").height();
            exportPrintCanvas.setAttribute('width', chartWidth);
            exportPrintCanvas.setAttribute('height', chartHeight);
            chart = $("#" + id + '_canvas')[0];
            expCtx.drawImage(chart, 0, 0, chartWidth, chartHeight);

            return { canvasContainer: exportPrintCanvas, canvasArea: expCtx, width: chartWidth, height: chartHeight };

        },
        // export and print the svg element
        getSVGElement: function (id) {
            var chartWidthSVG = $("#" + id + "_svg").width(),
                chartHeightSVG = $("#" + id + "_svg").height(),
                svgChart = document.getElementById(id + "_svg"),
                containerSVG = $('<div>').append($(svgChart).clone()).html(),
                legendChart = document.getElementById("legend_" + id + "_svg"),
                position = $("#legend_" + id).position(),
                element = $("#" + id + "_svg_Legend").attr('transform', "translate(" + position.left + "," + position.top + ")"),
                containerLegendSVG = $('<div>').append($(legendChart).clone()).html();

            return { chartSVG: containerSVG, legendChartSVG: containerLegendSVG, width: chartWidthSVG, height: chartHeightSVG };
        },

        print: function () {
            //declaration
            var contentSVG, Id, svgID, canvasElement, chartObj, printId, printCtxAnnot, legend, selectionChart, selectionLegendChart,
                selectionChartSVG, legendChartSVG, annotationChartCanvas, canvasChart = [], writeCode = [], containerselectionChartSVG,
                containerSelectionLegendSVG, legendPos, annotationChartSVG, containerAnnotationChartSVG,
                serIndex = this.model.series.length, scrollbar, TDStyle = "", oImg = "", chartHeight = 0, chartDistance = 50;
            for (var i = 0; i < arguments.length; i++) {

                printId = $("#" + arguments[i]);
                Id = arguments[i];

                //to check whether the div contains chart element
                if (printId.hasClass("e-datavisualization-chart")) {
                    chartObj = printId.ejChart("instance");
                    contentSVG = "<html> <div style='position:relative; left:0px; top:" + chartHeight + "px'>";
                    scrollbar = "";
                    svgID = chartObj.svgObject.id;

                    chartHeight = $("#" + svgID).height() + chartDistance;

                    if ($("#axisScrollbar_" + Id)[0])
                        scrollbar = $("#axisScrollbar_" + Id)[0].innerHTML;

                    var zoomButton = ["ResetZoom", "PanBtn", "ZoomBtn", "ZoomOutBtn", "ZoomInBtn"], zoomBtnObj = [], zoomToolbarID, btnCount = 5;
                    for (var l = 0; l < btnCount; l++) {
                        zoomToolbarID = "#" + svgID + "_" + zoomButton[l];
                        if ($(zoomToolbarID)[0]) {
                            zoomBtnObj.push($(zoomToolbarID));
                            //Remove zoomButtons on printing
                            $(zoomToolbarID).remove();
                        }
                    }

                    if (chartObj.model.enableCanvasRendering == true) { //to check the chart to render in canvas
                        canvasElement = this.getCanvasElement(Id);

                        //to find the lengend position  
                        legendPos = chartObj.model.LegendBounds;

                        oImg = document.createElement("img");
                        oImg.setAttribute('src', $('#legend_' + Id + '_canvas')[0].toDataURL());
                        $("#legend_Scroller" + Id).prepend(oImg);
                        contentSVG += document.getElementById('chartContainer_' + Id).outerHTML;
                        $(oImg).remove();
                        oImg = "";

                        var mode;
                        //selection chart to print in canvas
                        for (var index = 0; index < serIndex; index++) {
                            mode = chartObj.model.series[index].selectionSettings.mode.toLowerCase();
                            if (chartObj.model.AreaType != "none") {
                                if (mode == "series") {
                                    if ($(printId).find("#" + Id + "_Selection_series" + index + "_canvas").length > 0) {
                                        selectionChart = $("#" + Id + "_Selection_series" + index + "_canvas")[0];
                                        canvasElement.canvasArea.drawImage(selectionChart, 0, 0, canvasElement.width, canvasElement.height);
                                    }
                                    if ($(printId).find("#" + Id + "_Selection_Legend" + index + "_canvas").length > 0) {
                                        selectionLegendChart = $("#" + Id + "_Selection_Legend" + index + "_canvas")[0];
                                        oImg = "<img style='position:absolute;left:0px;' src='" + selectionLegendChart.toDataURL() + "'/>";
                                    }
                                } else if (mode == "point") {
                                    var selectedPoints = chartObj.model.selectedDataPointIndexes;
                                    for (var l = 0; l < selectedPoints.length; l++) {
                                        if (selectedPoints[l].seriesIndex == index) {
                                            if ($(printId).find("#" + Id + "_Selection_series" + index + "_point_" + selectedPoints[l].pointIndex + "_canvas").length > 0) {
                                                selectionChart = $("#" + Id + "_Selection_series" + index + "_point_" + selectedPoints[l].pointIndex + "_canvas")[0];
                                                canvasElement.canvasArea.drawImage(selectionChart, 0, 0, canvasElement.width, canvasElement.height);
                                            }
                                        }
                                    }
                                    if ($(printId).find("#" + Id + "_Selection_Legend" + index + "_canvas").length > 0) {
                                        selectionLegendChart = $("#" + Id + "_Selection_Legend" + index + "_canvas")[0];
                                        oImg = "<img style='position:absolute;left:0px;' src='" + selectionLegendChart.toDataURL() + "'/>";
                                    }
                                } else {
                                    var selectedPoints = chartObj.model.selectedDataPointIndexes;
                                    for (var l = 0; l < selectedPoints.length; l++) {
                                        if (selectedPoints[l].seriesIndex == index) {
                                            if ($(printId).find("#" + Id + "_Selection_Cluster_point_" + selectedPoints[l].pointIndex + "_canvas").length > 0) {
                                                selectionChart = $("#" + Id + "_Selection_Cluster_point_" + selectedPoints[l].pointIndex + "_canvas")[0];
                                                canvasElement.canvasArea.drawImage(selectionChart, 0, 0, canvasElement.width, canvasElement.height);
                                            }
                                        }
                                    }
                                    if ($(printId).find("#" + Id + "_SelectionCluster_Legend" + index + "_canvas").length > 0) {
                                        selectionLegendChart = $("#" + Id + "_SelectionCluster_Legend" + index + "_canvas")[0];
                                        oImg = "<img style='position:absolute;left:0px;' src='" + selectionLegendChart.toDataURL() + "'/>";
                                    }
                                }
                            } else {
                                var selectedPoints = chartObj.model.selectedDataPointIndexes;
                                for (var l = 0; l < selectedPoints.length; l++) {
                                    if (selectedPoints[l].seriesIndex == index) {
                                        if ($('#' + Id + '_Selection_series' + index + "_point_" + selectedPoints[l].pointIndex + "_canvas").length > 0) {
                                            selectionChart = document.getElementById(Id + '_Selection_series' + index + "_point_" + selectedPoints[l].pointIndex + "_canvas");
                                            canvasElement.canvasArea.drawImage(selectionChart, 0, 0, canvasElement.width, canvasElement.height);
                                            if ($('#' + Id + "_Selection_Legend" + selectedPoints[l].pointIndex + "_canvas").length > 0) {
                                                selectionLegendChart = document.getElementById(Id + "_Selection_Legend" + selectedPoints[l].pointIndex + "_canvas");
                                                oImg = "<img style='position:absolute;left:0px;' src='" + selectionLegendChart.toDataURL() + "'/>";
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        canvasElement.canvasArea.save();
                        //to store the chart canvas element
                        canvasChart.push(canvasElement.canvasContainer);
                    }
                    //to check the chart to render in svg
                    else {
                        var printSvgElement = this.getSVGElement(Id);

                        $("#" + Id + "_svg_Legend").removeAttr("transform");
                        contentSVG += $("#chartContainer_" + Id)[0].outerHTML;

                        //selection chart to print in svg
                        contentSVG = this._getSelectionContentInSVG(chartObj, Id, contentSVG, "print");

                        //draw background image for chart
                        if (chartObj.model.backGroundImageUrl != null) {
                            var img = new Image();
                            img.src = chartObj.model.backGroundImageUrl;
                            var canvasObj = document.createElement('canvas');
                            var ctx = canvasObj.getContext("2d");
                            canvasObj.setAttribute('width', printSvgElement.width);
                            canvasObj.setAttribute('height', printSvgElement.height);
                            ctx.drawImage(img, 0, 0, printSvgElement.width, printSvgElement.height);
                            contentSVG += "<img src='" + canvasObj.toDataURL() + "'/>";
                        }
                        contentSVG += '<svg xmlns="http://www.w3.org/2000/svg" style="left:0px; top:0px; position:absolute;" width="' + printSvgElement.width + '" height="' + printSvgElement.height + '" >';
                        contentSVG += printSvgElement.chartSVG.toString() + " </svg>";

                        //Add zooming scrollbar with chart
                        contentSVG += scrollbar + "</div></html>";

                        //to store the chart svg element
                        writeCode.push(contentSVG);
                    }

                    for (var l = 0; l < zoomBtnObj.length; l++) {
                        //push zoomButtons again
                        $("#chartContainer_" + Id).append(zoomBtnObj[l]);
                    }
                }
                //the div does not contains the chart element
                else {
                    contentSVG = "<html>";
                    contentSVG += document.getElementById(arguments[i]).innerHTML;
                    contentSVG += "</html>";
                    //to store the div id elements
                    writeCode.push(contentSVG);
                }
            }
            //to print the chart in a new window
            var win = window.open();
            for (var s = 0; s < writeCode.length; s++)
                win.document.write(writeCode[s]);
            //to open a print window for canvas element
            if (canvasChart.length > 0) {
                var img = new Image();
                for (var y = 0; y < canvasChart.length; y++) {
                    contentSVG += "<img src='" + canvasChart[y].toDataURL() + "'/>";
                    img.src = canvasChart[y].toDataURL();
                }
                contentSVG += oImg;
                //Add zooming scrollbar with chart
                contentSVG += scrollbar + "</div></html>";
                img.onload = function () {
                    win.document.write(contentSVG);
                    contentSVG = "";
                    win.document.close();
                    win.focus();
                    win.print();
                    win.close();
                }
            }
            //to open a print window for svg element
            else if (writeCode.length > 0) {
                contentSVG = "";
                win.document.close();
                win.focus();
                win.print();
                win.close();
            }

        },


        redraw: function (excludeDataUpdate, pinchPanning, target, isTouch) {
            if (this.model.enableCanvasRendering) {
                if (this.model.zooming.enable && this.svgRenderer.ctx){
                    this.svgRenderer.ctx.clearRect(0, 0, $("#" + this._id).width(), $("#" + this._id).height());
					$(this.axisScroll).empty();
				}
                else {
                    $(this.svgObject).remove();
                    var width = this.svgWidth;
                    $("#canvas_trackSymbol").remove();
                    $("#" + this._id + "_canvas_Tracker").remove();
                    $("#secondCanvas").remove();
                    this.svgRenderer = new sf.EjCanvasRender(this.element); // to create canvas container
                    this.svgRenderer.svgObj.height = sf.util.isNullOrUndefined(this.model.size.height) ? "450" : this.model.size.height;
                    this.svgRenderer.svgObj.width = sf.util.isNullOrUndefined(this.model.size.width) ? width : this.model.size.width;
                    this.svgObject = this.svgRenderer.svgObj;
                    var ctx = this.svgRenderer.svgObj.getContext("2d");

                    $(this.scrollerContainer).remove();
                    $(this.legendSvgContainer).remove();
                    $(this.legendContainer).remove();
                    this.legendContainer = $("<div></div>").attr('id', "legend_" + this._id).css("height", "0px");
                    this.scrollerContainer = $("<div></div>").attr('id', "legend_Scroller" + this._id).css("height", "0px");
                    this.legendSvgContainer = this.svgRenderer.createLegendCanvas(this.element); //creating new CANVAS element for legend
                    this.svgRenderer.append(this.legendSvgContainer, this.scrollerContainer);
                    $(this.scrollerContainer).appendTo(this.legendContainer);
                    $(this.legendContainer).appendTo(this.chartContainer);
                }
            }
            else if ((this.svgObject.id).indexOf("_canvas") != -1) {
                this._removeZoomkit();
                $(this.svgObject).remove();
                this.svgRenderer = new sf.EjSvgRender(this.element);  // to create svg container
                this.svgObject = this.svgRenderer.svgObj;
                this.canvasX = this.canvasY = 0;

                $(this.scrollerContainer).remove();
                $(this.legendSvgContainer).remove();
                $(this.legendContainer).remove();
                this.legendContainer = $("<div></div>").attr('id', "legend_" + this._id).css("height", "0px");
                this.scrollerContainer = $("<div></div>").attr('id', "legend_Scroller" + this._id).css("height", "0px");
                this.legendSvgContainer = this.svgRenderer.createLegendSvg(this.element); //creating new SVG element for legend
                this.svgRenderer.append(this.legendSvgContainer, this.scrollerContainer);
                $(this.scrollerContainer).appendTo(this.legendContainer);
                $(this.legendContainer).appendTo(this.chartContainer);
            } else {
                if (!this.dragPoint || (!pinchPanning && (!this.panning || !target || this.scrollbarUpdate || (isTouch || this.panning && this.model.browserInfo.name != "chrome")) || this.model.enable3D)) {
                    $(this.svgObject).empty();  // using existing svg container
                    $(this.legendSvgContainer).empty();
					$(this.axisScroll).empty();
				}
                else {
                    var svg = this.svgObject;
                    this.chartUpdating = true;
                    if (!this.continuePinching && target) {
                        target.id = "";
                        target.setAttribute("opacity", 0);
                        svg.appendChild(target);
                        this.continuePinching = false;
                    }
                    while (svg.childNodes.length > 1)
                        svg.removeChild(svg.firstChild);

                    $(this.legendSvgContainer).empty();
                }
            }
			if(this.model._chartAreaZoom)
			this.zoomed = this.model._chartAreaZoom = this.model._axes.some((function (val) {
                        return val.zoomFactor < 1 || val.zoomPosition > 0;
                    }));
			this._removeZoomkit();
            $("#annotation_group_" + this._id).remove();   // to remove annotation on redraw
            if (!excludeDataUpdate) {

                if (this.model.canResize || this.model.isResponsive)
                    this.bindResizeEvents();
                else
                    this.removeResizeEvents();
            }
			if ($(this.element).is(":visible") || $(this.element).css("visibility") != "hidden" || $(this.element).css('display') != 'none') {
				if(!this._isEventsBinded)
					this.bindEvents();
				this.bindTo(excludeDataUpdate);
			}
        },

        "export": function (type, action, multipleExport) {       // method to export chart
            var data,
                exporting = this.model.exportSettings,
                type = sf.util.isNullOrUndefined(type) ? exporting.type : type.toLowerCase(),
                action = sf.util.isNullOrUndefined(action) ? exporting.action : action.toLowerCase();

            if (type == "xlsx")
                this._getExportModel(type, action, multipleExport);
            else if (type == "svg" || !this.model.enableCanvasRendering)
                data = this.svgExport();
            else
                data = this.imageExport();

            return data;
        },

        _getExportModel: function (type, action, multipleExport) {           // to export chart as excel
            var modelClone = $.extend(true, {}, this.model),
                exporting = this.model.exportSettings,
                multipleExport = sf.util.isNullOrUndefined(type) ? exporting.multipleExport : multipleExport,
                svgHeight = this.svgHeight, svgWidth = this.svgWidth,
                actualHeight = modelClone.size.height, actualWidth = modelClone.size.width,
                attr = { action: action, method: 'post' },
                form = sf.buildTag('form', "", null, attr),
                series, chartobj = this;
            modelClone.event = null; // event is not API and having circular structure object type
            modelClone.primaryXAxis.range = modelClone.primaryXAxis.actualRange;
            modelClone.primaryYAxis.range = modelClone.primaryYAxis.actualRange;
			delete modelClone.chartRegions;
            if (this._ignoreOnExport) {
                series = modelClone.series;
                for (var j = 0; j < series.length; j++) {
                    delete series[j].dataSource;
                    delete series[j].query;
                    series[j].fill = jQuery.type(series[j].fill) == "array" ? series[j].fill[0].color : series[j].fill;
                }
            }
            for (var j = 0; j < series.length; j++) {
                if (!series[j].dataPoint) {
                    series[j].dataPoint = series[j].points;
                    for (var k = 0; k < series[j].dataPoint.length; k++) {
                        if (!series[j].dataPoint[k].fill && modelClone.pointColors.length > k)
                            series[j].dataPoint[k].fill = modelClone.pointColors[k];
                    }
                }
				if (!series[j].trendLine)
                    series[j].trendLine = series[j].trendlines;
            }
            if (sf.raiseWebFormsServerEvents) {
                this.raiseWebServerEvents(JSON.stringify(modelClone), "excelExporting");
                this.raiseWebServerEvents(JSON.stringify(modelClone));
            }
            else {
                if (modelClone.size.height && modelClone.size.height.indexOf("%") != -1)
                    modelClone.size.height = $(this.svgObject).height().toString();
                if (modelClone.size.width && modelClone.size.width.indexOf("%") != -1)
                    modelClone.size.width = $(this.svgObject).width().toString();

                if (multipleExport) {
                    var chartObjectArray = {};
                    $('body').find('.e-datavisualization-chart').each(function (index, object) {
                        var chartObject = $(object).data('ejChart');
                        if (!sf.isNullOrUndefined(chartObject)) {
                            chartObject.model.event = null;
                            var modelClone = JSON.parse(JSON.stringify(chartObject.model));
                            if (chartobj._ignoreOnExport) {
                                series = modelClone.series;
                                for (var j = 0; j < series.length; j++) {
                                    delete series[j].dataSource;
                                    delete series[j].query;
                                    series[j].fill = jQuery.type(series[j].fill) == "array" ? series[j].fill[0].color : series[j].fill;
                                }
                                chartObjectArray[index] = JSON.stringify(modelClone);
                                var inputAttr = { name: 'ChartModel', type: 'hidden', value: JSON.stringify(modelClone) }
                                var input = sf.buildTag('input', "", null, inputAttr);
                                form.append(input);
                            }
                        }
                    });
                }
                else {
					series = modelClone.series;
					for (var j = 0; j < series.length; j++) {
                     	delete series[j]._visiblePoints;
                     	delete series[j].points;
                	}
                    var inputAttr = { name: 'ChartModel', type: 'hidden', value: JSON.stringify(modelClone) }
                    var input = sf.buildTag('input', "", null, inputAttr);
                    form.append(input);
                    form.append(this);
                }
                $('body').append(form);
                form.submit();
                modelClone.size = { width: actualWidth, height: actualHeight };
            }
            return modelClone;
        },

        imageExport: function () {       // to export chart as image
            var modelClone = $.extend(true, {}, this.model);
            modelClone.primaryXAxis.range = modelClone.primaryXAxis.actualRange;
            modelClone.primaryYAxis.range = modelClone.primaryYAxis.actualRange;
            modelClone.event = null; // event is not API and having circular structure object type
            var Id = this._id,
                selectionChart = $('[id*=' + Id + '_Selection_' + ']'),
                legend = $('#legend_' + Id + '_canvas')[0],
                exporting = this.model.exportSettings,
                angle = exporting.angle, exportChart, exprtCtx, chartWidth, chartHeight, chart,
                legendPos = this.model.LegendBounds, containerStyle, i, dataURL,
                exportCanvas = this.getCanvasElement(Id);
            exportChart = exportCanvas.canvasContainer;
            exprtCtx = exportCanvas.canvasArea;
            chartWidth = exportCanvas.width;
            chartHeight = exportCanvas.height;
            chart = $("#" + Id + '_canvas')[0];
            exportChart.setAttribute('id', 'Export_' + Id);
            if (angle == 0) {
                legendPos = this.model.LegendBounds;
                if (legendPos.X && (legendPos.Width != 0 && legendPos.Height != 0))
                    exprtCtx.drawImage(legend, legendPos.X, legendPos.Y);
            } else if (angle == 90 || angle == -90) {
                exportChart.setAttribute('width', chartHeight);
                exportChart.setAttribute('height', chartWidth);
                exprtCtx.save();
                exprtCtx.translate(chartHeight / 2, chartWidth / 2);
                exprtCtx.rotate(angle * Math.PI / 180);
                exprtCtx.drawImage(chart, -chartWidth / 2, - chartHeight / 2);
                exprtCtx.restore();
                if (legendPos.X) {
                    exprtCtx.save();
                    if (angle == 90)
                        exprtCtx.translate(chartHeight - legendPos.Y - legendPos.Height / 2, chartWidth - legendPos.X - legendPos.Width / 2);
                    else
                        exprtCtx.translate(legendPos.Y + legendPos.Height / 2, legendPos.X + legendPos.Width / 2);
                    exprtCtx.rotate(angle * Math.PI / 180);
                    exprtCtx.drawImage(legend, -legendPos.Width / 2, -legendPos.Height / 2);
                    exprtCtx.restore();
                }
            } else {
                exportChart.setAttribute('width', chartWidth);
                exportChart.setAttribute('height', chartHeight);
                exprtCtx.save();
                exprtCtx.translate(chartWidth, chartHeight);
                exprtCtx.rotate(180 * Math.PI / 180);
                exprtCtx.drawImage(chart, 0, 0);
                exprtCtx.restore();
                if (legendPos.X) {
                    exprtCtx.save();
                    exprtCtx.translate(legendPos.X + legendPos.Width / 2, chartHeight - legendPos.Y - legendPos.Height / 2);
                    exprtCtx.rotate(angle * Math.PI / 180);
                    exprtCtx.drawImage(legend, -legendPos.Width / 2, -legendPos.Height / 2);
                    exprtCtx.restore();
                }
            }

            for (i = 0; i < selectionChart.length; i++) {       // export for selection
                containerStyle = document.getElementById(selectionChart[i].id).getBoundingClientRect();
                if (angle == 0)
                    exprtCtx.drawImage(selectionChart[i], 0, 0);
                else if (angle == 90 || angle == -90) {
                    exprtCtx.save();
                    exprtCtx.translate(chartHeight / 2, chartWidth / 2);
                    exprtCtx.rotate(angle * Math.PI / 180);
                    exprtCtx.drawImage(selectionChart[i], -chartWidth / 2, -chartHeight / 2);
                    exprtCtx.restore();
                    if (angle == 90 && selectionChart[i].id.indexOf(Id + '_Selection_Legend') >= 0) {
                        exprtCtx.save();
                        exprtCtx.translate(chartHeight - legendPos.Y - legendPos.Height / 2, chartWidth - legendPos.X - legendPos.Width / 2);
                        exprtCtx.rotate(angle * Math.PI / 180);
                        exprtCtx.drawImage(selectionChart[i], -legendPos.Width / 2, -legendPos.Height / 2);
                        exprtCtx.restore();
                    }
                    else if (angle == -90 && selectionChart[i].id.indexOf(Id + '_Selection_Legend') >= 0) {
                        exprtCtx.save();
                        exprtCtx.translate(legendPos.X + legendPos.Width / 2, chartHeight - legendPos.Y - legendPos.Height / 2);
                        exprtCtx.rotate(angle * Math.PI / 180);
                        exprtCtx.drawImage(selectionChart[i], -legendPos.Width / 2, -legendPos.Height / 2);
                        exprtCtx.restore();
                    }
                }
                else if (angle == 180) {
                    exprtCtx.save();
                    exprtCtx.translate(chartWidth, chartHeight);
                    exprtCtx.rotate(180 * Math.PI / 180);
                    exprtCtx.drawImage(selectionChart[i], 0, 0);
                    exprtCtx.restore();
                    if (angle == 180 && selectionChart[i].id.indexOf(Id + '_Selection_Legend') >= 0) {
                        exprtCtx.save();
                        exprtCtx.translate(legendPos.X + legendPos.Width / 2, chartHeight - legendPos.Y - legendPos.Height / 2);
                        exprtCtx.rotate(angle * Math.PI / 180);
                        exprtCtx.drawImage(selectionChart[i], -legendPos.Width / 2, -legendPos.Height / 2);
                        exprtCtx.restore();
                    }
                }
            }
            dataURL = exporting.type == "jpg" ? exportChart.toDataURL("image/jpeg") : exportChart.toDataURL();
            if (exporting.mode == "client")                    // for client side
                return exportChart;
            else if (sf.raiseWebFormsServerEvents)                            // for web forms
                this.raiseWebServerEvents(dataURL);
            else if (exporting.mode == "server") {                       // server side
                var attr, form, chartModel, input1, data, input2;
                attr = { action: exporting.action, method: 'post' };
                form = sf.buildTag('form', "", null, attr);
                chartModel = { name: 'ChartModel', type: 'hidden', value: JSON.stringify(modelClone) };
                input1 = sf.buildTag('input', "", null, chartModel);
                data = { name: 'Data', type: 'hidden', value: dataURL };
                input2 = sf.buildTag('input', "", null, data);
                form.append(input1).append(input2).append(this);
                $('body').append(form);
                form.submit();
            }
        },

        svgExport: function () {                   // to export chart as SVG
            var svgObj = this.svgObject.id,
                modelClone = $.extend(true, {}, this.model);
            for (var i = 0; i < this.model._axes.length; i++)
                modelClone._axes[i].range = modelClone._axes[i].actual_Range;
            modelClone.event = null; // event is not API and having circular structure object type
            var Id = this._id,
                exportChartSVG = this.getSVGElement(Id),
                exporting = this.model.exportSettings, angle = exporting.angle, chartHeight = exportChartSVG.height,
                svg = exportChartSVG.chartSVG, legend = exportChartSVG.legendChartSVG, chartWidth = exportChartSVG.width,
                content = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">', selectionContent;
            if (angle == 0)
                content = content + svg.toString() + legend.toString() + "</svg>";
            else if (angle == 90)
                content = content + '<g transform="translate(' + chartHeight + ',0) rotate(90 0 0)">' + svg.toString() + legend.toString() + "</g></svg>";
            else if (angle == -90)
                content = content + '<g transform="translate(0,' + chartWidth + ') rotate(-90 0 0)">' + svg.toString() + legend.toString() + "</g></svg>";
            else
                content = content + '<g transform="translate(' + chartWidth + ',' + chartHeight + ') rotate(180 0 0)">' + svg.toString() + legend.toString() + "</g></svg>";
            selectionContent = this._getSelectionContentInSVG(this, Id, content, "export");//export the chart along with selection
            var selected = $('#' + Id).find('[class*="Selection"]');
            content = selected.length > 0 ? selectionContent : content;
            content = encodeURIComponent(content);
            $("#" + svgObj + "_Legend").removeAttr("transform");
            if (exporting.mode == "client")            // for client side
                return content;
            else if (sf.raiseWebFormsServerEvents)                               // for web forms
                this.raiseWebServerEvents(content);
            else if (exporting.mode == "server") {                         // server side
                var attr, form, inputAttr, input, input1, chartModel;
                attr = { action: exporting.action, method: 'post' };
                form = sf.buildTag('form', "", null, attr);
                chartModel = { name: 'ChartModel', type: 'hidden', value: JSON.stringify(modelClone) };
                input1 = sf.buildTag('input', "", null, chartModel);
                inputAttr = { name: 'Data', type: 'hidden', value: content };
                input = sf.buildTag('input', "", null, inputAttr);
                form.append(input).append(input1).append(this);
                $('body').append(form);
                form.submit();
            }
        },
        _getSelectionContentInSVG: function (chartObj, Id, contentSVG, method) {
            var serIndex = this.model.series.length, selectionContent, selectionChartSVG, containerselectionChartSVG, legendChartSVG, containerSelectionLegendSVG, TDStyle;
            //selection chart to export/ print in SVG
            if (!chartObj.model.enable3D) {
                var mode;
                for (var index = 0; index < serIndex; index++) {
                    mode = chartObj.model.series[index].selectionSettings.mode.toLowerCase();
                    if (chartObj.model.AreaType != "none") {
                        if (mode != "cluster") {
                            if ($('#' + Id + 'SelectionSegmentseries' + index).length > 0) {
                                selectionChartSVG = document.getElementById(Id + "SelectionSegmentseries" + index);
                                containerselectionChartSVG = $('<div>').append($(selectionChartSVG).clone()).html();
                                legendChartSVG = document.getElementById(Id + "SelectionLegendSegmentseries" + index);
                                containerSelectionLegendSVG = $('<div>').append($(legendChartSVG).clone()).html();
                                if (method === "export") {
                                    selectionContent = contentSVG.slice(0, contentSVG.length - 6);
                                    selectionContent += '<svg>' + containerselectionChartSVG.toString() + containerSelectionLegendSVG.toString() + "</svg>" + "</svg>";
                                }
                                else
                                    contentSVG += containerselectionChartSVG.toString() + containerSelectionLegendSVG.toString();
                            }
                        } else {
                            if ($('#' + Id + 'SelectionSegmentClusterSeries' + index).length > 0) {
                                selectionChartSVG = document.getElementById(Id + "SelectionSegmentClusterSeries" + index);
                                containerselectionChartSVG = $('<div>').append($(selectionChartSVG).clone()).html();
                                legendChartSVG = document.getElementById(Id + "SelectionLegendSegmentClusterSeries" + index);
                                containerSelectionLegendSVG = $('<div>').append($(legendChartSVG).clone()).html();
                                if (method === "export") {
                                    selectionContent = sf.util.isNullOrUndefined(selectionContent) ? contentSVG.slice(0, contentSVG.length - 6) : selectionContent;
                                    selectionContent += '<svg >' + containerselectionChartSVG.toString() + containerSelectionLegendSVG.toString() + "</svg>";
                                }
                                else
                                    contentSVG += containerselectionChartSVG.toString() + containerSelectionLegendSVG.toString();
                            }
                        }
                    } else {
                        var selectedPoints = chartObj.model.selectedDataPointIndexes;
                        for (var l = 0; l < selectedPoints.length; l++) {
                            if (selectedPoints[l].seriesIndex == index) {
                                if ($('#' + Id + 'SelectionSegmentseries' + index + "Point" + selectedPoints[l].pointIndex).length > 0) {
                                    selectionChartSVG = document.getElementById(Id + 'SelectionSegmentseries' + index + "Point" + selectedPoints[l].pointIndex);
                                    containerselectionChartSVG = $('<div>').append($(selectionChartSVG).clone()).html();
                                    legendChartSVG = document.getElementById(Id + "SelectionLegendSegmentseries" + index + "Point" + selectedPoints[l].pointIndex);
                                    containerSelectionLegendSVG = $('<div>').append($(legendChartSVG).clone()).html();
                                    if (method === "export") {
                                        selectionContent = contentSVG.slice(0, contentSVG.length - 6);
                                        selectionContent += '<svg>' + containerselectionChartSVG.toString() + containerSelectionLegendSVG.toString() + "</svg>" + "</svg>";
                                    }
                                    else
                                        contentSVG += containerselectionChartSVG.toString() + containerSelectionLegendSVG.toString();
                                }
                            }
                        }
                    }
                }
                if (mode == "cluster" && method === "export") selectionContent += "</svg>"
            } else {
                TDStyle = "";
                for (var index = 0; index < serIndex; index++) {
                    if ($("#Selectionseries" + index + "Segmentseries" + index).length > 0) {
                        TDStyle += $("#Selectionseries" + index + "Segmentseries" + index)[0].outerHTML;
                    }
                }
                contentSVG += TDStyle;
            }
            return method === "export" ? selectionContent : contentSVG;
        },
        raiseWebServerEvents: function (content, event) {             // to trigger server events in web forms
            var modelClone = $.extend(true, {}, this.model),
                exporting = this.model.exportSettings, args, clientArgs,
                event = sf.util.isNullOrUndefined(event) ? "exporting" : event;
            this.model.size._width = $(this.svgObject).width();
            this.model.size._height = $(this.svgObject).height();
            args = { model: modelClone, originalEventType: event },
                clientArgs = { Data: content, Format: exporting.type, Orientation: exporting.orientation, FileName: exporting.fileName };
            sf.raiseWebFormsServerEvents(event, args, clientArgs);
        },

        animate: function (options) {
            if (!options) { // Animate the entire series and indicators "previous behavior"
                var series = this.model.series;
                for (var i = 0; i < series.length; i++) {
                    series[i]._animatedSeries = false;
                    series[i]._animatedTrendline = false;
                    series[i].AnimationComplete = false; //pie doughnut animation with datalabel
                }
                var indicators = this.model.indicators;
                for (var j = 0; j < indicators.length; j++) {
                    indicators[j]._animatedSeries = false;
                    indicators[j]._animatedTrendline = false;
                }
            } else if (options.constructor === Array) { // Animate array of series
                for (var i = 0; i < options.length; i++) {
                    options[i]._animatedSeries = false;
                    options[i]._animatedTrendline = false;
                    options[i].AnimationComplete = false; //pie doughnut animation with datalabel
                }
            } else {   // Animate the specific series
                options._animatedSeries = false;
                options._animatedTrendline = false;
                options.AnimationComplete = false;  //pie doughnut animation with datalabel
            }
            this.redraw();
        },


        _setModel: function (options) {
            var series, axes;
            for (var prop in options) {
                this.disableAnimation();
                switch (prop) {
                    case "theme":
                        this.model._themeChanged = true;
                        this.model.theme = options[prop];
                        this.setTheme(sf.EjSvgRender.themes, this.model.theme);
                        $.extend(true, this.model.primaryXAxis, sf.EjSvgRender.themes[this.model.theme].primaryXAxis);
                        $.extend(true, this.model.primaryYAxis, sf.EjSvgRender.themes[this.model.theme].primaryYAxis);
                        for (var k = 0; k < this.model.axes.length; k++) {
                            if (this.model.axes[k].orientation && this.model.axes[k].orientation.toLowerCase() == "horizontal")
                                $.extend(true, this.model.axes[k], sf.EjSvgRender.themes[this.model.theme].secondaryX);
                            else
                                $.extend(true, this.model.axes[k], sf.EjSvgRender.themes[this.model.theme].secondaryY);
                        }
                        for (var l = 0; l < this.model.series.length; l++) {
                            $.extend(true, this.model.series[l], sf.EjSvgRender.themes[this.model.theme].commonSeriesOptions);
                        }
                        break;
                    case "commonSeriesOptions":
                        for (var i = 0; i < this.model.series.length; i++) {
                            if (options[prop].dataSource)
                                this.model.series[i].dataSource = null;
                            $.extend(true, this.model.series[i], {}, options[prop]);
                        }
                        break;
                    case "series":
						if (options[prop].length < this.model.series.length) { 
							this.model.series = this.model.series.slice(0, options[prop].length);
						} 
                        series = this.model.series;
                        for (var i = 0; i < series.length; i++) {
                            if (options[prop][i].dataSource) {
                                series[i].dataSource = null;
                            }
                        }
                        $.extend(true, series, {}, options[prop]);
                        for (var i = 0, len = series.length; i < len; i++) {
                            if (series[i].enableAnimation)
                                series[i]._animatedSeries = false;
                            if (options[prop][i] && options[prop][i].dataSource instanceof sf.DataManager)
                                //jQuery extends data manager as object.
                                series[i].dataSource = options[prop][i].dataSource;
                            if (options[prop][i] && options[prop][i].query instanceof sf.Query)
                                //jQuery.extend does not update the existing query with new one.
                                series[i].query = options[prop][i].query;
                        }
                        break;
                    case "legend":
                        $.extend(true, this.model.legend, {}, options[prop]);
                        break;
                    case "axes":
                        $.extend(true, this.model.axes, {}, options[prop]);
                        break;
                    case "primaryXAxis":
                        this.model.primaryXAxis.setRange = (options[prop].range) ? true : false;
                        this.model.primaryXAxis.setAxisInterval = (options[prop].range && options[prop].range.interval) ? true : this.model.primaryXAxis.setAxisInterval;
                        this.model.primaryXAxis.actual_Range = (this.model._axes[0].setRange) ? null : this.model._axes[0].actual_Range;
                        $.extend(true, this.model.primaryXAxis, {}, options[prop]);
                        break;
                    case "primaryYAxis":
                        this.model.primaryYAxis.setRange = (options[prop].range) ? true : false;
                        this.model.primaryYAxis.log_Range = options[prop].range ? options[prop].range : this.model.primaryYAxis.log_Range;
                        this.model.primaryYAxis.actual_Range = (!this.model._axes || this.model._axes[1].setRange) ? null : this.model._axes[1].actual_Range;
                        $.extend(true, this.model.primaryYAxis, {}, options[prop]);
                        break;
                    case "xZoomFactor":
                        this.model.primaryXAxis.zoomFactor = this._xZoomFactor();
                        axes = this.model.axes;
                        for (var i = 0; i < axes.length; i++) {
                            if (axes[i].orientation.toLowerCase() == "horizontal")
                                axes[i].zoomFactor = this._xZoomFactor();
                        }
                        break;
                    case "yZoomFactor":
                        this.model.primaryYAxis.zoomFactor = this._yZoomFactor();
                        axes = this.model.axes;
                        for (var i = 0; i < axes.length; i++) {
                            if (axes[i].orientation.toLowerCase() == "vertical")
                                axes[i].zoomFactor = this._yZoomFactor();
                        }
                        break;
                    case "xZoomPosition":
                        this.model.primaryXAxis.zoomPosition = this._xZoomPosition();
                        axes = this.model.axes;
                        for (var i = 0; i < axes.length; i++) {
                            if (axes[i].orientation.toLowerCase() == "horizontal")
                                axes[i].zoomPosition = this._xZoomPosition();
                        }
                        break;
                    case "yZoomPosition":
                        this.model.primaryYAxis.zoomPosition = this._yZoomPosition();
                        axes = this.model.axes;
                        for (var i = 0; i < axes.length; i++) {
                            if (axes[i].orientation.toLowerCase() == "vertical")
                                axes[i].zoomPosition = this._yZoomPosition();
                        }
                        break;
                    case "drilldown":
                        this.model.series = [];
                        this.model.explodeValue = null;
                        $.extend(true, this.model, {}, options[prop]);
                        break;
                    case "datasource":
                        for (var i = 0; i < this.model.series.length; i++) {
                            this.model.series[i].dataSource = null;
                            this.model.series[i].points = null;
                        }
                        $.extend(true, this.model, {}, options[prop]);
                        break;
                    case "chartArea":
                        $.extend(true, this.model.chartArea, {}, options[prop]);
                        break;

                    default:
                        $.extend(true, this.model, {}, options[prop]);
                        series = this.model.series;
                        for (var i = 0, len = series.length; i < len; i++) {
                            if (series[i].enableAnimation)
                                series[i]._animatedSeries = false;
                        }
                }
            }
            if (this.model.canResize || this.model.isResponsive)
                this.bindResizeEvents();
            else
                this.removeResizeEvents();
            $("#annotation_group_" + this._id).remove(); // to remove annotation on set model
            if (this.model.enableCanvasRendering) {
                $(this.svgObject).remove();
                $("#canvas_trackSymbol").remove();
                $("#" + this._id + "_canvas_Tracker").remove();
                $("#secondCanvas").remove();
                this.svgRenderer = new sf.EjCanvasRender(this.element); // to create canvas container
                this.svgRenderer.svgObj.height = sf.util.isNullOrUndefined(this.model.size.height) ? "450" : this.model.size.height;
                this.svgRenderer.svgObj.width = sf.util.isNullOrUndefined(this.model.size.width) ? $("#" + this._id).width() : this.model.size.width;
                this.svgObject = this.svgRenderer.svgObj;

                $(this.legendSvgContainer).remove();
                this.legendSvgContainer = this.svgRenderer.createLegendCanvas(this.element); //creating new CANVAS element for legend
                this.svgRenderer.append(this.legendSvgContainer, this.legendContainer);
            }
            else if ((this.svgObject.id).indexOf("_canvas") != -1) {
                this._removeZoomkit();
                $(this.svgObject).remove();
                this.svgRenderer = new sf.EjSvgRender(this.element);  // to create svg container
                this.svgObject = this.svgRenderer.svgObj;
                this.canvasX = this.canvasY = 0;

                $(this.legendSvgContainer).remove();
                this.legendSvgContainer = this.svgRenderer.createLegendSvg(this.element); //creating new SVG element for legend
                this.svgRenderer.append(this.legendSvgContainer, this.legendContainer);
            }
            else if (!this.chartUpdating) { // Condition checked to avoid knockout removing event.target
                $(this.svgObject).empty();              // using existing svg container
                $(this.legendSvgContainer).empty();
            }

            this.bindTo();
        }
    });

    sf.datavisualization.Chart.Locale = sf.datavisualization.Chart.Locale || {};
    sf.datavisualization.Chart.Locale['default'] = sf.datavisualization.Chart.Locale['en-US'] = {
        zoomIn: "Zoom In",
        zoomOut: "Zoom Out",
        zoom: "Zoom",
        pan: "Pan",
        reset: "Reset"
    };
    sf.datavisualization.Chart.CrosshairType = {

        Crosshair: 'crosshair',

        TrackBall: 'trackBall'
    };
    sf.datavisualization.Chart.TrackballDisplayMode = {

        Float: 'float',

        Grouping: 'grouping'
    };

    sf.datavisualization.Chart.VisibleOnLegend = {

        Visible: 'visible',

        Hidden: 'hidden'
    };

    sf.datavisualization.Chart.ExportingType = {

        PNG: 'png',

        JPG: 'jpg',

        PDF: 'pdf',

        SVG: 'svg',

        DOCX: 'docx',

        XLSX: 'xlsx'
    };

    sf.datavisualization.Chart.ExportingMode = {

        Client: 'client',

        Server: 'server'
    };

    sf.datavisualization.Chart.ExportingOrientation = {

        Portrait: 'portrait',

        Landscape: 'landscape'
    };

    sf.datavisualization.Chart.ValueType = {

        Double: 'double',

        DateTime: 'datetime',

        Category: 'category',

        Logarithmic: 'logarithmic',

        DateTimeCategory: 'datetimecategory'
    };

    sf.datavisualization.Chart.TextOverflow = {

        None: 'none',

        Wrap: 'wrap',

        Trim: 'trim',

        WrapAndTrim: 'wrapandtrim'
    };

    sf.datavisualization.Chart.Type = {

        Line: 'line',

        Spline: 'spline',

        Column: 'column',

        Doughnut: 'doughnut',

        Area: 'area',

        SplineArea: 'splinearea',

        StepLine: 'stepline',

        StepArea: 'steparea',

        Pie: 'pie',

        PieOfPie: 'pieofpie',

        Hilo: 'hilo',

        HiloOpenClose: 'hiloopenclose',

        Candle: 'candle',

        Bubble: 'bubble',

        Scatter: 'scatter',

        Bar: 'bar',

        StackingArea: 'stackingarea',

        StackingArea100: 'stackingarea100',

        RangeColumn: 'rangecolumn',

        StackingColumn: 'stackingcolumn',

        StackingColumn100: 'stackingcolumn100',

        StackingBar: 'stackingbar',

        StackingBar100: 'stackingbar100',

        Pyramid: 'pyramid',

        Funnel: 'funnel',

        Polar: 'polar',

        Radar: 'radar',

        RangeArea: 'rangearea',

        SplineRangeArea: 'splinerangearea',

        Waterfall: 'waterfall',

        BoxAndWhishker: 'boxandwhisker',

        StackingSplineArea: 'stackingsplinearea',

        StackingSplineArea100: 'stackingsplinearea100'

    };
    sf.datavisualization.Chart.SplitMode = {

        Position: 'position',

        Value: 'value',

        Percentage: 'percentage',

        Indexes: 'indexes'

    };

    sf.datavisualization.Chart.SplineType = {

        Natural: 'natural',

        Monotonic: 'monotonic',

        Cardinal: 'cardinal',

        Clamped: 'clamped'

    };
    sf.datavisualization.Chart.DragType = {

        XY: "xy",

        X: "x",

        Y: "y"
    };
    sf.datavisualization.Chart.LabelPlacement = {

        BetweenTicks: "betweenTicks",

        OnTicks: "onTicks"
    };

    sf.datavisualization.Chart.TrendlinesType = {

        Linear: "linear",

        Exponential: "exponential",

        Logarithmic: "logarithmic",

        Power: "power",

        Polynomial: "polynomial"
    };

    sf.datavisualization.Chart.ErrorBarType = {

        FixedValue: "fixedValue",

        Percentage: "percentage",

        StandardDeviation: "standardDeviation",

        StandardError: "standardError",

        Custom: "custom"
    };

    sf.datavisualization.Chart.ErrorBarMode = {

        Both: "both",

        Vertical: "vertical",

        Horizontal: "horizontal"
    };

    sf.datavisualization.Chart.ErrorBarDirection = {

        Both: "both",

        Plus: "plus",

        Minus: "minus"
    };

    sf.datavisualization.Chart.LabelIntersectAction = {

        None: "none",

        Rotate90: "rotate90",

        Rotate45: "rotate45",

        Wrap: "wrap",

        WrapByword: "wrapByWord",

        Trim: "trim",

        Hide: "hide",

        MultipleRows: "multipleRows"
    };

    sf.datavisualization.Chart.EdgeLabelPlacement = {

        None: "none",

        Shift: "shift",

        Hide: "hide"
    };

    sf.datavisualization.Chart.roundedCorner = {

        Both: "both",

        Start: "start",

        End: "end"

    };

    sf.datavisualization.Chart.Theme = {

        Azure: 'azure',

        FlatLight: 'flatlight',

        Azuredark: 'azuredark',

        Lime: 'lime',

        LimeDark: 'limedark',

        Saffron: 'saffron',

        SaffronDark: 'saffrondark',

        GradientLight: 'gradientlight',

        GradientDark: 'gradientdark',

        HighContrast01: 'highcontrast01',

        HighContrast02: 'highcontrast02',

        Material: 'material',

        Office365: 'office365',

        Bootstrap: 'bootstrap'
    };

    sf.datavisualization.Chart.FontStyle = {

        Normal: 'normal',

        Italic: 'italic'
    };

    sf.datavisualization.Chart.FontWeight = {

        Regular: 'regular',

        Bold: 'bold',

        Lighter: 'lighter'
    };

    sf.datavisualization.Chart.IntervalType = {

        Auto: 'auto',

        Days: 'days',

        Hours: 'hours',

        Seconds: 'seconds',

        Milliseconds: 'milliseconds',

        Minutes: 'minutes',

        Months: 'months',

        Years: 'years'
    };

    sf.datavisualization.Chart.RangePadding = {

        Additional: 'additional',

        Normal: 'normal',

        None: 'none',

        Round: 'round',

        Auto: 'auto'
    };

    sf.datavisualization.Chart.TextAlignment = {

        MiddleTop: 'middletop',

        MiddleCenter: 'middlecenter',

        MiddleBottom: 'middlebottom'
    };

    sf.datavisualization.Chart.LabelPosition = {

        Inside: 'inside',

        Outside: 'outside'
    };
	
	sf.datavisualization.Chart.TitleRotation = {
		
		None: 'none',

        Rotate90: 'rotate90',

        RotateMinus90: 'rotateminus90'
    };

    sf.datavisualization.Chart.ZIndex = {

        Over: 'over',

        Behind: 'behind'
    };

    sf.datavisualization.Chart.Unit = {

        percentage: 'percentage',

        pixel: 'pixel'
    };

    sf.datavisualization.Chart.PyramidMode = {

        Linear: 'linear',

        Surface: 'Surface'
    };

    sf.datavisualization.Chart.DrawType = {

        Line: 'line',

        Column: 'column',

        Area: 'area',

        RangeColumn: 'rangecolumn',

        Scatter: 'scatter',

        Spline: 'spline'
    };

    sf.datavisualization.Chart.AnimationType = {

        Linear: 'linear',

        Smooth: 'smooth'

    };

    sf.datavisualization.Chart.columnFacet = {

        Rectangle: 'rectangle',

        Cylinder: 'cylinder'
    };

    sf.datavisualization.Chart.EmptyPointMode = {

        Gap: 'gap',

        Zero: 'zero',

        Average: 'average'

    };

    sf.datavisualization.Chart.Pattern = {

        None: 'none',

        Chessboard: 'chessboard',

        Crosshatch: 'crosshatch',

        Dots: 'dots',

        Pacman: 'pacman',

        DiagonalBackward: 'diagonalBackward',

        DiagonalForward: 'diagonalForward',

        Grid: 'grid',

        Turquoise: 'turquoise',

        Star: 'star',

        Triangle: 'triangle',

        Circle: 'circle',

        Tile: 'tile',

        HorizontalDash: 'horizontalDash',

        VerticalDash: 'verticalDash',

        Rectangle: 'rectangle',

        Box: 'box',

        VerticalStripe: 'verticalStripe',

        HorizontalStripe: 'horizontalStripe',

        Bubble: 'bubble',

        Custom: 'custom'
    };

    sf.datavisualization.Chart.Mode = {

        Series: 'series',

        Point: 'point',

        Cluster: 'cluster',

        Range: 'range'
    };

    sf.datavisualization.Chart.SelectionType = {

        Single: 'single',

        Multiple: 'multiple'
    };
    sf.datavisualization.Chart.Shape = {

        None: 'none',

        LeftArrow: 'leftarrow',

        RightArrow: 'rightarrow',

        Circle: 'circle',

        Cross: 'cross',

        HorizLine: 'horizline',

        VertLine: 'vertLine',

        Diamond: 'diamond',

        Rectangle: 'rectangle',

        Triangle: 'triangle',

        InvertedTriangle: 'invertedtriangle',

        Hexagon: 'hexagon',

        Pentagon: 'pentagon',

        Star: 'star',

        Ellipse: 'ellipse',

        Wedge: 'wedge',

        Trapezoid: 'trapezoid',

        UpArrow: 'uparrow',

        DownArrow: 'downarrow',

        Image: 'image'
    };

    sf.datavisualization.Chart.DrawMode = {

        Both: 'both',

        Open: 'open',

        Close: 'close'
    };

    sf.datavisualization.Chart.LineCap = {

        Butt: 'butt',

        Round: 'round',

        Square: 'square'
    };

    sf.datavisualization.Chart.LineJoin = {

        Round: 'round',

        Bevel: 'bevel',

        Miter: 'miter'
    };

    sf.datavisualization.Chart.Position = {

        Top: 'top',

        Middle: 'middle',

        Bottom: 'bottom'
    };

    sf.datavisualization.Chart.Alignment = {

        Center: 'center',

        Near: 'near',

        Far: 'far'
    };

    sf.datavisualization.Chart.RotateOn = {

        Start: 'start',

        Middle: 'middle',
		
		End: 'end'
    };
	
	sf.datavisualization.Chart.TextAnchor = {

        Start: 'start',

        Middle: 'middle',
		
		End: 'end'
    };

    sf.datavisualization.Chart.TickLinesPosition = {

        Inside: 'inside',

        Outside: 'outside'
    };

    sf.datavisualization.Chart.CoordinateUnit = {

        None: 'none',

        Pixels: 'pixels',

        Points: 'points'
    };

    sf.datavisualization.Chart.HorizontalAlignment = {

        Left: 'left',

        Right: 'right',

        Middle: 'middle'
    };

    sf.datavisualization.Chart.VerticalAlignment = {

        Top: 'top',

        Bottom: 'bottom',

        Middle: 'middle'
    };

    sf.datavisualization.Chart.Region = {

        Chart: 'chart',

        Series: 'series'
    };

    sf.datavisualization.Chart.ConnectorLineType = {

        Line: 'line',

        Bezier: 'bezier'
    };

    sf.datavisualization.Chart.HorizontalTextAlignment = {

        Near: 'near',

        Far: 'far',

        Center: 'center'
    };

    sf.datavisualization.Chart.VerticalTextAlignment = {

        Near: 'near',

        Far: 'far',

        Center: 'center'
    };

    sf.datavisualization.Chart.multiLevelLabelsBorderType = {

        None: 'none',

        Rectangle: 'rectangle',

        WithoutTopAndBottom: 'withouttopandbottom',

        Brace: 'brace',

        CurlyBrace: 'curlybrace'
    };

    sf.datavisualization.Chart.MACDType = {

        Line: 'line',

        Histogram: 'histogram',

        Both: 'both'
    };

    sf.datavisualization.Chart.IndicatorsType = {

        RSI: 'rsi',

        Momentum: 'momentum',

        Bollingerband: 'bollingerband',

        Accumulationdistribution: 'accumulationdistribution',

        EMA: 'ema',

        SMA: 'sma',

        Stochastic: 'stochastic',

        ATR: 'atr',

        MACD: 'macd',

        TMA: 'tma'
    };

    sf.datavisualization.Chart.BoxPlotMode = {

        Normal: 'normal',

        Exclusive: 'exclusive',

        Inclusive: 'inclusive',


    };

    sf.datavisualization.Chart.BubbleRadiusMode = {

        MinMax: 'minmax',

        Auto: 'auto'

    };
	
	sf.datavisualization.Chart.SizeType = {

        Auto: 'auto',

        Pixel: 'pixel',
		
		Years: 'years',
		
		Months: 'months',
		
		Days: 'days',
		
		Hours: 'hours',
		
		Minutes: 'minutes',
		
		Seconds: 'seconds'

    };

    $.extend(sf.datavisualization.Chart.prototype, sf.ejChart);
})(jQuery, Sfusion);;
/* global jQuery, sf, document, Image */
sf.EjCanvasRender = function (element) {
    this.svgObj = document.createElement('canvas');
    this._rootId = jQuery(element).attr("id");
    this.svgObj.setAttribute('id', this._rootId + '_canvas');
    this.ctx = this.svgObj.getContext("2d");

};
(function ($) {
    sf.EjCanvasRender.prototype = {

        drawPath: function (options, element, canvasTranslate) {
            var hasStackingInnerRadius = options.hasStackingInnerRadius ? options.hasStackingInnerRadius : false;
            var path = options.d;
            var dataSplit = path.split(" ");
            var borderWidth = options["stroke-width"];
            if (!options.lgndCtx) {
                var canvasCtx = this.ctx;
                this.ctx = element != undefined ? element : this.ctx;
                this.ctx.save();
                this.ctx.beginPath();
                if (canvasTranslate) this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
                this.ctx.globalAlpha = options.opacity ? options.opacity : options["fill-opacity"];
                var flag = true;
                this.ctx.lineWidth = borderWidth;
                var dashArray = options["stroke-dasharray"] ? options["stroke-dasharray"].split(",") : false;
                if (dashArray) this.ctx.setLineDash(dashArray);
                this.ctx.strokeStyle = options.stroke;
                for (var i = 0; i < dataSplit.length; i = i + 3) {
                    var x1 = parseFloat(dataSplit[i + 1]);
                    var y1 = parseFloat(dataSplit[i + 2]);
                    switch (dataSplit[i]) {
                        case "M":
                            if ((!options.innerR || hasStackingInnerRadius) && !options.cx)
                                this.ctx.moveTo(x1, y1);
                            break;
                        case "L":
                            if (!options.innerR || hasStackingInnerRadius)
                                this.ctx.lineTo(x1, y1);
                            break;
                        case "C":
                            this.ctx.bezierCurveTo(x1, y1, parseFloat(dataSplit[i + 3]), parseFloat(dataSplit[i + 4]), parseFloat(dataSplit[i + 5]), parseFloat(dataSplit[i + 6]));
                            i = i + 4;
                            break;
                        case "A":
                            if (!options.innerR) {
                                if (options.cx) {
                                    this.ctx.arc(options.cx, options.cy, options.radius, 0, 2 * Math.PI, options.counterClockWise);
                                }
                                else {
                                    this.ctx.moveTo(options.x, options.y);
                                    this.ctx.arc(options.x, options.y, options.radius, options.start, options.end, options.counterClockWise);
                                    this.ctx.lineTo(options.x, options.y);
                                }
                            }
                            else if (flag) {
                                this.ctx.arc(options.x, options.y, options.radius, options.start, options.end, options.counterClockWise);
                                this.ctx.arc(options.x, options.y, options.innerR, options.end, options.start, !options.counterClockWise);
                                flag = false;
                            }
                            i = i + 5;
                            break;
                        case "Q":
                            this.ctx.bezierCurveTo(x1, y1, parseFloat(dataSplit[i + 1]), parseFloat(dataSplit[i + 2]), parseFloat(dataSplit[i + 3]), parseFloat(dataSplit[i + 4]));
                            i = i + 2;
                            break;
                        case "z":
                            this.ctx.closePath();
                            break;
                    }
                }
                if (options.fill != "none" && options.fill != undefined) {
                    this.ctx.fillStyle = options.fill;
                    this.ctx.fill();
                }
                if (borderWidth > 0)
                    this.ctx.stroke();
                this.ctx.restore();
                this.ctx = canvasCtx;
            } else {
                var legendCtx = this.lgndCtx;
                this.lgndCtx = element != undefined ? element : this.lgndCtx;
                this.lgndCtx.save();
                this.lgndCtx.beginPath();
                if (canvasTranslate) this.lgndCtx.translate(canvasTranslate[0], canvasTranslate[1]);
                this.lgndCtx.globalAlpha = options.opacity ? options.opacity : options["fill-opacity"];

                this.lgndCtx.lineWidth = options["stroke-width"];
                this.lgndCtx.strokeStyle = options.stroke;
                for (var i = 0; i < dataSplit.length; i = i + 3) {
                    var x1 = parseFloat(dataSplit[i + 1]);
                    var y1 = parseFloat(dataSplit[i + 2]);
                    switch (dataSplit[i]) {
                        case "M":
                            this.lgndCtx.moveTo(x1, y1);
                            break;
                        case "L":
                            this.lgndCtx.lineTo(x1, y1);
                            break;
                        case "C":
                            this.lgndCtx.bezierCurveTo(x1, y1, parseFloat(dataSplit[i + 3]), parseFloat(dataSplit[i + 4]), parseFloat(dataSplit[i + 5]), parseFloat(dataSplit[i + 6]));
                            i = i + 4;
                            break;
                        case "A":
                            this.lgndCtx.arc(parseFloat(dataSplit[i - 5]), parseFloat(dataSplit[i - 4]), x1, 0, 2 * Math.PI, false);
                            i = i + 5;
                            break;
                        case "a":
                            this.lgndCtx.beginPath();
                            var centerX = parseFloat(dataSplit[i - 2]) + x1;
                            var centerY = dataSplit[i - 1];
                            this.lgndCtx.arc(centerX, centerY, x1, 0, 2 * Math.PI, false);
                            i = i + 5;
                            break;
                        case "Z":
                            this.lgndCtx.fillStyle = options.fill;
                            this.lgndCtx.fill();
                            i = i - 2;
                            break;
                        case "Q":
                            this.lgndCtx.quadraticCurveTo(x1, y1, parseFloat(dataSplit[i + 3]), parseFloat(dataSplit[i + 4]));
                            i = i + 2;
                            break;
                    }
                }
                if (options.fill != "none" && options.fill != undefined) {
                    this.lgndCtx.fillStyle = options.fill;
                    this.lgndCtx.fill();
                }
                this.lgndCtx.stroke();
                this.lgndCtx.restore();
                this.lgndCtx = legendCtx;
            }
        },

        _setLinePathStyle: function (options, canvasTranslate) {

            var borderWidth = options["stroke-width"],
                dashArray;

            if (canvasTranslate) this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
            this.ctx.globalAlpha = options.opacity ? options.opacity : options["fill-opacity"];
            this.ctx.lineWidth = borderWidth;
            dashArray = options["stroke-dasharray"] ? options["stroke-dasharray"].split(",") : false;
            if (dashArray) this.ctx.setLineDash(dashArray);
            this.ctx.strokeStyle = options.stroke;

            if (options.fill != "none" && options.fill != undefined) {
                this.ctx.fillStyle = options.fill;
                this.ctx.fill();
            }
        },


        drawRect: function (options, element) {
            var canvasCtx = this.ctx, cornerRadius = options.rx;
            this.ctx = element ? (element.canvas ? element : this.ctx) : this.ctx;
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.globalAlpha = options.opacity;
            this.ctx.lineWidth = options["stroke-width"];
            var dashArray = options["stroke-dasharray"] ? options["stroke-dasharray"].split(",") : false;
            if (dashArray) this.ctx.setLineDash(dashArray);
            this.ctx.strokeStyle = options.stroke;
            this.ctx.rect(options.x, options.y, options.width, options.height);
            if (cornerRadius != null && cornerRadius >= 0) {
                this.drawCornerRadius(options);
            }
            else {
                if (options.fill == "none") options.fill = "transparent";
                this.ctx.fillStyle = options.fill;
                this.ctx.fillRect(options.x, options.y, options.width, options.height);
                this.ctx.stroke();
            }
            if (options.id.indexOf("Series") >= 0)
                this.ctx.clip();
            this.ctx.restore();
            this.ctx = canvasCtx;
        },
        drawCylinder: function (options, element, seriesOption) {
            var canvasCtx = this.ctx;
            this.ctx = element ? (element.canvas ? element : this.ctx) : this.ctx;
            this.ctx.save();
            var grad = sf.datavisualization.Chart.prototype.colorNameToHex(options.fill);
            var obj = { svgRenderer: sf.EjSvgRender.prototype };
            'use strict';
            var i, xPos, yPos, pi = Math.PI, twoPi = 2 * pi + 0.1, rx, ry, cx1, cx2, cy1, cy2, x1, x2, y1, y2, cx, cy, xl, yl, step, ini, gx1, gy2, gx2, gy1, rxt, ryt;
            var x = options.x, y = options.y, w = options.width, h = options.height, a = twoPi;
            this.ctx.fillStyle = sf.Ej3DRender.prototype.polygon3D.prototype.applyZLight(grad, obj)
            this.ctx.lineWidth = 0;
            this.ctx.strokeStyle = sf.Ej3DRender.prototype.polygon3D.prototype.applyZLight(grad, obj);
            this.ctx.globalAlpha = options.opacity;
            if (seriesOption.isColumn == true) {
                gx1 = x;
                gx2 = w + x;
                gy1 = gy2 = 0;
                rx = w / 2;
                ry = rx / 4;
                cx2 = cx1 = x + rx;
                y2 = cy1 = y - ry;
                x2 = x;
                x1 = x + w;
                cy2 = y1 = y + h - ry;
                ini = 0;
                step = pi;
                rxt = -rx;
                ryt = ry;
                if (seriesOption.stacking = true) {
                    if (!seriesOption.isLastSeries) {
                        y2 = cy1 = y + ry;

                    }
                }

            }
            else {
                gx1 = gx2 = 0;
                gy2 = h + y;
                gy1 = y;
                ry = h / 2;
                rx = ry / 4;
                x2 = cx1 = x + rx;
                x1 = cx2 = x + w + rx;
                y1 = y + h;
                y2 = y;
                cy2 = cy1 = y + ry;
                ini = pi / 2;
                step = pi * 1.5;
                if (seriesOption.stacking = true) {
                    if (!seriesOption.isLastSeries) {
                        x1 = cx2 = x + w - rx;
                    }
                }
                ry = -ry;
                rx = -rx;
                rxt = rx;
                ryt = -ry;
            }
            var color = sf.Ej3DRender.prototype.polygon3D.prototype.applyXLight(grad, obj);
            var grd = this.ctx.createLinearGradient(gx1, gy1, gx2, gy2);
            grd.addColorStop(0, grad);
            grd.addColorStop(0.3, color);
            grd.addColorStop(0.7, color);
            grd.addColorStop(1, grad);

            for (var j = 1; j <= 4; j++) {
                var i = 0;
                j < 4 ? this.ctx.beginPath() : "";
                if (j % 2 == 0) {
                    cx = cx2; cy = cy2; xl = x2; yl = y2;
                }
                else {
                    cx = cx1; cy = cy1; xl = x1; yl = y1;
                }
                if (j == 4) {
                    rx = rxt;
                    ry = ryt;
                    this.ctx.fillStyle = grd;
                }
                if (j > 2) {
                    i = ini;
                    a = step;
                }
                for (; i <= a; i += 0.1) {
                    xPos = cx - (rx * Math.cos(i));
                    yPos = cy + (ry * Math.sin(i));

                    if (i === 0) {
                        this.ctx.moveTo(xPos, yPos);
                    } else {
                        this.ctx.lineTo(xPos, yPos);
                    }
                }

                if (j > 2) {

                    this.ctx.lineTo(xl, yl);
                }
                if (j != 3) {

                    this.ctx.stroke();
                    this.ctx.fill();
                }
            }

            if (options.id.indexOf("Series") >= 0)
                this.ctx.clip();
            this.ctx.restore();
            this.ctx = canvasCtx;
        },
        drawCornerRadius: function (options) {
            var cornerRadius = options.rx, x = options.x, y = options.y, width = options.width, height = options.height;
            if (options.fill == "none") options.fill = "transparent";
            this.ctx.fillStyle = options.fill;
            if (width < 2 * cornerRadius) cornerRadius = width / 2;
            if (height < 2 * cornerRadius) cornerRadius = height / 2;
            this.ctx.beginPath();
            this.ctx.moveTo(x + width - cornerRadius, y);
            this.ctx.arcTo(x + width, y, x + width, y + height, cornerRadius);
            this.ctx.arcTo(x + width, y + height, x, y + height, cornerRadius);
            this.ctx.arcTo(x, y + height, x, y, cornerRadius);
            this.ctx.arcTo(x, y, x + width, y, cornerRadius);
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
        },

        createGradientElement: function (name, colors) {
            var colorName;
            var ctx = this.ctx;
            if (Object.prototype.toString.call(colors) == '[object Array]') {
                var my_gradient = ctx.createLinearGradient(0, 0, 0, this.svgObj.height);

                for (var i = 0; i <= colors.length - 1; i++) {
                    var color = colors[i].color;
                    var colorStop = (colors[i].colorStop).slice(0, -1);
                    colorStop = parseInt(colorStop) / 100;
                    my_gradient.addColorStop(colorStop, color);

                }
                colorName = my_gradient;
            }
            else {
                colorName = colors;
            }
            return colorName;
        },
        drawLine: function (options) {
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.lineWidth = options["stroke-width"];
            this.ctx.strokeStyle = options.stroke;
            this.ctx.moveTo(options.x1, options.y1);
            this.ctx.lineTo(options.x2, options.y2);
            this.ctx.stroke();
            this.ctx.restore();
        },
        drawText: function (options, label, highestText) {
            if (!sf.util.isNullOrUndefined(options["font-weight"]) && options["font-weight"].toLowerCase() == "regular")
                options["font-weight"] = "normal";
            var font = (options["font-style"].toLowerCase() + " " + options["font-weight"] + " " + options["font-size"] + " " + options["font-family"]);
            // text-anchor
            var anchor = options["text-anchor"];
            var opacity = options["opacity"] !== undefined ? options["opacity"] : 1;
            if (anchor == "middle")
                anchor = "center";
            if (!options.lgndCtx) {
                this.ctx.save();
                this.ctx.fillStyle = options.fill;
                this.ctx.font = font;
                this.ctx.textAlign = anchor;
                this.ctx.globalAlpha = opacity;
                if (options.baseline)
                    this.ctx.textBaseline = options.baseline;
                // dominant-baseline
                //if (options["dominant-baseline"] == "middle")
                //this.ctx.textBaseline = "center";
                if (!options.labelRotation) {
                    if (typeof label == "object" || options.isTrackball) {
                        if (options.isTrackball && typeof label == "string")
                            this.ctx.fillText(label, options.x, options.y);
                        else {
                            var len = label.length;
                            for (var i = 0; i < len; i++) {
                                var padding = sf.util.isNullOrUndefined(options.padding) ? 0 : options.padding;
                                var height = (sf.EjSvgRender.utils._measureText(label[i], null, font)).height;
                                var fontvalue = options.isTrackball ? Number(parseInt(options["font-size"])) : height;
                                this.ctx.fillText(label[i], options.x, options.y + (fontvalue + padding) * i);
                            }
                        }
                    }
                    else {
                        this.ctx.fillText(label, options.x, options.y);
                    }
                } else {
                    var txtlngth = 0, rotation = options.labelRotation;
                    if ((rotation) && (options.id.indexOf("XLabel") != -1 || options.id.indexOf("YLabel") != -1)) {
                        var rotate = 'rotate(' + options.labelRotation.toString() + 'deg)';
                        $(options).attr('rotateAngle', rotate);

                        var labelText = highestText ? highestText : label;
                        var labelTextHeight = (sf.EjSvgRender.utils._measureText(labelText, null, font)).height;
                        var textElement = this.createText(options, labelText);
                        $(document.body).append(textElement);
                        var box = textElement.getBoundingClientRect();
                        $(textElement).remove();
                        txtlngth = box.height;
                        if (rotation < 0) {
                            rotation = 360 + rotation;
                        }
                        var str = options.transform.split(',');
                        anchor = anchor != undefined ? anchor : "center";
                        var xValue = parseFloat(str[1]);
                        var yValue = parseFloat(str[2]);
                        var diff = (txtlngth / 2);
                        if (options.labelPosition == "outside") {
                            if (anchor == "start")
                                this.ctx.translate(xValue, yValue + diff - ((rotation < 0 && rotation > -180) || rotation > 180 ? txtlngth / 2 : (txtlngth - labelTextHeight) / 2));
							else if(anchor == "end")
								this.ctx.translate(xValue, yValue + diff - ((rotation < 0 && rotation > -180) || rotation > 180 ? txtlngth / 2 : -(txtlngth - labelTextHeight) / 2));
							else
                                this.ctx.translate(xValue, yValue + diff);
                        }
                        else {
                            if (anchor == "start")
                                this.ctx.translate(xValue, yValue - diff - ((rotation < 0 && rotation > -180) || rotation > 180 ? txtlngth / 2 : (txtlngth - labelTextHeight) / 2));
							else if(anchor == "end")
								this.ctx.translate(xValue, yValue - diff - ((rotation < 0 && rotation > -180) || rotation > 180 ? txtlngth / 2 : -(txtlngth - labelTextHeight) / 2));
                            else
                                this.ctx.translate(xValue, yValue - diff);
                        }
                        this.ctx.textAlign = anchor;
                        this.ctx.rotate(rotation * (Math.PI / 180));
                        if (typeof label == "object") {
                            var len = label.length;
                            for (var i = 0; i < len; i++) {
                                var height = (sf.EjSvgRender.utils._measureText(label[i], null, font)).height;
                                this.ctx.fillText(label[i], 0, i * height);
                            }
                        }
                        else
                            this.ctx.fillText(label, 0, 0);
                    }
                    else {
                        this.ctx.translate(options.x, options.y);
                        this.ctx.rotate(options.labelRotation * Math.PI / 180);
                        this.ctx.fillText(label, 0, 0);
                    }
                }
                this.ctx.restore();
            } else {
                this.lgndCtx.save();
                this.lgndCtx.fillStyle = options.fill;
                this.lgndCtx.font = font;
                this.lgndCtx.textAlign = anchor;
                this.lgndCtx.globalAlpha = opacity;
                // dominant-baseline
                if (options["dominant-baseline"] == "middle")
                    this.lgndCtx.textBaseline = "center";
                if (!options.labelRotation) {
                    this.lgndCtx.fillText(label, options.x, options.y);
                } else {
                    this.lgndCtx.translate(options.x, options.y);
                    this.lgndCtx.rotate(options.labelRotation * Math.PI / 180);
                    this.lgndCtx.fillText(label, 0, 0);
                }
                this.lgndCtx.restore();
            }
        },
        drawZoomRect: function (options, chartObj) {

            var chartPos = { left: 0, top: 0 }, width, height, x, y;
            var zoomRect = $("<div id=" + options.id + "></div>");
            var areaBounds = chartObj.model.m_AreaBounds;

            // for drawing zoom area within the chartArea
            if (options.x < areaBounds.X || options.x + chartPos.left + options.width > chartPos.left + $(this.svgObj).width() - 20) {
                width = this.prevWidth;
                x = this.prevX;
            } else {
                width = this.prevWidth = options.width;
                x = this.prevX = options.x + chartPos.left;
            }

            if (options.y < areaBounds.Y || options.y + chartPos.top + options.height > chartPos.top + areaBounds.Y + areaBounds.Height) {
                height = this.prevHeight;
                y = this.prevY;
            } else {
                height = this.prevHeight = options.height;
                y = this.prevY = options.y + chartPos.top;
            }

            $(zoomRect).css({
                "width": width,
                "height": height,
                "top": y,
                "left": x,
                "background-color": options.fill,
                "border-style": "solid",
                "position": "absolute",
                "border-color": options.stroke,
                "border-width": options["stroke-width"]
            });
            document.getElementById("chartContainer_" + this._rootId).appendChild(zoomRect[0]);
        },
        zoomButton: function (options, currentItem, chart) {
            var svgObj = chart.svgObj ? chart.svgObj : chart.svgObject;
            var id = chart._rootId ? chart._rootId : chart._id;
            if (currentItem == "zoom")
                var currentItemId = "_Zoom";
            else if (currentItem == "zoomIn")
                currentItemId = "_ZoomIn";
            else
                currentItemId = "_ZoomOut";

            var chartPos = { left: 0, top: 0 };
            if ($("#" + options.zoomId).length <= 0) {
                var zoomButton = $("<div id=" + svgObj.id + currentItemId + 'Btn' + "></div>");
                $(zoomButton).css({
                    "width": options.width,
                    "height": options.height,
                    "top": options.top + chartPos.top,
                    "left": options.left + chartPos.left,
                    "background-color": options.fill,
                    "border-style": "solid",
                    "position": "absolute",
                    "border-radius": "0.4em",
                    "border-color": options.fill,
                    "box-sizing": "content-box",
                    "z-index": 2000
                });
                var svgLink = "http://www.w3.org/2000/svg";
                var svgShape = document.createElementNS(svgLink, "svg");
                svgShape.setAttribute('id', options.zoomId);
                svgShape.setAttribute('width', 25);
                svgShape.setAttribute('height', 25);

                if (currentItem == "zoom") {
                    var direction = "M26.101,22.893l-6.605-6.174c1.414-2.781,0.897-6.267-1.496-8.504c-2.901-2.711-7.448-2.56-10.161,0.341    c-2.712,2.9-2.56,7.45,0.341,10.163c2.426,2.266,6,2.523,8.694,0.853l6.579,6.151L26.101,22.893z M10.186,16.571    c-1.715-1.604-1.805-4.293-0.203-6.009c1.605-1.715,4.295-1.805,6.009-0.201c1.715,1.603,1.805,4.293,0.202,6.007    C14.59,18.084,11.901,18.175,10.186,16.571";
                    var transform = "translate(-3,-3)";
                } else if (currentItem == "zoomIn") {
                    direction = "M9.0983096,4.2999878L9.0983096,9.3999634 3.9983783,9.3999634 3.9983783,12.699951 9.0983096,12.699951 9.0983096,17.799988 12.398249,17.799988 12.398249,12.699951 17.49818,12.699951 17.49818,9.5 12.398249,9.5 12.398249,4.2999878z M10.998276,0C14.298215,0 17.49818,1.3999634 19.69813,4.1999512 22.79809,8.0999756 22.79809,13.5 19.998144,17.399963L28.597992,28.299988 23.898081,32 15.398205,21.199951C10.898271,23.099976 5.5983606,21.899963 2.3983956,17.899963 -1.4015366,13.099976 -0.60156059,6.0999756 4.1983567,2.3999634 6.1983276,0.79998779 8.5983163,0 10.998276,0z";
                    transform = "translate(4,4) scale(0.6)";
                } else {
                    direction = "M3.9983433,9.5L3.9983433,12.799988 17.598165,12.799988 17.598165,9.5z M10.998234,0C14.298169,0 17.498131,1.3999634 19.698108,4.1999512 22.798034,8.0999756 22.798034,13.5 19.998092,17.399963L28.597994,28.299988 23.898054,32 15.398188,21.199951C10.898259,23.099976 5.5983546,21.899963 2.398393,17.899963 -1.4015351,13.099976 -0.60155994,6.0999756 4.1983522,2.3999634 6.1983207,0.79998779 8.5983074,0 10.998234,0z";
                    transform = "translate(4,4) scale(0.6)";
                }

                var attrOptions = {
                    'id': currentItemId + 'Path',
                    'fill': options.iconColor,
                    'transform': transform,
                    'd': direction
                };

                var path = document.createElementNS(svgLink, "path");
                $(path).attr(attrOptions).appendTo(svgShape);
                zoomButton[0].appendChild(svgShape);
                document.getElementById("chartContainer_" + id).appendChild(zoomButton[0]);
            } else {
                var zoomButton = document.getElementById(svgObj.id + currentItemId + 'Btn');
                $(zoomButton).css({
                    "top": options.top + chartPos.top,
                    "left": options.left + chartPos.left
                });
            }
        },
        panButton: function (options, chart) {
            var svgObj = chart.svgObj ? chart.svgObj : chart.svgObject;
            var id = chart._rootId ? chart._rootId : chart._id;
            var chartPos = { left: 0, top: 0 };
            if ($("#" + options.panId).length <= 0) {
                var panButton = $("<div id=" + svgObj.id + '_PanBtn' + "></div>");
                $(panButton).css({
                    "width": options.width,
                    "height": options.height,
                    "top": options.top + chartPos.top,
                    "left": options.left + chartPos.left,
                    "background-color": options.fill,
                    "border-style": "solid",
                    "position": "absolute",
                    "border-radius": "0.4em",
                    "border-color": options.fill,
                    "box-sizing": "content-box",
                    "z-index": 2000
                });
                var svgLink = "http://www.w3.org/2000/svg";
                var svgShape = document.createElementNS(svgLink, "svg");
                svgShape.setAttribute('id', options.panId);
                svgShape.setAttribute('width', 25);
                svgShape.setAttribute('height', 25);

                var attrOptions = {
                    'id': 'panPath',
                    'fill': options.iconColor,
                    'transform': 'translate(-3,-3)'
                };
                attrOptions.points = "26.105,16 21.053,12.211 21.053,14.737 17.263,14.737 17.263,10.947 19.834,10.947 16.044,5.895 12.255,10.947 14.737,10.947 14.737,14.737 10.947,14.737 10.947,12.211 5.895,16 10.947,19.789 10.947,17.263 14.737,17.263 14.737,21.053 12.255,21.053 16.044,26.105 19.834,21.053 17.263,21.053 17.263,17.263 21.053,17.263 21.053,19.789";

                var path = document.createElementNS(svgLink, "polygon");
                $(path).attr(attrOptions).appendTo(svgShape);
                panButton[0].appendChild(svgShape);
                document.getElementById("chartContainer_" + id).appendChild(panButton[0]);
            } else {
                var panButton = document.getElementById(svgObj.id + '_PanBtn');
                $(panButton).css({
                    "top": options.top + chartPos.top,
                    "left": options.left + chartPos.left
                });
            }
        },
        resetZoom: function (options, chart) {
            var svgObj = chart.svgObj ? chart.svgObj : chart.svgObject;
            var id = chart._rootId ? chart._rootId : chart._id;
            var chartPos = { left: 0, top: 0 };
            if ($("#" + options.resetZoomId).length <= 0) {
                var resetZoom = $("<div id=" + svgObj.id + '_ResetZoom' + "></div>");
                $(resetZoom).css({
                    "width": options.width,
                    "height": options.height,
                    "top": options.top + chartPos.top,
                    "left": options.left + chartPos.left,
                    "background-color": options.fill,
                    "border-style": "solid",
                    "border-radius": "0.4em",
                    "position": "absolute",
                    "border-color": options.fill,
                    "box-sizing": "content-box",
                    "z-index": 2000
                });
                var svgLink = "http://www.w3.org/2000/svg";
                var svgShape = document.createElementNS(svgLink, "svg");
                svgShape.setAttribute('id', options.resetZoomId);
                svgShape.setAttribute('width', 25);
                svgShape.setAttribute('height', 25);

                var points1 = {
                    'id': 'p1',
                    'fill': options.iconColor,
                    'transform': 'translate(-3,-3)'
                };
                points1.points = "11.895,18.398 8.061,22.23 5.796,19.967 5.796,26.283 12.112,26.283 9.848,24.018 13.682,20.186";

                var path1 = document.createElementNS(svgLink, "polygon");
                $(path1).attr(points1).appendTo(svgShape);

                var points2 = {
                    'id': 'p2',
                    'fill': options.iconColor,
                    'transform': 'translate(-3,-3)'
                };
                points2.points = "19.691,6.072 21.955,8.337 18.121,12.172 19.908,13.959 23.742,10.123 26.007,12.389 26.007,6.072";

                var path2 = document.createElementNS(svgLink, "polygon");
                $(path2).attr(points2).appendTo(svgShape);

                var points3 = {
                    'id': 'p3',
                    'fill': options.iconColor,
                    'transform': 'translate(-3,-3)'
                };
                points3.points = "11.895,13.958 13.682,12.172 9.848,8.337 12.112,6.072 5.796,6.072 5.796,12.389 8.061,10.123";

                var path3 = document.createElementNS(svgLink, "polygon");
                $(path3).attr(points3).appendTo(svgShape);

                var points4 = {
                    'id': 'p4',
                    'fill': options.iconColor,
                    'transform': 'translate(-3,-3)'
                };
                points4.points = "19.908,18.396 18.121,20.186 21.955,24.018 19.691,26.283 26.007,26.283 26.007,19.967 23.741,22.23";

                var path4 = document.createElementNS(svgLink, "polygon");
                $(path4).attr(points4).appendTo(svgShape);

                resetZoom[0].appendChild(svgShape);
                document.getElementById("chartContainer_" + id).appendChild(resetZoom[0]);
            } else {
                var resetZoom = document.getElementById(svgObj.id + '_ResetZoom');
                $(resetZoom).css({
                    "top": options.top + chartPos.top,
                    "left": options.left + chartPos.left
                });
            }
        },
        drawCrosshairLine: function (options, element) {
            var line = $("<div id=" + options.id + "></div>");
            $(line).css({
                "width": options.width,
                "height": options.height,
                "left": options.left,
                "top": options.top,
                "border-style": options.style,
                "opacity": options.opacity,
                "visibility": "visible",
                "border-color": options.stroke,
                "border-width": options["stroke-width"],
                "position": options.position
            });
            $(element).append(line[0]);
        },
        drawCrosshairlabel: function (rectOptions, textOptions, text) {
            var chartOffset = $("#" + this._rootId).offset(),
                chartPos = { left: 0, top: 0 };
            if ($("#" + rectOptions.id).length > 0) {
                var label = document.getElementById(rectOptions.id);
                $(label).css({
                    "width": rectOptions.width - 5,
                    "height": rectOptions.height - 5,
                    "left": textOptions.x + chartPos.left - 5,
                    "top": textOptions.y + chartPos.top - 15,
                    "visibility": "visible",
                    "display": rectOptions.display
                });
                document.getElementById(rectOptions.id).textContent = text;
            } else {
                var label = $("<div id=" + rectOptions.id + " style='position: absolute; z-index: 13000;'></div>");
                $(label).css({
                    "color": textOptions.fill,
                    "font-family": textOptions["font-family"],
                    "font-size": textOptions["font-size"],
                    "font-weight": textOptions["font-weight"],
                    "font-style": textOptions["font-style"],
                    "background-color": rectOptions.fill,
                    "border-style": "solid",
                    "border-color": rectOptions.stroke,
                    "border-width": rectOptions["stroke-width"],
                    "opacity": rectOptions["fill-opacity"],
                    "text-align": "center"
                });

                document.getElementById(this._rootId).appendChild(label[0]);
            }
        },
        createCrosshairCanvas: function () {

            var chartCanvas = document.getElementById(this._rootId + "_canvas"),
                chartOffset = $("#" + this._rootId).offset(), secCanvas,
                chartPos = { left: 0, top: 0 };

            if (!$("#secondCanvas").length) {
                secCanvas = document.createElement('canvas');
                $(document).find("#" + this.svgObj.id + '_CrosshairGroup').append(secCanvas);
                $(secCanvas).attr({
                    'id': 'secondCanvas',
                    'width': chartCanvas.width,
                    'height': chartCanvas.height,
                    'top': chartPos.top,
                    'left': chartPos.left,
                });
                $(secCanvas).css({
                    'width': chartCanvas.width,
                    'height': chartCanvas.height,
                    'top': chartPos.top,
                    'left': chartPos.left
                });
            }
            else {
                secCanvas = document.getElementById("secondCanvas");
            }
            return secCanvas;
        },
        drawTrackToolTip: function (rectOptions, textOptions, text, padding) {
            var chartPos = { left: this.svgObj.offsetLeft, top: this.svgObj.offsetTop };
            if ($("#" + rectOptions.id).length > 0) {
                var label = document.getElementById(rectOptions.id);
                $(label).css({
                    "left": rectOptions.x + chartPos.left,
                    "top": rectOptions.y + chartPos.top,
                    "visibility": "visible",
                    "border-box": "content-box",
                    "background-color": rectOptions.fill,
                    "color": textOptions.fill,
                    "border-color": rectOptions.stroke,
                    "border-width": rectOptions["stroke-width"]
                });
                if (jQuery.type(text) == "array") {
                    var j = 0;
                    var arrayText = "";
                    for (var i = 0; i < text.length; i++) {
                        arrayText = arrayText + text[i] + '</br>';
                    }
                    $("#" + rectOptions.id).html(arrayText);
                } else
                    $("#" + rectOptions.id).html(text);
            } else {
                var label = $("<div id=" + rectOptions.id + " style='position: absolute; z-index: 13000;'></div>");
                $(label).css({
                    "color": textOptions.fill,
                    "font-family": textOptions["font-family"],
                    "font-size": textOptions["font-size"],
                    "font-weight": textOptions["font-weight"],
                    "font-style": textOptions["font-style"],
                    "width": rectOptions.width,
                    "height": rectOptions.height - padding - 2 * rectOptions["stroke-width"],
                    "background-color": rectOptions.fill,
                    "border-style": "solid",
                    "text-align": "center",
                    "padding": "0px",
                    "padding-top": (padding / 2) + 'px',
                    "padding-bottom": (padding / 2) + 'px',
                    "border-color": rectOptions.stroke,
                    "border-width": rectOptions["stroke-width"],
                    "opacity": rectOptions["fill-opacity"]
                });
                document.getElementById(this._rootId).appendChild(label[0]);
            }
        },
        trackSymbol: function (options, evt, symbolName, trackSymbol, chartObj) {
            var chartAreaRect = chartObj.model.m_AreaBounds, chartOffset = $("#" + this._rootId).offset(), parent;
            if (evt.startX >= chartAreaRect.X && evt.startX <= chartAreaRect.X + chartAreaRect.Width && evt.startY >= chartAreaRect.Y && evt.startY <= chartAreaRect.Y + chartAreaRect.Height) {
                var seriesIndex = options.SeriesIndex, radius;
                var pointIndex = options.PointIndex;
                if (chartObj.model.series[seriesIndex].type.toLowerCase() == "bubble") {
                    var point = chartObj.model.series[seriesIndex]._visiblePoints[pointIndex];
                    radius = (point.radius * 2) + 5;//exploding the bubble
                    options.Style.BorderColor = options.Style.Color;
                }

                if (chartObj.model.series[seriesIndex].type.toLowerCase() == "scatter" && sf.util.isNullOrUndefined(trackSymbol)) {
                    var circleOptions = {
                        "cx": evt.startX - 2,
                        "cy": evt.startY - 2,
                        "r": options.ShapeSize.width / 2,
                        "fill": options.Style.Color,
                        "opacity": options.Style.Opacity,
                        "stroke": options.Style.BorderColor
                    };
                    this.drawCircle(circleOptions, null);
                }

                else {
                    if ($("#" + "canvas_trackSymbol").length > 0) {
                        var parentDiv = $("#" + "canvas_trackSymbol");
                        $(parentDiv).css({ "visibility": "visible", "display": "block" });
                    }
                    else
                        parentDiv = $("<div id=" + "canvas_trackSymbol" + "></div>");

                    var chartPos = { left: evt.startX, top: evt.startY };

                    var symbol = $("<div id=" + options.ID + "></div>");
                    var left = (chartPos.left - (radius || options.ShapeSize.width));
                    var top = (chartPos.top - (radius || options.ShapeSize.height));

                    $(symbol).css({

                        "left": left,
                        "top": top,
                        "box-sizing": 'content-box',
                        "position": "absolute",
                        "visibility": "visible",
                        "opacity": options.Style.Opacity,
                        "z-index": 200
                    });
                    var style = options.ShapeSize;
                    options.symbol = symbol;
                    var shapeAttr = {};
                    switch (symbolName.toLowerCase()) {
                        case "circle":
                            $(symbol).css({
                                //radius for bubble exploding
                                "width": radius || options.ShapeSize.width + 'px',
                                "height": radius || options.ShapeSize.height + 'px',
                                "left": radius ? (left + radius / 2) : (left + options.ShapeSize.width / 2 - options.Style.BorderWidth) + 'px',
                                "top": radius ? (top + radius / 2) : (top + options.ShapeSize.height / 2 - options.Style.BorderWidth) + 'px',
                                "border-style": "solid",
                                "background-color": options.Style.Color,
                                "border-color": options.Style.BorderColor,
                                "border-width": options.Style.BorderWidth,
                                "border-radius": "100%"
                            });
                            break;
                        case "rectangle":
                            $(symbol).css({
                                "width": options.ShapeSize.width,
                                "height": options.ShapeSize.height,
                                "left": left + options.ShapeSize.width / 2 - options.Style.BorderWidth / 2,
                                "top": top + options.Style.BorderWidth / 2,
                                "border-style": "solid",
                                "background-color": options.Style.Color,
                                "border-color": options.Style.BorderColor,
                                "border-width": options.Style.BorderWidth
                            });
                            break;
                        case "diamond":

                            var direction = "M" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY) + " "
                                + "L" + " " + (evt.startX) + " " + (evt.startY + (-options.ShapeSize.height / 2)) + " "
                                + "L" + " " + (evt.startX + (options.ShapeSize.width / 2)) + " " + (evt.startY) + " "
                                + "L" + " " + (evt.startX) + " " + (evt.startY + (options.ShapeSize.height / 2)) + " "
                                + "L" + " " + (evt.startX + (-options.ShapeSize.width / 2)) + " " + (evt.startY) + "z";
                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "triangle":

                            var direction = "M" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX) + " " + (evt.startY + (-style.height / 2))
                                + " " + "L" + " " + (evt.startX + (style.width / 2)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY + (style.height / 2)) + "z";
                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "invertedtriangle":

                            var direction = "M" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX) + " " +
                                (evt.startY + (-style.height / 2)) + " " + "L" + " " + (evt.startX + (style.width / 2)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " +
                                (evt.startX + (-style.width / 2)) + " " + (evt.startY + (style.height / 2)) + "z";
                            var x = evt.startX;
                            var y = evt.startY;
                            var rotate = 'rotate(180,' + x + ',' + y + ')';

                            shapeAttr.direction = direction;
                            shapeAttr.rotate = rotate;
                            this.drawSvgShape(options, shapeAttr);

                            break;

                        case "cross":

                            var direction = "M" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY) + " " + "L" + " " + (evt.startX + (style.width / 2))
                                + " " + (evt.startY) + " " + "M" + " " + (evt.startX) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX) + " " +
                                (evt.startY + (-style.height / 2)) + "z";

                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "star":

                            var direction = "M" + " " + (evt.startX + (style.width / 3)) + " " + (evt.startY + (-style.height / 2)) + " " + "L" + " " + (evt.startX + (-style.width / 2)) + " " +
                                (evt.startY + (style.height / 6)) + " " + "L" + " " + (evt.startX + (style.width / 2)) + " " + (evt.startY + (style.height / 6)) + " " + "L" + " " + (evt.startX + (-style.width / 3)) + " " +
                                (evt.startY + (-style.height / 2)) + " " + "L" + " " + (evt.startX) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX + (style.width / 3)) + " " + (evt.startY + (-style.height / 2)) + "z";

                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "hexagon":

                            var direction = "M" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY) + " " + "L" + " " + (evt.startX + (-style.width / 4)) + " " +
                                (evt.startY + (-style.height / 2)) + " " + "L" + " " + (evt.startX + (style.width / 4)) + " " + (evt.startY + (-style.height / 2)) + " " + "L" + " " +
                                (evt.startX + (style.width / 2)) + " " + (evt.startY) + " " + "L" + " " + (evt.startX + (style.width / 4)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " +
                                (evt.startX + (-style.width / 4)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY) + "z";

                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "wedge":

                            var direction = "M" + " " + (evt.startX - style.width) + " " + (evt.startY) + " " + "L" + " " + (evt.startX + style.width) + " " +
                                (evt.startY + (-style.height / 2)) + " " + "L" + " " + (evt.startX + (3 * (style.width / 4))) + " " + (evt.startY) + " " + "L" + " " +
                                (evt.startX + (style.width)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX - style.width) + " " + (evt.startY) + "z";

                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "trapezoid":

                            var direction = "M" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY) + " " + "L" + " " + (evt.startX + (-style.width / 2)) + " " +
                                (evt.startY + (-style.height / 4)) + " " + "L" + " " + (evt.startX + (-style.width / 2) + (style.width)) + " " + (evt.startY + (-style.height / 2)) + " " + "L" + " " +
                                (evt.startX + (-style.width / 2) + (style.width)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY + (style.height / 4)) +
                                " " + "L" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY) + "z";

                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "uparrow":

                            var direction = "M" + " " + ((evt.startX - (style.width / 2) + (style.width / 4))) + " " + (evt.startY - (style.height / 2) + (style.height)) + " " + "L" + " " + ((evt.startX - (style.width / 2) + (style.width / 4))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX - (style.width / 2))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX)) + " " + (evt.startY - (style.height / 2)) + " " + "L" + " " + ((evt.startX + (style.width / 2))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX + (style.width / 2) - (style.width / 4))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX + (style.width / 2) - (style.width / 4))) + " " + (evt.startY - (style.height / 2) + (style.height)) + " " + "L" + " " + ((evt.startX - (style.width / 2) + (style.width / 4))) + " " + (evt.startY - (style.height / 2) + (style.height)) + "z";
                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "downarrow":

                            var direction = "M" + " " + ((evt.startX - (style.width / 2) + (style.width / 4))) + " " + (evt.startY - (style.height / 2)) + " " + "L" + " " + ((evt.startX + (style.width / 2) - (style.width / 4))) + " " + (evt.startY - (style.height / 2)) + " " + "L" + " " + ((evt.startX + (style.width / 2) - (style.width / 4))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX + (style.width / 2))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX)) + " " + (evt.startY - (style.height / 2) + (style.height)) + " " + "L" + " " + ((evt.startX - (style.width / 2))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX - (style.width / 2) + (style.width / 4))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX - (style.width / 2) + (style.width / 4))) + " " + (evt.startY - (style.height / 2)) + "z";
                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "leftarrow":

                            var direction = "M" + " " + ((evt.startX - (style.width / 2)) + style.width) + " " + (evt.startY + (style.height / 4)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + style.width) + " " + (evt.startY + (-style.height / 4)) + " " + "L" + " " +
                                ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " + (evt.startY + (-style.height / 4)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " + (evt.startY + (-style.height / 2)) + " " + "L" + " " + ((evt.startX -
                                    (style.width / 2))) + " " + (evt.startY) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " +
                                (evt.startY + (style.height / 4)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + style.width) + " " + (evt.startY + (style.height / 4)) + "z";

                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "rightarrow":

                            var direction = "M" + " " + ((evt.startX - (style.width / 2))) + " " + (evt.startY + (style.height / 4)) + " " + "L" + " " + ((evt.startX - (style.width / 2))) + " " + (evt.startY + (-style.height / 4)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " + (evt.startY + (-style.height / 4)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " + (evt.startY + (-style.height / 2)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + style.width) + " " + (evt.startY) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " + (evt.startY + (style.height / 4)) + " " + "L" + " " + ((evt.startX - (style.width / 2))) + " " + (evt.startY + (style.height / 4)) + "z";
                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "pentagon":

                            var eq = 72;
                            var radius = Math.sqrt(style.height * style.height + style.width * style.width) / 2;
                            var sb = sf.EjSvgRender.utils._getStringBuilder();
                            for (var i = 0; i <= 5; i++) {
                                var deg = i * eq;
                                var rad = (Math.PI / 180) * deg;
                                var x1 = radius * Math.cos(rad);
                                var y1 = radius * Math.sin(rad);
                                if (i == 0)
                                    sb.append("M" + " " + (evt.startX + x1) + " " + (evt.startY + y1) + " ");
                                else
                                    sb.append("L" + " " + (evt.startX + x1) + " " + (evt.startY + y1) + " ");
                            }
                            sb.append("z");
                            var direction = sb.toString();
                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "ellipse":
                            $(symbol).css({
                                "width": options.ShapeSize.width,
                                "height": options.ShapeSize.height / 2,
                                "border-style": "solid",
                                "left": left + options.ShapeSize.height / 2 - options.Style.BorderWidth / 2,
                                "top": (evt.startY + chartPos.top - options.ShapeSize.height + 4),
                                "background-color": options.Style.Color,
                                "border-color": options.Style.BorderColor,
                                "border-width": options.Style.BorderWidth,
                                "-moz-border-radius": "50%",
                                "-webkit-border-radius": "50%",
                                "border-radius": "50%",
                                "border-box": "content-box"
                            });
                            break;
                        case "horizline":
                            $(symbol).css({
                                "width": options.ShapeSize.width,
                                "height": 0,
                                "border-style": "solid",
                                "left": left + options.ShapeSize.width / 2,
                                "top": (evt.startY + chartPos.top - 1),
                                "border-color": options.Style.BorderColor,
                                "border-width": '2px',
                                "border-box": "content-box"
                            });
                            break;
                        case "vertline":
                            $(symbol).css({
                                "width": 0,
                                "height": options.ShapeSize.height,
                                "border-style": "solid",
                                "left": (evt.startX + chartPos.left - 1),
                                "top": top + options.ShapeSize.height / 2 - 2,
                                "border-color": options.Style.BorderColor,
                                "border-width": '2px',
                                "border-box": "content-box"
                            });
                            break;
                        default:
                            $(symbol).css({
                                "width": options.ShapeSize.width,
                                "height": options.ShapeSize.height,
                                "border-style": "solid",
                                "background-color": options.Style.Color,
                                "border-color": options.Style.BorderColor,
                                "border-width": options.Style.BorderWidth,
                                "border-radius": "50px"
                            });
                            break;
                    }
                    parentDiv[0].appendChild(symbol[0]);
                    parent = document.getElementById(this.svgObj.id + '_CrosshairGroup') || document.getElementById("chartContainer_" + this._rootId);
                    parent.appendChild(parentDiv[0]);
                }
            }
        },
        //draw SVG Marker shape on mouse over the points
        drawSvgShape: function (options, attr) {
            var chartCanvas = document.getElementById(this._rootId + "_canvas");
            var chartPos = { left: 0, top: 0 };
            var svgLink = "http://www.w3.org/2000/svg";
            var svgShape = document.createElementNS(svgLink, "svg");
            svgShape.setAttribute('id', 'mySVG');
            svgShape.setAttribute('width', $(chartCanvas).width());
            svgShape.setAttribute('height', $(chartCanvas).height());
            $(options.symbol).css({
                "left": chartPos.left + 'px',
                "top": chartPos.top + 'px'
            });
            var attrOptions = {
                'id': 'svgPath',
                'fill-opacity': options.Style.Opacity,
                'stroke-width': options.Style.BorderWidth,
                'fill': options.Style.Color,
                'transform': attr.rotate,
                'stroke': options.Style.BorderColor
            };
            attrOptions.d = attr.direction;

            var path = document.createElementNS(svgLink, "path");
            $(path).attr(attrOptions).appendTo(svgShape);
            options.symbol[0].appendChild(svgShape);
        },
        drawCircle: function (options, element) {
            if (!options.lgndCtx) {
                var canvasCtx = this.ctx, dashArray;
                this.ctx = element != undefined ? element : this.ctx;
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.arc(options.cx, options.cy, options.r, 0, 2 * Math.PI);
                this.ctx.fillStyle = options.fill;
                this.ctx.globalAlpha = options.opacity;
                this.ctx.fill();
                this.ctx.lineWidth = options["stroke-width"];
                dashArray = options["stroke-dasharray"] ? options["stroke-dasharray"].split(",") : false;
                if (dashArray) this.ctx.setLineDash(dashArray);
                this.ctx.strokeStyle = options.stroke;
                this.ctx.stroke();
                this.ctx.restore();
                this.ctx = canvasCtx;
            } else {
                var legendCtx = this.lgndCtx;
                this.lgndCtx = element != undefined ? element : this.lgndCtx;
                this.lgndCtx.save();
                this.lgndCtx.beginPath();
                this.lgndCtx.arc(options.cx, options.cy, options.r, 0, 2 * Math.PI);
                this.lgndCtx.fillStyle = options.fill;
                this.lgndCtx.globalAlpha = options.opacity;
                this.lgndCtx.fill();
                this.lgndCtx.lineWidth = options["stroke-width"];
                this.lgndCtx.strokeStyle = options.stroke;
                this.lgndCtx.stroke();
                this.lgndCtx.restore();
                this.lgndCtx = legendCtx;
            }
        },

        drawPolyline: function (options, element) {

            this.ctx.save();
            this.ctx.beginPath();
            var points = options.points.split(" ");
            for (var i = 0; i < points.length - 1; i++) {
                var point = points[i].split(",");
                var x = point[0];
                var y = point[1];
                if (i == 0)
                    this.ctx.moveTo(x, y);
                else
                    this.ctx.lineTo(x, y);
            }
            this.ctx.lineWidth = options["stroke-width"];
            this.ctx.strokeStyle = options.stroke;
            this.ctx.stroke();
            this.ctx.restore();
        },
        drawPolygon: function (options, element) {

        },
        setFillAttribute: function (element, options) {

        },
        setStrokeAttribute: function (element, options) {

        },
        changePathValue: function (options) {

        },


        drawArc: function (w, h, options) {
            var x = 0, y = 0;

        },
        changeVMLStyle: function ($element, options) {

        },
        applyVMLStyle: function ($element, options) {

        },

        drawEllipse: function (options, element) {
            var canvasCtx = this.ctx;
            this.ctx = element != undefined ? element : this.ctx;
            var circumference = Math.max(options.rx, options.ry);
            var scaleX = options.rx / circumference;
            var scaleY = options.ry / circumference;
            if (!options.lgndCtx) {
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.translate(options.cx, options.cy);
                this.ctx.save();
                this.ctx.scale(scaleX, scaleY);
                this.ctx.arc(0, 0, circumference, 0, 2 * Math.PI, false);
                this.ctx.fillStyle = options.fill;
                this.ctx.fill();
                this.ctx.restore();
                this.ctx.lineWidth = options["stroke-width"];
                this.ctx.strokeStyle = options.stroke;
                this.ctx.stroke();
                this.ctx.restore();
                this.ctx = canvasCtx;
            } else {
                this.lgndCtx.save();
                this.lgndCtx.beginPath();
                this.lgndCtx.translate(options.rx, options.ry);
                this.lgndCtx.scale(scaleX, scaleY);
                this.lgndCtx.arc(options.cx - options.rx, options.cy * 2 - options.rx, options.rx, 0, 2 * Math.PI, false);
                this.lgndCtx.fillStyle = options.fill;
                this.lgndCtx.fill();
                this.lgndCtx.restore();
                this.lgndCtx.lineWidth = options["stroke-width"];
                this.lgndCtx.strokeStyle = options.stroke;
                this.lgndCtx.stroke();
                this.lgndCtx.restore();
            }
        },

        _getAttrVal: function (ele, val, option) {
            var value = $(ele).attr(val);
            if (value != null)
                return value;
            else
                return option;
        },
        _setAttr: function (element, attribute) {

        },

        setSpanAttr: function (options, label, element) {

        },

        //text element attributes values are replaced 
        _textAttrReplace: function (options, label, font, $Ele) {

        },

        drawImage: function (options, element) {
            this.ctx.save();
            var renderer = this;
            var imageObj = new Image();
            imageObj.src = options.href;
            imageObj.onload = function () {
                renderer.ctx.drawImage(imageObj, options.x, options.y, options.width, options.height);
            }
            this.ctx.restore();
        },

        createDefs: function () {

        },

        createGroup: function (options) {

        },

        createText: function (options, label) {
            var text = document.createElement("div");
            var diff = 1.1; // difference between svg and div element rotated text height
            $(text).css({
                "transform": options.rotateAngle,
                "font-family": parseFloat(options["font-family"]),
                "font-size": parseFloat(options["font-size"]) * diff,
                "position": "absolute"
            });
            if (!sf.util.isNullOrUndefined(label))
                text.textContent = label;
            return text;
        },


        //Draw clip path for each series to avoid series overlap in multiple axes zooming
        drawAxesBoundsClipPath: function (gSeriesGroupEle, options, invertedAxis) {
            var clipOptions = options;

        },

        getAttrVal: function (ele, val, option) {

        },

        hexFromRGB: function (color) {

        },

        createDelegate: function (context, handler) {

        },

        drawClipPath: function (options, element) {

        },

        drawCircularClipPath: function (options, element) {

        },

        append: function (childEle, parentEle) {
            $(childEle).appendTo(parentEle);
        },

        createLegendCanvas: function (element) {
            this.legendsvgObj = document.createElement('canvas');
            this._rootId = jQuery(element).attr("id");
            this.legendsvgObj.setAttribute('id', "legend_" + this._rootId + '_canvas');
            this.lgndCtx = this.legendsvgObj.getContext("2d");
            return this.legendsvgObj;
        }

    };
})(jQuery);


;
/* global jQuery, sf */
sf.Ej3DAxisRenderer = function () {
};

sf.Ej3DSeriesRender = function () {
};


sf.Ej3DChart = function () {
};

sf.series3DTypes = {};

(function ($) {

    sf.Ej3DAxisRenderer.prototype = {

        _drawAxes: function (index, axis, params) {
            if (axis.majorGridLines.visible)
                this._drawGridLines3D(axis, params);
            if (axis.visible && axis.majorTickLines.visible)
                this._renderTicks3D(axis, axis.majorTickLines.size, axis.majorTickLines.width, params);

            if (axis.visible) {
                this._drawAxisLabel(axis, params);
                this._drawMultiLevelLabel(index, axis, params);
                this._drawAxisTitle(axis);
            }
        },

        _drawAxisTitle: function (axis) {
            if (axis.title.visible) {
                var font = axis.title.font, id;
                this.gAxisTitleEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + "axisTitle_" + axis.name });
                var opposedPosition = axis._opposed;
                var size = { Width: $(this.svgObject).width(), Height: $(this.svgObject).height() },
                    padding = 10,
                    transform = sf.EjSvgRender.chartTransform3D.transform3D(size);
                transform.mViewport = size;
                transform.Rotation = 0;
                transform.Tilt = 0;
                transform.Depth = 100;
                transform.PerspectiveAngle = 90;
                sf.EjSvgRender.chartTransform3D.transform(transform);
                var result = sf.EjSvgRender.chartTransform3D.result,
                    matrix3D = sf.Ej3DRender.prototype.matrix3D.prototype,
                    orientation = axis.orientation.toLowerCase(),
                    multiLevelLabelsVisible = false, currentAxis, element;

                for (var i = 0; i < this.model._axes.length; i++) {
                    currentAxis = this.model._axes[i];
                    if (currentAxis.orientation.toLowerCase() == orientation) {
                        for (var j = 0; j < currentAxis.multiLevelLabels.length; j++) {
                            if (currentAxis.multiLevelLabels[j].visible) {
                                multiLevelLabelsVisible = true;
                                break;
                            }
                        }
                    }
                }

                if (orientation == "horizontal") {
                    var xtitleLocation = (this.model.elementSpacing) + axis._LableMaxWidth.height;
                    var titlesize = (sf.EjSvgRender.utils._measureText(axis.title.text, (axis.width), axis.title.font).height / 2);
                    var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                    commonEventArgs.data = { Text: axis.title.text, location: { x: (axis.width) / 2, y: (xtitleLocation + titlesize + axis.majorTickLines.size + axis.axisLine.width + this.model.wallSize + axis._multiLevelLabelHeight) }, axes: axis };
                    this._trigger("axesTitleRendering", commonEventArgs);

                    font = axis.title.font;
                    var x1 = commonEventArgs.data.location.x + axis.x;
                    var y1 = (opposedPosition) ? (axis.y - commonEventArgs.data.location.y) : (commonEventArgs.data.location.y + axis.y);

                    element = { Width: titlesize.width, Height: titlesize.height, Label: commonEventArgs.data, TextAnchor: 'middle', tag: 'text', font: font, id: this.svgObject.id + "axisTitle", child: this.chart3D };
                    if (!multiLevelLabelsVisible)
                        this.graphics.addVisual(this.polygon.createTextElement(this.vector.vector3D(x1, y1, 0), element, 10, 10));
                    else {

                        var options = {
                            'id': this.svgObject.id + "axisTitle",
                            'x': x1,
                            'y': y1,
                            'fill': font.color,
                            'font-size': font.size,
                            'font-family': font.fontFamily,
                            'font-style': font.fontStyle,
                            'font-weight': font.fontWeight,
                            'opacity': font.opacity,
                            'text-anchor': "middle"
                        };
                        var newOptions = sf.EjSvgRender.chartTransform3D.toScreen({ x: x1, y: y1, z: 0 }, transform, result, matrix3D);
                        options.x = newOptions.x; options.y = newOptions.y;
                        this.svgRenderer.drawText(options, commonEventArgs.data.Text, this.gAxisTitleEle);
                        this.svgRenderer.append(this.gAxisTitleEle, this.svgObject);
                    }
                }
                else {
                    var titleSize = sf.EjSvgRender.utils._measureText(axis.title.text, (axis.height), axis.title.font);
                    var x1 = (opposedPosition) ? axis.x + ((4 * this.model.elementSpacing) + axis._LableMaxWidth.width + axis.majorTickLines.size + axis.axisLine.width + this.model.wallSize + axis._multiLevelLabelHeight) : axis.x - ((3 * this.model.elementSpacing) + axis._LableMaxWidth.width + axis.majorTickLines.size + axis.axisLine.width + this.model.wallSize + axis._multiLevelLabelHeight);

                    var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                    commonEventArgs.data = { Text: axis.title.text, location: { x: titleSize.width / 2, y: 0 }, axes: axis };
                    this._trigger("axesTitleRendering", commonEventArgs);

                    font = axis.title.font;
                    var y1 = commonEventArgs.data.location.y + (axis.y + axis.height) + (((axis.height) / 2) * -1);

                    var labelRotation = (opposedPosition) ? 90 : -90;
                    var value = opposedPosition ? 25 : -25;
                    element = { Width: titleSize.width, Height: titleSize.height, Angle: -90, Label: commonEventArgs.data, TextAnchor: 'middle', tag: 'text', font: font, id: this.svgObject.id + '_YAxisTitle', child: this.chart3D };
                    if (!multiLevelLabelsVisible)
                        this.graphics.addVisual(this.polygon.createTextElement(this.vector.vector3D(x1, y1, 0), element, 10, 10));
                    else {

                        var options = {
                            'id': id,
                            'x': x1,
                            'y': y1,
                            'fill': font.color,
                            'font-size': font.size,
                            'font-family': font.fontFamily,
                            'font-style': font.fontStyle,
                            'font-weight': font.fontWeight,
                            'opacity': font.opacity,
                            'text-anchor': "middle",
                            'transform': 'rotate(' + -90 + ',' + (x1) + ',' + (opposedPosition ? y1 + padding : y1 - padding) + ')',
                        };
                        var newOptions = sf.EjSvgRender.chartTransform3D.toScreen({ x: x1, y: y1, z: 0 }, transform, result, matrix3D);
                        options.x = newOptions.x + value; options.y = newOptions.y;
                        this.svgRenderer.drawText(options, commonEventArgs.data.Text, this.gAxisTitleEle);
                        this.svgRenderer.append(this.gAxisTitleEle, this.svgObject);
                    }
                }
            }
        },

        _drawMultiLevelLabel: function (axisIndex, axis, params) {    // to render multilevel labels
            // declaration
            this.gMultiLevelEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_axisMultiLevelLabels' + '_' + axisIndex });
            var i, j, x, y, rows, gap, labelSize, grpLabel, id, font, center, centerX, startX, startY, endX, textOptions, textOverflow, depth = 0,
                textCollection, borderOptions, border, style, alignment, multiLevelLabelsLength = axis.multiLevelLabels.length, model = this.model,
                elementSpacing = model.elementSpacing, padding = 10, x1 = 0, y1 = 0, element, level, anchor, topValue, bottomValue, leftValue, text, actualText, maximumTextWidth, width, newId, value, 
                rightValue, lineTop, bottom, right, left, areaBounds = model.m_AreaBounds, textSize, visibleRange = axis.visibleRange, actual3DPosition1,
                wallSize = model.wallSize, opposedPosition = axis._opposed, validCross = params.axes[axis.name]._validCross, actual3DPosition2,
                orientation = axis.orientation.toLowerCase(), y = validCross ? axis.y : areaBounds.Y + (!opposedPosition && areaBounds.Height), alignment,
                x = validCross ? axis.x : areaBounds.X + (opposedPosition && areaBounds.Width), options, newOptions, vectorColl = [], l, borderWidth;

            var size = { Width: $(this.svgObject).width(), Height: $(this.svgObject).height() };
            var transform = sf.EjSvgRender.chartTransform3D.transform3D(size);
            transform.mViewport = size;
            transform.Rotation = 0;
            transform.Tilt = 0;
            transform.Depth = 100;
            transform.PerspectiveAngle = model.perspectiveAngle;
            sf.EjSvgRender.chartTransform3D.transform(transform);
            var result = sf.EjSvgRender.chartTransform3D.result,
                matrix3D = sf.Ej3DRender.prototype.matrix3D.prototype;

            for (var i = 0; i < multiLevelLabelsLength; i++) {
                grpLabel = axis.multiLevelLabels[i];
                id = this.svgObject.id + "_" + axis.name + "MultiLevelLabels_" + axisIndex + "_" + i;
                if (grpLabel.text != "" && grpLabel.visible) {
                    level = grpLabel._level;
                    anchor = "middle";
                    font = grpLabel.font;
                    borderWidth = grpLabel.border.width;
                    maximumTextWidth = grpLabel.maximumTextWidth;
                    alignment = grpLabel.textAlignment.toLowerCase();
                    actualText = text = grpLabel.text;
                    textOverflow = grpLabel.textOverflow.toLowerCase();
                    textSize = sf.EjSvgRender.utils._measureText(grpLabel.text, areaBounds.Width, grpLabel.font);
                    center = (grpLabel.end - grpLabel.start) / 2;
                    centerX = (grpLabel.start + center - visibleRange.min) / (visibleRange.delta);
                    startX = (grpLabel.start - visibleRange.min) / (visibleRange.delta);
                    endX = (grpLabel.end - visibleRange.min) / (visibleRange.delta);
                    if (axis.isInversed) {
                        centerX = isNaN(centerX) ? 0 : 1 - centerX;
                        startX = isNaN(startX) ? 0 : 1 - startX;
                        endX = isNaN(endX) ? 0 : 1 - endX;
                    }
                    if (orientation == "horizontal") {    // start, end and gap calculation
                        x1 = (Math.round(axis.width * centerX)) + areaBounds.X + ((axis.plotOffset));
                        y1 = (opposedPosition) ? (y - wallSize - (axis.majorTickLines.size) - elementSpacing - padding / 2 - axis._LableMaxWidth.height) : y + wallSize + (axis.majorTickLines.size) + elementSpacing + axis._LableMaxWidth.height;
                        startX = (Math.round(axis.width * startX)) + areaBounds.X + ((axis.plotOffset));
                        endX = (Math.round(axis.width * endX)) + areaBounds.X + ((axis.plotOffset));
                        gap = maximumTextWidth ? maximumTextWidth : endX - startX - padding;
                    } else {
                        y1 = Math.round(axis.plotOffset + axis.y + (axis.height * (1 - centerX)));
                        x1 = (opposedPosition) ? (axis.x + wallSize + axis.majorTickLines.size + axis.axisLine.width + elementSpacing / 2 + axis._LableMaxWidth.width + axis.prevHeight[level] + axis.multiLevelLabelHeight[level] / 2) : (x - wallSize - axis.majorTickLines.size - elementSpacing / 2 - axis._LableMaxWidth.width - axis.prevHeight[level] - axis.multiLevelLabelHeight[level] / 2);
                        startX = Math.round(axis.plotOffset + axis.y + (axis.height * (1 - startX)));
                        endX = Math.round(axis.plotOffset + axis.y + (axis.height * (1 - endX)));
                        gap = maximumTextWidth ? maximumTextWidth : axis.multiLevelLabelHeight[level] + padding;
                    }
                    if(orientation == "horizontal")
					y1 = opposedPosition ? y1 - axis.prevHeight[level] : y1 + axis.prevHeight[level];

                    if (alignment == "far") {
                        x1 = x1 + gap / 2 - borderWidth / 2;
                        anchor = "end";
                    } else if (alignment == "near") {
                        anchor = "start";
                        x1 = x1 - (gap / 2) + (borderWidth / 2);
                    }

                    // to trigger event
                    var data = sf.EjAxisRenderer.prototype._triggerMultiLevelLabelsRendering(actualText, x1, y1, textOverflow, font, grpLabel.border, this), text, actualText;
                    text = actualText = data.text;
                    x1 = data.location.x;
                    y1 = data.location.y;
                    textOverflow = data.textOverflow.toLowerCase();
                    font = data.font;
                    font.color = font.color ? font.color : axis.multiLevelLabelsFontColor;
                    border = data.border;
                    style = data.border.type.toLowerCase();
                    borderWidth = data.border.width;

                    options = {
                        'id': id,
                        'x': x1,
                        'y': y1,
                        'fill': font.color,
                        'font-size': font.size,
                        'font-family': font.fontFamily,
                        'font-style': font.fontStyle,
                        'font-weight': font.fontWeight,
                        'opacity': font.opacity,
                        'text-anchor': anchor
                    };

                    // calculation for wrap and wrapbyword
                    if (textOverflow != "none")
                        text = sf.EjAxisRenderer.prototype.textOverflowMultiLevelLabels(axis, gap, text, actualText, textOverflow, font, textSize, { x: x1, y: y1 }, null, this);
                    if (textOverflow == "wrap" || textOverflow == "wrapandtrim") {
                        var newY = y1;
                        for (j = 0; j < text.length; j++) {
                            textSize = sf.EjSvgRender.utils._measureText(text[j], null, font);
                            if (j != 0) newY = opposedPosition ? newY - textSize.height : newY + textSize.height;
                            element = { Width: textSize.width, Height: textSize.height, Label: { "Text": text[j] }, TextAnchor: anchor, tag: 'text', font: font, id: id + "_" + j, child: this.chart3D };
                            options.id = options.id + "_" + j;
                            var newOptions = sf.EjSvgRender.chartTransform3D.toScreen({ x: x1, y: newY + padding / 2, z: 0 }, transform, result, matrix3D);
                            options.x = newOptions.x; options.y = newOptions.y;
                            this.svgRenderer.drawText(options, text[j], this.gMultiLevelEle);
                        }
                    }
                    x1 = orientation == "horizontal" ? x1 : (opposedPosition ? x1 + padding : x1 - padding);

                    //rendering multi level labels text
                    if (textOverflow != "wrap" && textOverflow != "wrapandtrim") {
                        element = { Width: textSize.width, Height: textSize.height, Label: { "Text": text }, TextAnchor: anchor, tag: 'text', font: font, id: id, child: this.chart3D };
                        var newOptions = sf.EjSvgRender.chartTransform3D.toScreen({ x: x1, y: y1 + padding / 2, z: 0 }, transform, result, matrix3D);
                        options.x = newOptions.x; options.y = newOptions.y;
                        this.svgRenderer.drawText(options, text, this.gMultiLevelEle);
                    }
                    // storing region for multi level labels click event
                    if (orientation == "horizontal")
                        var region = { bounds: { x: startX, y: y1 - padding, height: axis.multiLevelLabelHeight[level], width: gap }, axisIndex: axisIndex, multiLevelLabel: grpLabel };
                    else
                        var region = { bounds: { x: x1 - width / 2 - padding / 2, y: endX, height: startX - endX, width: width }, axisIndex: axisIndex, multiLevelLabel: grpLabel };
                    this.model.multiLevelLabelRegions.push(region);

                    // to render border
                    if (style != "none" && borderWidth > 0) {
                        id = this.svgObject.id + "_" + axis.name + "MultiLevelLabelsBorder_" + axisIndex + "_" + i;
                        var height = y1 - padding + axis.multiLevelLabelHeight[level] + padding / 2;
                        var borderColor = grpLabel.border.color ? grpLabel.border.color : axis.multiLevelLabelsColor
                        if (orientation == "horizontal") {
                            topValue = { x1: startX, y1: y1 - padding, x2: endX, y2: y1 - padding };
                            bottomValue = { x1: startX, y1: height, x2: endX, y2: height };
                            leftValue = { x1: startX, y1: y1 - padding, x2: startX, y2: height };
                            rightValue = { x1: endX, y1: y1 - padding, x2: endX, y2: height };
                        } else {
                            width = axis.multiLevelLabelHeight[level] - (padding/2);
                            topValue = { x1: x1 - width / 2 - padding / 2, y1: endX, x2: x1 + width / 2 + padding / 2, y2: endX };
                            bottomValue = { x1: x1 - width / 2 - padding / 2, y1: startX, x2: x1 + width / 2 + padding / 2, y2: startX };
                            leftValue = { x1: x1 - width / 2 - padding / 2, y1: endX, x2: x1 - width / 2 - padding / 2, y2: startX };
                            rightValue = { x1: x1 + width / 2 + padding / 2, y1: endX, x2: x1 + width / 2 + padding / 2, y2: startX };
                        }
                        for (l = 0; l < 4; l++) {
                            switch (l) {
                                case 0:
                                    newId = id + "_top";
                                    value = topValue;
                                    break;
                                case 1:
                                    newId = id + "_bottom";
                                    value = bottomValue;
                                    break;
                                case 2:
                                    newId = id + "_left";
                                    value = leftValue;
                                    break;
                                case 3:
                                    newId = id + "_right";
                                    value = rightValue;
                                    break;
                            }
                            vectorColl[0] = sf.Ej3DRender.prototype.vector3D.prototype.vector3D(value.x1, value.y1, depth);
                            vectorColl[1] = sf.Ej3DRender.prototype.vector3D.prototype.vector3D(value.x2, value.y2, depth);
                            actual3DPosition1 = sf.EjSvgRender.chartTransform3D.toScreen(vectorColl[0], transform, result, matrix3D);
                            actual3DPosition2 = sf.EjSvgRender.chartTransform3D.toScreen(vectorColl[1], transform, result, matrix3D);
                            options = {
                                'id': newId,
                                'x1': actual3DPosition1.x,
                                'y1': actual3DPosition1.y,
                                'x2': actual3DPosition2.x,
                                'y2': actual3DPosition2.y,
                                'stroke': borderColor,
                                'stroke-width': borderWidth
                            };
                            this.svgRenderer.drawLine(options, this.gMultiLevelEle);
                        }
                        this.svgRenderer.append(this.gMultiLevelEle, this.svgObject);
                    }
                }
            }
        },

        _textTrim: function (maxWidth, text, font) {
            var textLength = text.length; var trimmedSize;
            var label;
            var textSize = sf.EjSvgRender.utils._measureText(text, this.model.m_AreaBounds.Width, font);
            if (textSize.width > maxWidth) {
                for (var k = textLength - 1; k >= 0; --k) {
                    label = text.substring(0, k) + '...';
                    trimmedSize = sf.EjSvgRender.utils._measureText(label, this.model.m_AreaBounds.Width, font)
                    if (trimmedSize.width <= maxWidth) {
                        return label;
                    }
                }
            } else {
                return text;
            }
        },

        _textWrap: function (maxWidth, currentLabel, font) {
            var textCollection = currentLabel.toString().split(' ');
            var label = '';
            var labelCollection = []; var length = textCollection.length;
            var text = '';
            for (var i = 0; i < length; i++) {
                text = textCollection[i];
                if (sf.EjSvgRender.utils._measureText(label.concat(text), this.model.m_AreaBounds.Width, font).width < maxWidth) {
                    label = label.concat((label === '' ? '' : ' ') + text);
                } else {
                    if (label !== '') {
                        labelCollection.push(this._textTrim(maxWidth, label, font));
                        label = text;
                    } else {
                        labelCollection.push(this._textTrim(maxWidth, text, font));
                        text = '';
                    }
                }
                if (label && i === length - 1) {
                    labelCollection.push(this._textTrim(maxWidth, label, font));
                }
            }
            return labelCollection;

        },

        _textWrapByLength: function (maxWidth, currentLabel, font) {
            var start = 0; var labelCollection = []; var tempLabel = '';
            currentLabel = currentLabel.toString();
            var maxWordLength = currentLabel.length;
            for (var j = 0; j <= maxWordLength; j++) {
                tempLabel = start == 0 ? currentLabel.slice(start, j) : '-' + currentLabel.slice(start, j);
                if (sf.EjSvgRender.utils._measureText(tempLabel, this.model.m_AreaBounds.Width, font).width > maxWidth - 5) {
                    labelCollection.push(tempLabel);
                    start = j++;
                } else if (j === maxWordLength) {
                    labelCollection.push(tempLabel);
                }
            }
            return labelCollection;
        },

        _multipleRows: function (length, currentX, currentLabel, axis) {
            var label, pointX, labelSize;
            var store = [];
            var isMultiRows;

            for (var i = length - 1; i >= 0; i--) {
                label = axis.visibleLabels[i];
                labelSize = sf.EjSvgRender.utils._measureText(label.Text, this.model.m_AreaBounds.Width, axis.font);
                pointX = sf.EjSvgRender.utils._valueToCoefficient(axis, i) * axis.width + axis.x
                isMultiRows = currentX < (pointX + labelSize.width / 2);
                if (isMultiRows) {
                    label.index = label.index ? label.index : 0;
                    store.push(label.index);
                    currentLabel.index = (currentLabel.index > label.index) ? currentLabel.index : label.index + 1;
                } else {
                    currentLabel.index = store.indexOf(label.index) > - 1 ? currentLabel.index : label.index;
                }
            }
        },

        _drawAxisLabel: function (axis, params) {
            var labels = []; var angleValue = null; var extraHeight = 0;
            var labelsCount = axis.visibleLabels.length,
                areaBounds = this.model.m_AreaBounds,
                opposedPosition = axis._opposed, element,
                validCross = params.axes[axis.name]._validCross,
                y = validCross ? axis.y : areaBounds.Y + (!opposedPosition && areaBounds.Height),
                x = validCross ? axis.x : areaBounds.X + (opposedPosition && areaBounds.Width);

            for (var i = 0; i < labelsCount; i++) {
                if (!sf.util.isNullOrUndefined(axis.visibleLabels[i].Text)) {
                    var x1 = 0, y1 = 0, x2 = 0, y2 = 0; var pointX; var previousVisblelabel;
                    axis.visibleLabels[i].originalText = axis.visibleLabels[i].Text;
                    var textAnchor;

                    var textSize = sf.EjSvgRender.utils._measureText(axis.visibleLabels[i].Text, this.model.m_AreaBounds.Width, axis.font);
                    var value = (axis.visibleLabels[i].Value - axis.visibleRange.min) / (axis.visibleRange.delta);
                    value = (axis.isInversed) ? 1 - value : value;
                    value = isNaN(value) ? 0 : value;

                    if (axis.orientation.toLowerCase() == "horizontal") {
                        x2 = x1 = (Math.round(axis.width * value)) + this.model.m_AreaBounds.X + ((axis.plotOffset));
                        y1 = (opposedPosition) ? (y - this.model.wallSize - (axis.majorTickLines.size) - (this.model.elementSpacing / 2)) : y + this.model.wallSize + (axis.majorTickLines.size) + this.model.elementSpacing;
                        textAnchor = "middle"
                    }
                    else {
                        y1 = y2 = Math.round(axis.plotOffset + axis.y + (textSize.height / 4) + (axis.height * (1 - value)));
                        x1 = (opposedPosition) ? (axis.x + axis.majorTickLines.size + axis.axisLine.width + this.model.elementSpacing / 2) : (x - this.model.wallSize - axis.majorTickLines.size - this.model.elementSpacing / 2);
                        textAnchor = (opposedPosition) ? "start" : "end"
                    }
                    labels.push({ x: x1, y: y1, size: textSize })
                    var maxWidth = axis.width / axis.visibleLabels.length - 5;
                    var label = labels[i];
                    if (((label.x - label.size.width / 2 < axis.x && i === 0) || (label.x + label.size.width / 2 > axis.x + axis.width && i === axis.visibleLabels.length - 1)) && axis.labelIntersectAction != 'trim' && axis.labelIntersectAction.indexOf('wrap') < 0) {
                        if (axis.edgeLabelPlacement === 'hide') {
                            continue;
                        } else if (axis.edgeLabelPlacement === 'shift') {
                            if (i == 0) {
                                label.x = x1 = axis.x + label.size.width / 2;
                            } else if (i == axis.visibleLabels.length - 1) {
                                label.x = x1 = axis.x + axis.width - label.size.width / 2;
                            }

                        }
                    }

                    //angle rotation and label intersect actions for 3d-chart
                    if (axis.orientation.toLowerCase() == 'horizontal') {
                        if (axis.labelRotation) {
                            angleValue = axis.labelRotation;
                            var rotatedSize = sf.EjSvgRender.utils.rotatedLabel(axis, this, axis.labelRotation, axis.visibleLabels[i].Text, true);
                            y1 += rotatedSize.height / 2;
                        } else {
                            if (axis.labelIntersectAction == 'trim') {
                                axis.visibleLabels[i].Text = this._textTrim(maxWidth, axis.visibleLabels[i].Text, axis.font);
                            } else if (axis.labelIntersectAction == 'wrapByWord') {
                                axis.visibleLabels[i].Text = this._textWrap(maxWidth, axis.visibleLabels[i].Text, axis.font);
                            } else if (axis.labelIntersectAction == 'wrap') {
                                axis.visibleLabels[i].Text = this._textWrapByLength(maxWidth, axis.visibleLabels[i].Text, axis.font);
                            } else if (axis.labelIntersectAction == 'rotate45' || axis.labelIntersectAction == 'rotate90') {
                                angleValue = axis.labelIntersectAction.indexOf('45') > -1 ? 45 : 90;
                                var rotatedSize = sf.EjSvgRender.utils.rotatedLabel(axis, this, angleValue, axis.visibleLabels[i].Text, true);
                                y1 += rotatedSize.height / 2;
                            } else if (axis.labelIntersectAction === 'multipleRows') {
                                pointX = label.x
                                pointX -= textSize.width / 2;
                                this._multipleRows(i, pointX, axis.visibleLabels[i], axis);
                                y1 = axis.visibleLabels[i].index ? y1 + axis.visibleLabels[i].index * (textSize.height + 5) : y1;
                            } else if (axis.labelIntersectAction === 'hide') {
                                previousVisblelabel = previousVisblelabel ? previousVisblelabel : 0;
                                if (i != 0) {
                                    if (labels[previousVisblelabel].x + labels[previousVisblelabel].size.width / 2 >= labels[i].x - labels[i].size.width / 2) {
                                        continue;
                                    }
                                }
                                previousVisblelabel = i;
                            }
                        }
                    }

                    element = { Width: textSize.width, Height: textSize.height, Label: axis.visibleLabels[i], TextAnchor: textAnchor, tag: 'text', font: axis.font, id: this.svgObject.id + axis.orientation + i, child: this.chart3D, Angle: angleValue };

                    this.graphics.addVisual(this.polygon.createTextElement(this.vector.vector3D(x1, y1, 0), element, 10, 10));
                }
            }

        },

        _renderTicks3D: function (axis, size, width, params) {
            var labelsCount = axis.visibleLabels.length,
                parent, minorTicks, 
                gEle,
                m_AreaBounds = this.model.m_AreaBounds,
                y = axis.y;

            for (var i = 0; i < labelsCount; i++) {
                var x1 = 0, x2 = 0, y1 = 0, y2 = 0;


                var value = (axis.visibleLabels[i].Value - axis.visibleRange.min) / (axis.visibleRange.delta);
                value = (axis.isInversed) ? 1 - value : value;
                value = isNaN(value) ? 0 : value;

                if (axis.orientation.toLowerCase() == "horizontal") {
                    x2 = x1 = (Math.round(axis.width * value)) + m_AreaBounds.X + ((axis.plotOffset));
                }
                else {
                    y1 = y2 = Math.round(axis.plotOffset + ((axis.height) * (1 - value)) + axis.y);
                }

                var position = this._calculatePosition3D(axis, axis.tickLinesPosition, size, width, x1, y1, x2, y2, params);


                var line = { width: axis.majorTickLines.width, stroke: axis.majorTickLines.color, child: this.chart3D, tag: 'line' };

                line.id = this.svgObject.id + axis.name + "_majorTickLines_" + i;

                this.graphics.addVisual(this.polygon.createLine(line, position.X1, position.Y1, position.X2, position.Y2, 0));

                if (axis.minorGridLines.visible && axis.minorTicksPerInterval > 0 && i < labelsCount - 1) {
                    minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);
                    for (var k = 0; k < axis.minorTicksPerInterval; k++) {
                        value = sf.EjSvgRender.utils._valueToCoefficient(axis, axis.visibleLabels[i].Value + (minorTicks * (k + 1)));

                        value = isNaN(value) ? 0 : value;

                        if (axis.orientation.toLowerCase() == "horizontal") {
                            x1 = x2 = Math.round(axis.plotOffset + (m_AreaBounds.Width * value) + m_AreaBounds.X);
                        }
                        else {
                            y1 = y2 = Math.round(axis.plotOffset + ((m_AreaBounds.Height) * (1 - value))) + axis.y;
                        }

                        var position = this._calculatePosition3D(axis, axis.tickLinesPosition, size, width, x1, y1, x2, y2, params);


                        var line = { width: axis.minorTickLines.width, stroke: axis.minorTickLines.color, child: this.chart3D, tag: 'line' };

                        line.id = this.svgObject.id + axis.name + "_minorTickLines_" + i + k;

                        this.graphics.addVisual(this.polygon.createLine(line, position.X1, position.Y1, position.X2, position.Y2, 0));
                    }
                }
            }
        },

        _calculatePosition3D: function (axis, ticksPosition, tickSize, width, x1, y1, x2, y2, params) {
            var orientation = axis.orientation;
            var isOpposed = axis._opposed,
                ticksPosition = "outside",
                areaBounds = this.model.m_AreaBounds,
                validCross = params.axes[axis.name]._validCross,
                y = validCross ? axis.y : areaBounds.Y + (!isOpposed && areaBounds.Height),
                x = validCross ? axis.x : areaBounds.X + (isOpposed && areaBounds.Width);
            if (axis.orientation.toLowerCase() == "horizontal") {
                switch (ticksPosition) {
                    case "inside":
                        y1 = isOpposed ? width : 0;
                        y2 = isOpposed ? y1 + tickSize : tickSize;
                        break;
                    case "outside":
                        y1 = 0;
                        y2 = isOpposed ? tickSize : y1 + tickSize;
                        break;
                }
                var screenPositionTop = ((isOpposed) ? y - this.model.wallSize - (tickSize) : y + this.model.wallSize - (tickSize / 2));
                var screenPositionLeft = axis.x;
                y1 += screenPositionTop;
                y2 += screenPositionTop;

                x1 = x2 = x1;
            }
            else {
                switch (ticksPosition) {
                    case "inside":
                        x1 = 0;
                        x2 = isOpposed ? tickSize : x1 + tickSize;
                        break;
                    case "outside":
                        x1 = 0;
                        x2 = isOpposed ? x1 + tickSize : tickSize;
                        break;
                }
                var screenPositionLeft = (isOpposed) ? x + this.model.wallSize : (x - this.model.wallSize - tickSize);
                var screenPositionTop = this.model.m_AreaBounds.Y;
                x1 += screenPositionLeft;
                x2 += screenPositionLeft;

                y1 = y2 = y1;
            }
            return { X1: x1, Y1: y1, X2: x2, Y2: y2 };
        },



        _drawGridLines3D: function (axis, params) {
            if (axis == null)
                return;

            var labelsCount = axis.visibleLabels.length,
                minorTicks, opposedPosition = axis._opposed,
                orientation = axis.orientation, validCross = params.axes[axis.name]._validCross,
                x1, x2, y1, y2, index;
            if (orientation.toLowerCase() == "horizontal") {

                var i;
                for (i = 0; i < labelsCount; i++) {
                    var value = sf.EjSvgRender.utils._valueToCoefficient(axis, axis.visibleLabels[i].Value);
                    value = isNaN(value) ? 0 : value;
                    x2 = x1 = (Math.round(axis.width * value)) + this.model.m_AreaBounds.X + axis.plotOffset;
                    y1 = this.model.m_AreaBounds.Y;
                    y2 = this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height;


                    var depth = this.model.depth > 2 ? this.model.depth - 2 : 1;
                    var bottom = validCross ? axis.y : this.model.m_AreaBounds.Y + (!opposedPosition && this.model.m_AreaBounds.Height);

                    var line = { opacity: axis.majorGridLines.opacity, width: axis.majorGridLines.width, stroke: axis.majorGridLines.color, child: this.chart3D, tag: 'line' };
                    line.id = this.svgObject.id + axis.name + "_gridlines_" + i;
                    this.graphics.addVisual(this.polygon.createLine(line, x1, y1, x2, y2, depth));
                    var parallelLine = $.extend({}, line);
                    parallelLine.id = this.svgObject.id + axis.name + "_parallelGridlines_" + i;

                    var line3D = this.polygon.createLine(parallelLine, x2, 0, x2, -depth, bottom);
                    //To fold the gridline alone the wall(bottom)
                    this.polygon.transform(this.matrixobj.tilt((parseFloat)(Math.PI / 2)), line3D);

                    this.graphics.addVisual(line3D);

                    if (axis.minorGridLines.visible && axis.minorTicksPerInterval > 0 && i < labelsCount - 1) {
                        minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);
                        for (var k = 0; k < axis.minorTicksPerInterval; k++) {
                            value = sf.EjSvgRender.utils._valueToCoefficient(axis, axis.visibleLabels[i].Value + (minorTicks * (k + 1)));
                            value = isNaN(value) ? 0 : value;
                            x2 = x1 = (Math.round(this.model.m_AreaBounds.Width * value) + this.model.m_AreaBounds.X);
                            y1 = this.model.m_AreaBounds.Y;
                            y2 = this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height;

                            var line = { opacity: axis.minorGridLines.opacity, width: axis.minorGridLines.width, stroke: axis.minorGridLines.color, child: this.chart3D, tag: 'line' };
                            line.id = this.svgObject.id + axis.name + "_minorgridlines_" + i + k;
                            this.graphics.addVisual(this.polygon.createLine(line, x1, y1, x2, y2, depth));
                            var parallelLine = $.extend({}, line);
                            parallelLine.id = this.svgObject.id + axis.name + "_parallelMinorGridlines_" + i + k;

                            var line3D = this.polygon.createLine(parallelLine, x2, 0, x2, -depth, bottom);
                            //To fold the gridline alone the wall(bottom)
                            this.polygon.transform(this.matrixobj.tilt((parseFloat)(Math.PI / 2)), line3D);

                            this.graphics.addVisual(line3D);
                        }
                    }

                    index++;
                }
            }
            else {
                var i;


                for (i = 0; i < labelsCount; i++) {
                    //if (i < linesCount)
                    //{
                    var line;
                    var value = (axis.visibleLabels[i].Value - axis.visibleRange.min) / (axis.visibleRange.delta);
                    value = (axis.isInversed) ? 1 - value : value;
                    value = isNaN(value) ? 0 : value;
                    x1 = this.model.m_AreaBounds.X;
                    y1 = Math.round((axis.height) * (1 - value)) + 0.5;
                    y1 += axis.y;
                    x2 = x1 + this.model.m_AreaBounds.Width;
                    y2 = y1;

                    var depth = this.model.depth > 2 ? this.model.depth - 2 : 1;

                    var line = { opacity: axis.majorGridLines.opacity, width: axis.majorGridLines.width, stroke: axis.majorGridLines.color, axisName: axis.name, child: this.chart3D, tag: 'line' };

                    line.id = this.svgObject.id + axis.name + "_gridlines_" + i;

                    this.graphics.addVisual(this.polygon.createLine(line, x1, y1, x2, y2, depth));

                    var depthD = validCross ? axis.x : this.model.m_AreaBounds.X + (opposedPosition && this.model.m_AreaBounds.Width + 1);

                    var sideLine = $.extend({}, line);
                    sideLine.id = this.svgObject.id + axis.name + "_parallelGridlines_" + i;

                    var line3D = this.polygon.createLine(sideLine, -depth, y2, 0, y2, depthD);
                    //To fold the gridline alone the wall(right of vertical)
                    this.polygon.transform(this.matrixobj.turn((parseFloat)(-Math.PI / 2)), line3D);
                    this.graphics.addVisual(line3D);

                    if (axis.minorGridLines.visible && axis.minorTicksPerInterval > 0 && i < labelsCount - 1) {
                        minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);
                        for (var k = 0; k < axis.minorTicksPerInterval; k++) {
                            var value = sf.EjSvgRender.utils._valueToCoefficient(axis, axis.visibleLabels[i].Value + (minorTicks * (k + 1)));
                            value = isNaN(value) ? 0 : value;
                            x1 = this.model.m_AreaBounds.X;
                            y1 = Math.round((axis.height) * (1 - value)) + 0.5;
                            y1 += axis.y;
                            x2 = x1 + this.model.m_AreaBounds.Width;
                            y2 = y1;
                            var line = { opacity: axis.minorGridLines.opacity, width: axis.minorGridLines.width, stroke: axis.minorGridLines.color, axisName: axis.name, child: this.chart3D, tag: 'line' };

                            line.id = this.svgObject.id + axis.name + "_minorgridlines_" + i + k;

                            this.graphics.addVisual(this.polygon.createLine(line, x1, y1, x2, y2, depth));

                            var sideLine = $.extend({}, line);
                            sideLine.id = this.svgObject.id + axis.name + "_parallelMinorGridlines_" + i + k;

                            var line3D = this.polygon.createLine(sideLine, -depth, y2, 0, y2, depthD);
                            //To fold the gridline alone the wall(right of vertical)
                            this.polygon.transform(this.matrixobj.turn((parseFloat)(-Math.PI / 2)), line3D);
                            this.graphics.addVisual(line3D);
                        }
                    }

                    ////}
                    index++;
                }

            }
        }

    },



        sf.Ej3DSeriesRender.prototype = {
            _getSegmentDepth: function (series) {
                var actualDepth = this.chartObj.model.depth;
                var start, end;

                if (this.chartObj.model._sideBySideSeriesPlacement) {
                    var space = actualDepth / 4;
                    start = space;
                    end = space * 3;
                }
                else {
                    var index = series.position - 1;
                    var count = series.all;
                    var space = actualDepth / ((count * 2) + count + 1);
                    start = space + (space * index * 3);
                    end = start + space * 2;
                }
                return { Start: start, End: end, Delta: end - start };
            },

            createSegment: function (center, start, end, height, r, i, y, insideRadius, pointindex) {
				var segment;
                return {
                    StartValue: start,
                    EndValue: end,
                    depth: height,
                    radius: r,
                    index: i,
                    YData: y,
                    Center: center,
                    inSideRadius: insideRadius,
                    ActualEndValue: end,
                    ActualStartValue: start,
                    pointIndex: pointindex
                }

                return segment;

            },

            calculateSize: function (sender, series) {
                var legend = sender.chartObj.model.legend;

                var legXSpace = 0;
                var legYSpace = 0,
                    title = sender.chartObj.model.title,
                    subTitle = sender.chartObj.model.title.subTitle,
                    titleLocation = sender.chartObj.model._titleLocation,
                    subTitleLocation = sender.chartObj.model._subTitleLocation,
                    titleTextOverflow = sender.chartObj.model.title.textOverflow,
                    subTitleTextOverflow = sender.chartObj.model.title.subTitle.textOverflow,
                    titleEnable = (title.text && title.visible && title.enableTrim && (titleTextOverflow == 'wrap' || titleTextOverflow == 'wrapandtrim')) ? true : false,
                    subTitleEnable = (subTitle.text && subTitle.visible && subTitle.enableTrim && (subTitleTextOverflow == 'wrap' || subTitleTextOverflow == 'wrapandtrim')) ? true : false;
                if (legend.visible && legend.position.toLowerCase() != "custom") {
                    if (legend.position.toLowerCase() == "right" || legend.position.toLowerCase() == "left")
                        legXSpace = ((legend.position.toLowerCase() == "right") ? sender.chartObj.model.margin.right : sender.chartObj.model.margin.left) + sender.chartObj.model.LegendViewerBounds.Width;
                    else
                        legYSpace = ((legend.position.toLowerCase() == "top") ? sender.chartObj.model.margin.top : sender.chartObj.model.margin.bottom) + sender.chartObj.model.LegendViewerBounds.Height;

                }
                series.actualWidth = $(sender.chartObj.svgObject).width() - legXSpace;
                var centerx = series.actualWidth * 0.5 + ((legend.position.toLowerCase() === "left") ? legXSpace : 0);
                if (titleEnable || subTitleEnable) {
                    var yOffset = titleLocation.size.height + (subTitleEnable ? subTitleLocation.size.height : 0) + legYSpace;
                    series.actualHeight = $(sender.chartObj.svgObject).height() - yOffset;
                    var centery = series.actualHeight * 0.5 + ((legend.position.toLowerCase() === "top") ? yOffset : titleLocation.size.height + (subTitleEnable ? subTitleLocation.size.height : 0));
                }
                else {
                    var yOffset = ((title.text && title.visible) ? titleLocation.Y : 0) + legYSpace;
                    series.actualHeight = $(sender.chartObj.svgObject).height() - yOffset;
                    var centery = series.actualHeight * 0.5 + ((legend.position.toLowerCase() === "top") ? yOffset : ((title.text && title.visible) ? (titleLocation.Y) : 0));
                }
                return { centerX: centerx, centerY: centery };
            },

            createPoints: function (series, sender) {
                series.segments = [];
                var size = this.calculateSize(sender, series),
                    all = 0,
                    visiblepoints = this._calculateVisiblePoints(series).visiblePoints,
                    count = series._visiblePoints.length;
                for (var j = 0; j < count; j++)
                    all += visiblepoints[j].YValues[0];
				all = all !=0 ? all : 1;
                var coef = 360 / all,
                    seriesIndex = $.inArray(series, sender.chartObj.model._visibleSeries),
                    seriesLength = this.chartObj.model._visibleSeries.length,
                    InsideRadius = sender.chartObj.model.innerRadius[seriesIndex],
                    YValues = sender.chartObj._getYValues(series._visiblePoints),
                    pieHeight = sender.chartObj.model.depth, center,
                    arcStartAngle = 0, arcEndAngle = 0,
                    current = 0, pointindex, val, rect, offset, segment,
                    segindex = 0,
                    radius = sender.chartObj.model.circularRadius[seriesIndex];

                for (var i = 0; i < count; i++) {
                    if (series._visiblePoints[i].visible || series._visiblePoints[i].gapMode) {
                        pointindex = $.inArray(series._visiblePoints[i], series._visiblePoints);
                        val = Math.abs(YValues[i]);
                        arcEndAngle = Math.abs(val) * ((Math.PI * 2) / all);
                        rect = {};
                        rect.x = 0;
                        rect.y = 0;

                        if (!sf.util.isNullOrUndefined(val)) {
                            if (series.explodeIndex == series._visiblePoints[i].actualIndex || series.explodeAll) {
                                offset = { X: 0, Y: 0 };
                                offset.X = Math.cos(2 * Math.PI * (current + val / 2) / all),
                                    offset.Y = Math.sin(2 * Math.PI * (current + val / 2) / all);
                                rect.x = 0.01 * radius * offset.X * series.explodeOffset;
                                rect.y = 0.01 * radius * offset.Y * series.explodeOffset;
                            }

                            center = sender.chartObj.vector.vector3D(rect.x + size.centerX, rect.y + size.centerY, 0);
                            {
                                segment = this.createSegment(center, (parseFloat)(coef * current), (parseFloat)(coef * val), pieHeight, radius, i, val, InsideRadius, pointindex, series);
                                if (series._visiblePoints[i].gapMode)
                                    segment.visible = false;
                                else
                                    segment.visible = true;
                                series.segments.push(segment);
                            }
                        }

                        if (series.marker.dataLabel.visible)
                            this._addPieDataLabel(segindex, YValues[i], arcStartAngle, arcStartAngle + arcEndAngle, i, radius, this._isChartRotated(sender) ? sender.chartObj.model.depth + 5 : 0, center, series._visiblePoints[i]);

                        segindex++;
                        arcStartAngle += arcEndAngle;
                        current += val;

                    }
                }
                return series.segments;
            },

            _addPieDataLabel: function (x, y, startAngle, endAngle, i, radius, startDepth, center, point) {
                var angle = (startAngle + endAngle) / 2;
                point.symbolLocation = { x: 0, y: 0, radius: 0, angle: 0, StartDepth: 0 };
                point.symbolLocation.x = x;
                point.symbolLocation.y = y;
                point.symbolLocation.radius = radius;
                point.symbolLocation.angle = angle;
                point.symbolLocation.center = center;
                point.startDepth = startDepth;
            },

            _isChartRotated: function (sender) {
                var actualTiltView = Math.abs(sender.chartObj.model.tilt % 360);
                var actualRotateView = Math.abs(sender.chartObj.model.rotattion % 360);
                if ((actualTiltView > 90 && actualTiltView < 270) ^ (actualRotateView > 90 && actualRotateView < 270)) {
                    return true;
                }
                return false;
            },

            createSector: function (seg, sender, style, seriesIndex) {
                var count = (parseInt)(Math.ceil(seg.ActualEndValue / 6));
                var DtoR = Math.PI / 180;
                var inc = 0;
                var Points = [];
                var depth = sender.chartObj.model.depth;
                if (count < 1) return null;
                var res = [];
                var f = seg.ActualEndValue / count;

                var oPts = [];
                var iPts = [];

                for (var i = 0; i < count + 1; i++) {
                    var ox = (parseFloat)(seg.Center.x + seg.radius * Math.cos((seg.ActualStartValue + i * f) * DtoR));
                    var oy = (parseFloat)(seg.Center.y + seg.radius * Math.sin((seg.ActualStartValue + i * f) * DtoR));

                    oPts[i] = { X: ox, Y: oy };

                    var ix = (parseFloat)(seg.Center.x + seg.inSideRadius * Math.cos((seg.ActualStartValue + i * f) * DtoR));
                    var iy = (parseFloat)(seg.Center.y + seg.inSideRadius * Math.sin((seg.ActualStartValue + i * f) * DtoR));

                    iPts[i] = { X: ix, Y: iy };
                    Points.push({ X: ox, Y: oy });
                }

                var oPlgs = [], vts;

                for (var i = 0; i < count; i++) {
                    vts = new Array(sender.chartObj.vector.vector3D(oPts[i].X, oPts[i].Y, 0),
                        sender.chartObj.vector.vector3D(oPts[i].X, oPts[i].Y, depth),
                        sender.chartObj.vector.vector3D(oPts[i + 1].X, oPts[i + 1].Y, depth),
                        sender.chartObj.vector.vector3D(oPts[i + 1].X, oPts[i + 1].Y, 0))


                    oPlgs[i] = sender.chartObj.polygon.polygon3D(vts, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D);
                    inc++;
                }

                res[1] = oPlgs;

                if (seg.inSideRadius > 0) {
                    var iPlgs = [];

                    for (var i = 0; i < count; i++) {
                        vts = new Array(sender.chartObj.vector.vector3D(iPts[i].X, iPts[i].Y, 0),
                            sender.chartObj.vector.vector3D(iPts[i].X, iPts[i].Y, depth),
                            sender.chartObj.vector.vector3D(iPts[i + 1].X, iPts[i + 1].Y, depth),
                            sender.chartObj.vector.vector3D(iPts[i + 1].X, iPts[i + 1].Y, 0))


                        iPlgs[i] = sender.chartObj.polygon.polygon3D(vts, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D);
                        inc++;
                    }

                    res[3] = iPlgs;
                }

                var tVtxs = [];
                var bVtxs = [];

                for (var i = 0; i < count + 1; i++) {
                    tVtxs.push(sender.chartObj.vector.vector3D(oPts[i].X, oPts[i].Y, 0));
                    bVtxs.push(sender.chartObj.vector.vector3D(oPts[i].X, oPts[i].Y, depth));
                }

                if (seg.inSideRadius > 0) {
                    for (var i = count; i > -1; i--) {
                        tVtxs.push(sender.chartObj.vector.vector3D(iPts[i].X, iPts[i].Y, 0));
                        bVtxs.push(sender.chartObj.vector.vector3D(iPts[i].X, iPts[i].Y, depth));
                    }
                }
                else {
                    tVtxs.push(seg.Center);
                    bVtxs.push(sender.chartObj.vector.vector3D(seg.Center.x, seg.Center.y, depth));
                }
                res[0] = [];
                res[0].push(sender.chartObj.polygon.polygon3D(tVtxs, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D));
                inc++;
                res[0].push(sender.chartObj.polygon.polygon3D(bVtxs, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D));
                inc++;



                if (seg.inSideRadius > 0) {
                    var rvts = new Array(

                        sender.chartObj.vector.vector3D(oPts[0].X, oPts[0].Y, 0),
                        sender.chartObj.vector.vector3D(oPts[0].X, oPts[0].Y, depth),
                        sender.chartObj.vector.vector3D(iPts[0].X, iPts[0].Y, depth),
                        sender.chartObj.vector.vector3D(iPts[0].X, iPts[0].Y, 0)
                    )

                    var lvts = new Array
                        (
                        sender.chartObj.vector.vector3D(oPts[count].X, oPts[count].Y, 0),
                        sender.chartObj.vector.vector3D(oPts[count].X, oPts[count].Y, depth),
                        sender.chartObj.vector.vector3D(iPts[count].X, iPts[count].Y, depth),
                        sender.chartObj.vector.vector3D(iPts[count].X, iPts[count].Y, 0)
                        )
                    res[2] = [];

                    res[2].push(sender.chartObj.polygon.polygon3D(rvts, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D));
                    inc++;
                    res[2].push(sender.chartObj.polygon.polygon3D(lvts, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D));
                    inc++;

                }
                else {
                    var rvts = new Array(
                        sender.chartObj.vector.vector3D(oPts[0].X, oPts[0].Y, 0),
                        sender.chartObj.vector.vector3D(oPts[0].X, oPts[0].Y, depth),
                        sender.chartObj.vector.vector3D(seg.Center.x, seg.Center.y, depth),
                        sender.chartObj.vector.vector3D(seg.Center.x, seg.Center.y, 0)
                    )

                    var lvts = new Array(
                        sender.chartObj.vector.vector3D(oPts[count].X, oPts[count].Y, 0),
                        sender.chartObj.vector.vector3D(oPts[count].X, oPts[count].Y, depth),
                        sender.chartObj.vector.vector3D(seg.Center.x, seg.Center.y, depth),
                        sender.chartObj.vector.vector3D(seg.Center.x, seg.Center.y, 0)
                    )
                    res[2] = [];
                    res[2].push(sender.chartObj.polygon.polygon3D(rvts, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D));
                    inc++;
                    res[2].push(sender.chartObj.polygon.polygon3D(lvts, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D));
                    inc++;


                }


                return res;
            },

            createPolygons: function (series, sender, returnPoly) {
                var segments, poligons = [], seg, style,
                    pointindex, segmentsLength, plgs,
                    seriesIndex = $.inArray(series, sender.chartObj.model._visibleSeries);
                if (!series.segments || !returnPoly)
                    segments = this.createPoints(series, sender);
                else
                    segments = series.segments;
                segmentsLength = segments.length;
                for (var i = 0; i < segmentsLength; i++) {
                    seg = segments[i];
                    if (seg.visible) {
                        pointindex = segments[i].pointIndex;
                        style = sender.chartObj.setStyle(sender, series, seriesIndex, pointindex);
                        if (typeof (sender.chartObj.model.pointColors[pointindex]) == "object")
                            style.interior = sender.chartObj.model.pointColors[pointindex][0].color;
                        plgs = this.createSector(seg, sender, style, seriesIndex);
                        if (plgs != null)
                            for (var ai = 0; ai < plgs.length; ai++) {
                                if (!poligons[ai])
                                    poligons[ai] = [];
                                if (plgs[ai] != null) {
                                    for (var pi = 0; pi < plgs[ai].length; pi++) {
                                        poligons[ai].push(plgs[ai][pi]);

                                    }
                                }
                            }
                    }


                }
                if (returnPoly) {
                    return poligons;
                }

                for (var ai = 0; ai < poligons.length; ai++) {
                    for (var k = 0; k < poligons[ai].length; k++) {
                        sender.chartObj.graphics.addVisual(poligons[ai][k]);
                    }
                }
            },

            draw3DDataLabel: function (series, pointIndex, point, sender) {

                var connectorHeight = series.marker.dataLabel.connectorLine.height;
                var tag, radius, pointX, pointY, labelPrecision;
                var xOffset = 0; var yOffset = 0;
                if (typeof (series.marker.dataLabel.offset) === 'number') {
                    yOffset = series.marker.dataLabel.offset;
                } else {
                    xOffset = series.marker.dataLabel.offset.x;
                    yOffset = series.marker.dataLabel.offset.y;
                }
                if (this.chartObj.model.AreaType == "none") {
                    location = { x: 0, y: 0 };
                    var pointText = (point.text) ? point.text : point.y;
                    var seriesIndex = $.inArray(series, this.chartObj.model.series);
                    if (series.type.toLowerCase() == "doughnut" || series.type.toLowerCase() == "pie") {

                        var width = Math.min(series.actualWidth, series.actualHeight) / 2;
                        var center = point.symbolLocation.center;
                        var xOffset = series.marker.dataLabel.offset.x;
                        var yOffset = series.marker.dataLabel.offset.y;
                        var dradius = point.symbolLocation.radius * series._coefficient;
                        if (sf.util.isNullOrUndefined(connectorHeight))
                            connectorHeight = sf.EjSvgRender.utils._measureText(pointText, null, series.marker.dataLabel.font).height;
                        if (series != null && series.labelPosition != "inside")
                            radius = point.symbolLocation.radius + connectorHeight;
                        else if (series != null)
                            radius = dradius + (point.symbolLocation.radius - dradius) / 2;
                        pointX = location.X = center.x + radius * Math.cos(point.symbolLocation.angle) + xOffset;
                        pointY = location.Y = center.y + radius * Math.sin(point.symbolLocation.angle) + yOffset;

                        var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                        commonEventArgs.data = { text: pointText, location: { x: pointX, y: pointY }, series: series, pointIndex: pointIndex, seriesIndex: seriesIndex };
                        this.chartObj._trigger("displayTextRendering", commonEventArgs);
                        commonEventArgs.data.Text = commonEventArgs.data.text;
                        var size = sf.EjSvgRender.utils._measureText(commonEventArgs.data.Text, null, series.marker.dataLabel.font);
                        pointX = location.X = commonEventArgs.data.location.x;
                        pointY = location.Y = commonEventArgs.data.location.y;
                    }
                }
                else {
                    var labelFormat = series.yAxis.labelFormat ? series.yAxis.labelFormat : "";
                    var seriesIndex = $.inArray(series, this.chartObj.model.series);
                    var labelPrecisionDefault = 6, labelPrecisionHighest = 20;
                    var pointText = (point.text) ? point.text : point.y ;
                    if (labelFormat) {
                    if (labelFormat.indexOf("{value}") > -1)
                         pointText = labelFormat.replace("{value}", point.y);
                    else if (labelFormat.indexOf('e') == 0 || labelFormat.indexOf('E') == 0) {
                    labelPrecision = labelFormat.match(/(\d+)/g);
                    labelPrecision = labelPrecision == null ? labelPrecisionDefault : labelPrecision > labelPrecisionHighest ? labelPrecisionHighest : labelPrecision;
                    pointText = point.y.toExponential(labelPrecision);
                    }
                    else pointText = sf.globalize.format(point.y, labelFormat, this.chartObj.model.locale);
                    }
                    var pointHeight = 0;
                    var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                    var size = sf.EjSvgRender.utils._measureText(pointText, null, series.marker.dataLabel.font);
                    var location = sf.EjSvgRender.utils.Transform3DToVisible(series, point.symbolLocation.x, point.symbolLocation.y, this.chartObj);
                    var connectorHeight = (series.marker.dataLabel.connectorLine.height) ? series.marker.dataLabel.connectorLine.height : 0;
                    var angle = (6.28 * (1 - (90 / 360.0)));
                    var pointY = location.Y;
                    var pointX = location.X;
                    if (!this.chartObj.model.requireInvertedAxes) {
                        if (point.y > 0)
                            pointY = location.Y + (Math.sin((angle)) * connectorHeight);
                        else
                            pointY = location.Y + (Math.sin((-angle)) * connectorHeight);
                    }
                    else {
                        if (point.x > 0)
                            pointX = location.X - (Math.sin((angle)) * connectorHeight);
                        else
                            pointX = location.X + (Math.sin((angle)) * connectorHeight);
                        pointHeight = - size.height / 3;
                    }
                    if (series.marker.dataLabel.textPosition == 'bottom')
                        pointY = location.Y + yOffset;
                    else
                        pointY = location.Y - yOffset;
                    pointX = location.X + xOffset;
                    commonEventArgs.data = { text: pointText, location: { x: pointX, y: pointY }, series: series, pointIndex: pointIndex };
                    commonEventArgs.data.Text = commonEventArgs.data.text;
                    this.chartObj._trigger("displayTextRendering", commonEventArgs);
                    pointX = commonEventArgs.data.location.x;
                    pointY = commonEventArgs.data.location.y;
                }



                var depthInfo = this._getSegmentDepth(series);



                if (series.marker.dataLabel.shape.toLowerCase() != "none" && !point.marker.dataLabel.template && commonEventArgs.data.Text != '') {

                    var element = { tag: 'dataLabel', series: series, point: point, pointIndex: pointIndex, id: this.chartObj.svgObject.id + seriesIndex + '_DataLabel' + pointIndex, child: this.chartObj.chart3D };

                    this.chartObj.graphics.addVisual(this.chartObj.polygon.createTextElement(this.chartObj.vector.vector3D(pointX, pointY, (point.symbolLocation.z) ? point.symbolLocation.z : 0), element, 0, -size.height));
                }

                tag = (!point.marker.dataLabel.template) ? "text" : "template";

                var element = { Width: size.width, Height: size.height, Label: commonEventArgs.data, TextAnchor: "middle", tag: tag, font: series.marker.dataLabel.font, Angle: series.marker.dataLabel.angle, id: this.chartObj.svgObject.id + '_SeriesText' + pointIndex + seriesIndex, child: this.chartObj.chart3D };


                if (this.chartObj.model.AreaType != "none") {
                    if (series.marker.dataLabel.connectorLine.height && series.marker.dataLabel.connectorLine.height > 0) {
                        var drawPoints = [];
                        drawPoints.push({ x: location.X, y: location.Y + pointHeight, z: point.symbolLocation.z });

                        drawPoints.push({ x: pointX, y: pointY + pointHeight, z: point.symbolLocation.z });
                        this.drawLineSegment(drawPoints, pointIndex, series);
                    }
                    this.chartObj.graphics.addVisual(this.chartObj.polygon.createTextElement(this.chartObj.vector.vector3D(pointX, pointY, point.symbolLocation.z), element, 0, -size.height));
                }
                else {
                    if (series.labelPosition.toLowerCase() != "inside")
                        this.updateConnectorLine(point, pointIndex, series, location, connectorHeight)
                    var finalSize = { x: series.actualWidth, y: series.actualHeight };
                    this.chartObj.graphics.addVisual(this.chartObj.polygon.createTextElement(this.chartObj.vector.vector3D(location.X, location.Y, -1), element, 0, -size.height));
                }
            },
            updateConnectorLine: function (point, pointIndex, series, location, connectorHeight) {
                var drawPoints = [];
                var symbolLocation = point.symbolLocation;
                var x = symbolLocation.center.x + Math.cos(symbolLocation.angle) * symbolLocation.radius;
                var y = symbolLocation.center.y + Math.sin(symbolLocation.angle) * symbolLocation.radius;
                drawPoints.push({ x: x, y: y });
                var labelRadiusFromOrigin = symbolLocation.radius + connectorHeight;
                x = symbolLocation.center.x + (Math.cos((symbolLocation.angle)) * (labelRadiusFromOrigin));
                y = symbolLocation.center.y + (Math.sin((symbolLocation.angle)) * (labelRadiusFromOrigin));

                drawPoints.push({ x: x, y: y });
                //var hipen = height / 5;
                //x += (x > symbolLocation.center.x) ? hipen : -hipen;
                //drawPoints.push({ x: x, y: y });
                if (series.marker.dataLabel.connectorLine.type == "bezier")
                    drawPoints = this.getBezierApproximation(drawPoints, 256, series);
                this.drawLineSegment(drawPoints, pointIndex, series)
            },
            /// <returns></returns>
            getBezierApproximation: function (controlPoints, outputSegmentCount, series) {
                var points = [];
                for (var i = 0; i <= outputSegmentCount; i++) {
                    var t = i / outputSegmentCount;
                    points.push(this.GetBezierPoint(t, controlPoints, 0, controlPoints.length, series));
                }
                return points;
            },
            drawLineSegment: function (drawpoints, pointIndex, series) {
                var vectorPoints = [];
                for (var i = 0; i < drawpoints.length; i++) {
                    vectorPoints.push(this.chartObj.vector.vector3D(drawpoints[i].x, drawpoints[i].y, drawpoints[i].z ? drawpoints[i].z : 0));
                }
                var seriesIndex = $.inArray(series, this.chartObj.model._visibleSeries);
                var color = (this.chartObj.model.AreaType == "none") ? this.chartObj.model.pointColors[pointIndex] : this.chartObj.model.seriesColors[seriesIndex];
                var stroke = (series.marker.dataLabel.connectorLine.stroke) ? series.marker.dataLabel.connectorLine.stroke : color;
                var line = { width: series.marker.dataLabel.connectorLine.width, stroke: stroke, child: this.chartObj.chart3D, tag: 'polyline', id: this.chartObj.svgObject.id + "_" + seriesIndex + "_" + pointIndex };

                this.chartObj.graphics.addVisual(this.chartObj.polygon.createPolyline(vectorPoints, line));
            }

        },

        sf.ejCircularSeries = {

            draw: function (series, sender, type) {
                var MARGINS_RATIO = 0.03,

                    seriesLength = sender.chartObj.model._visibleSeries.length,
                    seriesIndex = $.inArray(series, sender.chartObj.model._visibleSeries);
                sender._calculateVisiblePoints(series);
                sender.calculateSize(sender, series);

                if (type == "pie") {
                    series._size = series.pieCoefficient;
                    series._coefficient = seriesIndex == 0 ? 0 : series._size;
                }
                else {
                    series._size = series.doughnutSize;
                    series._coefficient = series.doughnutCoefficient;
                }
                if (sender.chartObj.model.circularRadius.length > 1) {
                    for (var i = seriesIndex; i < sender.chartObj.model.circularRadius.length; i++) {
                        if (!sf.util.isNullOrUndefined(sender.chartObj.model.circularRadius[i])) {
                            sender.chartObj.model.circularRadius[seriesIndex] = sender.chartObj.model.circularRadius[i] * series._size;
                            break;
                        }
                    }
                }
                else
                    sender.chartObj.model.circularRadius[seriesIndex] = (((1 - MARGINS_RATIO) * Math.min(series.actualWidth / 2, series.actualHeight / 2)) * series._size);
                sender.chartObj.model.innerRadius[seriesIndex] = series._coefficient * sender.chartObj.model.circularRadius[seriesIndex];
                sender.createPolygons(series, sender);
            },
            doAnimation: function (series, sender) {
                var seriesRendering = this;
                series.count = 0;
                $.each(series.segments, function (pointIndex, point) {

                    var radius = point.radius;
                    var insideRadius = point.inSideRadius;

                    series.animate = true;
                    $(sender.chartObj.element).each(function () { point.radius = 0, point.inSideRadius = 0 }).animate(
                        { Radius: radius, InsideRadius: insideRadius },

                        {
                            duration: 1000, queue: false, step: function (now, fx) {


                                if (fx.prop.toString() === "Radius") {
                                    point.radius = now;
                                }
                                else {
                                    point.inSideRadius = now;
                                }


                                var poligons = sender.createPolygons(series, sender, true);

                                for (var ai = 0; ai < poligons.length; ai++) {
                                    for (var k = 0; k < poligons[ai].length; k++) {
                                        sender.chartObj.polygon.update(poligons[ai][k].VectorPoints, poligons[ai][k], sender)
                                    }
                                }

                            },
                            complete: function () {
                                sender.chartObj.model.AnimationComplete = true;
                                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                                commonEventArgs.data = { series: series };
                                sender.chartObj._trigger("animationComplete", commonEventArgs);

                            }
                        });
                });
            }
        },

        sf.series3DTypes.doughnut = sf.ejCircularSeries;
    sf.series3DTypes.pie = sf.ejCircularSeries;



    sf.ej3DStackingColumn = {

        draw: function (series, sender, type, params) {
            var visiblePoints = sender._isVisiblePoints(series);
            this.createSegments(series, sender, params);
            for (var i = 0; i < visiblePoints.length; i++) {
                if (visiblePoints[i].visible) {
                    series._visiblePoints[i].plans = null;
                    sf.ej3DColumnSeries.update(series, series._visiblePoints[i], i, sender)
                }
            }
        },

        createSegments: function (series, sender, params) {
            var xValues = sender.chartObj._getXValues(series._visiblePoints);

            var median,
                cons = 0.2;
            if (xValues == null) return;

            var sbsInfo = sender.getSideBySideInfo(series, params);
            var depthInfo = sender._getSegmentDepth(series);
            median = sbsInfo.Delta / 2;
            var visiblePoints = sender._isVisiblePoints(series);
            for (var i = 0; i < visiblePoints.length; i++) {

                var x1 = xValues[i] + sbsInfo.Start;
                var x2 = xValues[i] + sbsInfo.End;
                var y2 = series.stackedValue.StartValues[i];
                var y1 = series.stackedValue.EndValues[i];

                sf.ej3DColumnSeries._setData(x1, y1, x2, y2, depthInfo.Start, depthInfo.End, sender, visiblePoints[i]);

                if (!series.marker.dataLabel.visible) continue;
                visiblePoints[i].symbolLocation = { x: 0, y: 0, z: 0 };
                switch (series.marker.dataLabel.textPosition) {
                    case "top":
                        visiblePoints[i].symbolLocation.x = x1 + median;
                        visiblePoints[i].symbolLocation.y = y1;
                        visiblePoints[i].symbolLocation.z = depthInfo.Start + (depthInfo.Delta / 2);
                        break;
                    case "bottom":
                        visiblePoints[i].symbolLocation.x = x1 + median;
                        visiblePoints[i].symbolLocation.y = y2 - cons;
                        visiblePoints[i].symbolLocation.z = depthInfo.Start + (depthInfo.End - depthInfo.Start) / 2;
                        break;
                    default:
                        visiblePoints[i].symbolLocation.x = x1 + median;
                        visiblePoints[i].symbolLocation.y = y1 + (y2 - y1) / 2;
                        visiblePoints[i].symbolLocation.z = depthInfo.Start;
                        break;
                }

            }

        },

        doAnimation: function (series, sender) {

            var seriesRender = this;

            $.each(series._visiblePoints, function (pointIndex, point) {

                var topValue = point.Top;
                var bottomValue = point.Bottom;

                $(point).each(function () { point.Top = 0, point.Bottom = 0 }).animate(
                    { Top: topValue, Bottom: bottomValue },

                    {
                        duration: 1200, queue: false, step: function (now, fx) {

                            if (fx.prop.toString() === "Top") {
                                point.Top = now;
                            }
                            if (fx.prop.toString() === "Bottom") {
                                point.Bottom = now;
                            }

                            sf.ej3DColumnSeries.update(series, point, pointIndex, sender);

                        },

                        complete: function () {

                            sender.chartObj.model.AnimationComplete = true;
                            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                            commonEventArgs.data = { series: series };
                            sender.chartObj._trigger("animationComplete", commonEventArgs);

                        }

                    });

            });

        }



    },

        sf.series3DTypes.stackingcolumn = sf.ej3DStackingColumn;

    sf.series3DTypes.stackingbar = sf.ej3DStackingColumn;

    sf.series3DTypes.stackingbar100 = sf.ej3DStackingColumn;

    sf.series3DTypes.stackingcolumn100 = sf.ej3DStackingColumn;

    sf.ej3DColumnSeries = {
        draw: function (series, sender, type, params) {
            var visiblePoints = sender._isVisiblePoints(series);
            this.createSegments(series, sender, params);
            for (var i = 0; i < visiblePoints.length; i++) {
                if (visiblePoints[i].visible) {
                    series._visiblePoints[i].plans = null;
                    this.update(series, series._visiblePoints[i], i, sender);
                }
            }
        },

        update: function (series, point, pointIndex, sender) {
            var plans;
            var valueType = series.xAxis._valueType.toLowerCase();
            var seriesIndex = $.inArray(series, sender.chartObj.model._visibleSeries);
            var xBase = (valueType == "logarithmic") ? null : 1;
            var xIsLogarithmic = (valueType == "logarithmic") ? true : false;
            var left = xIsLogarithmic ? Math.log(point.Left, xBase) : point.Left;
            var right = xIsLogarithmic ? Math.log(point.Right, xBase) : point.Right;
            var bottom = series.yAxis.visibleRange.min;
            var top = series.yAxis.visibleRange.max;
            var xStart = series.xAxis.visibleRange.min;
            var xEnd = series.xAxis.visibleRange.max;
            if ((!(left >= xStart) || !(left <= xEnd)) && (!(right >= xStart) || !(right <= xEnd))) return;

            var topValue;
            if (point.Top < 0)
                topValue = point.Top > bottom ? point.Top : bottom;
            else
                topValue = (series.yAxis.valueType && series.yAxis.valueType.toLowerCase() == "logarithmic") ? point.Top : point.Top < top ? point.Top : top;
            var tlpoint = sf.EjSvgRender.utils.Transform3DToVisible(series, point.Left > xStart ? point.Left : xStart, topValue, sender.chartObj);
            var rbpoint = sf.EjSvgRender.utils.Transform3DToVisible(series, xEnd > point.Right ? point.Right : xEnd, bottom > point.Bottom ? bottom : point.Bottom, sender.chartObj);

            var tlfVector = sender.chartObj.vector.vector3D(Math.min(tlpoint.X, rbpoint.X), Math.min(tlpoint.Y, rbpoint.Y), point.StartDepth);
            var brbVector = sender.chartObj.vector.vector3D(Math.max(tlpoint.X, rbpoint.X), Math.max(tlpoint.Y, rbpoint.Y), point.EndDepth);

            var styleOptions = sender.chartObj.setStyle(sender, series, seriesIndex, pointIndex);
            if (styleOptions.interior.indexOf("url") >= 0)
                styleOptions.interior = sender.chartObj.model.seriesColors[seriesIndex][0].color;
            var name = "Region" + "_Series_" + seriesIndex + "_Point_" + pointIndex
            if (series.columnFacet == "cylinder")

                sender.chartObj.polygon.createCylinder(tlfVector, brbVector, this, pointIndex, series.type,
                    styleOptions.borderColor, styleOptions.interior, styleOptions.borderWidth, styleOptions.opacity, sender.chartObj.model.requireInvertedAxes, name, sender.chartObj.chart3D);
            else if (series.columnFacet == "rectangle")
                sender.chartObj.polygon.createBox(tlfVector, brbVector, this, pointIndex, series.type,
                    styleOptions.borderColor, styleOptions.interior, styleOptions.borderWidth, styleOptions.opacity, sender.chartObj.model.requireInvertedAxes, name, sender.chartObj.chart3D);

        },

        _setData: function () {
            var values = arguments,
                point = arguments[arguments.length - 1],
                sender = arguments[arguments.length - 2];

            point.Left = values[0];
            point.Bottom = values[3];
            point.Top = values[1];
            point.Right = values[2];
            point.StartDepth = values[4];
            point.EndDepth = values[5];
            point.XRange = sender.getDoubleRange(point.Left, point.Right);
            if (!isNaN(point.Top) && !isNaN(point.Bottom))
                point.YRange = sender.getDoubleRange(point.Top, point.Bottom);
        },

        createSegments: function (series, sender, params) {
            var xValues = sender.chartObj._getXValues(series._visiblePoints),
                YValues = sender.chartObj._getYValues(series._visiblePoints);
            if (xValues == null) return;

            var sbsInfo = sender.getSideBySideInfo(series, params),
                depthInfo = sender._getSegmentDepth(series),
                crossValue = sender.chartObj._getXCrossValue(series, series.xAxis, params),
                median = sbsInfo.Delta / 2,
                visiblePoints = series._visiblePoints,
                cons = 0.2, XData, YData;
            for (var i = 0; i < visiblePoints.length; i++) {
                var x1 = xValues[i] + sbsInfo.Start,
                    x2 = xValues[i] + sbsInfo.End,
                    y1 = YValues[i],
                    y2 = crossValue;

                this._setData(x1, y1, x2, y2, depthInfo.Start, depthInfo.End, sender, visiblePoints[i]);

                XData = xValues[i];
                YData = YValues[i];
                //Item = ActualData[i];

                if (!series.marker.dataLabel.visible) continue;
                visiblePoints[i].symbolLocation = { x: 0, y: 0, z: 0 };
                switch (series.marker.dataLabel.textPosition) {
                    case "top":
                        visiblePoints[i].symbolLocation.x = x1 + median;
                        visiblePoints[i].symbolLocation.y = y1;
                        visiblePoints[i].symbolLocation.z = depthInfo.Start;
                        break;
                    case "bottom":
                        visiblePoints[i].symbolLocation.x = x1 + median;
                        visiblePoints[i].symbolLocation.y = y2 - cons;
                        visiblePoints[i].symbolLocation.z = depthInfo.Start + (depthInfo.End - depthInfo.Start) / 2;
                        break;
                    default:
                        visiblePoints[i].symbolLocation.x = x1 + median;
                        visiblePoints[i].symbolLocation.y = Math.abs(y2 - y1) / 2;
                        visiblePoints[i].symbolLocation.z = depthInfo.Start;
                        break;
                }

            }


        },

        doAnimation: function (series, sender) {

            var seriesRender = this;

            $.each(series._visiblePoints, function (pointIndex, point) {

                var topValue = point.Top;
                $(point).each(function () { point.Top = 0 }).animate(
                    { Top: topValue },

                    {
                        duration: 1200, queue: false, step: function (now, fx) {

                            if (fx.prop.toString() === "Top") {
                                point.Top = now;
                            }

                            seriesRender.update(series, point, pointIndex, sender);

                        },

                        complete: function () {
                            sender.chartObj.model.AnimationComplete = true;
                            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                            commonEventArgs.data = { series: series };
                            sender.chartObj._trigger("animationComplete", commonEventArgs);

                        }

                    });

            })

        }

    }

    sf.series3DTypes.column = sf.ej3DColumnSeries;

    //bar series
    sf.series3DTypes.bar = sf.ej3DColumnSeries;

    sf.Ej3DChart.prototype = {
        renderSeries: function (sender, series, params) {

            var series;
            sf.Ej3DSeriesRender.prototype.chartObj = sender;

            $.extend(sf.Ej3DSeriesRender.prototype, sf.EjSeriesRender.prototype);

            var seriesRendering = new sf.Ej3DSeriesRender();
            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { "series": series };
            seriesRendering.chartObj._trigger("seriesRendering", commonEventArgs);
            var type = series.type.toLowerCase();
            var options = sf.series3DTypes[type];
            if (sf.util.isNullOrUndefined(options)) return;
            options.draw(series, seriesRendering, type, params);
            if (series.marker.dataLabel.visible) {
                $.each(series._visiblePoints, function (pointIndex, point) {
                    point.marker = $.extend(true, {}, series.marker, point.marker);
                    if (point.visible && (sf.util.isNullOrUndefined(point.marker) || (point.marker.dataLabel && point.marker.dataLabel.visible)))
                        seriesRendering.draw3DDataLabel(series, pointIndex, point, sender);
                });
            }




        },
        update3DWall: function (sender, params) {
            if (sender.model.AreaType == "cartesianaxes") {
                $.extend(sf.Ej3DRender.prototype, this);
                this.updateBackWall(sender);
                for (var i = 0; i < sender.model._axes.length; i++) {
                    var axis = sender.model._axes[i],
                        opposedPosition = axis._opposed;
                    if (axis.orientation.toLowerCase() == "vertical") {
                        if (!opposedPosition)
                            this.updateLeftWall(sender, axis, params);
                        else
                            this.updateRightWall(sender, axis, params);
                    }
                    else {
                        if (!opposedPosition)
                            this.updateBottomWall(sender, axis, params);
                        else
                            this.updateTopWall(sender, axis, params);
                    }
                }
            }
        },

        updateTopWall: function (sender, axis, params) {

            var offset = 0;
            var areaBounds = sender.model.m_AreaBounds, y = params.axes[axis.name]._validCross ? axis.y : areaBounds.Y;
            if (sender.model.wallSize < y)
                offset = y - sender.model.wallSize;
            else
                offset = -(sender.model.wallSize - y);
            var tlfVector = sender.vector.vector3D(areaBounds.X + areaBounds.Width, -sender.model.depth, y - 0.1);
            var brbVector = sender.vector.vector3D(areaBounds.X, - 0.1, offset);
            var topSideWallPlans = sender.polygon.createBox(tlfVector, brbVector, this, 0, "Graphics3D", "#e2e1e1", "#e2e1e1", 0, 0.15, false, "TopWallBrush", sender.chart3D);

            for (var i = 0; i < topSideWallPlans.length; i++)
                sender.polygon.transform(sender.matrixobj.tilt((parseFloat)(Math.PI / 2)), topSideWallPlans[i]);


        },

        updateRightWall: function (sender, axis, params) {
            var x = params.axes[axis.name]._validCross ? axis.x : sender.model.m_AreaBounds.X + sender.model.m_AreaBounds.Width;
            var rightRect = { left: -(sender.model.depth), top: sender.model.m_AreaBounds.Y, bottom: sender.model.m_AreaBounds.Height + sender.model.m_AreaBounds.Y, right: 0 };
            var tlfVector = sender.vector.vector3D(rightRect.left, rightRect.top, x + 1.5);
            var brbVector = sender.vector.vector3D(rightRect.right, rightRect.bottom, x + sender.model.wallSize);
            var rightSideWallPlans = sender.polygon.createBox(tlfVector, brbVector, sender, 0, "Graphics3D", "#e2e1e1", "#e2e1e1", 0, 0.15, false, "RightWallBrush", sender.chart3D);
            for (var i = 0; i < rightSideWallPlans.length; i++)
                sender.polygon.transform(sender.matrixobj.turn((parseFloat)(-Math.PI / 2)), rightSideWallPlans[i]);
        },
        updateBackWall: function (sender) {
            var areaBounds = sender.model.m_AreaBounds;
            var tlfVector = sender.vector.vector3D(areaBounds.X, areaBounds.Y, sender.model.depth == 0 ? 1.5 : sender.model.depth + sender.model.wallSize);
            var brbVector = sender.vector.vector3D((areaBounds.X + areaBounds.Width), areaBounds.Y + areaBounds.Height, sender.model.depth == 0 ? 1.5 : sender.model.depth);

            sender.polygon.createBox(tlfVector, brbVector, sender, 0, "Graphics3D", "#e2e1e1", "#e2e1e1", 0, 0.15, false, "BackWallBrush", sender.chart3D);
        },
        updateLeftWall: function (sender, axis, params) {
            var leftRect = { left: -(sender.model.depth), top: sender.model.m_AreaBounds.Y, bottom: sender.model.m_AreaBounds.Height + sender.model.m_AreaBounds.Y, right: 0 },
                offset = params.axes[axis.name]._validCross ? axis.x : sender.model.m_AreaBounds.X;
            var tlfVector = sender.vector.vector3D(leftRect.left, leftRect.top, offset - 0.1);
            var brbVector = sender.vector.vector3D(leftRect.right, leftRect.bottom, offset - sender.model.wallSize);

            var leftSideWallPlans = sender.polygon.createBox(tlfVector, brbVector, this, 0, "Graphics3D", "#e2e1e1", "#e2e1e1", 0, 0.15, false, "LeftWallBrush", sender.chart3D);
            for (var i = 0; i < leftSideWallPlans.length; i++)
                sender.polygon.transform(sender.matrixobj.turn((parseFloat)(-Math.PI / 2)), leftSideWallPlans[i]);
        },
        updateBottomWall: function (sender, axis, params) {
            var areaBounds = sender.model.m_AreaBounds;
            var y = params.axes[axis.name]._validCross ? axis.y : areaBounds.Y + areaBounds.Height;
            var tlfVector = sender.vector.vector3D((areaBounds.X + areaBounds.Width), -(sender.model.depth), sender.model.wallSize + y);
            var brbVector = sender.vector.vector3D(areaBounds.X, -0.1, y + 1);

            var bottomSideWallPlans = sender.polygon.createBox(brbVector, tlfVector, this, 0, "Graphics3D", "#D3D3D3", "#D3D3D3", 0, 0.15, false, "BottomWallBrush", sender.chart3D);
            for (var i = 0; i < bottomSideWallPlans.length; i++)
                sender.polygon.transform(sender.matrixobj.tilt((parseFloat)(Math.PI / 2)), bottomSideWallPlans[i]);
        }
    }

})(jQuery);
/* global jQuery, sf */
sf.Ej3DRender = function () {


};

(function ($) {

    sf.Ej3DRender.Polygons = [];


    sf.Ej3DRender.prototype = {
        matrix3D: function () {

        },

        vector3D: function () {

        },

        BSPTreeBuilder: function () {

        },

        Graphics3D: function () {

        },

        polygon3D: function () {

        }
    }

    var Ej3DRender = new sf.Ej3DRender();

    Ej3DRender.vector3D.prototype = {
        //Members
        x: "",
        y: "",
        z: "",
        Epsilon: 0.00001,
        //all coordinates indicate 0
        //  empty: new Vector3D(0, 0, 0),

        //isValid: !isNaN(this.x) && !isNaN(this.y) && !isNaN(this.z),
        isValid: function (point) {
            return !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z)
        },
        //Constructor
        vector3D: function (points, vz) {
            this.x = points.x;
            this.y = points.y;
            this.z = vz;
        },

        vector3D: function (vx, vy, vz) {
            this.x = vx;
            this.y = vy;
            this.z = vz;
            return { x: vx, y: vy, z: vz }
        },

        //operations
        vector3DMinus: function (v1, v2) {
            return this.vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
        },

        vector3DPlus: function (v1, v2) {
            return this.vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
        },

        vector3DMultiply: function (v1, v2) {
            var _x = v1.y * v2.z - v2.y * v1.z;
            var _y = v1.z * v2.x - v2.z * v1.x;
            var _z = v1.x * v2.y - v2.x * v1.y;

            return this.vector3D(_x, _y, _z);
        },

        vector3dAND: function (v1, v2) {
            return (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z);
        },

        vector3DStarMultiply: function (v1, val) {
            var _x = v1.x * val;
            var _y = v1.y * val;
            var _z = v1.z * val;

            return this.vector3D(_x, _y, _z);
        },

        //Methods
        getLength: function (vector) {
            var sqt = this.vector3dAND(vector, vector);
            return Math.sqrt(sqt);
        },



        normalize: function () {
            var l = this.getLength(), x, y, z;
            x /= l;
            y /= l;
            z /= l;
        },
        getNormal: function (v1, v2, v3) {
            var v4 = this.vector3DMinus(v1, v2);
            var v5 = this.vector3DMinus(v3, v2);
            var n = this.vector3DMultiply(v4, v5);
            var l = this.getLength(n);

            if (l < this.Epsilon) {
                l = 0;
            }
            return { x: n.x / l, y: n.y / l, z: n.z / l }
        }
    }

    Ej3DRender.matrix3D.prototype = {
        //Memebr
        MATRIX_SIZE: 4,
        //Constructor
        matrix3D: function (size) {
            var mData = [];
            for (var i = 0; i < size; i++) {
                mData[i] = this.createArray(size);
            }
            return mData;
        },

        //method
        isAffine: function (mData) {

            return (mData[0][3] == 0) && (mData[1][3] == 0)
                && (mData[2][3] == 0) && (mData[3][3] == 1);
        },
        createArray: function (initialSize) {
            var a = [];
            for (var index = 0; index < initialSize; ++index) {
                a[index] = 0;
            }
            return a;
        },

        getIdentity: function () {

            var mData = this.matrix3D(this.MATRIX_SIZE);

            for (var i = 0; i < this.MATRIX_SIZE; i++) {
                mData[i][i] = 1.0;
            }

            return mData;
        },

        getInvertal: function (matrix) {
            var m = this.getIdentity();

            for (var i = 0; i < this.MATRIX_SIZE; i++) {
                for (var j = 0; j < this.MATRIX_SIZE; j++) {
                    m[i][j] = this.getMinor(matrix, i, j);
                }
            }

            m = this.transposed(m);
            m = this.getMatrixMultiple((1 / this.getDeterminant(matrix)), m);

            return m;
        },
        getMatrixMultiple: function (factor, matrix) {
            for (var i = 0; i < matrix.length; i++) {
                for (var j = 0; j < matrix[i].length; j++) {
                    matrix[i][j] = matrix[i][j] * factor;
                }
            }
            return matrix;
        },
        getMatrixVectorMutiple: function (m1, point) {
            var x = m1[0][0] * point.x + m1[1][0] * point.y + m1[2][0] * point.z + m1[3][0];
            var y = m1[0][1] * point.x + m1[1][1] * point.y + m1[2][1] * point.z + m1[3][1];
            var z = m1[0][2] * point.x + m1[1][2] * point.y + m1[2][2] * point.z + m1[3][2];

            if (!this.isAffine(m1)) {
                var c = 1 / (m1[0][3] * point.x + m1[1][3] * point.y + m1[2][3] * point.z + m1[3][3]);
                x *= c;
                y *= c;
                z *= c;
            }

            return { x: x, y: y, z: z };
        },
        getMatrixVectorAnd: function (m1, v1) {
            var x = m1[0][0] * v1.x + m1[1][0] * v1.y + m1[2][0] * v1.z;
            var y = m1[0][1] * v1.x + m1[1][1] * v1.y + m1[2][1] * v1.z;
            var z = m1[0][2] * v1.x + m1[1][2] * v1.y + m1[2][2] * v1.z;

            return Ej3DRender.vector3D.prototype.vector3D(x, y, z);
        },
        getMatrixAdd: function (m1, m2) {
            var m = this.matrix3D(4);

            for (var i = 0; i < 4; i++) {
                for (var j = 0; j < 4; j++) {
                    m[i][j] = m1[i][j] + m2[i][j];
                }
            }

            return m;
        },
        getMatrixMultiplication: function (m1, m2) {
            var res = this.getIdentity();

            for (var i = 0; i < this.MATRIX_SIZE; i++) {
                for (var j = 0; j < this.MATRIX_SIZE; j++) {
                    var v = 0;

                    for (var k = 0; k < this.MATRIX_SIZE; k++) {
                        v += m1[k][j] * m2[i][k];
                        var t = v;
                    }

                    res[i][j] = v;
                }
            }

            return res;
        },
        getMatrixEqual: function (m1, m2) {
            var res = true;

            for (var i = 0; i < m1.length; i++) {
                for (var j = 0; j < m1.length; j++) {
                    if (m1[i][j] != m2[i][j]) {
                        res = false;
                    }
                }
            }

            return res;
        },
        getMatrixNotEqual: function (m1, m2) {
            var res = true;

            for (var i = 0; i < m1.length; i++) {
                for (var j = 0; j < m1.length; j++) {
                    if (m1[i][j] != m2[i][j]) {
                        res = false;
                    }
                }
            }

            return !res;
        },


        getMinor: function (dd, columnIndex, rowIndex) {
            return (((columnIndex + rowIndex) % 2 == 0) ? 1 : -1) * this.getDeterminant(this.getMMtr(dd, columnIndex, rowIndex));

        },

        getMMtr: function (dd, columnIndex, rowIndex) {
            var count = dd.length - 1;
            var d = this.createArray(count);

            for (var i = 0; i < count; i++) {
                var m = (i >= columnIndex) ? i + 1 : i;
                d[i] = this.createArray(count);

                for (var j = 0; j < count; j++) {
                    var n = (j >= rowIndex) ? j + 1 : j;

                    d[i][j] = dd[m][n];
                }
            }
            return d;
        },
        getDeterminant: function (dd) {
            var count = dd.length;
            var res = 0;

            if (count < 2) {
                res = dd[0][0];
            }
            else {
                var k = 1;

                for (var i = 0; i < count; i++) {
                    var dm = this.getMMtr(dd, i, 0);

                    res += k * dd[i][0] * this.getDeterminant(dm);
                    k = (k > 0) ? -1 : 1;
                }
            }

            return res;
        },


        transform: function (x, y, z) {
            var res = this.getIdentity();

            res[3][0] = x;
            res[3][1] = y;
            res[3][2] = z;

            return res;
        },


        turn: function (angle) {
            var res = this.getIdentity();

            res[0][0] = Math.cos(angle);
            res[2][0] = -Math.sin(angle);
            res[0][2] = Math.sin(angle);
            res[2][2] = Math.cos(angle);

            return res;
        },

        tilt: function (angle) {
            var res = this.getIdentity();

            res[1][1] = Math.cos(angle);
            res[2][1] = Math.sin(angle);
            res[1][2] = -(Math.sin(angle));
            res[2][2] = Math.cos(angle);

            return res;
        },
        transposed: function (matrix3D) {
            var m = this.getIdentity();

            for (var i = 0; i < this.MATRIX_SIZE; i++) {
                for (var j = 0; j < this.MATRIX_SIZE; j++) {
                    m[i][j] = matrix3D[j][i];
                }
            }
            return m;
        },
        shear: function (xy, xz, yx, yz, zx, zy) {
            var res = this.getIdentity();

            res[1, 0] = xy;
            res[2, 0] = xz;
            res[0, 1] = yx;
            res[2, 1] = yz;
            res[0, 2] = zx;
            res[1, 2] = zy;

            return res;
        }


    }
    Ej3DRender.Graphics3D.prototype = {
        addVisual: function (polygon) {
            if ((polygon == null) || (polygonobj.test(polygon))) {
                return -1;
            }
            polygon.Graphics3D = this;
            return bsptreeobj.add(polygon);
        },

        getVisualCount: function () {
            return sf.Ej3DRender.Polygons.length();
        },
        remove: function (polygon) {
            sf.Ej3DRender.Polygons.Remove(polygon);
        },

        clearVisual: function () {
            sf.Ej3DRender.Polygons = null;
        },

        getVisual: function () {
            return sf.Ej3DRender.Polygons;
        },
        prepareView: function (perspectiveAngle, depth, rotation, tilt, size, sender) {
            if (arguments.length == 0) {
                bsptreeobj.build();
            }
            else {
                if (sf.Ej3DRender.transform == null)
                    sf.Ej3DRender.transform = sf.EjSvgRender.chartTransform3D.transform3D(size);
                else
                    sf.Ej3DRender.transform.mViewport = size;
                if (!sf.Ej3DRender.tree)
                    sf.Ej3DRender.tree = [];
                sf.Ej3DRender.transform.Rotation = rotation;
                sf.Ej3DRender.transform.Tilt = tilt;
                sf.Ej3DRender.transform.Depth = depth;
                sf.Ej3DRender.transform.PerspectiveAngle = perspectiveAngle;
                sf.EjSvgRender.chartTransform3D.transform(sf.Ej3DRender.transform);
                sf.Ej3DRender.tree[sender._id] = bsptreeobj.build();

            }
        },
        view: function (panel, sender, rotation, tilt, size, perspectiveAngle, depth) {
            var MaxValue = 32767;
            if (arguments.length == 2) {
                if (panel == null) return;
                var eye = vector.vector3D(0, 0, MaxValue);
                this.drawBspNode3D(sf.Ej3DRender.tree[sender._id], eye, panel, sender);
            }
            else {
                if (panel == null) return;

                if (sf.Ej3DRender.transform == null)
                    sf.Ej3DRender.transform = sf.EjSvgRender.chartTransform3D.transform3D(size);
                else
                    sf.Ej3DRender.transform.mViewport = size;
                sf.Ej3DRender.transform.Rotation = rotation;
                sf.Ej3DRender.transform.Tilt = tilt;
                sf.Ej3DRender.transform.Depth = depth;
                sf.Ej3DRender.transform.PerspectiveAngle = perspectiveAngle;
                sf.EjSvgRender.chartTransform3D.transform(sf.Ej3DRender.transform);
                var eye = vector.vector3D(0, 0, MaxValue);
                this.drawBspNode3D(sf.Ej3DRender.tree[sender._id], eye, panel, sender);
            }
        },

        draw3DElement: function (tr, sender) {
            if (tr.Plane.element) {
                if (tr.Plane.element.tag == "text" || tr.Plane.element.tag == "dataLabel")
                    polygonobj.drawText(tr.Plane, sender);
                else if (tr.Plane.element.tag == "polyline")
                    polygonobj.drawPolyLine(tr.Plane, sender);
                else if (tr.Plane.element.tag == "template")
                    polygonobj.drawTemplate(tr.Plane, sender);
                else
                    polygonobj.drawLine(tr.Plane, sender);
            }

            else
                polygonobj.draw(tr.Plane, sender);
        },

        drawBspNode3D: function (tr, eye, panel, sender) {
            if (tr == null || sf.Ej3DRender.transform == null) return;
            while (true) {
                var r = vector.vector3dAND(polygonobj.getNormal(sf.EjSvgRender.chartTransform3D.result(sf.Ej3DRender.transform), tr.Plane.VectorPoints), eye);
                if (r > tr.Plane.D) {
                    if (tr.Front != null) {
                        this.drawBspNode3D(tr.Front, eye, panel, sender);
                    }

                    this.draw3DElement(tr, sender);

                    if (tr.Back != null) {
                        tr = tr.Back;
                        continue;
                    }
                }
                else {
                    if (tr.Back != null) {
                        this.drawBspNode3D(tr.Back, eye, panel, sender);
                    }

                    this.draw3DElement(tr, sender);

                    if (tr.Front != null) {
                        tr = tr.Front;
                        continue;
                    }
                }
                break;
            }

        }

    }


    Ej3DRender.BSPTreeBuilder.prototype = {
        //Members
        EPSILON: 0.0005,
        Polygon: [],

        //Methods
        add: function (poly) {
            sf.Ej3DRender.Polygons.push(poly);
            return sf.Ej3DRender.Polygons.length - 1;
        },

        remove: function (index) {
            sf.Ej3DRender.Polygons.splice(index, 1);
        },

        clear: function () {
            sf.Ej3DRender.Polygons = [];
        },

        count: function () {
            return sf.Ej3DRender.Polygons.length;
        },

        getNext: function (i, count) {
            if (i >= count) {
                return i - count;
            }
            if (i < 0) {
                return i + count;
            }

            return i;
        },
        getNodeCount: function (el) {
            return (el == null) ? 0 : 1 + this.getNodeCount(el.Back) + this.getNodeCount(el.Front);
        },
        vector3DIndexClassification: function (point, ind, res) {
            return {
                index: ind,
                result: res,
                vector: point,

                isCuttingBackPoint: false,
                cuttingBackPairIndex: null,
                alreadyCuttedBack: false,

                isCuttingFrontPoint: false,
                cuttingFrontPairIndex: null,
                alreadyCuttedFront: false
            }
        },
        classifyPoint: function (pt, pln) {
            var res = "OnPlane";
            var sv = -pln.D - Ej3DRender.vector3D.prototype.vector3dAND(pt, pln.normal);

            if (sv > this.EPSILON) {
                res = "OnBack";
            }
            else if (sv < -this.EPSILON) {
                res = "OnFront";
            }

            return res;
        },

        classifyPolygon: function (pln, plg) {
            var res = "Unknown";
            var points = plg.Points;

            if (points == null)
                return res;
            var onBack = 0;
            var onFront = 0;
            var onPlane = 0;
            var normal = pln.normal;// root node normailized value perpendicular direction
            var d = pln.D; // constant of the plan or depth

            for (var i = 0, len = points.length; i < len; i++) {
                var r = -d - Ej3DRender.vector3D.prototype.vector3dAND(points[i], normal); // Comparision of Plane point depth with the other nodes

                if (r > this.EPSILON) {
                    onBack++;
                }
                else if (r < -this.EPSILON) {
                    onFront++;
                }
                else {
                    onPlane++;
                }

                if ((onBack > 0) && (onFront > 0)) {
                    break;
                }
            }
            if (onPlane == points.length) {
                res = "OnPlane";
            }
            else if (onFront + onPlane == points.length) {
                res = "ToRight";
            }
            else if (onBack + onPlane == points.length) {
                res = "ToLeft";
            }
            else {
                res = "Unknown";
            }
            return res;
        },
        splitPolygon: function (poly, part) {
            var backP = [];
            var frontP = [];

            // this code looks for points which lie on the part plane and divide polygon into two parts
            if (poly.Points != null) {
                var polyPoints = [];
                var backPartPoints = [];
                var frontPartPoints = [];

                var outpts;
                var inpts;

                var count = poly.Points.length;
                for (var i = 0; i < count; i++) {
                    var ptB = poly.Points[i];
                    var ptC = poly.Points[this.getNext(i + 1, count)];
                    var sideB = this.classifyPoint(ptB, part);
                    var sideC = this.classifyPoint(ptC, part);

                    var vwiwcB = this.vector3DIndexClassification(ptB, polyPoints.length, sideB);
                    polyPoints.push(vwiwcB);

                    if ((sideB != sideC) && (sideB != "OnPlane") &&
                        (sideC != "OnPlane")) {
                        var v = vector.vector3DMinus(ptB, ptC);
                        var dir = vector.vector3DMinus(vector.vector3DStarMultiply(part.normal, (-part.D)), ptC);

                        var sv = vector.vector3dAND(dir, part.normal);
                        var sect = sv / vector.vector3dAND(part.normal, v);
                        var ptP = vector.vector3DPlus(ptC, vector.vector3DStarMultiply(v, sect));
                        var vwiwc = this.vector3DIndexClassification(ptP, polyPoints.length, "OnPlane");

                        polyPoints.push(vwiwc);
                        backPartPoints.push(vwiwc);
                        frontPartPoints.push(vwiwc);
                    }
                    else
                        if (sideB == "OnPlane") {
                            var ptA = poly.Points[this.getNext(i - 1, count)];
                            var sideA = this.classifyPoint(ptA, part);
                            if ((sideA == sideC)) continue;
                            if ((sideA != "OnPlane") && (sideC != "OnPlane")) {
                                backPartPoints.push(vwiwcB);
                                frontPartPoints.push(vwiwcB);
                            }
                            else
                                if (sideA == "OnPlane") {
                                    switch (sideC) {
                                        case "OnBack":
                                            backPartPoints.push(vwiwcB);
                                            break;
                                        case "OnFront":
                                            frontPartPoints.push(vwiwcB);
                                            break;
                                    }
                                }
                                else
                                    if (sideC == "OnPlane") {
                                        switch (sideA) {
                                            case "OnBack":
                                                backPartPoints.push(vwiwcB);
                                                break;
                                            case "OnFront":
                                                frontPartPoints.push(vwiwcB);
                                                break;
                                        }
                                    }
                        }
                }

                if ((frontPartPoints.length != 0) || (backPartPoints.length != 0)) {
                    for (var i = 0; i < backPartPoints.length - 1; i += 2) {
                        var vwiwc1 = backPartPoints[i];
                        var vwiwc2 = backPartPoints[i + 1];
                        vwiwc1.CuttingBackPoint = true;
                        vwiwc2.CuttingBackPoint = true;
                        vwiwc1.CuttingBackPairIndex = vwiwc2.index;
                        vwiwc2.CuttingBackPairIndex = vwiwc1.index;
                    }
                    for (var i = 0; i < frontPartPoints.length - 1; i += 2) {
                        var vwiwc1 = frontPartPoints[i];
                        var vwiwc2 = frontPartPoints[i + 1];
                        vwiwc1.CuttingFrontPoint = true;
                        vwiwc2.CuttingFrontPoint = true;
                        vwiwc1.CuttingFrontPairIndex = vwiwc2.index;
                        vwiwc2.CuttingFrontPairIndex = vwiwc1.index;
                    }


                    for (var i = 0; i < backPartPoints.length - 1; i++) {
                        var vwiwc1 = backPartPoints[i];
                        if (vwiwc1.alreadyCuttedBack) continue;
                        var outpts = this.cutOutBackPolygon(polyPoints, vwiwc1);

                        if (outpts.length > 2) {
                            var polygon1 = polygonobj.polygon3D(outpts, poly);
                            backP.push($.extend({}, polygon1));
                        }
                    }

                    for (var i = 0; i < frontPartPoints.length - 1; i++) {
                        var vwiwc2 = frontPartPoints[i];
                        if (vwiwc2.alreadyCuttedFront) continue;
                        inpts = this.cutOutFrontPolygon(polyPoints, vwiwc2);
                        if (inpts.length > 2) {
                            var polygon2 = polygonobj.polygon3D(inpts, poly);
                            frontP.push($.extend({}, polygon2));
                        }
                    }
                }
            }
            else {
                backP.push(poly);
                frontP.push(poly);
            }

            return { BackP: backP, FrontP: frontP }
        },
        cutOutFrontPolygon: function (polyPoints, vwiwc) {
            var points = [];

            var curVW = vwiwc;

            while (true) {
                curVW.alreadyCuttedFront = true;
                points.push(curVW.vector);

                var curVWPair = polyPoints[curVW.CuttingFrontPairIndex];

                if (curVW.CuttingFrontPoint) {
                    if (!curVWPair.alreadyCuttedFront) {
                        curVW = curVWPair;
                    }
                    else {
                        var curVWPrev = polyPoints[this.getNext(curVW.index - 1, polyPoints.length)];
                        var curVWNext = polyPoints[this.getNext(curVW.index + 1, polyPoints.length)];

                        if ((curVWPrev.result == "OnFront") && !curVWPrev.alreadyCuttedFront) {
                            curVW = curVWPrev;
                        }
                        else
                            if ((curVWNext.result == "OnFront") && !curVWNext.alreadyCuttedFront) {
                                curVW = curVWNext;
                            }
                            else {
                                return points;
                            }
                    }
                }
                else {
                    var curPrev = polyPoints[this.getNext(curVW.index - 1, polyPoints.length)];
                    var curNext = polyPoints[this.getNext(curVW.index + 1, polyPoints.length)];

                    if ((curPrev.result != "OnBack") && !curPrev.alreadyCuttedFront) {
                        curVW = curPrev;
                    }
                    else
                        if ((curNext.result != "OnBack") && !curNext.alreadyCuttedFront) {
                            curVW = curNext;
                        }
                        else {
                            return points;
                        }
                }
            }
            return points;
        },

        cutOutBackPolygon: function (polyPoints, vwiwc) {
            var points = [];
            var curVW = vwiwc;

            while (true) {
                curVW.alreadyCuttedBack = true;
                points.push(curVW.vector);

                var curVWPair = polyPoints[curVW.CuttingBackPairIndex];

                if (curVW.CuttingBackPoint) {
                    if (!curVWPair.alreadyCuttedBack) {
                        curVW = curVWPair;
                    }
                    else {
                        var curVWPrev = polyPoints[this.getNext(curVW.index - 1, polyPoints.length)];
                        var curVWNext = polyPoints[this.getNext(curVW.index + 1, polyPoints.length)];

                        if ((curVWPrev.result == "OnBack") && !curVWPrev.alreadyCuttedBack) {
                            curVW = curVWPrev;
                        }
                        else
                            if ((curVWNext.result == "OnBack") && !curVWNext.alreadyCuttedBack) {
                                curVW = curVWNext;
                            }
                            else {
                                return points;
                            }
                    }
                }
                else {
                    var curVWPrev = polyPoints[this.getNext(curVW.index - 1, polyPoints.length)];
                    var curVWNext = polyPoints[this.getNext(curVW.index + 1, polyPoints.length)];

                    if ((curVWPrev.result != "OnFront") && !curVWPrev.alreadyCuttedBack) {
                        curVW = curVWPrev;
                    }
                    else
                        if ((curVWNext.result != "OnFront") && !curVWNext.alreadyCuttedBack) {
                            curVW = curVWNext;
                        }
                        else {
                            return points;
                        }
                }
            }
            return points
        },
        build: function () {
            if (!arguments[0]) {
                return (this.build(sf.Ej3DRender.Polygons));
            }
            else {
                var arlist = arguments[0];
                if (arlist.length < 1) return null;
                var bspNode = { Back: null, Front: null, Plane: null }
                var plane = arlist[0];
                bspNode.Plane = plane;
                var arleft = [];
                var arright = [];

                for (var i = 1, len = arlist.length; i < len; i++) {
                    var pln = arlist[i];

                    if (pln == plane) continue;
                    var r = this.classifyPolygon(plane, pln);

                    switch (r) {
                        case "OnPlane":
                        case "ToRight":
                            arright.push(pln);
                            break;

                        case "ToLeft":
                            arleft.push(pln);
                            break;

                        case "Unknown":
                            //if (pln is Line3D || pln is UIElement3D)
                            if (pln.element && (pln.element.tag == "line" || pln.element.tag == "text")) {
                                arleft.push(pln);
                            }
                            else {

                                var result = this.splitPolygon(pln, plane);
                                for (var k = 0; k < result.BackP.length; k++) {
                                    result.BackP[k].Name = result.BackP[k].Name + "back";
                                    arleft.push(result.BackP[k]);
                                }
                                for (var j = 0; j < result.FrontP.length; j++) {
                                    result.FrontP[j].Name = result.FrontP[j].Name + "front";
                                    arright.push(result.FrontP[j]);
                                }
                            }
                            break;
                    }
                }

                if (arleft.length > 0) {
                    bspNode.Back = this.build(arleft);
                }

                if (arright.length > 0) {
                    bspNode.Front = this.build(arright);
                }

                return bspNode;
            }
        }

    }

    Ej3DRender.polygon3D.prototype = {
        // Member    
        epsilon: 0.00001,
        normal: { x: 0, y: 0, z: 0 },

        vector: new (new sf.Ej3DRender()).vector3D(),

        // Constructor
        polygon3D: function (points, tag, index, stroke, strokeThickness, opacity, fill, name) {

            if (arguments.length == 3) {
                this.calcNormal(arguments[0], arguments[1], arguments[2])
            }
            else if (arguments.length == 2) {
                points = arguments[0];
                this.calcNormal(points[0], points[1], points[2]);
                this.vectorPoints = points;
                this.calcNormal(this.vectorPoints);
                var polygon = arguments[1];
                polygon.Normal = this.normal;
                polygon.normal = this.normal;
                polygon.Points = points;
                polygon.VectorPoints = this.vectorPoints;
                polygon.IsSplitted = true;
                polygon.d = this.d;
                polygon.D = this.d;
                return polygon;

            }
            else {
                this.calcNormal(points[0], points[1], points[2]);
                this.vectorPoints = points;
                this.calcNormal(this.vectorPoints);
                var element = { Tag: 'path', Parent: arguments[arguments.length - 1] }
                var polygon = {
                    Normal: this.normal,
                    normal: this.normal,
                    Points: points,
                    VectorPoints: this.vectorPoints,
                    Index: index,
                    Tag: tag,
                    Name: (name) ? name : null,
                    StrokeThickness: strokeThickness,
                    Opacity: opacity,
                    Fill: fill,
                    d: this.d,
                    D: this.d
                }
                if (arguments.length != 1)
                    polygon.Element = element;

                return polygon;

            }
        },

        //Methods
        createLine: function (line, x1, y1, x2, y2, depth) {
            var strokeThickness = line.width;
            var vectorColl = [];
            vectorColl[0] = vector.vector3D(x1, y1, depth);
            vectorColl[1] = vector.vector3D(x1 + strokeThickness, y2 + strokeThickness, depth);
            vectorColl[2] = vector.vector3D(x2, y2, depth);
            return this.line3D(line, vectorColl);
        },
        createPolyline: function (points, element) {
            if (points.length == 2) {
                var prePoint = points[1];
                points.push(vector.vector3D(prePoint.x, prePoint.y, prePoint.z));
            }
            return this.polyLine3D(element, points);
        },
        polyLine3D: function (element, points) {
            var plane = this.polygon3D(points);
            plane.element = element;
            return plane;
        },

        line3D: function (element, points) {
            var plane = this.polygon3D(points);
            plane.element = element;
            return plane;
        },
        text3D: function (element, points) {
            var plane = this.polygon3D(points);
            plane.element = element;
            return plane;
        },
        createCylinder: function (v1, v2, tag, index, type, stroke, fill, strokeThickness, opacity, inverse, name, parent) {
            var i = 0, ox, oy, oz, vts, pathCount = 24, theta = 360 / pathCount, DtoR = Math.PI / 180, CenterZ = (parseFloat)((v1.z + v2.z) / 2), res = [], oPts = [], tVtxs = [], bVtxs = [], radiusb = (v2.y - v1.y) < (v2.z - v1.z) ? (parseFloat)((v2.y - v1.y) / 2) : (parseFloat)((v2.z - v1.z) / 2), radiusc = (v2.x - v1.x) < (v2.z - v1.z) ? (parseFloat)((v2.x - v1.x) / 2) : (parseFloat)((v2.z - v1.z) / 2), CenterX = (parseFloat)((v1.x + v2.x) / 2), CenterY = (parseFloat)((v1.y + v2.y) / 2);
            var type = type.toLowerCase();
            switch (type) {
                case "bar":
                case "stackingbar":
                case "stackingbar100":
                    pathCount++;
                    while (pathCount--) {
                        oy = (parseFloat)(CenterY + radiusb * Math.cos((i * theta) * DtoR));
                        oz = (parseFloat)(CenterZ + radiusb * Math.sin((i * theta) * DtoR));
                        oPts[i] = { Y: oy, Z: oz };
                        tVtxs.push(vector.vector3D(v1.x, oPts[i].Y, oPts[i].Z));
                        bVtxs.push(vector.vector3D(v2.x, oPts[i].Y, oPts[i].Z));
                        if (i > 0) {
                            vts = new Array(vector.vector3D(v1.x, oPts[i - 1].Y, oPts[i - 1].Z),
                                vector.vector3D(v2.x, oPts[i - 1].Y, oPts[i - 1].Z),
                                vector.vector3D(v2.x, oPts[i].Y, oPts[i].Z),
                                vector.vector3D(v1.x, oPts[i].Y, oPts[i].Z))
                            res[i + 1] = this.polygon3D(vts, tag, index, fill, 0, opacity, fill, "_" + (i + 1).toString() + "_" + name, parent);
                            graphics.addVisual(res[i + 1]);
                        }
                        i++;
                    }
                    break;
                case "column":
                case "stackingcolumn":
                case "stackingcolumn100":
                    pathCount++;
                    while (pathCount--) {
                        ox = (parseFloat)(CenterX + radiusc * Math.cos((i * theta) * DtoR));
                        oz = (parseFloat)(CenterZ + radiusc * Math.sin((i * theta) * DtoR));
                        oPts[i] = { X: ox, Z: oz };
                        tVtxs.push(vector.vector3D(oPts[i].X, v1.y, oPts[i].Z));
                        bVtxs.push(vector.vector3D(oPts[i].X, v2.y, oPts[i].Z));
                        if (i > 0) {
                            vts = new Array(vector.vector3D(oPts[i - 1].X, v1.y, oPts[i - 1].Z),
                                vector.vector3D(oPts[i - 1].X, v2.y, oPts[i - 1].Z),
                                vector.vector3D(oPts[i].X, v2.y, oPts[i].Z),
                                vector.vector3D(oPts[i].X, v1.y, oPts[i].Z))
                            res[i + 1] = this.polygon3D(vts, tag, index, fill, 0, opacity, fill, "_" + (i + 1).toString() + "_" + name, parent);
                            graphics.addVisual(res[i + 1]);
                        }
                        i++;
                    }
                    break;
                default:
                    break;
            }
            res[0] = this.polygon3D(bVtxs, tag, index, stroke, 0, opacity, fill, "_0_" + name, parent);
            res[1] = this.polygon3D(tVtxs, tag, index, stroke, strokeThickness, opacity, fill, "_1_" + name, parent);
            graphics.addVisual(res[0]);
            graphics.addVisual(res[1]);
            return res;
        },

        createBox: function (v1, v2, tag, index, graphics3D, stroke, fill, strokeThickness, opacity, inverse, name, parent) {
            var res = [];

            var p1 = new Array(vector.vector3D(v1.x, v1.y, v1.z),
                vector.vector3D(v2.x, v1.y, v1.z),
                vector.vector3D(v2.x, v2.y, v1.z),
                vector.vector3D(v1.x, v2.y, v1.z))

            var p2 = new Array(
                vector.vector3D(v1.x, v1.y, v2.z),
                vector.vector3D(v2.x, v1.y, v2.z),
                vector.vector3D(v2.x, v2.y, v2.z),
                vector.vector3D(v1.x, v2.y, v2.z)
            )

            var p3 = new Array(

                vector.vector3D(v1.x, v1.y, v2.z),
                vector.vector3D(v2.x, v1.y, v2.z),
                vector.vector3D(v2.x, v1.y, v1.z),
                vector.vector3D(v1.x, v1.y, v1.z)
            )

            var p4 = new Array(
                vector.vector3D(v1.x, v2.y, v2.z),
                vector.vector3D(v2.x, v2.y, v2.z),
                vector.vector3D(v2.x, v2.y, v1.z),
                vector.vector3D(v1.x, v2.y, v1.z)
            )

            var p5 = new Array(
                vector.vector3D(v1.x, v1.y, v1.z),
                vector.vector3D(v1.x, v1.y, v2.z),
                vector.vector3D(v1.x, v2.y, v2.z),
                vector.vector3D(v1.x, v2.y, v1.z)
            )

            var p6 = new Array(
                vector.vector3D(v2.x, v1.y, v1.z),
                vector.vector3D(v2.x, v1.y, v2.z),
                vector.vector3D(v2.x, v2.y, v2.z),
                vector.vector3D(v2.x, v2.y, v1.z)
            )
            if (arguments[10]) {

                res[0] = this.polygon3D(p1, tag, index, stroke, strokeThickness, opacity, fill, "_0_" + name, parent);
                res[1] = this.polygon3D(p2, tag, index, stroke, strokeThickness, opacity, fill, "_1_" + name, parent);
                res[2] = this.polygon3D(p3, tag, index, stroke, strokeThickness, opacity, fill, "_2_" + name, parent);
                res[3] = this.polygon3D(p4, tag, index, stroke, strokeThickness, opacity, fill, "_3_" + name, parent);
                res[4] = this.polygon3D(p5, tag, index, stroke, strokeThickness, opacity, fill, "_4_" + name, parent);
                res[5] = this.polygon3D(p6, tag, index, stroke, strokeThickness, opacity, fill, "_5_" + name, parent);
            }
            else {
                var parent = arguments[arguments.length - 1];
                res[0] = this.polygon3D(p1, tag, index, stroke, strokeThickness, opacity, fill, "_0_" + index, parent);
                res[1] = this.polygon3D(p2, tag, index, stroke, strokeThickness, opacity, fill, "_1_" + index, parent);
                res[2] = this.polygon3D(p3, tag, index, stroke, strokeThickness, opacity, fill, "_2_" + index, parent);
                res[3] = this.polygon3D(p4, tag, index, stroke, strokeThickness, opacity, fill, "_3_" + index, parent);
                res[4] = this.polygon3D(p5, tag, index, stroke, strokeThickness, opacity, fill, "_4_" + index, parent);
                res[5] = this.polygon3D(p6, tag, index, stroke, strokeThickness, opacity, fill, "_5_" + index, parent);
            }

            if (inverse) {
                graphics.addVisual(res[0]);
                graphics.addVisual(res[1]);
                graphics.addVisual(res[2]);
                graphics.addVisual(res[3]);
                graphics.addVisual(res[4]);
                graphics.addVisual(res[5]);
            }
            else {
                graphics.addVisual(res[5]);
                graphics.addVisual(res[4]);
                graphics.addVisual(res[0]);
                graphics.addVisual(res[1]);
                graphics.addVisual(res[2]);
                graphics.addVisual(res[3]);

            }
            return res;
        },


        calcNormal: function () {
            if (arguments.length >= 3) {
                // Relative information of the points
                var v1 = arguments[0];
                var v2 = arguments[1];
                var v3 = arguments[2];
                var v4 = vector.vector3DMinus(v1, v2);
                var v5 = vector.vector3DMinus(v3, v2);
                var n = vector.vector3DMultiply(v4, v5);

                var l = vector.getLength(n);//Get length of the vector

                if (l < this.epsilon) {
                    l = 1;
                }

                this.normal = vector.vector3D(n.x / l, n.y / l, n.z / l); //Calculate normalization of the vector
                this.d = -(this.normal.x * v1.x + this.normal.y * v1.y + this.normal.z * v1.z);// Normalized values * 1st coordinates Coordinates - Depth of the plan

                if (arguments[3]) {
                    arguments[3].normal = this.normal;
                    arguments.d = this.d;
                }
            }
            else {
                var Points = arguments[0];
                this.calcNormal(Points[0], Points[1], Points[2], arguments[1]);

                for (var i = 3; (i < Points.length) && (this.test()); i++) {
                    this.calcNormal(Points[i], Points[0], Points[i / 2]);
                }
            }
        },

        test: function () {
            return !vector.isValid(this.normal);
        },

        transform: function (matrix, plan) {
            if (plan.Points != null) {
                for (var i = 0; i < plan.Points.length; i++) {

                    plan.VectorPoints[i] = plan.Points[i] = matrixobj.getMatrixVectorMutiple(matrix, plan.Points[i]);
                }

                this.calcNormal(plan.VectorPoints, plan);
            }
            else {
                var v = matrix * (plan.normal * -plan.d);
                plan.normal = matrixobj.getMatrixVectorAnd(matrix, plan.normal);
                vector.normalize();
                plan.d = -(plan.normal & v);
            }
        },

        getPoint: function (x, y, normal, d) {
            if (typeof x == "number") {
                var z = -(normal.x * x + normal.y * y + d) / normal.z;

                return vector.vector3D(x, y, z);
            }
            else {
                var position = x;
                var ray = y;
                var dir = vector.vector3DMinus(vector.vector3DStarMultiply(normal, (-d)), position);

                var sv = vector.vector3dAND(dir, normal);
                var sect = sv / vector.vector3dAND(normal, ray);

                return vector.vector3DPlus(position, (vector.vector3DStarMultiply(ray * sect)));
            }
        },

        getNormal: function (transform, VectorPoints) {
            var norm;

            if (VectorPoints != null) {
                norm = vector.getNormal(matrixobj.getMatrixVectorMutiple(transform, VectorPoints[0]),
                    matrixobj.getMatrixVectorMutiple(transform, VectorPoints[1]), matrixobj.getMatrixVectorMutiple(transform, VectorPoints[2]))


                for (var i = 3; (i < VectorPoints.length) && !vector.isValid(norm) && VectorPoints[i / 2]; i++) {
                    var v1 = matrixobj.getMatrixVectorMutiple(transform, VectorPoints[i]);
                    var v2 = matrixobj.getMatrixVectorMutiple(transform, VectorPoints[0]);
                    var v3 = matrixobj.getMatrixVectorMutiple(transform, VectorPoints[i / 2]);

                    norm = vector.getNormal(v1, v2, v3);
                }
            }
            else {
                norm = matrixobj.getMatrixVectorAnd(transform);
                vector.normalize();
            }

            return norm;

        },

        createTextElement: function (position, element, xLen, yLen) {

            var vectorColl = [];
            var x = position.x;
            var y = position.y;

            var desiredWidth = element.Width;
            var desiredHeight = element.Height;

            vectorColl[0] = this.vector.vector3D(x, y, position.z);
            vectorColl[1] = this.vector.vector3D(x + desiredWidth, y + desiredHeight + yLen, position.z);
            vectorColl[2] = this.vector.vector3D(x + desiredWidth + xLen, y + desiredHeight + yLen, position.z);
            return this.text3D(element, vectorColl);
        },

        redraw: function () { },

        drawPolyLine: function (panel, sender) {
            var transform = sf.Ej3DRender.transform;
            var pathDirection = sf.EjSvgRender.utils._getStringBuilder();
            var StartPoint = sf.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[0], transform);
            pathDirection.append("M" + " " + (StartPoint.x) + " " + (StartPoint.y) + " ");
            for (var i = 0; i < panel.VectorPoints.length; i++) {
                var lineSegment = sf.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[i], transform);
                pathDirection.append("L" + " " + (lineSegment.x) + " " + (lineSegment.y) + " ");

            }

            var direction = pathDirection.toString();


            var optionsLine = {
                'id': panel.element.id,
                'stroke-dasharray': panel.element.dashArray,
                'stroke-width': panel.element.width,
                'stroke': panel.element.stroke,
                'd': direction
            };
            optionsLine.id = (optionsLine.id).replace(/[^a-zA-Z0-9]/g, "");
            sender.svgRenderer.drawPath(optionsLine, panel.element.child);
        },

        drawLine: function (panel, sender) {

            var transform = sf.Ej3DRender.transform;
            if (transform == null) return;
            var actual3DPosition1 = sf.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[0], transform);
            var actual3DPosition2 = sf.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[2], transform);

            var optionsLine = {
                'id': panel.element.id,
                x1: actual3DPosition1.x,
                y1: actual3DPosition1.y,
                x2: actual3DPosition2.x,
                y2: actual3DPosition2.y,
                'stroke-dasharray': panel.element.dashArray,
                'stroke-width': panel.element.width,
                'stroke': panel.element.stroke,
                'opacity': panel.element.opacity
            };
            optionsLine.id = (optionsLine.id).replace(/[^a-zA-Z0-9]/g, "");
            sender.svgRenderer.drawLine(optionsLine, panel.element.child);


        },
        drawTemplate: function (panel, sender) {
            var element = panel.element;
            var transform = sf.Ej3DRender.transform;
            if (transform == null) return;
            var actual3DPosition = sf.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[0], transform);
            sf.EjSeriesRender.prototype.drawLabelTemplate(element.Label.series, element.Label.series.points[element.Label.pointIndex], element.Label.pointIndex, { X: actual3DPosition.x, Y: actual3DPosition.y }, sender)
        },
        drawText: function (panel, sender) {

            var element = panel.element;
            var transform = sf.Ej3DRender.transform;
            if (transform == null) return;
            var actual3DPosition = sf.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[0], transform);
            var x = actual3DPosition.x;
            var y = actual3DPosition.y;

            if (element.tag == "text") {
                var options = {
                    'id': element.id,
                    'x': x,
                    'y': y,
                    'fill': element.font.color,
                    'font-size': element.font.size,
                    'font-family': element.font.fontFamily,
                    'font-style': element.font.fontStyle,
                    'font-weight': element.font.fontWeight,
                    'opacity': element.font.opacity,
                    'text-anchor': element.TextAnchor,
                    "cursor": "default",
                    'transform': element.Angle ? 'rotate(' + element.Angle + ',' + (x) + ',' + y + ')' : null
                };

                sender.svgRenderer.drawText(options, panel.element.Label.Text, panel.element.child, panel.element.font);
            }
            else {
                var series = element.series;

                var labelFormat = (series.yAxis && series.yAxis.labelFormat) ? series.yAxis.labelFormat : "";
                var pointText = (element.point.text) ? element.point.text : element.point.y + labelFormat.substring(labelFormat.indexOf('}') + 1);
                var textOffset = sf.EjSvgRender.utils._measureText(pointText, null, series.marker.dataLabel.font);
                var margin = series.marker.dataLabel.margin;
                var width = textOffset.width + margin.left + margin.right;
                var height = textOffset.height + margin.top + margin.bottom;
                var location = { X: actual3DPosition.x, Y: actual3DPosition.y }, symbolName;


                if (series.marker.dataLabel.shape)
                    var elementShape = series.marker.dataLabel.shape;
                else if (series.marker.dataLabel.shape)
                    elementShape = series.marker.dataLabel.shape;
                else
                    elementShape = "None";

                $.each(sender.model.symbolShape, function (name) {
                    if (elementShape.toLowerCase() == name.toLowerCase())
                        symbolName = name;
                });

                var xXalue = location.X - (margin.left) / 2 + (margin.right) / 2;
                var yValue = location.Y - (margin.top) / 2 - (height / margin.top) + (margin.bottom) / 2;

                var seriesIndex = $.inArray(series, sender.model.series);
                sf.EjSeriesRender.prototype.dataLabelSymbol(seriesIndex, series, element.pointIndex, xXalue, yValue, width, height, symbolName, sender);

            }

        },

        draw: function (panel, sender) {
            if (panel.VectorPoints == null || panel.VectorPoints.length <= 0) return;
            var transform = sf.Ej3DRender.transform;
            var pathDirection = sf.EjSvgRender.utils._getStringBuilder();
            var color = panel.Fill;
            var format = sender.svgRenderer.checkColorFormat(color);
            if (!format)
                color = sender.colorNameToHex(color);
            var figure = { Segments: null, StartPoint: null };
            if (transform != null) {
                figure.StartPoint = sf.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[0], transform);
                pathDirection.append("M" + " " + (figure.StartPoint.x) + " " + (figure.StartPoint.y) + " ");
                for (var i = 0; i < panel.VectorPoints.length; i++) {
                    var lineSegment = sf.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[i], transform);
                    pathDirection.append("L" + " " + (lineSegment.x) + " " + (lineSegment.y) + " ");

                }
            }

            var direction = pathDirection.toString();

            var name = "Light";
            var lightCoefZ = (2 * (Math.abs(vector.vector3dAND(panel.normal, vector.vector3D(0, 0, 1))) - 1));
            var lightCoefY = (2 * (Math.abs(vector.vector3dAND(panel.normal, vector.vector3D(0, 1, 0))) - 1));
            var lightCoefX = (2 * (Math.abs(vector.vector3dAND(panel.normal, vector.vector3D(1, 0, 0))) - 1));
            if (lightCoefZ == lightCoefX) {
                name = "ZLight";
                color = this.applyZLight(color, sender);
            }
            else if (((lightCoefY == lightCoefZ) || (lightCoefZ != 0 && lightCoefY < lightCoefZ))) {
                name = "XLight";
                color = this.applyXLight(color, sender);
            }
            else if (lightCoefZ < 0) {
                name = "ZLight";
                color = this.applyZLight(color, sender);
            }
            else {
                name = "Light";
                color = color;
            }
            if (sender.model.AreaType == "none")
                panel.StrokeThickness = 0;
            var optionsMinorGrid = {
                'id': sender.svgObject.id + "_" + panel.Name,
                'name': name,
                'fill': color,
                'stroke': panel.Stroke,
                'stroke-width': panel.StrokeThickness,
                'opacity': panel.Opacity,
                'd': direction
            };
            sender.svgRenderer.drawPath(optionsMinorGrid, panel.Element.Parent);
            if (sender.model.previousID && sender.model.touchCross)
                $("#" + optionsMinorGrid.id).insertAfter($("#" + sender.model.previousID));

            sender.model.previousID = optionsMinorGrid.id;
        },

        applyXLight: function (color, sender) {
            var RGB = sender.svgRenderer.hexToRGB(color);
            RGB.R = (parseInt)(RGB.R * 0.7);
            RGB.G = (parseInt)(RGB.G * 0.7);
            RGB.B = (parseInt)(RGB.B * 0.7);
            return sender.svgRenderer.hexFromRGB(RGB);
        },

        applyZLight: function (color, sender) {
            var RGB = sender.svgRenderer.hexToRGB(color);
            RGB.R = (parseInt)(RGB.R * 0.9);
            RGB.G = (parseInt)(RGB.G * 0.9);
            RGB.B = (parseInt)(RGB.B * 0.9);
            return sender.svgRenderer.hexFromRGB(RGB);
        },

        update: function (updatedVectors, panel, sender) {
            if (panel.VectorPoints == null || panel.VectorPoints.length <= 0) return;
            panel.VectorPoints = updatedVectors;
            var transform = sf.Ej3DRender.transform;
            var pathDirection = sf.EjSvgRender.utils._getStringBuilder();
            var color = panel.Fill;
            var figure = { Segments: null, StartPoint: null };
            if (transform != null) {
                figure.StartPoint = sf.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[0], transform);
                pathDirection.append("M" + " " + (figure.StartPoint.x) + " " + (figure.StartPoint.y) + " ");
                for (var i = 0; i < panel.VectorPoints.length; i++) {
                    var lineSegment = sf.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[i], transform);
                    pathDirection.append("L" + " " + (lineSegment.x) + " " + (lineSegment.y) + " ");

                }
            }

            var direction = pathDirection.toString();

            if ($(sender.chartObj.chart3D).find("#" + sender.chartObj.svgObject.id + "_" + panel.Name).length > 0) {
                var element = $(sender.chartObj.chart3D).find("#" + sender.chartObj.svgObject.id + "_" + panel.Name)[0];
                sender.chartObj.svgRenderer._setAttr($(element), { 'd': direction });

            }

        }


    }
    var Ej3DRender = new sf.Ej3DRender();
    var vector = new Ej3DRender.vector3D();
    var matrixobj = new Ej3DRender.matrix3D();
    var bsptreeobj = new Ej3DRender.BSPTreeBuilder();
    var polygonobj = new Ej3DRender.polygon3D();
    var graphics = new Ej3DRender.Graphics3D();


})(jQuery);;
/* global jQuery, sf, window, document, navigator, clearInterval, setInterval */
sf.EjSvgScrollbarRender = function (element, scrollObj) {
    this.svgSupport = (window.SVGSVGElement) ? true : false;
    var id = jQuery(element).attr("id");
    this.scrollsvgObj = this.scrollsvgObj ? this.scrollsvgObj : [];
    if (this.svgSupport) {
        this.svgLink = "http://www.w3.org/2000/svg";
        this.scrollsvgObj[scrollObj.index] = document.createElementNS(this.svgLink, "svg");
        this.scrollsvgObj[scrollObj.index].setAttribute('id', "scrollbar_" + id + scrollObj.index);
    } else {
        var doc = document;
        this.scrollsvgObj[scrollObj.index] = doc.createElement("div");
        this.scrollsvgObj[scrollObj.index].style.position = 'relative';
        this.scrollsvgObj[scrollObj.index].setAttribute('id', "scrollbar_" + id + scrollObj.index);
    }
};

(function ($) {
    sf.EjSvgScrollbarRender.prototype = {

        _initializeScrollbarVariables: function (scrollObj) {
            scrollObj.offsetLeftX = 0
            scrollObj.rectWidth = scrollObj.offsetRightX = scrollObj.oldWidth = scrollObj.width;
            scrollObj.startX = 0, scrollObj.endX = 0;
            scrollObj.scrollbarLoaded = false;

            if (scrollObj.zoomPosition || scrollObj.zoomFactor) {
                scrollObj.offsetLeftX = (scrollObj.zoomPosition * scrollObj.width);
                scrollObj.rectWidth = (scrollObj.zoomFactor) * scrollObj.width;
            }
        },

        _scrollbarUpdate: function (scrollObj) {

            var width = parseFloat(scrollObj.width),
                arrowsize = 15,
                minimumRect = 44,
                panningRect = width - 30;// arrowSize * 2 
            scrollObj.offsetLeftX = !scrollObj.scrollbarLoaded ? scrollObj.offsetLeftX : (scrollObj.offsetLeftX - arrowsize);
            scrollObj.offsetLeftX = scrollObj.offsetLeftX < arrowsize ? 0 : scrollObj.offsetLeftX;
            var offsetLeftX = ((scrollObj.offsetLeftX / scrollObj.oldWidth) * panningRect) + arrowsize;
            var rectWidth = ((scrollObj.rectWidth / scrollObj.oldWidth) * panningRect),
            isMinWidth = rectWidth < minimumRect;
            scrollObj._diff = isMinWidth ? minimumRect - rectWidth : 0;
            rectWidth = rectWidth > minimumRect ? rectWidth : minimumRect;
            scrollObj.oldWidth = panningRect;
            var offsetRightX = offsetLeftX + rectWidth;
            scrollObj.rectWidth = rectWidth;
            scrollObj.offsetLeftX = scrollObj.startX = offsetLeftX;
            scrollObj.offsetRightX = (offsetRightX - arrowsize) <= offsetLeftX ? (offsetRightX + arrowsize) : offsetRightX;
            scrollObj.endX = scrollObj.width - scrollObj.offsetRightX;
            scrollObj.startX = offsetLeftX < arrowsize ? arrowsize : offsetLeftX;
            if ((offsetLeftX + rectWidth) > (scrollObj.width - arrowsize)) {
                scrollObj.offsetLeftX = scrollObj.startX = scrollObj.width - arrowsize - rectWidth;
                scrollObj.offsetRightX = scrollObj.width - arrowsize;
                scrollObj.endX = scrollObj.width - scrollObj.offsetRightX;
            }
            scrollObj.scrollbarLoaded = true;

        },

        _renderScrollbar: function (scrollObj) {

            this.scrollsvgObj = this.scrollsvgObj ? this.scrollsvgObj : [];
            $(this.scrollsvgObj[scrollObj.index]).empty();
            if (this.scrollsvgObj[scrollObj.index])
                $(document).find('[id*= ' + this.scrollsvgObj[scrollObj.index].id + ']').attr('height', '0px');
            var id = this._id;
            var arrowSize = 15;
            var scrollHeight = 18;
            var minimumScrollSize = 44;
            this.scrollsvgObj[scrollObj.index] = this.scrollbarContainer.scrollsvgObj[scrollObj.index];
            var height = 17, width = parseFloat(scrollObj.width), padding = 8, centerY = (height / 2), panningRect = width - (arrowSize * 2);
            scrollObj.offsetLeftX = !scrollObj.scrollbarLoaded ? scrollObj.offsetLeftX : (scrollObj.offsetLeftX - arrowSize);
            scrollObj.offsetLeftX = scrollObj.offsetLeftX < arrowSize ? 0 : scrollObj.offsetLeftX;
            var offsetLeftX = ((scrollObj.offsetLeftX / scrollObj.oldWidth) * panningRect) + arrowSize;
            var rectWidth = ((scrollObj.rectWidth / scrollObj.oldWidth) * panningRect),
            isMinWidth = rectWidth < minimumScrollSize;
            scrollObj._diff = isMinWidth ? minimumScrollSize - rectWidth : 0;
            rectWidth = rectWidth > minimumScrollSize ? rectWidth : minimumScrollSize;
            scrollObj.oldWidth = panningRect;
            offsetLeftX = ((offsetLeftX + rectWidth) > panningRect) ? (panningRect - (rectWidth - arrowSize)) : offsetLeftX;
            var offsetRightX = offsetLeftX + rectWidth;
            scrollObj.rectWidth = rectWidth;
            scrollObj.offsetLeftX = scrollObj.startX = offsetLeftX;
            scrollObj.offsetRightX = offsetLeftX + rectWidth;
            scrollObj.endX = scrollObj.width - scrollObj.offsetRightX;
            scrollObj.scrollbarLoaded = true;
            offsetRightX = (offsetRightX - arrowSize) <= offsetLeftX ? (offsetRightX + arrowSize) : offsetRightX;
            var xPadding = this.padding || 0;
            var yPadding = !this.vmlRendering ? 0 : -5;
            if (scrollObj.orientation == 'horizontal')
                this.scrollbar = this.renderer.createGroup({ 'id': id + '_scrollbar' + '_' + scrollObj.index, transform: "translate(" + xPadding + "," + yPadding + ")" });
            else
                this.scrollbar = this.renderer.createGroup({ 'id': id + '_scrollbar' + '_' + scrollObj.index, transform: "translate(" + 0 + "," + scrollObj.width + ") rotate(270)" });
            //Draw a rounded corner path direction
            var makeShape = function (x, y, width, height, r, scrollObj) {
                var
                    spc = " ", // path drawing instruction letters with readable names
                    moveTo = "M",
                    horizLineTo = "h",
                    vertLineTo = "v",
                    arcTo = "a",
                    closePath = "z",
                    ori = scrollObj.orientation,
                    opp = scrollObj.opposed,
                    dStr;
                if ((ori == 'vertical' && !opp) || (opp && ori != 'vertical')) {
                    dStr = // the "d" path for the svg path
                        moveTo + spc + x + spc + r + spc +
                        vertLineTo + spc + (height - r) + spc +
                        horizLineTo + spc + (width) + spc +
                        vertLineTo + spc + (r - height) + spc +
                        arcTo + spc + r + spc + r + spc + 0 + spc + 0 + spc + 0 + spc + (-r) + spc + (-r) + spc +
                        horizLineTo + spc + -(width - 2 * r) + spc +
                        arcTo + spc + r + spc + r + spc + 0 + spc + 0 + spc + 0 + spc + (-4) + spc + (r) + spc +
                        closePath;

                } else {
                    dStr = // the "d" path for the svg path
                        moveTo + spc + x + spc + y + spc +
                        vertLineTo + spc + (height - r) + spc +
                        arcTo + spc + r + spc + r + spc + 0 + spc + 0 + spc + 0 + spc + r + spc + r + spc +
                        horizLineTo + spc + (width - 2 * r) + spc +
                        arcTo + spc + r + spc + r + spc + 0 + spc + 0 + spc + 0 + spc + r + spc + (-r) + spc +
                        vertLineTo + spc + (r - height) + spc +
                        closePath;
                }

                return dStr;
            };
            var direction = makeShape(0, 0, width, scrollHeight, 4, scrollObj);

            //Create a scrollbar background rectangle
            var rectBorder = {
                'id': id + '_scrollbarBackRect_' + scrollObj.index,
                'stroke-width': 1,
                'height': scrollHeight,
                'width': width,
                'stroke-linejoin': "round",
                'stroke': "#B4B4B4",
                'fill': "#F7F7F7",
                'class': 'e-rangeScroll-backRect'
            };

            if (!this.vmlRendering) {
                rectBorder.d = direction;
                this.renderer.drawPath(rectBorder, this.scrollbar);
            } else
                this.renderer.drawRect(rectBorder, this.scrollbar);

            var rightRectBorder = {
                'id': id + '_scrollbarRightRect_' + scrollObj.index,
                'stroke-width': 1,
                'x': (width - 5),
                'height': scrollHeight,
                'width': 5,
                'stroke-linejoin': "round",
                'stroke': "transparent",
                'fill': "transparent"
            };
            this.renderer.drawRect(rightRectBorder, this.scrollbar);

            var leftRectBorder = {
                'id': id + '_scrollbarLeftRect_' + scrollObj.index,
                'stroke-width': 1,
                'x': 0,
                'height': scrollHeight,
                'width': 5,
                'stroke-linejoin': "round",
                'stroke': "transparent",
                'fill': "transparent"
            };
            this.renderer.drawRect(leftRectBorder, this.scrollbar);

            //Create a left Arrow
            var leftArrow = {
                'id': id + '_scrollbarLeftArrow_' + scrollObj.index,
                'stroke-width': 1,
                'stroke': "#999999",
                'd': "M " + 5 + " " + 9 + " " + "L " + 10 + " " + 14 + " " + "L " + 10 + " " + 3.5 + " Z",
                'fill': "#999999",
                'class': "e-rangeScroll-arrow"
            };
            this.renderer.drawPath(leftArrow, this.scrollbar);

            ////Create a right Arrow
            var rightArrow = {
                'id': id + '_scrollbarRightArrow_' + scrollObj.index,
                'stroke-width': 1,
                'stroke': "#999999",
                'd': "M " + (width - 5) + " " + 9 + " " + "L " + (width - 10) + " " + 14 + " " + "L " + (width - 10) + " " + 3.5 + " Z",
                'fill': "#999999",
                'class': "e-rangeScroll-arrow"
            };
            this.renderer.drawPath(rightArrow, this.scrollbar);

            var options = {
                'id': id + '_scrollbarSelect_' + scrollObj.index,
                x: offsetLeftX,
                y: 0,
                'width': rectWidth,
                'rx': 4,
                'ry': 4,
                'height': height,
                'stroke': "#999999",
                'stroke-width': 1,
                'fill': "#CECECE",
                'class': 'e-rangeScroll-select'
            };
            this.renderer.drawRect(options, this.scrollbar);
            this.centerLine = this.renderer.createGroup({ 'id': id + '_scrollbarCenterLine_' + scrollObj.index, transform: "translate(" + (offsetLeftX + (rectWidth / 2) - 7.5) + ")" });

            //Create a center shape
            var shape = {
                'id': id + '_scrollbarCenterShape_' + scrollObj.index,
                'stroke-width': 1,
                'stroke': "#999999",
                'd': "M " + 0 + " " + 3.5 + " " + "L " + 0 + " " + 13.5 + " Z" + "M " + 5 + " " + 3.5 + " " + "L " + 5 + " " + 13.5 + " Z" + "M " + 10 + " " + 3.5 + " " + "L " + 10 + " " + 13.5 + " Z" + "M " + 15 + " " + 3.5 + " " + "L " + 15 + " " + 13.5 + " Z",
                'fill': "#999999",
                'class': 'e-rangeScroll-centerShape'
            };
            this.renderer.drawPath(shape, this.centerLine);
            this.renderer.append(this.centerLine, this.scrollbar);
            var leftHeaderHideRectOptions = {
                'id': id + '_leftHeaderHideRect_' + scrollObj.index,
                'x': offsetLeftX,
                'y': 0,
                'width': 11,
                'height': 17,
                'fill': 'transparent',
                'opacity': 0,
                'stroke-width': 1,
                'class': 'e-rangeScroll-leftRect'
            }
            this.renderer.drawRect(leftHeaderHideRectOptions, this.scrollbar);
            var leftHeaderOptions = {
                'id': id + '_scrollbarLeftHeader_' + scrollObj.index,
                'cx': offsetLeftX + padding,
                'cy': centerY,
                'r': 3,
                "fill": "#999999",
                'stroke': "#999999",
                'stroke-width': 1,
                'class': 'e-rangeScroll-leftCircle'
            };
            this.renderer.drawCircle(leftHeaderOptions, this.scrollbar);
            var rightHeaderHideRectOptions = {
                'id': id + '_rightHeaderHideRect_' + scrollObj.index,
                'x': offsetRightX - 11,
                'y': 0,
                'width': 11,
                'height': height,
                'fill': 'transparent',
                'opacity': 0,
                'stroke-width': 1,
                'class': 'e-rangeScroll-rightRect'
            };
            this.renderer.drawRect(rightHeaderHideRectOptions, this.scrollbar);
            var rightHeaderOptions = {
                'id': id + '_scrollbarRightHeader_' + scrollObj.index,
                "fill": "#999999",
                'cx': offsetRightX - padding,
                'cy': centerY,
                'r': 3,
                'stroke': "#999999",
                'stroke-width': 1,
                'class': 'e-rangeScroll-rightCircle'
            };
            this.renderer.drawCircle(rightHeaderOptions, this.scrollbar);

            this.renderer.append(this.scrollbar, this.scrollsvgObj[scrollObj.index]);
            if (scrollObj.orientation == 'horizontal') {
                this.scrollsvgObj[scrollObj.index].setAttribute("height", scrollHeight);
                this.scrollsvgObj[scrollObj.index].setAttribute("width", width);
            } else {
                this.scrollsvgObj[scrollObj.index].setAttribute("height", width);
                this.scrollsvgObj[scrollObj.index].setAttribute("width", scrollHeight);
            }
            this.renderer.append(this.scrollsvgObj[scrollObj.index], scrollObj.parent);

            //Apply CSS styles to scrollbar controls          
            var vmlPadding = !this.vmlRendering ? scrollObj.y : scrollObj.y + 5;
            if (this.pluginName == "ejRangeNavigator")
                this.scrollsvgObj[scrollObj.index].setAttribute('style', 'overflow:visible;position:relative;display:block; top:' + (vmlPadding - scrollObj.y) + 'px;' + 'left:' + scrollObj.x + 'px');
            else
                this.scrollsvgObj[scrollObj.index].setAttribute('style', 'overflow:visible;position:absolute;display:block; top:' + vmlPadding + 'px;' + 'left:' + scrollObj.x + 'px');
            $("#" + id + "_scrollbarSelect_" + scrollObj.index).css({ "cursor": "pointer" });
            if (scrollObj.enableResize) {
                $("#" + id + "_leftHeaderHideRect_" + scrollObj.index).css({ "cursor": scrollObj.orientation == 'horizontal' ? "w-resize" : "n-resize" });
                $("#" + id + "_rightHeaderHideRect_" + scrollObj.index).css({ "cursor": scrollObj.orientation == 'horizontal' ? "w-resize" : "n-resize" });
                $("#" + id + "_scrollbarRightHeader_" + scrollObj.index).css({ "cursor": scrollObj.orientation == 'horizontal' ? "w-resize" : "n-resize" });
                $("#" + id + "_scrollbarLeftHeader_" + scrollObj.index).css({ "cursor": scrollObj.orientation == 'horizontal' ? "w-resize" : "n-resize" });
            } else {
                $("#" + id + "_leftHeaderHideRect_" + scrollObj.index).hide();
                $("#" + id + "_rightHeaderHideRect_" + scrollObj.index).hide();
                $("#" + id + '_scrollbarLeftHeader_' + scrollObj.index).hide();
                $("#" + id + '_scrollbarRightHeader_' + scrollObj.index).hide();
            }

            if (this.vmlRendering) {
                $('#' + id + '_leftHeaderHideRect_' + scrollObj.index).css("visibility", 'hidden');
                $('#' + id + '_rightHeaderHideRect_' + scrollObj.index).css("visibility", 'hidden');
            }

            this.scrollbarContainer._bindScrollEvents.call(this, scrollObj);
        },

        _bindScrollEvents: function (scrollObj) {
            //Binding Mouse Events to scrollbar
            var rootId = this._id;
            var matched = jQuery.uaMatch(navigator.userAgent);
            var isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
            bindDesktopEvents.call(this, scrollObj);
            if (window.PointerEvent) { //Added pointer event for IE11

                this._on($('#' + rootId + '_scrollbarLeftHeader_' + scrollObj.index), "pointerdown", this.scrollbarContainer._leftScrollbarDown);
                this._on($('#' + rootId + '_scrollbarRightHeader_' + scrollObj.index), "pointerdown", this.scrollbarContainer._rightScrollbarDown);

                this._on($('#' + rootId + '_leftHeaderHideRect_' + scrollObj.index), "pointerdown", this.scrollbarContainer._leftScrollbarDown);
                this._on($('#' + rootId + '_rightHeaderHideRect_' + scrollObj.index), "pointerdown", this.scrollbarContainer._rightScrollbarDown);

                this._on($('#' + rootId + '_scrollbarLeftArrow_' + scrollObj.index), "pointerdown", this.scrollbarContainer._leftArrowDown);
                this._on($('#' + rootId + '_scrollbarLeftArrow_' + scrollObj.index), "pointerup", this.scrollbarContainer._leftArrowUp);

                this._on($('#' + rootId + '_scrollbarRightArrow_' + scrollObj.index), "pointerdown", this.scrollbarContainer._rightArrowDown);
                this._on($('#' + rootId + '_scrollbarRightArrow_' + scrollObj.index), "pointerup", this.scrollbarContainer._rightArrowUp);

                this._on($('#' + rootId + '_scrollbarSelect_' + scrollObj.index), "pointerdown", this.scrollbarContainer._scrollSelectRectDown);
                this._on($('#' + rootId + '_scrollbarBackRect_' + scrollObj.index), "pointerdown", this.scrollbarContainer._scrollBackRectDown);
                this._on($('#' + rootId + '_scrollbarBackRect_' + scrollObj.index), "pointerup", this.scrollbarContainer._scrollBackRectUp);

                this._on($(window), "pointermove", this.scrollbarContainer._scrollbarMove);
                this._on($(window), "pointerup", this.scrollbarContainer._scrollbarUp);
                this._on($(this.scrollsvgObj[scrollObj.index]), "pointermove", this.scrollbarContainer._scrollbarMove);
                this._on($(this.scrollsvgObj[scrollObj.index]), "pointerup", this.scrollbarContainer._scrollbarUp);

                $(this.scrollsvgObj[scrollObj.index]).css('touch-action', 'none');
            }
            else if (window.navigator.msPointerEnabled && !isIE11) {

                this._on($('#' + rootId + '_scrollbarLeftHeader_' + scrollObj.index), "MSPointerDown", this.scrollbarContainer._leftScrollbarDown);
                this._on($('#' + rootId + '_scrollbarRightHeader_' + scrollObj.index), "MSPointerDown", this.scrollbarContainer._rightScrollbarDown);

                this._on($('#' + rootId + '_leftHeaderHideRect_' + scrollObj.index), "MSPointerDown", this.scrollbarContainer._leftScrollbarDown);
                this._on($('#' + rootId + '_rightHeaderHideRect_' + scrollObj.index), "MSPointerDown", this.scrollbarContainer._rightScrollbarDown);

                this._on($('#' + rootId + '_scrollbarLeftArrow_' + scrollObj.index), "MSPointerDown", this.scrollbarContainer._leftArrowDown);
                this._on($('#' + rootId + '_scrollbarLeftArrow_' + scrollObj.index), "MSPointerUp", this.scrollbarContainer._leftArrowUp);

                this._on($('#' + rootId + '_scrollbarRightArrow_' + scrollObj.index), "MSPointerDown", this.scrollbarContainer._rightArrowDown);
                this._on($('#' + rootId + '_scrollbarRightArrow_' + scrollObj.index), "MSPointerUp", this.scrollbarContainer._rightArrowUp);

                this._on($('#' + rootId + '_scrollbarSelect_' + scrollObj.index), "MSPointerDown", this.scrollbarContainer._scrollSelectRectDown);
                this._on($('#' + rootId + '_scrollbarBackRect_' + scrollObj.index), "MSPointerDown", this.scrollbarContainer._scrollBackRectDown);
                this._on($('#' + rootId + '_scrollbarBackRect_' + scrollObj.index), "MSPointerUp", this.scrollbarContainer._scrollBackRectUp);

                this._on($(window), "MSPointerMove", this.scrollbarContainer._scrollbarMove);
                this._on($(window), "MSPointerUp", this.scrollbarContainer._scrollbarUp);
                this._on($(this.scrollsvgObj[scrollObj.index]), "MSPointerMove", this.scrollbarContainer._scrollbarMove);
                this._on($(this.scrollsvgObj[scrollObj.index]), "MSPointerUp", this.scrollbarContainer._scrollbarUp);

                $(this.scrollsvgObj[scrollObj.index]).css('-ms-touch-action', 'none');

            } else if (matched.browser.toLowerCase() == "chrome") {
                bindTouchEvents.call(this, scrollObj);
            } else if (this.isDevice()) {

                var isSafari = (navigator.userAgent.indexOf('Safari') != -1 && navigator.userAgent.indexOf('Chrome') == -1);
                var isInIframe = (window.location != window.parent.location) ? true : false;
                var userAgent = isInIframe ? window.parent.navigator.userAgent.toLowerCase() : window.navigator.userAgent.toLowerCase();
                var device = /mobile|tablet|android|kindle/i.test(userAgent);
                if ((sf.isMobile() && this.isWindows()) || (!device && sf.isMobile() && isSafari)) { // for safari mobile browser and windows phone                    
                    bindDesktopEvents.call(this);
                    $(this.scrollsvgObj[scrollObj.index]).css('-ms-touch-action', 'none');
                } else
                    bindTouchEvents.call(this, scrollObj);
            }
            var eventName = matched.browser.toLowerCase() == "mozilla" ? (isIE11 ? "mousewheel" : "DOMMouseScroll") : "mousewheel";
            this._on($(this.scrollsvgObj[scrollObj.index]), eventName, this.scrollbarContainer._scrollMouseWheel);

            if (isIE11)
                $(this.scrollsvgObj[scrollObj.index]).css('touch-action', 'none');

            function bindDesktopEvents(scrollObj) {
                this._on($('#' + rootId + '_scrollbarLeftHeader_' + scrollObj.index), "mousedown", this.scrollbarContainer._leftScrollbarDown);
                this._on($('#' + rootId + '_scrollbarRightHeader_' + scrollObj.index), "mousedown", this.scrollbarContainer._rightScrollbarDown);

                this._on($('#' + rootId + '_leftHeaderHideRect_' + scrollObj.index), "mousedown", this.scrollbarContainer._leftScrollbarDown);
                this._on($('#' + rootId + '_rightHeaderHideRect_' + scrollObj.index), "mousedown", this.scrollbarContainer._rightScrollbarDown);

                this._on($('#' + rootId + '_scrollbarLeftArrow_' + scrollObj.index), "mousedown", this.scrollbarContainer._leftArrowDown);
                this._on($('#' + rootId + '_scrollbarLeftArrow_' + scrollObj.index), "mouseup", this.scrollbarContainer._leftArrowUp);

                this._on($('#' + rootId + '_scrollbarRightArrow_' + scrollObj.index), "mousedown", this.scrollbarContainer._rightArrowDown);
                this._on($('#' + rootId + '_scrollbarRightArrow_' + scrollObj.index), "mouseup", this.scrollbarContainer._rightArrowUp);

                this._on($('#' + rootId + '_scrollbarSelect_' + scrollObj.index), "mousedown", this.scrollbarContainer._scrollSelectRectDown);
                this._on($('#' + rootId + '_scrollbarBackRect_' + scrollObj.index), "mousedown", this.scrollbarContainer._scrollBackRectDown);
                this._on($('#' + rootId + '_scrollbarBackRect_' + scrollObj.index), "mouseup", this.scrollbarContainer._scrollBackRectUp);

                this._on($(window), "mousemove", this.scrollbarContainer._scrollbarMove);
                this._on($(window), "mouseup", this.scrollbarContainer._scrollbarUp);
                this._on($(this.svgObject), "mousemove", this.scrollbarContainer._scrollbarMove);
                this._on($(this.scrollsvgObj[scrollObj.index]), "mousemove", this.scrollbarContainer._scrollbarMove);
                this._on($(this.scrollsvgObj[scrollObj.index]), "mouseup", this.scrollbarContainer._scrollbarUp);
            }

            function bindTouchEvents(scrollObj) {
                this._on($('#' + rootId + '_scrollbarLeftHeader_' + scrollObj.index), "touchstart", this.scrollbarContainer._leftScrollbarDown);
                this._on($('#' + rootId + '_scrollbarRightHeader_' + scrollObj.index), "touchstart", this.scrollbarContainer._rightScrollbarDown);

                this._on($('#' + rootId + '_leftHeaderHideRect_' + scrollObj.index), "touchstart", this.scrollbarContainer._leftScrollbarDown);
                this._on($('#' + rootId + '_rightHeaderHideRect_' + scrollObj.index), "touchstart", this.scrollbarContainer._rightScrollbarDown);

                this._on($('#' + rootId + '_scrollbarLeftArrow_' + scrollObj.index), "touchstart", this.scrollbarContainer._leftArrowDown);
                this._on($('#' + rootId + '_scrollbarLeftArrow_' + scrollObj.index), "touchend", this.scrollbarContainer._leftArrowUp);

                this._on($('#' + rootId + '_scrollbarRightArrow_' + scrollObj.index), "touchstart", this.scrollbarContainer._rightArrowDown);
                this._on($('#' + rootId + '_scrollbarRightArrow_' + scrollObj.index), "touchend", this.scrollbarContainer._rightArrowUp);

                this._on($('#' + rootId + '_scrollbarSelect_' + scrollObj.index), "touchstart", this.scrollbarContainer._scrollSelectRectDown);
                this._on($('#' + rootId + '_scrollbarBackRect_' + scrollObj.index), "touchstart", this.scrollbarContainer._scrollBackRectDown);
                this._on($('#' + rootId + '_scrollbarBackRect_' + scrollObj.index), "touchend", this.scrollbarContainer._scrollBackRectUp);

                this._on($(window), "touchmove", this.scrollbarContainer._scrollbarMove);
                this._on($(window), "touchend", this.scrollbarContainer._scrollbarUp);
                this._on($(this.scrollsvgObj[scrollObj.index]), "touchmove", this.scrollbarContainer._scrollbarMove);
                this._on($(this.scrollsvgObj[scrollObj.index]), "touchend", this.scrollbarContainer._scrollbarUp);

            }
        },

        _setScrollPosition: function (startX, offsetRightX, scrollObj) {
            var padding = 8;
            var rootId = this._id;
            var centerLine = (startX + (scrollObj.rectWidth / 2) - 7.5);
            $('#' + rootId + '_scrollbarLeftHeader_' + scrollObj.index).attr("cx", startX + padding);
            $('#' + rootId + '_leftHeaderHideRect_' + scrollObj.index).attr("x", startX);

            $('#' + rootId + '_scrollbarRightHeader_' + scrollObj.index).attr("cx", offsetRightX - padding);
            $('#' + rootId + '_rightHeaderHideRect_' + scrollObj.index).attr("x", offsetRightX - 5);
            $('#' + rootId + '_scrollbarSelect_' + scrollObj.index).attr("x", startX);
            $('#' + rootId + '_scrollbarSelect_' + scrollObj.index).attr("width", scrollObj.rectWidth);
            $('#' + rootId + '_scrollbarCenterLine_' + scrollObj.index).attr('transform', 'translate(' + centerLine + ')');
            //Apply styles for VML support
            if (this.pluginName == "ejRangeNavigator") {
                $('#' + rootId + '_scrollbarLeftHeader_' + scrollObj.index).css("left", startX);
                $('#' + rootId + '_leftHeaderHideRect_' + scrollObj.index).css("left", startX);
                $('#' + rootId + '_scrollbarRightHeader_' + scrollObj.index).css("left", offsetRightX - padding);
                $('#' + rootId + '_rightHeaderHideRect_' + scrollObj.index).css("left", offsetRightX - 5);
                $('#' + rootId + '_scrollbarSelect_' + scrollObj.index).css("left", startX);
                $('#' + rootId + '_scrollbarCenterLine_' + scrollObj.index).css('left', centerLine);
            }
        },
        _calculateScrollLeftMove: function (moveLength, scrollObj) {

            if (scrollObj._startX - moveLength > 15) {
                scrollObj.startX = scrollObj._startX - moveLength;
                scrollObj.offsetLeftX = scrollObj.startX;
                scrollObj._offsetRightX = scrollObj.startX + scrollObj.rectWidth;
                scrollObj.offsetRightX = scrollObj._offsetRightX;
                scrollObj.endX = scrollObj.width - scrollObj.offsetRightX;
            } else {
                scrollObj.startX = 15;
                scrollObj._offsetLeftX = scrollObj.offsetLeftX;
                scrollObj.offsetLeftX = scrollObj.startX;
                scrollObj._offsetRightX = scrollObj.startX + scrollObj.rectWidth;
                scrollObj.offsetRightX = scrollObj._offsetRightX;
                scrollObj.endX = scrollObj.width - scrollObj.offsetRightX;
            }
        },
        _calculateScrollRightMove: function (moveLength, scrollObj) {
            if (scrollObj && (scrollObj._offsetRightX + (Math.abs(moveLength))) < scrollObj.width - 15) {
                scrollObj._startX = scrollObj.startX + Math.abs(moveLength);
                scrollObj.offsetLeftX = scrollObj._startX;
                scrollObj.offsetRightX = scrollObj._offsetRightX + Math.abs(moveLength);
                scrollObj.endX = scrollObj.width - scrollObj.offsetRightX;
            } else {
                scrollObj._ofsetRightX = scrollObj.offsetRightX;
                scrollObj.offsetRightX = scrollObj.width - 15;
                scrollObj._startX = scrollObj.offsetRightX - scrollObj.rectWidth;
                scrollObj.offsetLeftX = scrollObj._startX;
                scrollObj.endX = scrollObj.width - scrollObj.offsetRightX;
            }
        },
        _calculateRange: function (startX, endX, scrollObj) {

            var zoomPos, zoomFactor, scrollRange, start, end, padding = 30, startArgs, endArgs;

            //Modify scrollbar center rectangle position on mouse move
            zoomPos = (startX - 15) / (scrollObj.width - padding - scrollObj._diff);
            scrollRange = scrollObj.scrollRange;
            zoomFactor = ((scrollObj.rectWidth - scrollObj._diff) / (scrollObj.width - padding - scrollObj._diff));
            if (!scrollObj.isRTL) {
                start = scrollRange.min + zoomPos * scrollRange.delta;
                end = start + zoomFactor * scrollRange.delta;
            } else {
                end = scrollRange.max - zoomPos * scrollRange.delta;
                start = end - zoomFactor * scrollRange.delta;
            }
            if (scrollObj.valueType == "datetime") {
                startArgs = scrollObj.startDateTime;
                endArgs = scrollObj.endDateTime;
                scrollObj.startDateTime = this.startDateTime = start = new Date(start);
                scrollObj.endDateTime = this.endDateTime = end = new Date(end);
            } else {
                startArgs = parseInt(scrollObj.startValue);
                endArgs = parseInt(scrollObj.endValue);
                scrollObj.startValue = this.startValue = start = Math.ceil(start);
                scrollObj.endValue = this.endValue = end = Math.ceil(end);
            }

            //Bind event on changing scrollbar position 
            scrollObj._scrollChanged = true;
            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = {
                zoomPosition: zoomPos, zoomFactor: zoomFactor,
                oldRange: {
                    start: startArgs,
                    end: endArgs
                },
                newRange: {
                    start: start,
                    end: end
                }
            };

            scrollObj.zoomPosition = zoomPos;
            scrollObj.zoomFactor = zoomFactor;

            return commonEventArgs;
        },
        _calculateScrollPosition: function (mouseX, scrollObj) {
            var zoomPos, zoomFact, scrollRange, start, end, startArgs, endArgs, width,
                padding = 30, offset = 15, valueType, startRange, minScrollWidth = 36;

            if (this.leftScrollbarClicked && scrollObj.enableResize) {
                mouseX = mouseX >= offset ? mouseX : offset;
                mouseX = (mouseX >= offset && mouseX < scrollObj.offsetRightX - offset) ? mouseX : scrollObj.offsetRightX - offset;
                zoomPos = (mouseX - minScrollWidth) / (scrollObj.width - padding);
                zoomFact = scrollObj.rectWidth / (scrollObj.width - padding);

                valueType = scrollObj.valueType.toLowerCase();
                scrollRange = scrollObj.scrollRange;
                if (!scrollObj.isRTL) {
                    start = scrollRange.min + zoomPos * scrollRange.delta;
                    start = start > scrollRange.min ? start : scrollRange.min;
                    if (valueType == "datetime") {
                        startArgs = scrollObj.startDateTime;
                        endArgs = scrollObj.endDateTime;
                        scrollObj.startDateTime = this.startDateTime = start = new Date(start), end = scrollObj.endDateTime;
                    }
                    else {
                        startArgs = parseInt(scrollObj.startValue);
                        endArgs = parseInt(scrollObj.endValue);
                        scrollObj.startValue = this.startValue = start = Math.ceil(start), end = Math.ceil(scrollObj.endValue);
                    }
                } else {
                    end = scrollRange.max - zoomPos * scrollRange.delta;
                    end = end < scrollRange.max ? end : scrollRange.max;
                    if (valueType == "datetime") {
                        startArgs = scrollObj.startDateTime;
                        endArgs = scrollObj.endDateTime;
                        scrollObj.endDateTime = this.endDateTime = end = new Date(end), start = scrollObj.startDateTime;
                    }
                    else {
                        startArgs = parseInt(scrollObj.startValue);
                        endArgs = parseInt(scrollObj.endValue);
                        scrollObj.endValue = this.endValue = end = Math.ceil(end), start = Math.ceil(scrollObj.startValue);
                    }
                }
                //Bind event on changing scrollbar position 
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = {
                    zoomPosition: zoomPos, zoomFactor: zoomFact,
                    oldRange: {
                        start: startArgs,
                        end: endArgs
                    },
                    newRange: {
                        start: start,
                        end: end
                    }
                };
                scrollObj._scrollChanged = true;
                scrollObj.zoomPosition = zoomPos;
                scrollObj.zoomFactor = zoomFact;

                return commonEventArgs;
            }
            if (this.rightScrollbarClicked && scrollObj.enableResize) {
                scrollRange = scrollObj.scrollRange;
                zoomFact = scrollObj.rectWidth / (scrollObj.width - padding);
                zoomPos = scrollObj.zoomPosition;
                valueType = scrollObj.valueType.toLowerCase();
                if (!scrollObj.isRTL) {
                    startRange = scrollRange.min + zoomPos * scrollRange.delta;
                    end = startRange + zoomFact * scrollRange.delta;
                    if (valueType == "datetime") {
                        startArgs = scrollObj.startDateTime;
                        endArgs = scrollObj.endDateTime;
                        scrollObj.endDateTime = this.endDateTime = end = new Date(end), start = scrollObj.startDateTime;
                    }
                    else {
                        startArgs = parseInt(scrollObj.startValue);
                        endArgs = parseInt(scrollObj.endValue);
                        scrollObj.endValue = this.endValue = end = Math.floor(end), start = Math.ceil(scrollObj.startValue);
                    }
                } else {
                    zoomPos = (mouseX - minScrollWidth) / (scrollObj.width - padding);
                    start = scrollRange.max - zoomPos * scrollRange.delta;
                    if (valueType == "datetime") {
                        startArgs = scrollObj.startDateTime;
                        endArgs = scrollObj.endDateTime;
                        scrollObj.startDateTime = this.startDateTime = start = new Date(start), end = scrollObj.endDateTime;
                    }
                    else {
                        startArgs = parseInt(scrollObj.startValue);
                        endArgs = parseInt(scrollObj.endValue);
                        scrollObj.startValue = this.startValue = start = Math.floor(start), end = Math.ceil(scrollObj.endValue);
                    }
                }

                //Bind event on changing scrollbar position 
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = {
                    zoomPosition: scrollObj.zoomPosition ? scrollObj.zoomPosition : 0, zoomFactor: zoomFact,
                    oldRange: {
                        start: startArgs,
                        end: endArgs
                    },
                    newRange: {
                        start: start,
                        end: end
                    }
                };
                scrollObj._scrollChanged = true;
                scrollObj.zoomFactor = zoomFact;

                return commonEventArgs;
            }
            if (scrollObj && this.scrollRectClicked) {
                var moveLength = this.mouseDownPos - mouseX;
                if (moveLength > 0 && scrollObj.offsetLeftX >= 0) {
                    this.scrollbarContainer._calculateScrollLeftMove.call(this, moveLength, scrollObj);
                    return this.scrollbarContainer._calculateRange.call(this, scrollObj.startX, scrollObj.offsetRightX, scrollObj);
                }
                if (moveLength < 0) {
                    this.scrollbarContainer._calculateScrollRightMove.call(this, moveLength, scrollObj);
                    return this.scrollbarContainer._calculateRange.call(this, scrollObj._startX, scrollObj.offsetRightX, scrollObj);
                }
            }
        },

        _scrollbarMove: function (evt) {

            this.moveClientX = !sf.isNullOrUndefined(evt.clientX) ? evt.clientX : (evt.originalEvent.clientX == null ? evt.originalEvent.touches[0].clientX : evt.originalEvent.clientX);
            if (this.moveClientX != this.downClientX) {//update scrollbar only on mouse move
                var zoomPos, axis, start, end, width, padding = 8, minScrollWidth = 34, mouseX, centerLine;
                var rangePadding = this.model.padding || 0;
                var matched = jQuery.uaMatch(navigator.userAgent);
                var scrollObj = this.scrollbarContainer._doScrollIndex.call(this, evt);
                if (!scrollObj) return 0;

                this.lastIndex = scrollObj.index;
                if (((!this.vmlRendering && evt.originalEvent.toString() !== "[object TouchEvent]") && matched.browser.toLowerCase() != "msie") || (this.vmlRendering))
                    mouseX = (scrollObj.orientation == 'horizontal' ? this.calMousePosition(evt).X - scrollObj.x : scrollObj.width - (this.calMousePosition(evt).Y - scrollObj.y)) - rangePadding;
                else
                    mouseX = (scrollObj.orientation == 'horizontal' ? this.calTouchPosition(evt).X - scrollObj.x : scrollObj.width - (this.calTouchPosition(evt).Y - scrollObj.y)) - rangePadding;

                this.mouseX = mouseX;
                var rootId = this._id;
                if (this.leftScrollbarClicked && scrollObj.enableResize) {


                    if (scrollObj && (mouseX > minScrollWidth || mouseX > 23) && mouseX < scrollObj.offsetRightX - minScrollWidth) {
                        scrollObj.rectWidth = scrollObj.width - (scrollObj.endX + mouseX - padding);
                        centerLine = ((mouseX - padding) + (scrollObj.rectWidth / 2) - 7.5);
                        $('#' + rootId + '_scrollbarLeftHeader_' + scrollObj.index).attr("cx", mouseX);
                        $('#' + rootId + '_leftHeaderHideRect_' + scrollObj.index).attr("x", mouseX - 7.5);
                        $('#' + rootId + '_scrollbarSelect_' + scrollObj.index).attr('x', mouseX - padding);
                        $('#' + rootId + '_scrollbarSelect_' + scrollObj.index).attr("width", scrollObj.rectWidth);
                        $('#' + rootId + '_scrollbarCenterLine_' + scrollObj.index).attr('transform', 'translate(' + centerLine + ')');
                        //Apply styles for VML support
                        if (this.pluginName == "ejRangeNavigator") {
                            $('#' + rootId + '_scrollbarLeftHeader_' + scrollObj.index).css("left", mouseX);
                            $('#' + rootId + '_leftHeaderHideRect_' + scrollObj.index).css("left", mouseX - 7.5);
                            $('#' + rootId + '_scrollbarSelect_' + scrollObj.index).css('left', mouseX);
                            $('#' + rootId + '_scrollbarSelect_' + scrollObj.index).css("width", scrollObj.rectWidth);
                            $('#' + rootId + '_scrollbarCenterLine_' + scrollObj.index).css('left', centerLine);
                        }
                        scrollObj.offsetLeftX = scrollObj.startX = mouseX - 8;
                        this.scrollbarContainer._scrollStartArgs.call(this, scrollObj);
                        this.scrollbarContainer._scrollChangeArgs.call(this, scrollObj);
                        scrollObj._diff = 0;
                    } else if (mouseX > scrollObj.offsetRightX - minScrollWidth)
                        this.rectWidth = 42.89984101748814;
                }
                if (this.rightScrollbarClicked && scrollObj.enableResize) {
                    if (scrollObj && (mouseX <= scrollObj.width - minScrollWidth || mouseX <= scrollObj.width - 23) && mouseX > scrollObj.offsetLeftX + minScrollWidth) {
                        scrollObj.rectWidth = mouseX - scrollObj.offsetLeftX + padding;
                        centerLine = (scrollObj.offsetLeftX + (scrollObj.rectWidth / 2) - 7.5);
                        $('#' + rootId + '_scrollbarRightHeader_' + scrollObj.index).attr("cx", mouseX);
                        $('#' + rootId + '_rightHeaderHideRect_' + scrollObj.index).attr("x", mouseX - 2.5);
                        $('#' + rootId + '_scrollbarSelect_' + scrollObj.index).attr("width", scrollObj.rectWidth);
                        $('#' + rootId + '_scrollbarCenterLine_' + scrollObj.index).attr('transform', 'translate(' + centerLine + ')');
                        //Apply styles for VML support
                        if (this.pluginName == "ejRangeNavigator") {
                            $('#' + rootId + '_scrollbarRightHeader_' + scrollObj.index).css("left", mouseX);
                            $('#' + rootId + '_rightHeaderHideRect_' + scrollObj.index).css("left", mouseX - 2.5);
                            $('#' + rootId + '_scrollbarSelect_' + scrollObj.index).css("width", scrollObj.rectWidth);
                            $('#' + rootId + '_scrollbarCenterLine_' + scrollObj.index).css('left', centerLine);
                        }
                        scrollObj.offsetRightX = mouseX + padding;
                        scrollObj.endX = scrollObj.width - mouseX - padding;
                        // this.scrollbarContainer._calculateScrollPosition.call(this, mouseX, scrollObj);
                        this.scrollbarContainer._scrollStartArgs.call(this, scrollObj);
                        this.scrollbarContainer._scrollChangeArgs.call(this, scrollObj);
                        scrollObj._diff = 0;
                    }

                }
                if (this.scrollRectClicked) {
                    var moveLength = this.mouseDownPos - mouseX;
                    scrollObj._startX = sf.isNullOrUndefined(scrollObj._startX) ? scrollObj.startX : scrollObj._startX;
                    if (scrollObj && moveLength > 0 && scrollObj.offsetLeftX >= 0) {
                        this.scrollbarContainer._calculateScrollLeftMove.call(this, moveLength, scrollObj);
                        this.scrollbarContainer._setScrollPosition.call(this, scrollObj.startX, scrollObj.offsetRightX, scrollObj);
                        if (scrollObj.offsetLeftX > 15 || scrollObj.offsetLeftX != scrollObj._offsetLeftX) {
                            this.scrollbarContainer._scrollStartArgs.call(this, scrollObj);
                            this.scrollbarContainer._scrollChangeArgs.call(this, scrollObj);
                        }
                    }

                    if (scrollObj && moveLength < 0) {
                        if (sf.isNullOrUndefined(scrollObj._offsetRightX)) {
                            this.scrollbarContainer._scrollSelectRectDown.call(this, evt);
                            this.scrollbarContainer._scrollbarMove.call(this, evt);
                        }
                        this.scrollbarContainer._calculateScrollRightMove.call(this, moveLength, scrollObj);
                        this.scrollbarContainer._setScrollPosition.call(this, scrollObj._startX, (scrollObj._startX + scrollObj.rectWidth), scrollObj);
                        if (scrollObj.offsetRightX < scrollObj.width - 15 || scrollObj.offsetRightX != scrollObj._ofsetRightX) {
                            this.scrollbarContainer._scrollStartArgs.call(this, scrollObj);
                            if (this.model.enableDeferredUpdate === false || scrollObj.isZooming || this.model.scrollChanged != '') {
                                var commonEventArgs = this.scrollbarContainer._calculateRange.call(this, scrollObj._startX, (scrollObj._startX + scrollObj.rectWidth), scrollObj);
                                var oldRange = commonEventArgs.data.oldRange,
                                    newRange = commonEventArgs.data.newRange, oldStart, oldEnd, newStart, newEnd;
                                if (scrollObj.valueType.toLowerCase() == 'datetime') {
                                    oldStart = Date.parse(oldRange.start), newStart = Date.parse(newRange.start),
                                        oldEnd = Date.parse(oldRange.end), newEnd = Date.parse(newRange.end);
                                } else {
                                    oldStart = oldRange.start, newStart = newRange.start,
                                        oldEnd = oldRange.end, newEnd = newRange.end;
                                }
                                if (this.model.scrollChanged != '' && ((oldStart != newStart) || (oldEnd != newEnd))) {
                                    commonEventArgs = this.scrollbarContainer._args.call(this, scrollObj, commonEventArgs);
                                    this._trigger("scrollChanged", commonEventArgs);
                                }
                                if (!this.model.enableDeferredUpdate)
                                    this.scrollUpdate ? this.scrollUpdate = false : this.scrollbarContainer._appendScrollRange.call(this, scrollObj);
                            }
                        }
                    }
                }
            }
            this.offsetX = mouseX;
        },
        _scrollbarUp: function (evt) {
            var scrollObj = this.scrollbarContainer._doScrollIndex.call(this, evt);
            $("[id^=" + this._id + '_scrollbarSelect_' + "]").attr('class', 'e-rangeScroll-select');
            this.lastIndex = null;
            var args = this.scrollbarContainer._calculateScrollPosition.call(this, this.mouseX, scrollObj),
                deferred = this.model.enableDeferredUpdate;
            if (args) {
                var oldRange = args.data.oldRange,
                    newRange = args.data.newRange, oldStart, oldEnd, newStart, newEnd;
                if (scrollObj.valueType.toLowerCase() == 'datetime') {
                    oldStart = Date.parse(oldRange.start), newStart = Date.parse(newRange.start),
                        oldEnd = Date.parse(oldRange.end), newEnd = Date.parse(newRange.end);
                } else {
                    oldStart = oldRange.start, newStart = newRange.start,
                        oldEnd = oldRange.end, newEnd = newRange.end;
                }

                if (((oldStart != newStart) || (oldEnd != newEnd)) || (this.scrollRectClicked && !deferred) || (deferred) || (this.leftScrollbarClicked || this.rightScrollbarClicked)) {
                    //Checked condition for chrome browser mouse click issue.. on mouseClick in chrome move event also triggered
                    var is_chrome = ((navigator.userAgent.toLowerCase().indexOf('chrome') > -1) && (navigator.vendor.toLowerCase().indexOf("google") > -1));
                    if (!is_chrome || (is_chrome && ((this.leftScrollbarClicked || this.rightScrollbarClicked) && this.downClientX != this.moveClientX)
                        || this.scrollRectClicked || this.leftArrowClicked || this.rightArrowClicked)) {
                        //event will no trigger when rect value is not changed on left and right header moved
                        if ((!this.leftScrollbarClicked && !this.rightScrollbarClicked) ||
                            ((this.leftScrollbarClicked || this.rightScrollbarClicked) && Math.ceil(scrollObj.rectWidth) != Math.ceil(this.rectOldWidth) && (Math.abs(scrollObj.rectWidth - scrollObj.rectOldWidth) > 4 || !scrollObj.rectOldWidth))) {
                            if (sf.isNullOrUndefined(scrollObj._previousStart) || ((scrollObj._previousStart != newStart) || (scrollObj._previousEnd != newEnd))) {
                                args = this.scrollbarContainer._args.call(this, scrollObj, args);
                                this._trigger("scrollEnd", args);
                                scrollObj._scrollStarted = false;
                                scrollObj._previousStart = newStart;
                                scrollObj._previousEnd = newEnd;
                                scrollObj.rectOldWidth = scrollObj.rectWidth;
                                this.scrollUpdate ? this.scrollUpdate = false : this.scrollbarContainer._appendScrollRange.call(this, scrollObj);
                            }
                        }
                    }
                }
                scrollObj.release = true;
                scrollObj.clicked = false;
            }
            this._scrollEnd = false;
            this.leftScrollbarClicked = false;
            this.rightScrollbarClicked = false;
            this.scrollRectClicked = false;
            this.leftArrowClicked = false;
            this.rightArrowClicked = false;
            this.scrollbarBackRectClicked = false;
        },
        _leftScrollbarDown: function (evt) {
            evt.preventDefault();
            this.leftScrollbarClicked = true;
            this.downClientX = !sf.isNullOrUndefined(evt.clientX) ? evt.clientX : evt.originalEvent.touches[0].clientX;
        },

        _rightScrollbarDown: function (evt) {
            evt.preventDefault();
            this.rightScrollbarClicked = true;
            this.downClientX = !sf.isNullOrUndefined(evt.clientX) ? evt.clientX : evt.originalEvent.touches[0].clientX;
        },

        _scrollSelectRectDown: function (evt) {
            var scrollObj = this.scrollbarContainer._doScrollIndex.call(this, evt);
            $('#' + this._id + '_scrollbarSelect_' + scrollObj.index).attr('class', 'e-rangeScroll-select e-rangeScroll-select-hover');
            evt.preventDefault();
            var matched = jQuery.uaMatch(navigator.userAgent);
            var rangePadding = this.model.padding || 0;
            var scrollObj = this.scrollbarContainer._doScrollIndex.call(this, evt);
            if (((!this.vmlRendering && evt.originalEvent.toString() !== "[object TouchEvent]") && matched.browser.toLowerCase() != "msie") || (this.vmlRendering))
                var mouseX = (scrollObj.orientation == 'horizontal' ? this.calMousePosition(evt).X - scrollObj.x : scrollObj.width - (this.calMousePosition(evt).Y - scrollObj.y)) - rangePadding;
            else
                var mouseX = (scrollObj.orientation == 'horizontal' ? this.calTouchPosition(evt).X - scrollObj.x : scrollObj.width - (this.calTouchPosition(evt).Y - scrollObj.y)) - rangePadding;
            this.mouseDownPos = mouseX;
            scrollObj._startX = scrollObj.startX = scrollObj.offsetLeftX;
            scrollObj._offsetRightX = scrollObj.offsetRightX;
            scrollObj.clicked = true;
            scrollObj.release = false;
            this.scrollRectClicked = true;
        },

        //MouseWheel Scrolling event for scrollbarControl
        _scrollMouseWheel: function (e) {
            e.preventDefault();
            var scrollObj = this.scrollbarContainer._doScrollIndex.call(this, e);
            var isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
            var wheelDelta = e.originalEvent.wheelDelta;
            var matched = jQuery.uaMatch(navigator.userAgent);
            var direction = matched.browser.toLowerCase() == "mozilla" ? ((isIE11 ? ((wheelDelta / 120) > 0 ? 1 : -1) : -(e.originalEvent.detail) / 3 > 0 ? 1 : -1)) : ((wheelDelta / 120) > 0 ? 1 : -1);
            var currentScale = Math.max(1 / sf.EjSvgRender.utils._minMax(scrollObj.zoomFactor, 0, 1), 1);
            var cumulativeScale = Math.max(currentScale + (0.25 * direction), 1);
            this.scrollbarContainer.doMouseWheelZoom.call(this, cumulativeScale, 0.5, scrollObj);

        },

        _scrollStartArgs: function (scrollObj) {
            scrollObj._scrollStarted = true;
            if (this.model.scrollStart != '' && !this._scrollEnd) {
                var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
                if (!scrollObj.isZooming) {
                    commonEventArgs.data = {
                        startRange: scrollObj.valueType == "datetime" ? scrollObj.startDateTime : scrollObj.startValue,
                        endRange: scrollObj.valueType == "datetime" ? scrollObj.endDateTime : scrollObj.endValue
                    };
                } else {
                    commonEventArgs.data = {
                        axis: this.model._axes[scrollObj.index],
                        currentRange: this.model._axes[scrollObj.index].visibleRange
                    };
                }
                this._trigger("scrollStart", commonEventArgs);
                this._scrollEnd = true;
            }
        },

        _scrollChangeArgs: function (scrollObj) {
            if (this.model.enableDeferredUpdate === false || scrollObj.isZooming || this.model.scrollChanged != '') {
                var commonEventArgs = this.scrollbarContainer._calculateRange.call(this, scrollObj.offsetLeftX, scrollObj.offsetRightX, scrollObj);
                var oldRange = commonEventArgs.data.oldRange,
                    newRange = commonEventArgs.data.newRange, oldStart, oldEnd, newStart, newEnd;
                if (scrollObj.valueType.toLowerCase() == 'datetime') {
                    oldStart = Date.parse(oldRange.start), newStart = Date.parse(newRange.start),
                        oldEnd = Date.parse(oldRange.end), newEnd = Date.parse(newRange.end);
                } else {
                    oldStart = oldRange.start, newStart = newRange.start,
                        oldEnd = oldRange.end, newEnd = newRange.end;
                }

                if (this.model.scrollChanged != '' && ((oldStart != newStart) || (oldEnd != newEnd))) {
                    commonEventArgs = this.scrollbarContainer._args.call(this, scrollObj, commonEventArgs);
                    this._trigger("scrollChanged", commonEventArgs);
                }
                if (!this.model.enableDeferredUpdate)
                    this.scrollUpdate ? this.scrollUpdate = false : this.scrollbarContainer._appendScrollRange.call(this, scrollObj);
            }
        },

        _scrollEndArgs: function (startX, scrollObj) {
            var args = this.scrollbarContainer._calculateRange.call(this, startX, scrollObj.offsetRightX, scrollObj);
            if (args && scrollObj._scrollStarted) {
                var oldRange = args.data.oldRange,
                    newRange = args.data.newRange, oldStart, oldEnd, newStart, newEnd;
                if (scrollObj.valueType.toLowerCase() == 'datetime') {
                    oldStart = Date.parse(oldRange.start), newStart = Date.parse(newRange.start),
                        oldEnd = Date.parse(oldRange.end), newEnd = Date.parse(newRange.end);
                } else {
                    oldStart = oldRange.start, newStart = newRange.start,
                        oldEnd = oldRange.end, newEnd = newRange.end;
                }

                if (((oldStart != newStart) || (oldEnd != newEnd)) || (this.leftScrollbarClicked || this.rightScrollbarClicked)) {
                    args = this.scrollbarContainer._args.call(this, scrollObj, args);
                    this._trigger("scrollEnd", args);
                }
                scrollObj._scrollStarted = false;
                this.scrollUpdate ? this.scrollUpdate = false : this.scrollbarContainer._appendScrollRange.call(this, scrollObj);
            }
        },

        _args: function (scrollObj, args) {
            if (scrollObj.isZooming) {
                var axis = this.model._axes[scrollObj.index],
                    data = args.data;
                data.axis = axis;
                data.newRange = axis.visibleRange;
                data.oldRange = axis.previousRange;
            }

            if (scrollObj.isVirtual) {
                args.data.axis = this.model._axes[scrollObj.index];
                delete args.data.zoomFactor;
                delete args.data.zoomPosition;
            }
            return args;
        },

        doMouseWheelZoom: function (cumulativeScale, origin, scrollObj) {
            if (cumulativeScale >= 1) {
                var calZoomVal = this.scrollbarContainer.calZoomFactors(cumulativeScale, origin, scrollObj.zoomFactor, scrollObj.zoomPosition);

                if (scrollObj.zoomPosition != calZoomVal.zoomMPosition && calZoomVal.zoomMPosition + scrollObj.zoomFactor <= 1 && scrollObj.zoomPosition >= 0) {
                    if (calZoomVal.zoomMPosition + scrollObj.zoomFactor >= 1) {
                        calZoomVal.zoomMPosition = 1 - scrollObj.zoomFactor
                    }
                    if (calZoomVal.zoomMPosition < 0) {
                        calZoomVal.zoomMPosition = 0;
                    }
                    scrollObj.zoomPosition = calZoomVal.zoomMPosition;
                    scrollObj.startX = ((scrollObj.zoomPosition) * (scrollObj.width - 30 - scrollObj._diff) + 15);
                    scrollObj.startX = (scrollObj.startX + scrollObj.rectWidth + 5) > scrollObj.width ? (scrollObj.width - scrollObj.rectWidth - 15) : scrollObj.startX;
                    scrollObj.offsetLeftX = scrollObj.startX;

                    scrollObj._offsetRightX = scrollObj.startX + scrollObj.rectWidth;
                    if (scrollObj._offsetRightX > scrollObj.width - 15) {
                        scrollObj.offsetRightX = scrollObj.width - 15;
                        scrollObj.startX = scrollObj.offsetRightX - scrollObj.rectWidth;
                        scrollObj.offsetLeftX = scrollObj.startX;
                    } else {
                        scrollObj.offsetRightX = scrollObj._offsetRightX;
                    }
                    scrollObj.endX = scrollObj.width - scrollObj.offsetRightX;
                    this.scrollbarContainer._setScrollPosition.call(this, scrollObj.startX, scrollObj.offsetRightX, scrollObj);
                    this.scrollbarContainer._calculateMouseWheelRange.call(this, scrollObj.startX, scrollObj.offsetRightX, scrollObj);
                }
            }
            return false;
        },
        _calculateMouseWheelRange: function (startX, endX, scrollObj) {

            var scrollRange, start, end, padding = 30, startArgs, endArgs;
            scrollObj.zoomFactor = (scrollObj.rectWidth / (scrollObj.width - padding));
            scrollObj.zoomPosition = (startX - 15) / (scrollObj.width - padding - scrollObj._diff);
            scrollRange = scrollObj.scrollRange;

            if (!scrollObj.isRTL) {
                start = scrollRange.min + scrollObj.zoomPosition * scrollRange.delta;
                end = start + scrollObj.zoomFactor * scrollRange.delta;
            } else {
                end = scrollRange.max - scrollObj.zoomPosition * scrollRange.delta;
                start = end - scrollObj.zoomFactor * scrollRange.delta;
            }

            if (scrollObj.valueType == "datetime") {
                startArgs = scrollObj.startDateTime;
                endArgs = scrollObj.endDateTime;
                scrollObj.startDateTime = this.startDateTime = start = new Date(start);
                scrollObj.endDateTime = this.endDateTime = end = new Date(end);
            } else {
                startArgs = parseInt(scrollObj.startValue);
                endArgs = parseInt(scrollObj.endValue);
                scrollObj.startValue = this.startValue = start = Math.ceil(start);
                scrollObj.endValue = this.endValue = end = Math.ceil(end);
            }

            //Bind event on changing scrollbar position 
            var commonEventArgs = $.extend({}, sf.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = {
                zoomPosition: scrollObj.zoomPosition, zoomFactor: scrollObj.zoomFactor,
                oldRange: {
                    start: startArgs,
                    end: endArgs
                },
                newRange: {
                    start: start,
                    end: end
                }
            };
            scrollObj._scrollChanged = true;
            scrollObj._scrollStarted = false;
            var oldRange = commonEventArgs.data.oldRange,
                newRange = commonEventArgs.data.newRange, oldStart, oldEnd, newStart, newEnd;
            if (scrollObj.valueType.toLowerCase() == 'datetime') {
                oldStart = Date.parse(oldRange.start), newStart = Date.parse(newRange.start),
                    oldEnd = Date.parse(oldRange.end), newEnd = Date.parse(newRange.end);
            } else {
                oldStart = oldRange.start, newStart = newRange.start,
                    oldEnd = oldRange.end, newEnd = newRange.end;
            }
            if (oldStart != newStart || oldEnd != newEnd || scrollObj.isZooming) {
                this.scrollbarContainer._scrollStartArgs.call(this, scrollObj);
                commonEventArgs = this.scrollbarContainer._args.call(this, scrollObj, commonEventArgs);
                this._trigger("scrollEnd", commonEventArgs);
                this.scrollUpdate ? this.scrollUpdate = false : this.scrollbarContainer._appendScrollRange.call(this, scrollObj);
                this._scrollEnd = false;
            }
        },
        calZoomFactors: function (cumulativeScale, origin, currentZoomFactor, currentZoomPos) {
            var calcZoomFactorVal, calcZoomPosition;
            if (cumulativeScale == 1) {
                calcZoomFactorVal = 1;
                calcZoomPosition = 0;
            } else {
                calcZoomFactorVal = sf.EjSvgRender.utils._minMax(1 / cumulativeScale, 0, 1);
                calcZoomPosition = currentZoomPos + ((currentZoomFactor - calcZoomFactorVal) * origin);
            }
            return { zoomMFactor: calcZoomFactorVal, zoomMPosition: calcZoomPosition };
        },
        _leftArrowDown: function (evt) {
            this.leftArrowClicked = true;
            var scrollObj = this.scrollbarContainer._doScrollIndex.call(this, evt);
            scrollObj._startX = scrollObj.startX = scrollObj.offsetLeftX;
            scrollObj._offsetRightX = scrollObj.offsetRightX;
            scrollObj.leftIncrement = 5;
            var range = this;
            scrollObj.interval = setInterval(function () {
                range.scrollbarContainer.leftArrowRecursive.call(range, scrollObj)
            }, 50);
        },

        _leftArrowUp: function (evt) {
            this.leftArrowClicked = false;
            var scrollObj = this.scrollbarContainer._doScrollIndex.call(this, evt);
            this.scrollbarContainer.leftArrowRecursive.call(this, scrollObj);
        },

        leftArrowRecursive: function (scrollObj) {
            if (this.leftArrowClicked) {
                var rootId = this._id;
                this.scrollbarContainer._calculateScrollLeftMove.call(this, scrollObj.leftIncrement, scrollObj);
                scrollObj._scrollStarted = true;
                if (scrollObj.startX > 15)
                    this.scrollbarContainer._scrollEndArgs.call(this, scrollObj.startX, scrollObj);
                this.scrollbarContainer._setScrollPosition.call(this, scrollObj.startX, scrollObj.offsetRightX, scrollObj);
                scrollObj.leftIncrement += 5;
            } else {
                clearInterval(scrollObj.interval);
                scrollObj.leftIncrement = 0;
            }
        },

        _rightArrowDown: function (evt) {
            this.rightArrowClicked = true;
            var scrollObj = this.scrollbarContainer._doScrollIndex.call(this, evt);
            scrollObj._startX = scrollObj.startX = scrollObj.offsetLeftX;
            scrollObj._offsetRightX = scrollObj.offsetRightX;
            scrollObj.rightIncrement = -5;
            var range = this;
            scrollObj.interval = setInterval(function () { range.scrollbarContainer.rightArrowRecursive.call(range, scrollObj) }, 50);
        },

        _rightArrowUp: function (evt) {
            this.rightArrowClicked = false;
            var scrollObj = this.scrollbarContainer._doScrollIndex.call(this, evt);
            this.scrollbarContainer.rightArrowRecursive.call(this, scrollObj);
        },

        rightArrowRecursive: function (scrollObj) {
            if (this.rightArrowClicked) {
                var rootId = this._id;
                this.scrollbarContainer._calculateScrollRightMove.call(this, scrollObj.rightIncrement, scrollObj);
                scrollObj._scrollStarted = true;
                if (scrollObj.offsetRightX < scrollObj.width - 15)
                    this.scrollbarContainer._scrollEndArgs.call(this, scrollObj._startX, scrollObj);
                this.scrollbarContainer._setScrollPosition.call(this, scrollObj._startX, scrollObj.offsetRightX, scrollObj);
                scrollObj.rightIncrement -= 5;
            } else {
                clearInterval(scrollObj.interval);
                scrollObj.rightIncrement = 0;
            }
        },

        _scrollBackRectDown: function (evt) {

            var matched = jQuery.uaMatch(navigator.userAgent);
            var rangePadding = this.model.padding || 0;
            var scrollObj = this.scrollbarContainer._doScrollIndex.call(this, evt);
            if (((!this.vmlRendering && evt.originalEvent.toString() !== "[object TouchEvent]") && matched.browser.toLowerCase() != "msie") || (this.vmlRendering))
                var mouseX = (scrollObj.orientation == 'horizontal' ? this.calMousePosition(evt).X - scrollObj.x : scrollObj.width - (this.calMousePosition(evt).Y - scrollObj.y)) - rangePadding;
            else
                var mouseX = (scrollObj.orientation == 'horizontal' ? this.calTouchPosition(evt).X - scrollObj.x : scrollObj.width - (this.calTouchPosition(evt).Y - scrollObj.y)) - rangePadding;
            this.mouseDownPos = mouseX;
            this.scrollbarBackRectClicked = true;

            var range = this;
            this.scrollbarContainer._scrollStartArgs.call(this, scrollObj);
            var interval = setInterval(function () {
                range.scrollbarContainer.scrollBackRectRecursive.call(range, scrollObj)
                if (!this.scrollbarBackRectClicked)
                    clearInterval(interval);
            }, 50);
        },
        _scrollBackRectUp: function (evt) {
            this.scrollbarBackRectClicked = false;
            var scrollObj = this.scrollbarContainer._doScrollIndex.call(this, evt);
            this.scrollbarContainer.scrollBackRectRecursive.call(this, scrollObj);
        },

        _doScrollIndex: function (evt) {
            var matchStr = this._id + '_scrollbar' + '_';
            var parentNodeId = (evt.target.parentNode && evt.target.parentNode.id) ? evt.target.parentNode.id : '';
            var selectionIndex = parentNodeId.indexOf(matchStr) > -1 ? parseInt(parentNodeId.substr(matchStr.length)) : NaN;
            if (!sf.isNullOrUndefined(this.lastIndex) && !isNaN(this.lastIndex)) {
                if (!this.model.scrollObj[this.lastIndex].release && this.model.scrollObj[this.lastIndex].clicked)
                    selectionIndex = this.lastIndex;
            }
            this.lastIndex = sf.isNullOrUndefined(this.lastIndex) ? selectionIndex : this.lastIndex;
            var scrollObj = sf.isNullOrUndefined(this.model.scrollObj[selectionIndex]) ? this.model.scrollObj[this.lastIndex] : this.model.scrollObj[selectionIndex];

            return scrollObj;
        },

        scrollBackRectRecursive: function (scrollObj) {
            if (this.scrollbarBackRectClicked) {
                var moveLength = (10 / 100) * (scrollObj.width - 30);
                scrollObj._startX = scrollObj.startX = scrollObj.offsetLeftX;
                scrollObj._offsetRightX = scrollObj.offsetRightX;
                if (this.mouseDownPos < scrollObj.startX) {
                    moveLength = moveLength < scrollObj.startX ? moveLength : (scrollObj.startX - 16);
                    this.scrollbarContainer._calculateScrollLeftMove.call(this, moveLength, scrollObj);
                    scrollObj._scrollStarted = true;
                    this.scrollbarContainer._scrollEndArgs.call(this, scrollObj.startX, scrollObj);
                    this.scrollbarContainer._setScrollPosition.call(this, scrollObj.startX, scrollObj.offsetRightX, scrollObj);
                } else if (this.mouseDownPos > scrollObj.offsetRightX) {
                    moveLength = (moveLength < scrollObj.endX ? moveLength : (scrollObj.endX - 16)) * -1;
                    this.scrollbarContainer._calculateScrollRightMove.call(this, moveLength, scrollObj);
                    scrollObj._scrollStarted = true;
                    this.scrollbarContainer._scrollEndArgs.call(this, scrollObj._startX, scrollObj);
                    this.scrollbarContainer._setScrollPosition.call(this, scrollObj._startX, scrollObj.offsetRightX, scrollObj);
                } else {
                    scrollObj._scrollStarted = false;
                }
            } else {
                scrollObj._scrollStarted = false;
            }
        },

        //Redraw the RangeNavigator and Chart
        _appendScrollRange: function (scrollObj) {
            this.scrollbarUpdate = true;
            if (this.pluginName == "ejRangeNavigator")
                this.renderNavigator();
            else {
                var index = scrollObj.index,
                    axes = this.model._axes[index];
                if (scrollObj.isZooming && (axes.zoomFactor != scrollObj.zoomFactor || axes.zoomPosition != scrollObj.zoomPosition)) {
                    axes.zoomFactor = scrollObj.zoomFactor;
                    axes.zoomPosition = scrollObj.zoomPosition;
                    this.redraw(true);
                }
            }
            this.scrollbarUpdate = false;
        }

    };
})(jQuery);;